/*
 * Copyright (c) 2021-2022 Amlogic, Inc. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 */

// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_from_register_h.pl
//
// and was applied to the file
//
// Project name: s7
//
// Create time: Tue Jul 18 12:06:34 CST 2023 by chong.gu
//
// ./REG_LIST_RTL.h
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef P_REGISTER_H
#else
#define P_REGISTER_H


#include "p_dos_register.h"

//
// Reading file:  ./REG_LIST_RTL.h
//
// synopsys translate_off
// synopsys translate_on
//
//`include "../mmc_lp4/dmc/rtl/dmc_sec.vh"
//`include "../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh"
//`include "../mmc_lp4/dmc/rtl/dmc_reg.vh"
//`include "../mmc_lp4/dmc/rtl/dmc_siu_reg.vh"
//`include "../mmc_lp4/dmc/rtl/dmc_sticky_reg.vh"
//
// Reading file:  ../dmc_v26/rtl/dmc_reg.vh
//
//`define DMC_FREQ_REG_BASE   32'hfe036000
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe036000
// -----------------------------------------------
#define P_DMC_REQ_CTRL                             (volatile uint32_t *)0xfe036000
  //bit 13.   enable dmc request of axibus chan 13.  GE2D Async interface.
  //bit 12.   enable dmc request of axibus chan 12.  GPU Async interface.
  //bit 11.   enable dmc request of axibus chan 11.  DEMUX async interface.
  //bit 10.   enable dmc request of axibus chan 10.  system Async interface.
  //bit 9.   enable dmc request of axibus chan 9.  HCODEC Async interface.
  //bit 8.   enable dmc request of axibus chan 8.  VDEC Async interface.
  //bit 7.   enable dmc request of axibus chan 7.  HEVC Async interface.
  //bit 6.   enable dmc request of axibus chan 6.  VPU4 async interface.
  //bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.  VPU3 Async interface.
  //bit 3.   enable dmc request of axibus chan 3.  VPU2 Async interface.
  //bit 2.   enable dmc request of axibus chan 2.  VPU1 Async interface.
  //bit 1.   enable dmc request of axibus chan 1.  VPU0 Async interface.
  //bit 0.   enable dmc request of axibus chan 0.  CPU/A55   async interface.
//DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define P_DMC_SOFT_RST                             (volatile uint32_t *)0xfe036004
  //bit 31~14. reserved for future.
  //bit 13:0. 14 software reset for 14 axi ports n clock domain.
#define P_DMC_SOFT_RST1                            (volatile uint32_t *)0xfe036008
  //To reset the Async interface, you need to disable the interface both clock domain, then reset both n_clk and m_clk domain
  //bit 31~14 not used.  all channels are synchronous interface.
  //bit 13~0. 14 software reset for 14 axi ports master clock domain.
#define P_DMC_SOFT_RST2                            (volatile uint32_t *)0xfe03600c
  //bit 31  DMC channel 1 dfi misc module soft reset_n.
  //bit 30  DMC channel 1 dfi data module soft reset_n.
  //bit 29  DMC channel 1 dfi cmd module soft reset_n.
  //bit 28  DMC channel 1 dmc dram control module soft reset_n.
  //bit 27  DMC channel 1 dmc cmd filter module soft reset_n.
  //bit 26  DMC channel 1 dmc wbuf module soft reset_n.
  //bit 25  DMC channel 1 dmc rbuf module soft reset_n.
  //bit 24  DMC channel 1 dfi low power control module soft reset_n.
  //bit 23  DMC channel 0 dfi misc module soft reset_n.
  //bit 22  DMC channel 0 dfi data module soft reset_n.
  //bit 21  DMC channel 0 dfi cmd module soft reset_n.
  //bit 20  DMC channel 0 dmc dram control module soft reset_n.
  //bit 19  DMC channel 0 dmc cmd filter module soft reset_n.
  //bit 18  DMC channel 0 dmc wbuf module soft reset_n.
  //bit 17  DMC channel 0 dmc rbuf module soft reset_n.
  //bit 16  DMC channel 0 dfi low power control module soft reset_n.
  //bit 9   DMC siu soft reset_n .
  //bit 8   DMC test soft reset_n .
  //bit 7   DMC read response soft reset_n .
  //bit 6   DMC read split soft reset_n.
  //bit 5.  DMC read sec check soft reset_n.
  //bit 4.  DMC write response module soft reset_n.
  //bit 3.  DMC wd ctrl module soft reset_n.
  //bit 2.  DMC qos monitor module soft reset_n.
  //bit 1.  not used.
  //bit 0.  DMC command buffers and command generation modules soft reset.
#define P_DMC_RST_STS1                             (volatile uint32_t *)0xfe036010
  //31~14.  not used.
  //13~0.   14 software reset for 14 axi ports master clock domain.. Read only.
#define P_DMC_CLKG_CTRL0                           (volatile uint32_t *)0xfe036018
  //bit 31:14  not used.
  //bit 13:0.  enable the 14 axi interfaces  m_clk auto clock gating function. each 1 bit for one interface.
#define P_DMC_CLKG_CTRL1                           (volatile uint32_t *)0xfe03601c
  //bit 31:14. not used.
  //bit 13:0.  force to disable the 14 axi interfaces m_clk. each 1 bit for one interface.
#define P_DMC_CLKG_CTRL2                           (volatile uint32_t *)0xfe036020
  //bit 31  enalbe auto clock gating for channel 1 dfi misc.
  //bit 30  enalbe auto clock gating for channel 1 dfi data.
  //bit 29  enable auto clock gating for channel 1 dfi command generation.
  //bit 28  enable auto clock gating for channel 1 dram controller
  //bit 27  enable auto clock gating for channel 1 command filter.
  //bit 26  enalbe auto clock gating for channel 1 wbuf generation.
  //bit 25  enalbe auto clock gating for channel 1 rbuf generation.
  //bit 24  enalbe auto clock gating for channel 1 ddr0 command filter.
  //bit 23  enalbe auto clock gating for channel 0 dfi misc.
  //bit 22  enalbe auto clock gating for channel 0 dfi data.
  //bit 21  enable auto clock gating for channel 0 dfi command generation.
  //bit 20  enable auto clock gating for channel 0 dram controller
  //bit 19  enable auto clock gating for channel 0 command filter.
  //bit 18  enalbe auto clock gating for channel 0 wbuf generation.
  //bit 17  enalbe auto clock gating for channel 0 rbuf generation.
  //bit 16  enalbe auto clock gating for channel 0 ddr0 command filter.
  //bit 8.  enalbe auto clock gating for test.
  //bit 7.  enalbe auto clock gating for rd response.
  //bit 6.  enalbe auto clock gating for read split.
  //bit 5.  enalbe auto clock gating for read sec check.
  //bit 4.  enalbe auto clock gating for write response.
  //bit 3.  enalbe auto clock gating for wd control.
  //bit 2.  enalbe auto clock gating for qos monitor.
  //bit 1:0.  not used.
#define P_DMC_CLKG_CTRL3                           (volatile uint32_t *)0xfe036024
  //bit 31  force to disable the clock of channel 1 dfi misc.
  //bit 30  force to disable the clock of channel 1 dfi data.
  //bit 29  force to disable the clock of channel 1 dfi command generation.
  //bit 28  force to disable the clock of channel 1 dram controller
  //bit 27  force to disable the clock of channel 1 command filter.
  //bit 26  force to disable the clock of channel 1 wbuf generation.
  //bit 25  force to disable the clock of channel 1 rbuf generation.
  //bit 24  force to disable the clock of channel 1 ddr0 command filter.
  //bit 23  force to disable the clock of channel 0 dfi misc.
  //bit 22  force to disable the clock of channel 0 dfi data.
  //bit 21  force to disable the clock of channel 0 dfi command generation.
  //bit 20  force to disable the clock of channel 0 dram controller
  //bit 19  force to disable the clock of channel 0 command filter.
  //bit 18  force to disable the clock of channel 0 wbuf generation.
  //bit 17  force to disable the clock of channel 0 rbuf generation.
  //bit 16  force to disable the clock of channel 0 ddr0 command filter.
  //bit 8.  test.
  //bit 7.  rd response.
  //bit 6.  read split.
  //bit 5.  read sec check.
  //bit 4.  write response.
  //bit 3.  wd control.
  //bit 2.  qos monitor.
  //bit 1:0.    not used.
#define P_DMC_MON_CTRL0                            (volatile uint32_t *)0xfe036040
   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.  read 1 = qos mon finish interrupt.
   //bit 7:0    bw_mon_range_en.    enables 8 monitor channels.
#define P_DMC_MON_TIMER                            (volatile uint32_t *)0xfe036044
 // timer for the monitor period.
#define P_DMC_MON_ALL_IDLE_CNT                     (volatile uint32_t *)0xfe036048
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define P_DMC_MON_ALL_BW                           (volatile uint32_t *)0xfe03604c
  // at the test period,  the whole MMC granted data cycles. units one data clock cycle = 16bytes.
#define P_DMC_MON_ALL16_BW                         (volatile uint32_t *)0xfe036050
  // at the test period,  the whole MMC granted data cycles which goes to 16bits ddr. units one data clock cycle = 16byte.
#define P_DMC_MON0_CTRL1                           (volatile uint32_t *)0xfe036060
//bit 31:16 not used.
//bit 15:0. mon0 R/W ack AXI subid enable.
#define P_DMC_MON1_CTRL1                           (volatile uint32_t *)0xfe036064
//bit 31:16 not used.
//bit 15:0. mon1 R/W ack AXI subid enable.
#define P_DMC_MON2_CTRL1                           (volatile uint32_t *)0xfe036068
//bit 31:16 not used.
//bit 15:0. mon2 R/W ack AXI subid enable.
#define P_DMC_MON3_CTRL1                           (volatile uint32_t *)0xfe03606c
//bit 31:16 not used.
//bit 15:0. mon3 R/W ack AXI subid enable.
#define P_DMC_MON4_CTRL1                           (volatile uint32_t *)0xfe036070
//bit 31:16 not used.
//bit 15:0. mon4 R/W ack AXI subid enable.
#define P_DMC_MON5_CTRL1                           (volatile uint32_t *)0xfe036074
//bit 31:16 not used.
//bit 15:0. mon5 R/W ack AXI subid enable.
#define P_DMC_MON6_CTRL1                           (volatile uint32_t *)0xfe036078
//bit 31:16 not used.
//bit 15:0. mon6 R/W ack AXI subid enable.
#define P_DMC_MON7_CTRL1                           (volatile uint32_t *)0xfe03607c
//bit 31:16 not used.
//bit 15:0. mon7 R/W ack AXI subid enable.
//each monitor can check upto 3 master IDs.
#define P_DMC_MON0_STA                             (volatile uint32_t *)0xfe036080
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define P_DMC_MON0_EDA                             (volatile uint32_t *)0xfe036084
  //bit 31:20. Not used.
  //bit 19:0  MON0 end address unit 4Kbyte.
#define P_DMC_MON0_CTRL                            (volatile uint32_t *)0xfe036088
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON0_BW                              (volatile uint32_t *)0xfe03608c
  //monitor bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON1_STA                             (volatile uint32_t *)0xfe036090
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define P_DMC_MON1_EDA                             (volatile uint32_t *)0xfe036094
  //bit 31:20. Not used.
  //bit 19:0  MON0 end address unit 4Kbyte.
#define P_DMC_MON1_CTRL                            (volatile uint32_t *)0xfe036098
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON1_BW                              (volatile uint32_t *)0xfe03609c
  //monitor 1 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON2_STA                             (volatile uint32_t *)0xfe0360a0
  //bit 31:20. not used.
  //bit 19:0  MON0 start address unit 4Kbyte.
#define P_DMC_MON2_EDA                             (volatile uint32_t *)0xfe0360a4
  //bit 31:20. Not used.
  //bit 19:0  MON2 end address unit 4Kbyte.
#define P_DMC_MON2_CTRL                            (volatile uint32_t *)0xfe0360a8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON2_BW                              (volatile uint32_t *)0xfe0360ac
  //monitor 2 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON3_STA                             (volatile uint32_t *)0xfe0360b0
  //bit 31:20. not used.
  //bit 19:0  MON3 start address unit 4Kbyte.
#define P_DMC_MON3_EDA                             (volatile uint32_t *)0xfe0360b4
  //bit 31:20. Not used.
  //bit 19:0  MON3 end address unit 4Kbyte.
#define P_DMC_MON3_CTRL                            (volatile uint32_t *)0xfe0360b8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON3_BW                              (volatile uint32_t *)0xfe0360bc
  //monitor 3 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON4_STA                             (volatile uint32_t *)0xfe0360c0
  //bit 31:20. not used.
  //bit 19:0  MON4 start address unit 4Kbyte.
#define P_DMC_MON4_EDA                             (volatile uint32_t *)0xfe0360c4
  //bit 31:20. Not used.
  //bit 19:0  MON4 end address unit 4Kbyte.
#define P_DMC_MON4_CTRL                            (volatile uint32_t *)0xfe0360c8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON4_BW                              (volatile uint32_t *)0xfe0360cc
  //monitor 4 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON5_STA                             (volatile uint32_t *)0xfe0360d0
  //bit 31:20. not used.
  //bit 19:0  MON5 start address unit 4Kbyte.
#define P_DMC_MON5_EDA                             (volatile uint32_t *)0xfe0360d4
  //bit 31:20. Not used.
  //bit 19:0  MON4 end address unit 4Kbyte.
#define P_DMC_MON5_CTRL                            (volatile uint32_t *)0xfe0360d8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON5_BW                              (volatile uint32_t *)0xfe0360dc
  //monitor 5 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON6_STA                             (volatile uint32_t *)0xfe0360e0
  //bit 31:20. not used.
  //bit 19:0  MON6 start address unit 4Kbyte.
#define P_DMC_MON6_EDA                             (volatile uint32_t *)0xfe0360e4
  //bit 31:20. Not used.
  //bit 19:0  MON6 end address unit 4Kbyte.
#define P_DMC_MON6_CTRL                            (volatile uint32_t *)0xfe0360e8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON6_BW                              (volatile uint32_t *)0xfe0360ec
  //monitor 6 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_MON7_STA                             (volatile uint32_t *)0xfe0360f0
  //bit 31:20. not used.
  //bit 19:0  MON7 start address unit 4Kbyte.
#define P_DMC_MON7_EDA                             (volatile uint32_t *)0xfe0360f4
  //bit 31:20. Not used.
  //bit 19:0  MON7 end address unit 4Kbyte.
#define P_DMC_MON7_CTRL                            (volatile uint32_t *)0xfe0360f8
  //bit 31:24. not used.
  //bit 23:0. master ID number.
#define P_DMC_MON7_BW                              (volatile uint32_t *)0xfe0360fc
  //monitor 7 bandwidth report. read only.  unit: 1 clock cycle data transfer = 16byte.
#define P_DMC_CMD_FILTER_CTRL0                     (volatile uint32_t *)0xfe036128
  //23:16   urgent4 bank hold
  //15:8    rbuf urgent5 hold
  //7:0     rbuf urgent4 hold
#define P_DMC_CMD_FILTER_CTRL1                     (volatile uint32_t *)0xfe036100
  //31:24   rbuf urgent3 hold
  //23:16   rbuf urgent2 hold
  //15:8    rbuf urgent1 hold
  //7:0     rbuf urgent0 hold
#define P_DMC_CMD_FILTER_CTRL2                     (volatile uint32_t *)0xfe036104
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.
#define P_DMC_CMD_FILTER_CTRL3                     (volatile uint32_t *)0xfe036108
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number
#define P_DMC_CMD_FILTER_CTRL4                     (volatile uint32_t *)0xfe03610c
  //bit 31:26.  rank write min number
  //bit 25:20.  rank read min number
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.
#define P_DMC_CMD_FILTER_CTRL5                     (volatile uint32_t *)0xfe036110
  //bit 31:24   Once ddr data bus switch to read, the maxmum read command number to give up the bus when there's write request pending for write buffer.
  //bit 23:16   Once ddr data bus switch to write, the maxmum write command number to give up the bus when there's read request pending too long.
  //bit 15:8.   Once ddr data bus switch to read, the minimum read command number to transfer back to write stage if there's still pending read request.
  //bit 7:0.    Once ddr data bus switch to write, the minimum write command number to transfer back to read stage if there's still pending write request.
#define P_DMC_CMD_FILTER_CTRL6                     (volatile uint32_t *)0xfe036114
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.
#define P_DMC_CMD_FILTER_CTRL7                     (volatile uint32_t *)0xfe036118
  //bit 31:24.  aw_req_pending singal assertion after wbuf full.
  //bit 23:16   aw_req_pending singal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.
#define P_DMC_CMD_FILTER_CTRL8                     (volatile uint32_t *)0xfe03611c
  //bit 31:24   tITW_short
  //bit 23:16   tITW_long
  //bit 15:8    rank limit minmum to change to another rank if another rank has hit request.
  //bit 7:0     rank limit to change to another rank.
#define P_DMC_CMD_BUFFER_CTRL                      (volatile uint32_t *)0xfe036120
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8   reserved.
  //bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write command waiting to in write buffer that long.
#define P_DMC_CMD_BUFFER_CTRL1                     (volatile uint32_t *)0xfe036124
  //bit 31.    rbuf urgent 4 read hit request high priority enable.
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.
#define P_DMC_2ARB_CTRL                            (volatile uint32_t *)0xfe036130
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //23:10.  Not used.
  //9:0.   cfg_inc_ugt_limit. increase urgent level if the arbiter wait that long.
#define P_DMC_VERSION                              (volatile uint32_t *)0xfe03613c
   //read only 32'h01000024  for s7
#define P_DMC_AXI0_CHAN_CTRL                       (volatile uint32_t *)0xfe036200
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI0_HOLD_CTRL                       (volatile uint32_t *)0xfe036204
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI0_CHAN_CTRL1                      (volatile uint32_t *)0xfe036208
  //31:28.  FIQ  chan0 QOS setting.
  //27:24.  IRQ  chan0 QOS setting.
  //23:23.  chan0 write QOS with VPU request.
  //19:16.  chan0 write QOS with other request .
  //15:12.  chan0 write QOS with none other requests.
  //11:8.   chan0 read QOS with VPU request.
  //7:4.    chan0 read QOS with other request .
  //3:0.    chan0 read QOS with none other requests.
#define P_DMC_AXI0_CHAN_CTRL2                      (volatile uint32_t *)0xfe03620c
 //bit 31:4.  Not used.
 //bit 3.     CPU FIQ QOS ctrl_en.
 //bit 2.     CPU IRQ QOS ctrl_en.
 //bit 1.     CPU read channel auto QOS enable (based on other traffic).
 //bit 0.     CPU write channel auto QOS enable( based on other traffic).
#define P_DMC_AXI1_CHAN_CTRL                       (volatile uint32_t *)0xfe036210
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define P_DMC_AXI1_HOLD_CTRL                       (volatile uint32_t *)0xfe036214
  //bit 31:24 write hold num.   max outstanding request number.
  //bit 23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
  //bit 15:8 read hold num.   max outstanding request number.
  //bit 7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI1_CHAN_CTRL1                      (volatile uint32_t *)0xfe036218
   //bit 30     cfg_wrdata_mode
   //bit 30:29. not used.
   //bit 29:16. when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block vpu itself and  CPU or other urgent request.
   //bit 15:12. Not used.				
   //bit 11.   use side band write urgent control signal to control AWQOS.  1: enabe. 0: disable.
   //bit 10.   use side band read  urgent control signal to control ARQOS.  1: enabe. 0: disable.
   //bit 9.    use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 8.    use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 7:4.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 3:0.  the ARQOS value when side band read  urgent control signal = 1 while bit 18 enabled.
#define P_DMC_AXI2_CHAN_CTRL                       (volatile uint32_t *)0xfe036220
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI2_HOLD_CTRL                       (volatile uint32_t *)0xfe036224
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI2_CHAN_CTRL1                      (volatile uint32_t *)0xfe036228
   //bit 30     cfg_wrdata_mode
   //bit 30:29. not used.
   //bit 29:16. when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block vpu itself and  CPU or other urgent request.
   //bit 15:12. Not used.				
   //bit 11.   use side band write urgent control signal to control AWQOS.  1: enabe. 0: disable.
   //bit 10.   use side band read  urgent control signal to control ARQOS.  1: enabe. 0: disable.
   //bit 9.    use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 8.    use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 7:4.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 3:0.  the ARQOS value when side band read  urgent control signal = 1 while bit 18 enabled.
#define P_DMC_AXI3_CHAN_CTRL                       (volatile uint32_t *)0xfe036230
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI3_HOLD_CTRL                       (volatile uint32_t *)0xfe036234
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI3_CHAN_CTRL1                      (volatile uint32_t *)0xfe036238
#define P_DMC_AXI4_CHAN_CTRL                       (volatile uint32_t *)0xfe036240
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI4_HOLD_CTRL                       (volatile uint32_t *)0xfe036244
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI4_CHAN_CTRL1                      (volatile uint32_t *)0xfe036248
#define P_DMC_AXI5_CHAN_CTRL                       (volatile uint32_t *)0xfe036250
  //not used.
#define P_DMC_AXI5_HOLD_CTRL                       (volatile uint32_t *)0xfe036254
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI6_CHAN_CTRL                       (volatile uint32_t *)0xfe036260
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI6_HOLD_CTRL                       (volatile uint32_t *)0xfe036264
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI6_CHAN_CTRL1                      (volatile uint32_t *)0xfe036268
#define P_DMC_AXI7_CHAN_CTRL                       (volatile uint32_t *)0xfe036270
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI7_HOLD_CTRL                       (volatile uint32_t *)0xfe036274
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI7_CHAN_CTRL1                      (volatile uint32_t *)0xfe036278
#define P_DMC_AXI0_CHAN_STS                        (volatile uint32_t *)0xfe036280
  // AXI0 Async interface status.
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.   not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI1_CHAN_STS                        (volatile uint32_t *)0xfe036284
  // AXI1 Async interface status
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI2_CHAN_STS                        (volatile uint32_t *)0xfe036288
  //AXI chan2 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI3_CHAN_STS                        (volatile uint32_t *)0xfe03628c
  //AXI chan3 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI4_CHAN_STS                        (volatile uint32_t *)0xfe036290
  //AXI chan4 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI5_CHAN_STS                        (volatile uint32_t *)0xfe036294
  //AXI chan4 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  write address without read data counter.
  //7:0.  not used.
#define P_DMC_AXI6_CHAN_STS                        (volatile uint32_t *)0xfe036298
  //AXI channel 6 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI7_CHAN_STS                        (volatile uint32_t *)0xfe03629c
  //AXI channel 7 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI8_CHAN_STS                        (volatile uint32_t *)0xfe0362a0
  //AXI channel 7 status.
  //31:24. read command pending transaction number.
  //23:16. write command pending transaction number.
  //15:8.  AWVALID without WDATA transaction number..
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define P_DMC_AXI8_CHAN_CTRL                       (volatile uint32_t *)0xfe0362b0
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define P_DMC_AXI8_HOLD_CTRL                       (volatile uint32_t *)0xfe0362b4
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define P_DMC_AXI8_CHAN_CTRL1                      (volatile uint32_t *)0xfe0362b8
#define P_DMC_AXI9_CHAN_CTRL                       (volatile uint32_t *)0xfe0362c0
#define P_DMC_AXI9_HOLD_CTRL                       (volatile uint32_t *)0xfe0362c4
#define P_DMC_AXI9_CHAN_CTRL1                      (volatile uint32_t *)0xfe0362c8
#define P_DMC_AXI9_CHAN_STS                        (volatile uint32_t *)0xfe0362cc
#define P_DMC_AXI10_CHAN_CTRL                      (volatile uint32_t *)0xfe0362d0
#define P_DMC_AXI10_HOLD_CTRL                      (volatile uint32_t *)0xfe0362d4
#define P_DMC_AXI10_CHAN_CTRL1                     (volatile uint32_t *)0xfe0362d8
#define P_DMC_AXI10_CHAN_STS                       (volatile uint32_t *)0xfe0362dc
#define P_DMC_AXI11_CHAN_CTRL                      (volatile uint32_t *)0xfe0362e0
#define P_DMC_AXI11_HOLD_CTRL                      (volatile uint32_t *)0xfe0362e4
#define P_DMC_AXI11_CHAN_CTRL1                     (volatile uint32_t *)0xfe0362e8
#define P_DMC_AXI11_CHAN_STS                       (volatile uint32_t *)0xfe0362ec
#define P_DMC_AXI12_CHAN_CTRL                      (volatile uint32_t *)0xfe0362f0
#define P_DMC_AXI12_HOLD_CTRL                      (volatile uint32_t *)0xfe0362f4
#define P_DMC_AXI12_CHAN_CTRL1                     (volatile uint32_t *)0xfe0362f8
#define P_DMC_AXI12_CHAN_STS                       (volatile uint32_t *)0xfe0362fc
#define P_DMC_AXI13_CHAN_CTRL                      (volatile uint32_t *)0xfe036300
#define P_DMC_AXI13_HOLD_CTRL                      (volatile uint32_t *)0xfe036304
#define P_DMC_AXI13_CHAN_CTRL1                     (volatile uint32_t *)0xfe036308
#define P_DMC_AXI13_CHAN_STS                       (volatile uint32_t *)0xfe03630c
#define P_DMC_AXI0_CHAN_STS1                       (volatile uint32_t *)0xfe036310
  //7:4. CPU FIQ STS
  //3:0. CPU IRQ STS.
#define P_DMC_CHAN_STS                             (volatile uint32_t *)0xfe036330
  // read only register.
  //bit 31:30   not used. always 1
  //bit 29      ddr1 read buf idle.  1 : idle 0: busy.
  //bit 28      ddr0 read buf idle.  1 : idle 0: busy.
  //bit 27      ddr1 write data buffer idle. 1 : idle 0: busy.
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      ddr1 wbuf idle.              1 : idle 0: busy.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:14    not used.   always 1.
  //bit 13       AXI channel13 idle.
  //bit 12       AXI channel12 idle.
  //bit 11       AXI channel11 idle.
  //bit 10       AXI channel10 idle.
  //bit 9       AXI channel9 idle.
  //bit 8       AXI channel8 idle.
  //bit 7       AXI channel7 idle.
  //bit 6       AXI channel6 idle.
  //bit 5       AXI channel5 idle.
  //bit 4       AXI channel4 idle.
  //bit 3       AXI channel3 idle.
  //bit 2       AXI channel2 idle.
  //bit 1       AXI channel1 idle.
  //bit 0       AXI channel0 idle.
#define P_DMC_MON_IRQ_STS                          (volatile uint32_t *)0xfe03636c
  //bit 31:1   Not used.
  //bit 0 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrup.  write 1 to clean this interrupt.
//DMC protection function domain register.
// one protection can chose upto 4 master IDs to monitors.
//for these 4 master IDs, you can chose either include them. or exclude them.
#define P_DMC_PROT0_STA                            (volatile uint32_t *)0xfe036380
  //31:20. not used.
  //19:0   protection 0 start address . unit 4Kbyte.
#define P_DMC_PROT0_EDA                            (volatile uint32_t *)0xfe036384
  //31:20. not used.
  //19:0   protection 0 end address. unit 4Kbyte.
#define P_DMC_PROT0_CTRL                           (volatile uint32_t *)0xfe036388
  //bit 31:16. not used.
  //bit 15:0.  prot0 id enable.
#define P_DMC_PROT0_CTRL1                          (volatile uint32_t *)0xfe03638c
  //bit 31:27. not used.
  //bit 26:    (read channel) prot0 enable.
  //bit 25:    not used.
  //bit 24:    (write channel) prot0 enable.
  //bit 23:16  not used.
  //bit 15:0.  prot0 subid enable.
#define P_DMC_PROT1_STA                            (volatile uint32_t *)0xfe036390
  //bit 31:20. not used.
  //bit 19:0   protection 1 start address . unit 4Kbyte.
#define P_DMC_PROT1_EDA                            (volatile uint32_t *)0xfe036394
  //bit 31:20. not used.
  //bit 19:0   protection 1 end address. unit 4Kbyte.
#define P_DMC_PROT1_CTRL                           (volatile uint32_t *)0xfe036398
  //bit 31:16. not used.
  //bit 15:0.  prot1 id enable.
#define P_DMC_PROT1_CTRL1                          (volatile uint32_t *)0xfe03639c
  //bit 31:27. not used.
  //bit 26:    (read channel) prot1 enable.
  //bit 25:    not used.
  //bit 24:    (write channel) prot1 enable.
  //bit 23:16  not used.
  //bit 15:0.  prot1 subid enable.
#define P_DMC_PROT_VIO_0                           (volatile uint32_t *)0xfe0363a0
  //protection write violation low 32bits address.
#define P_DMC_PROT_VIO_1                           (volatile uint32_t *)0xfe0363a4
  //bit 31:12. not used.
  //bit 11.    protection 1 write violation.
  //bit 10.    protection 0 write violation.
  //bit 9:0    AWUSER. please refer  AXI bus AWUSER bits define.
#define P_DMC_PROT_VIO_2                           (volatile uint32_t *)0xfe0363a8
  //protection read violation low 32bits address. ARADDR[31:0].
#define P_DMC_PROT_VIO_3                           (volatile uint32_t *)0xfe0363ac
  //bit 31:12. not used.
  //bit 11.    protection 1 read violation.
  //bit 10.    protection 0 read violation.
  //bit 9:0    ARUSER. please refer AXI bus ARUSER bits define.
#define P_DMC_PROT_IRQ_CTRL_STS                    (volatile uint32_t *)0xfe0363b0
  //bit 2.   protection IRQ enable.
  //bit 1.   read for write prot violation. write 1 to clean the write protection status and interrup.
  //bit 0.   read for read prot violation. write 1 to clean the read protection status and interrup.
#define P_DMC_PROT0_CTRL2                          (volatile uint32_t *)0xfe0363b4
  //bit 19.  prot0 SubID3 en for prot0 id3.
  //bit 18.  prot0 SubID2 en for prot0 id2.
  //bit 17.  prot0 SubID1 en for prot0 id1.
  //bit 16.  prot0 SubID0 en for prot0 id0.
  //bit 15:12.prot0 subid3 id number.
  //bit 11:8. prot0 subid2 id number.
  //bit 7:4.  prot0 subid1 id number.
  //bit 3:0.  prot0 subid0 id number.
#define P_DMC_PROT1_CTRL2                          (volatile uint32_t *)0xfe0363b8
  //bit 19.   prot1 SubID3 en for prot0 id3.
  //bit 18.   prot1 SubID2 en for prot0 id2.
  //bit 17.   prot1 SubID1 en for prot0 id1.
  //bit 16.   prot1 SubID0 en for prot0 id0.
  //bit 15:12.prot1 subid3 id number.
  //bit 11:8. prot1 subid2 id number.
  //bit 7:4.  prot1 subid1 id number.
  //bit 3:0.  prot1 subid0 id number.
//SIU register.
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency, the hardware would automatically select one of these two set of timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define P_DMC_DRAM_TMRD                            (volatile uint32_t *)0xfe036400
   //bit 7:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define P_DMC_DRAM_TRFC                            (volatile uint32_t *)0xfe036404
   //bit 25:16 tRFCpb
   //bit 9:0   tRFCab
#define P_DMC_DRAM_TRP                             (volatile uint32_t *)0xfe036408
   //bit 23:16.  tRP for precharge all banks.
   //bit 7:0.    tRP for precharge one bank.
#define P_DMC_DRAM_TRTW                            (volatile uint32_t *)0xfe03640c
   //bit 31:8:   Not used.
   //bit 7:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + TDQSCK_MAX + tWPRE +RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define P_DMC_DRAM_TCL                             (volatile uint32_t *)0xfe036410
  //bit 7:0  tCL/tRL. read latency.
#define P_DMC_DRAM_TCWL                            (volatile uint32_t *)0xfe036414
  //bit 7:0.  CWL:  write latency.
#define P_DMC_DRAM_TRAS                            (volatile uint32_t *)0xfe036418
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define P_DMC_DRAM_TRC                             (volatile uint32_t *)0xfe03641c
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define P_DMC_DRAM_TRCD                            (volatile uint32_t *)0xfe036420
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define P_DMC_DRAM_TRRD                            (volatile uint32_t *)0xfe036424
  //bit 23:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 7:0.    tRRD/tRRD_s   active bank A to active bank b time.
              //tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define P_DMC_DRAM_TFAW                            (volatile uint32_t *)0xfe036428
  //bit 8:0   tFAW.  four active command windows
#define P_DMC_DRAM_TRTP                            (volatile uint32_t *)0xfe03642c
  //bit 7:0  tRTP. in LPDDR5 should be tBL + tRBTP
#define P_DMC_DRAM_TWR                             (volatile uint32_t *)0xfe036430
  //bit 7:0 tWR.
#define P_DMC_DRAM_TWTR                            (volatile uint32_t *)0xfe036434
  //bit 23:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 7:0 tWTR_s.
#define P_DMC_DRAM_TCCD                            (volatile uint32_t *)0xfe036438
  //bit 21:16. tCCD/tCCD_l.
  //bit 5:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define P_DMC_DRAM_TEXSR                           (volatile uint32_t *)0xfe03643c
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define P_DMC_DRAM_TXS                             (volatile uint32_t *)0xfe036440
  //bit 10:0  tXS.  EXIT SELF_REFRESH to other command time
#define P_DMC_DRAM_TXP                             (volatile uint32_t *)0xfe036444
  //bit 6:0. LPDDR4 tXP.  EXIT power down to other command time
             //LPDDR5 tCSL
#define P_DMC_DRAM_TXPDLL                          (volatile uint32_t *)0xfe036448
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define P_DMC_DRAM_TZQCS                           (volatile uint32_t *)0xfe03644c
  //bit 7:0.  ZQCS command to other command time.
#define P_DMC_DRAM_TCKSRE                          (volatile uint32_t *)0xfe036450
  //bit 7:0. enter self refresh to disable clock time.
#define P_DMC_DRAM_TCKSRX                          (volatile uint32_t *)0xfe036454
  //bit 7:0. enable clock to exit self refresh time.
#define P_DMC_DRAM_TCKE                            (volatile uint32_t *)0xfe036458
  //bit 7:0.  CKE high or low minimum time.
             //LPDDR5: tCSPD. power down to power up
#define P_DMC_DRAM_TMOD                            (volatile uint32_t *)0xfe03645c
  //bit 7:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register but it called tMRD.
#define P_DMC_DRAM_TDQS                            (volatile uint32_t *)0xfe036460
  //bit 31:28 reserved
  //bit 27:24 tDQS_wr. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS_rw. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS_ww. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS_rr. the delay for read after read in different rank.
#define P_DMC_DRAM_TRSTL                           (volatile uint32_t *)0xfe036464
  //bit 6:0 t_tstl. not used.
#define P_DMC_DRAM_TZQLAT                          (volatile uint32_t *)0xfe036468
  //bit 7:0 ZQ LATCH command to other comand timing in LPDDR4 mode.
#define P_DMC_DRAM_TMRR                            (volatile uint32_t *)0xfe03646c
  //bit 7:0 tMRR  not used in DMC.
#define P_DMC_DRAM_TCKESR                          (volatile uint32_t *)0xfe036470
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define P_DMC_DRAM_TDPD                            (volatile uint32_t *)0xfe036474
 //bit 9:0 tdpd. not support.
#define P_DMC_DRAM_DFITCTRLDELAY                   (volatile uint32_t *)0xfe036478
  //bit 5:0. DFI_t_ctrldelay
#define P_DMC_DRAM_DFITPHYWRDATA                   (volatile uint32_t *)0xfe03647c
  //bit 5:0.  dfi_t_phy_wrdata.
#define P_DMC_DRAM_DFITPHYWRLAT                    (volatile uint32_t *)0xfe036480
  //bit 7:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define P_DMC_DRAM_DFITRDDATAEN                    (volatile uint32_t *)0xfe036484
  //bit 7:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define P_DMC_DRAM_DFITPHYRDLAT                    (volatile uint32_t *)0xfe036488
  //bit 7:0.  dfi_t_rdlat.
#define P_DMC_DRAM_DFITCTRLUPDMIN                  (volatile uint32_t *)0xfe03648c
  //bit 15:0.  CTRLUPD_MIN  minimum clock cycle to maintain CTRLUPD_REQ.
#define P_DMC_DRAM_DFITCTRLUPDMAX                  (volatile uint32_t *)0xfe036490
  //bit 15:0   CTRLUPD_MAX.  maximum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define P_DMC_DRAM_DFITREFMSKI                     (volatile uint32_t *)0xfe036498
  //not used.
#define P_DMC_DRAM_DFITCTRLUPDI                    (volatile uint32_t *)0xfe03649c
  //bit 31:0    frq0_dfitctrlupdi. not used.
#define P_DMC_DRAM_DFITDRAMCLK                     (volatile uint32_t *)0xfe0364a0
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer
#define P_DMC_DRAM_DFITLPRESP                      (volatile uint32_t *)0xfe0364a8
  //bit 4:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.
#define P_DMC_DRAM_TCKECK                          (volatile uint32_t *)0xfe0364b0
 //bit 7:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay
            //in LPDDR5 tCSLCK
#define P_DMC_DRAM_TREFI                           (volatile uint32_t *)0xfe0364b4
 //write this register will update the auto refresh related register to the auto refresh control logic.
 //bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
 //bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
 //bit 15:0.   tREFI.dmc send auto refresh command period. unit is dmc clock cycles
#define P_DMC_DRAM_TSR                             (volatile uint32_t *)0xfe0364b8
  //bit 7:0 tSR.  self resfresh enter to exit time.
#define P_DMC_DRAM_TCCDMW                          (volatile uint32_t *)0xfe0364bc
  //bit 7:0.  4*tCCD in LPDDR4 mask write.
#define P_DMC_DRAM_TESCKE                          (volatile uint32_t *)0xfe0364c0
  //bit 7:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define P_DMC_DRAM_TREFI_DDR3                      (volatile uint32_t *)0xfe0364c4
  //9:0. use this register to reset refi_disable_cnt. the unit is t100ns.
  //use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define P_DMC_DRAM_TZQCAL                          (volatile uint32_t *)0xfe0364c8
  //15:0. ZQCAL for LPDDR4.  tZQCAL4/8/16 for LP5.
#define P_DMC_DRAM_T10US                           (volatile uint32_t *)0xfe0364cc
  //bit 15:0 10us clock cycle number used for LP2 mode.
#define P_DMC_DRAM_TMRRI                           (volatile uint32_t *)0xfe0364d0
//bit 7:0   tMRRI for MRR
#define P_DMC_DRAM_TXS_FAST                        (volatile uint32_t *)0xfe0364d4
 //bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define P_DMC_DRAM_DFIODTCFG                       (volatile uint32_t *)0xfe0364d8
  //bit 12.  rank1 ODT default. default value for ODT[1] pins if theres no read/write activity.
  //bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
  //bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
  //bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
  //bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occure in rank0.
  //bit 4.   rank0 ODT default.    default value for ODT[0] pins if theres no read/write activity.
  //bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
  //bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
  //bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
  //bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occure in rank1.
#define P_DMC_DRAM_DFIODTCFG1                      (volatile uint32_t *)0xfe0364dc
  //bit 28:24  ODT length for BL8 read transfer.
  //bit 20:16. ODT length for BL8 write transfer.
  //bit 13:8.  ODT latency for reads.  suppose to be 0.
  //bit 5:0.   ODT latency for writes.  suppose to be 0.
#define P_DMC_DRAM_TWODTON                         (volatile uint32_t *)0xfe0364e0
  //bit 7:0   DRAM write access ODT on time.
  //   in DDR3/4 should be same as WL.
  //   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
  //   In LPDDR4 ODT disable mode:  tWL.
#define P_DMC_DRAM_PHYADDRON                       (volatile uint32_t *)0xfe0364e8
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define P_DMC_DRAM_PHYWRON                         (volatile uint32_t *)0xfe0364ec
  //bit 6:0 PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define P_DMC_DRAM_PHYRDON                         (volatile uint32_t *)0xfe0364f0
  //bit 6:0 PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2
#define P_DMC_DRAM_ZQCTRL                          (volatile uint32_t *)0xfe0364f4
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period, which refresh period count to send ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.
#define P_DMC_DRAM_DFITPHYWRLATCSN                 (volatile uint32_t *)0xfe0364f8
  //not used. bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define P_DMC_DRAM_DFITRDDATACSN                   (volatile uint32_t *)0xfe0364fc
  //not used. bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define P_DMC_DRAM_TPBR                            (volatile uint32_t *)0xfe036680
  //bit 23:16 tPBR2ACT
  //bit 9:0   tPBR2PBR
#define P_DMC_DRAM_TWCK_FS                         (volatile uint32_t *)0xfe036684
  //not used. timing for wck_fs sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define P_DMC_DRAM_TWCK_WR                         (volatile uint32_t *)0xfe036688
  //not used. timing for wck_wr sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define P_DMC_DRAM_TWCK_RD                         (volatile uint32_t *)0xfe03668c
  //not used. timing for wck_rd sync command
  //bit 31:24 tWCKOFF
  //bit 23:16 tWCKPRE_TOGGLE
  //bit 15:8  tWCKPRE_STATIC
  //bit 7:0   tWCKENL
#define P_DMC_DRAM_TWCK_OFF                        (volatile uint32_t *)0xfe036690
  //not used. timing for wck_rd sync command
  //bit 31:24 not used.
  //bit 23:16 timing from write command to wck off timing.
             //  = WL + BURST + TWCKPOST + tWCK2DQI ?
  //bit 15:8  WCKOFF cmd to other command timing.
  //bit 7:0   timing from read command to wck off timing.
             //  = RL + BURST + TWCKPOST + tWCK2DQO ?
#define P_DMC_DRAM_TPPD                            (volatile uint32_t *)0xfe036694
  //bit 31:24 not used.
  //bit 7:0.  tPPD. precharge to precharge delay in LPDDR5.
#define P_DMC_DRAM_TCSH                            (volatile uint32_t *)0xfe036698
  //bit 7:0.  tCSH for LPDDR5
#define P_DMC_DRAM_TCMDPD                          (volatile uint32_t *)0xfe03669c
  //bit 7:0.  tCMDPD for LPDDR5
#define P_DMC_DRAM_TOSCPD                          (volatile uint32_t *)0xfe0366a0
  //bit 15:0.  tOSCPD for LPDDR5 : tOSCPD + tOSC
#define P_DMC_DRAM_TWCK2DQ                         (volatile uint32_t *)0xfe0366a4
 //not used.
 //bit 23:16. tWCK2DQI max
 //bit 7:0.   tWCK2DQO max
#define P_DMC_DRAM_TRFM                            (volatile uint32_t *)0xfe0366a8
 //not used.
 //9:0. tRFMpb for lpddr5
#define P_DMC_DRAM_TCKMAX                          (volatile uint32_t *)0xfe0366ac
 //9:0  tclk(max).    100ns in LPDDR4.
//timing parameter for frequency set 1.
#define P_DMC_NFQ_TMRD                             (volatile uint32_t *)0xfe036500
#define P_DMC_NFQ_TRFC                             (volatile uint32_t *)0xfe036504
#define P_DMC_NFQ_TRP                              (volatile uint32_t *)0xfe036508
#define P_DMC_NFQ_TRTW                             (volatile uint32_t *)0xfe03650c
#define P_DMC_NFQ_TCL                              (volatile uint32_t *)0xfe036510
#define P_DMC_NFQ_TCWL                             (volatile uint32_t *)0xfe036514
#define P_DMC_NFQ_TRAS                             (volatile uint32_t *)0xfe036518
#define P_DMC_NFQ_TRC                              (volatile uint32_t *)0xfe03651c
#define P_DMC_NFQ_TRCD                             (volatile uint32_t *)0xfe036520
#define P_DMC_NFQ_TRRD                             (volatile uint32_t *)0xfe036524
#define P_DMC_NFQ_TFAW                             (volatile uint32_t *)0xfe036528
#define P_DMC_NFQ_TRTP                             (volatile uint32_t *)0xfe03652c
#define P_DMC_NFQ_TWR                              (volatile uint32_t *)0xfe036530
#define P_DMC_NFQ_TWTR                             (volatile uint32_t *)0xfe036534
#define P_DMC_NFQ_TCCD                             (volatile uint32_t *)0xfe036538
#define P_DMC_NFQ_TEXSR                            (volatile uint32_t *)0xfe03653c
#define P_DMC_NFQ_TXS                              (volatile uint32_t *)0xfe036540
#define P_DMC_NFQ_TXP                              (volatile uint32_t *)0xfe036544
#define P_DMC_NFQ_TXPDLL                           (volatile uint32_t *)0xfe036548
#define P_DMC_NFQ_TZQCS                            (volatile uint32_t *)0xfe03654c
#define P_DMC_NFQ_TCKSRE                           (volatile uint32_t *)0xfe036550
#define P_DMC_NFQ_TCKSRX                           (volatile uint32_t *)0xfe036554
#define P_DMC_NFQ_TCKE                             (volatile uint32_t *)0xfe036558
#define P_DMC_NFQ_TMOD                             (volatile uint32_t *)0xfe03655c
#define P_DMC_NFQ_TDQS                             (volatile uint32_t *)0xfe036560
#define P_DMC_NFQ_TRSTL                            (volatile uint32_t *)0xfe036564
#define P_DMC_NFQ_TZQLAT                           (volatile uint32_t *)0xfe036568
#define P_DMC_NFQ_TMRR                             (volatile uint32_t *)0xfe03656c
#define P_DMC_NFQ_TCKESR                           (volatile uint32_t *)0xfe036570
#define P_DMC_NFQ_TDPD                             (volatile uint32_t *)0xfe036574
#define P_DMC_NFQ_DFITCTRLDELAY                    (volatile uint32_t *)0xfe036578
#define P_DMC_NFQ_DFITPHYWRDATA                    (volatile uint32_t *)0xfe03657c
#define P_DMC_NFQ_DFITPHYWRLAT                     (volatile uint32_t *)0xfe036580
#define P_DMC_NFQ_DFITRDDATAEN                     (volatile uint32_t *)0xfe036584
#define P_DMC_NFQ_DFITPHYRDLAT                     (volatile uint32_t *)0xfe036588
#define P_DMC_NFQ_DFITCTRLUPDMIN                   (volatile uint32_t *)0xfe03658c
#define P_DMC_NFQ_DFITCTRLUPDMAX                   (volatile uint32_t *)0xfe036590
#define P_DMC_NFQ_DFITREFMSKI                      (volatile uint32_t *)0xfe036598
#define P_DMC_NFQ_DFITCTRLUPDI                     (volatile uint32_t *)0xfe03659c
#define P_DMC_NFQ_DFITDRAMCLK                      (volatile uint32_t *)0xfe0365a0
#define P_DMC_NFQ_DFITLPRESP                       (volatile uint32_t *)0xfe0365a8
#define P_DMC_NFQ_TCKECK                           (volatile uint32_t *)0xfe0365b0
#define P_DMC_NFQ_TREFI                            (volatile uint32_t *)0xfe0365b4
#define P_DMC_NFQ_TSR                              (volatile uint32_t *)0xfe0365b8
#define P_DMC_NFQ_TCCDMW                           (volatile uint32_t *)0xfe0365bc
#define P_DMC_NFQ_TESCKE                           (volatile uint32_t *)0xfe0365c0
#define P_DMC_NFQ_TREFI_DDR3                       (volatile uint32_t *)0xfe0365c4
#define P_DMC_NFQ_TZQCAL                           (volatile uint32_t *)0xfe0365c8
#define P_DMC_NFQ_T10US                            (volatile uint32_t *)0xfe0365cc
#define P_DMC_NFQ_TMRRI                            (volatile uint32_t *)0xfe0365d0
#define P_DMC_NFQ_TXS_FAST                         (volatile uint32_t *)0xfe0365d4
#define P_DMC_NFQ_DFIODTCFG                        (volatile uint32_t *)0xfe0365d8
#define P_DMC_NFQ_DFIODTCFG1                       (volatile uint32_t *)0xfe0365dc
#define P_DMC_NFQ_TWODTON                          (volatile uint32_t *)0xfe0365e0
#define P_DMC_NFQ_PHYADDRON                        (volatile uint32_t *)0xfe0365e8
#define P_DMC_NFQ_PHYWRON                          (volatile uint32_t *)0xfe0365ec
#define P_DMC_NFQ_PHYRDON                          (volatile uint32_t *)0xfe0365f0
#define P_DMC_NFQ_ZQCTRL                           (volatile uint32_t *)0xfe0365f4
#define P_DMC_NFQ_DFITPHYWRLATCSN                  (volatile uint32_t *)0xfe0365f8
#define P_DMC_NFQ_DFITRDDATACSN                    (volatile uint32_t *)0xfe0365fc
#define P_DMC_NFQ_TPBR                             (volatile uint32_t *)0xfe0366c0
#define P_DMC_NFQ_TWCK_FS                          (volatile uint32_t *)0xfe0366c4
#define P_DMC_NFQ_TWCK_WR                          (volatile uint32_t *)0xfe0366c8
#define P_DMC_NFQ_TWCK_RD                          (volatile uint32_t *)0xfe0366cc
#define P_DMC_NFQ_TWCK_OFF                         (volatile uint32_t *)0xfe0366d0
#define P_DMC_NFQ_TPPD                             (volatile uint32_t *)0xfe0366d4
#define P_DMC_NFQ_TCSH                             (volatile uint32_t *)0xfe0366d8
#define P_DMC_NFQ_TCMDPD                           (volatile uint32_t *)0xfe0366dc
#define P_DMC_NFQ_TOSCPD                           (volatile uint32_t *)0xfe0366e0
#define P_DMC_NFQ_TWCK2DQ                          (volatile uint32_t *)0xfe0366e4
#define P_DMC_NFQ_TRFM                             (volatile uint32_t *)0xfe0366e8
#define P_DMC_NFQ_TCKMAX                           (volatile uint32_t *)0xfe0366ec
#define P_DMC_DRAM_DFITPHYUPDTYPE0                 (volatile uint32_t *)0xfe036600
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define P_DMC_DRAM_DFITPHYUPDTYPE1                 (volatile uint32_t *)0xfe036604
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define P_DMC_DRAM_DFITPHYUPDTYPE2                 (volatile uint32_t *)0xfe036608
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define P_DMC_DRAM_DFITPHYUPDTYPE3                 (volatile uint32_t *)0xfe03660c
 //bit 7:0. dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.
#define P_DMC_DRAM_MCFG                            (volatile uint32_t *)0xfe036618
 //bit 31:28  not used.
 //bit 27:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23:20  rank0_d16_sel.  16bit mode, rank 0 byte selection.
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit register triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.
#define P_DMC_DRAM_ZQ_CTRL                         (volatile uint32_t *)0xfe03661c
 //bit 31:16. how long PHY will finish PHY ZQ calibration. so DMC can send update request.
 //bit 15:4 not used.
 //bit 3  enable PHY ZQ CAL in ASR mode.
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only
#define P_DMC_DRAM_MCFG1                           (volatile uint32_t *)0xfe036620
 //bit 26.  siu_srx_phymr_en
 //bit 25.  siu_lp4_r17_en
 //bit 23.  mrr_dbi_en. to enable dbi function for MR read.
 //bit 21;  enable separate dfi_lp_data_req. 1: enable. 0: dfi_lp_data_req same as dfi_lp_ctrl_req.
 //bit 20:16 dfi_lp_data_wakeup value.
 //bit 14.  enable SIU read data with DBI result.
 //bit 13.  LPDDR5 LINK_ECC read enable.
 //bit 12.  LPDDR5 LINK_ECC write enable.
 //bit 9.   LPDDR5 use WCK always on mode.
 //bit 8    LPDDR5 wck use WCK_FS command for fast 2 rank wck sync command.
 //bit 7:0.  LPDDR4 MRW DBI data mask pattern.  //default 8'b11111000;
#define P_DMC_DRAM_DFI_CTRL                        (volatile uint32_t *)0xfe036624
  //bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data error. 0 : disable.
  //bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional EXSR time for new command. 0: phy will handle all the timing    after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
#define P_DMC_DRAM_DFIINITCFG                      (volatile uint32_t *)0xfe036628
  //bit 31.     dfi_init_complete status. read only.
  //bit 19:18.  Frequency set 1 dfi_freq_fsp value.
  //bit 17:16.  Frequency set 0 dfi_freq_fsp value.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.
#define P_DMC_DRAM_APD_CTRL                        (volatile uint32_t *)0xfe036630
 //bit 20:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
            //non zero value to enable auto power down when DMC is in idle state for this number of clock cycles.
#define P_DMC_DRAM_ASR_CTRL                        (volatile uint32_t *)0xfe036634
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit [28:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode. //not support for P1 LP5PHY
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
             // Non-zero value enable ASR mode. when DMC is in idle state for this number of clock cycles, the DMC will enter ASR mode.
#define P_DMC_DRAM_REFR_CTRL                       (volatile uint32_t *)0xfe036648
  //bit 28  enable send phy pvt request after PHY ZQ calibration request.
  //bit 27:24 not used.
  //bit 23  enable Per Bank refresh mode.
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  not used.
  //bit 6  not used.
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.
#define P_DMC_DRAM_FREQ_CTRL                       (volatile uint32_t *)0xfe03664c
//bit 31 .  chan0 write 1 to change freqency   read 0: finished.
//bit 30.   chan0 waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29 .  chan1 write 1 to change freqency   read 0: finished.
//bit 28.   chan1 waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 27:23.  not used.
//bit 22    siu_freq_refr_en, enter FREQ_AUTO_REFR after DFI freq init start complete
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW function: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh state in case there's something need to handle.
              //     0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.
#define P_DMC_DRAM_SCFG                            (volatile uint32_t *)0xfe036650
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.
#define P_DMC_DRAM_STAT                            (volatile uint32_t *)0xfe036654
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 30:29.     not used.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:16  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 15:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
                          //1 :   ACCESS sending precharge command.
                          //2 :   ACCESS sending AUTO REFRESH command.
                          //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
                          //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
                          //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.
  //bit 11:8   APD STATUS:   0 :   APD_IDLE
                          //1 :    APD sending PRECHARGE command
                          //2 :    APD sending CKE low command
                          //3 :    APD sending DISABLE DRAM CLOCK command
                          //4 :    APD sending DFI_LP_CTRL_REQ
                          //5 :    APD in Auto Power down mode.
                          //6 :    APD deassert DFI_LP_CTRL_REQ
                          //7 :    APD sending enable DRAM CLOCK command
                          //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
                         //1  :    DRAM_STOP/DRAM_CFG
                         //2  :    DRAM_ACCESS
                         //3  :    DRAM_SLEEP
                         //4  :    DRAM APD(AUTO POWER DOWN).
                         //5  :    IDLE -> STOP/CONFIG
                         //6  :    STOP -> SLEEP
                         //7  :    STOP -> ACCESS
                         //8  :    ACCESS -> SLEEP.
                         //9  :    ACCESS -> STOP
                         //A  :    ACCESS -> APD
                         //B  :    SLEEP -> STOP
                         //C  :    SLEEP -> ACCESS
                         //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.
#define P_DMC_DRAM_STAT1                           (volatile uint32_t *)0xfe036658
  //bit 12:8   sleep_st
  //bit  7:5   train_st
  //bit  4:0   dram_phy_st
#define P_DMC_PHY_RETRAINING_CTRL                  (volatile uint32_t *)0xfe03665c
  //bit 31 :  phy_retraining enable.
  //bit 30 :  check  vpu sleep_en.
  //bit 29 :  retrain_only 1: use full 28:24 as retrain dfi_freq value 0: use only 28:27 + original dfi_freq2:0 as the retrain dfi_freq.
  //bit 28:24 : retraining dfi_freq[4:3], the [2:0] bit still use the dfi_freq bits to keep the frequency.
  //bit 23:    retrain cke mode enable use for LPDDR4 mode. before send dfi_init_start request to DDR_PHY,
               //1: put LPDDR4 SDRAM into self_refresh + power down mode. 0: put LPDDR4 SDRAM in self-refresh  mode.
  //bit 22:16:  reserved
  //bit 15:0: retraining period unit : one refresh period.
#define P_DMC_DFI_ERR_STAT                         (volatile uint32_t *)0xfe036660
 //not used
 //LPDDR4 PHY DFI error information.
 //bit 31:20. not used.
 //bit 9.    ddr0_dfi_error
 //bit 8:5   ddr0_dfi_error_info.
 //bit 4.    ddr1_dfi_error.
 //bit 3:0.  ddr1_dfi_error_info.
#define P_DMC_LP2_TIMER                            (volatile uint32_t *)0xfe036668
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register. if the counter is large than this number,  that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.
#define P_DMC_DRAM_COMPLETE_WAIT                   (volatile uint32_t *)0xfe03666c
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.
#define P_DMC_OSC_CTRL                             (volatile uint32_t *)0xfe036670
//bit 31  osc_en. for LPDDR4 enable MPC DQS2DQ OSC counter .
//bit 30:16.  siu_osc_run.  LPDDR4 DQS interval timer run time in n_clk unit.
//bit 15:0 osc counter value in tREFI time. how long to trigger one DQS2DQ retraining.
#define P_DMC_TEMP_CTRL                            (volatile uint32_t *)0xfe036674
//bit 31  mr temp read control.
//bit 15:0 counter value in t100NS.
#define P_DMC_TEMP_CTRL1                           (volatile uint32_t *)0xfe036678
//bit 7:0  mr index.
#define P_DMC_DRAM_DFI_SWAP_0                      (volatile uint32_t *)0xfe036700
#define P_DMC_DRAM_DFI_SWAP_1                      (volatile uint32_t *)0xfe036704
#define P_DMC_DRAM_DFI_SWAP_2                      (volatile uint32_t *)0xfe036708
#define P_DMC_DRAM_DFI_SWAP_3                      (volatile uint32_t *)0xfe03670c
#define P_DMC_DRAM_DFI_SWAP_4                      (volatile uint32_t *)0xfe036710
#define P_DMC_DRAM_CMD                             (volatile uint32_t *)0xfe036740
 //bit 31. cmd done.  write 0 to clean.
 //bit 30. cmd r/w channel select. 1:chan1  0:chan0
 //bit 8 . dram command is for data 16 bits.
 //bit 7:6 2'b01: user command with data read.
         //2'b10: user command with data write.
         //2'b00: user command without data.
 //bit 5.  user defined command.
 //bit 4.  LPDDR4 MPC write data command( MPC WR FIFO). not support in LPDDR5.
 //bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO). not support in LPDDR5
 //bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
 //bit 1.  mrr comand.
 //bit 0.  mrw command.
#define P_DMC_DRAM_CMD_CODE                        (volatile uint32_t *)0xfe036744
  //bit 27:26. 128bits data cycles . 0: 1 clock cycles;  1: 2  clock cycles; 2: 3 clock cycles; 3:4 clock cycles.
        //LPDDR4 : 2 clock cycles;
        //LPDDR5 : 2 clock cycles for MRR command.  4 cycles for RFF command.
#define P_DMC_DRAM_CMD_TIME                        (volatile uint32_t *)0xfe036748
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.
#define P_DMC_DRAM_WSTRB0                          (volatile uint32_t *)0xfe03674c
#define P_DMC_DRAM_WSTRB1                          (volatile uint32_t *)0xfe036750
#define P_DMC_DRAM_RDBI0                           (volatile uint32_t *)0xfe036754
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define P_DMC_DRAM_RDBI1                           (volatile uint32_t *)0xfe036758
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.
#define P_DMC_DRAM_RSTS                            (volatile uint32_t *)0xfe03675c
    //bit3 data cnt 3 for dfi phy read latency error
    //bit2 data cnt 2 for dfi phy read latency error
    //bit1 data cnt 1 for dfi phy read latency error
    //bit0 data cnt 0 for dfi phy read latency error
//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER comand enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command, the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n, ras_n, cas_n, we_n} value for user command
                                     //in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
             //DDR3:    18:16 bank address. 15:0:  address.
             //DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
             //LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
             //LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge address. 23:18, forth edge address.
           //MRW command format:
              //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
              //bit 15:0   opcode.
#define P_DMC_DRAM_WD0                             (volatile uint32_t *)0xfe036780
#define P_DMC_DRAM_WD1                             (volatile uint32_t *)0xfe036784
#define P_DMC_DRAM_WD2                             (volatile uint32_t *)0xfe036788
#define P_DMC_DRAM_WD3                             (volatile uint32_t *)0xfe03678c
#define P_DMC_DRAM_WD4                             (volatile uint32_t *)0xfe036790
#define P_DMC_DRAM_WD5                             (volatile uint32_t *)0xfe036794
#define P_DMC_DRAM_WD6                             (volatile uint32_t *)0xfe036798
#define P_DMC_DRAM_WD7                             (volatile uint32_t *)0xfe03679c
#define P_DMC_DRAM_WD8                             (volatile uint32_t *)0xfe0367a0
#define P_DMC_DRAM_WD9                             (volatile uint32_t *)0xfe0367a4
#define P_DMC_DRAM_WD10                            (volatile uint32_t *)0xfe0367a8
#define P_DMC_DRAM_WD11                            (volatile uint32_t *)0xfe0367ac
#define P_DMC_DRAM_WD12                            (volatile uint32_t *)0xfe0367b0
#define P_DMC_DRAM_WD13                            (volatile uint32_t *)0xfe0367b4
#define P_DMC_DRAM_WD14                            (volatile uint32_t *)0xfe0367b8
#define P_DMC_DRAM_WD15                            (volatile uint32_t *)0xfe0367bc
#define P_DMC_DRAM_RD0                             (volatile uint32_t *)0xfe0367c0
#define P_DMC_DRAM_RD1                             (volatile uint32_t *)0xfe0367c4
#define P_DMC_DRAM_RD2                             (volatile uint32_t *)0xfe0367c8
#define P_DMC_DRAM_RD3                             (volatile uint32_t *)0xfe0367cc
#define P_DMC_DRAM_RD4                             (volatile uint32_t *)0xfe0367d0
#define P_DMC_DRAM_RD5                             (volatile uint32_t *)0xfe0367d4
#define P_DMC_DRAM_RD6                             (volatile uint32_t *)0xfe0367d8
#define P_DMC_DRAM_RD7                             (volatile uint32_t *)0xfe0367dc
#define P_DMC_DRAM_RD8                             (volatile uint32_t *)0xfe0367e0
#define P_DMC_DRAM_RD9                             (volatile uint32_t *)0xfe0367e4
#define P_DMC_DRAM_RD10                            (volatile uint32_t *)0xfe0367e8
#define P_DMC_DRAM_RD11                            (volatile uint32_t *)0xfe0367ec
#define P_DMC_DRAM_RD12                            (volatile uint32_t *)0xfe0367f0
#define P_DMC_DRAM_RD13                            (volatile uint32_t *)0xfe0367f4
#define P_DMC_DRAM_RD14                            (volatile uint32_t *)0xfe0367f8
#define P_DMC_DRAM_RD15                            (volatile uint32_t *)0xfe0367fc
//chan1 control register.
#define P_DMC_DRAM1_SCFG                           (volatile uint32_t *)0xfe036a00
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.
#define P_DMC_DRAM1_STAT                           (volatile uint32_t *)0xfe036a04
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 30:29.     not used.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:16  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 15:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
                          //1 :   ACCESS sending precharge command.
                          //2 :   ACCESS sending AUTO REFRESH command.
                          //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
                          //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
                          //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.
  //bit 11:8   APD STATUS:   0 :   APD_IDLE
                          //1 :    APD sending PRECHARGE command
                          //2 :    APD sending CKE low command
                          //3 :    APD sending DISABLE DRAM CLOCK command
                          //4 :    APD sending DFI_LP_CTRL_REQ
                          //5 :    APD in Auto Power down mode.
                          //6 :    APD deassert DFI_LP_CTRL_REQ
                          //7 :    APD sending enable DRAM CLOCK command
                          //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
                         //1  :    DRAM_STOP/DRAM_CFG
                         //2  :    DRAM_ACCESS
                         //3  :    DRAM_SLEEP
                         //4  :    DRAM APD(AUTO POWER DOWN).
                         //5  :    IDLE -> STOP/CONFIG
                         //6  :    STOP -> SLEEP
                         //7  :    STOP -> ACCESS
                         //8  :    ACCESS -> SLEEP.
                         //9  :    ACCESS -> STOP
                         //A  :    ACCESS -> APD
                         //B  :    SLEEP -> STOP
                         //C  :    SLEEP -> ACCESS
                         //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.
#define P_DMC_DRAM1_STAT1                          (volatile uint32_t *)0xfe036a08
  //bit 12:8   sleep_st
  //bit  7:5   train_st
  //bit  4:0   dram_phy_st
#define P_DMC_DRAM1_DFI_CTRL                       (volatile uint32_t *)0xfe036a24
//not used
  //bit 31  siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data error. 0 : disable.
  //bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional EXSR time for new command. 0: phy will handle all the timing    after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
#define P_DMC_DRAM1_DFIINITCFG                     (volatile uint32_t *)0xfe036a28
  //bit 31.     dfi_init_complete status. read only.
  //bit 19:18.  Frequency set 1 dfi_freq_fsp value.
  //bit 17:16.  Frequency set 0 dfi_freq_fsp value.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.
#define P_DMC_DRAM1_APD_CTRL                       (volatile uint32_t *)0xfe036a30
 //bit 20:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
            //non zero value to enable auto power down when DMC is in idle state for this number of clock cycles.
#define P_DMC_DRAM1_ASR_CTRL                       (volatile uint32_t *)0xfe036a34
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit [28:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode. //not support for P1 LP5PHY
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
             // Non-zero value enable ASR mode. when DMC is in idle state for this number of clock cycles, the DMC will enter ASR mode.
#define P_DMC_DRAM1_REFR_CTRL                      (volatile uint32_t *)0xfe036a38
  //bit 28  enable send phy pvt request after PHY ZQ calibration request.
  //bit 27:24 refresh post. not used.
  //bit 23  enable Per Bank refresh mode.
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  not used.
  //bit 6  Not used.
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.
#define P_DMC_DRAM1_OSC_CTRL                       (volatile uint32_t *)0xfe036a3c
//bit 31  osc_en. for LPDDR4 enable MPC DQS2DQ OSC counter .
//bit 30:16.  siu_osc_run.  LPDDR4 DQS interval timer run time in n_clk unit.
//bit 15:0 osc counter value in tREFI time. how long to trigger one DQS2DQ retraining.
#define P_DMC_DRAM1_TEMP_CTRL                      (volatile uint32_t *)0xfe036a40
//bit 31  mr temp read control.
//bit 15:0 counter value in t100NS.
#define P_DMC_DRAM1_TEMP_CTRL1                     (volatile uint32_t *)0xfe036a44
//bit 7:0  mr index.
#define P_DMC_DRAM1_DFI_SWAP_0                     (volatile uint32_t *)0xfe036a60
#define P_DMC_DRAM1_DFI_SWAP_1                     (volatile uint32_t *)0xfe036a64
#define P_DMC_DRAM1_DFI_SWAP_2                     (volatile uint32_t *)0xfe036a68
#define P_DMC_DRAM1_DFI_SWAP_3                     (volatile uint32_t *)0xfe036a6c
#define P_DMC_DRAM1_DFI_SWAP_4                     (volatile uint32_t *)0xfe036a70
#define P_DMC_DRAM1_COMPLETE_WAIT                  (volatile uint32_t *)0xfe036a74
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.
#define P_DMC_DRAM_MRR0                            (volatile uint32_t *)0xfe036a80
 //15:0  the 1st MR read result for snoop
#define P_DMC_DRAM_MRR1                            (volatile uint32_t *)0xfe036a84
 //15:0  the 2nd MR read result for snoop
#define P_DMC_DRAM1_MRR0                           (volatile uint32_t *)0xfe036a88
 //15:0  the 2nd MR read result for rfc rate
#define P_DMC_DRAM1_MRR1                           (volatile uint32_t *)0xfe036a8c
 //15:0  the 2nd MR read result for rfc rate
//STICKY registers.
//those register is for software save some temporary value. and because it's in RAM. it won't lose if DMC get reseted.
#define P_DMC_STICKY_0                             (volatile uint32_t *)0xfe036800
#define P_DMC_STICKY_1                             (volatile uint32_t *)0xfe036804
#define P_DMC_STICKY_2                             (volatile uint32_t *)0xfe036808
#define P_DMC_STICKY_3                             (volatile uint32_t *)0xfe03680c
#define P_DMC_STICKY_4                             (volatile uint32_t *)0xfe036810
#define P_DMC_STICKY_5                             (volatile uint32_t *)0xfe036814
#define P_DMC_STICKY_6                             (volatile uint32_t *)0xfe036818
#define P_DMC_STICKY_7                             (volatile uint32_t *)0xfe03681c
#define P_DMC_STICKY_8                             (volatile uint32_t *)0xfe036820
#define P_DMC_STICKY_9                             (volatile uint32_t *)0xfe036824
#define P_DMC_STICKY_10                            (volatile uint32_t *)0xfe036828
#define P_DMC_STICKY_11                            (volatile uint32_t *)0xfe03682c
#define P_DMC_STICKY_12                            (volatile uint32_t *)0xfe036830
#define P_DMC_STICKY_13                            (volatile uint32_t *)0xfe036834
#define P_DMC_STICKY_14                            (volatile uint32_t *)0xfe036838
#define P_DMC_STICKY_15                            (volatile uint32_t *)0xfe03683c
#define P_DMC_STICKY_16                            (volatile uint32_t *)0xfe036840
#define P_DMC_STICKY_17                            (volatile uint32_t *)0xfe036844
#define P_DMC_STICKY_18                            (volatile uint32_t *)0xfe036848
#define P_DMC_STICKY_19                            (volatile uint32_t *)0xfe03684c
#define P_DMC_STICKY_20                            (volatile uint32_t *)0xfe036850
#define P_DMC_STICKY_21                            (volatile uint32_t *)0xfe036854
#define P_DMC_STICKY_22                            (volatile uint32_t *)0xfe036858
#define P_DMC_STICKY_23                            (volatile uint32_t *)0xfe03685c
#define P_DMC_STICKY_24                            (volatile uint32_t *)0xfe036860
#define P_DMC_STICKY_25                            (volatile uint32_t *)0xfe036864
#define P_DMC_STICKY_26                            (volatile uint32_t *)0xfe036868
#define P_DMC_STICKY_27                            (volatile uint32_t *)0xfe03686c
#define P_DMC_STICKY_28                            (volatile uint32_t *)0xfe036870
#define P_DMC_STICKY_29                            (volatile uint32_t *)0xfe036874
#define P_DMC_STICKY_30                            (volatile uint32_t *)0xfe036878
#define P_DMC_STICKY_31                            (volatile uint32_t *)0xfe03687c
#define P_DMC_STICKY_32                            (volatile uint32_t *)0xfe036880
#define P_DMC_STICKY_33                            (volatile uint32_t *)0xfe036884
#define P_DMC_STICKY_34                            (volatile uint32_t *)0xfe036888
#define P_DMC_STICKY_35                            (volatile uint32_t *)0xfe03688c
#define P_DMC_STICKY_36                            (volatile uint32_t *)0xfe036890
#define P_DMC_STICKY_37                            (volatile uint32_t *)0xfe036894
#define P_DMC_STICKY_38                            (volatile uint32_t *)0xfe036898
#define P_DMC_STICKY_39                            (volatile uint32_t *)0xfe03689c
#define P_DMC_STICKY_40                            (volatile uint32_t *)0xfe0368a0
#define P_DMC_STICKY_41                            (volatile uint32_t *)0xfe0368a4
#define P_DMC_STICKY_42                            (volatile uint32_t *)0xfe0368a8
#define P_DMC_STICKY_43                            (volatile uint32_t *)0xfe0368ac
#define P_DMC_STICKY_44                            (volatile uint32_t *)0xfe0368b0
#define P_DMC_STICKY_45                            (volatile uint32_t *)0xfe0368b4
#define P_DMC_STICKY_46                            (volatile uint32_t *)0xfe0368b8
#define P_DMC_STICKY_47                            (volatile uint32_t *)0xfe0368bc
#define P_DMC_STICKY_48                            (volatile uint32_t *)0xfe0368c0
#define P_DMC_STICKY_49                            (volatile uint32_t *)0xfe0368c4
#define P_DMC_STICKY_50                            (volatile uint32_t *)0xfe0368c8
#define P_DMC_STICKY_51                            (volatile uint32_t *)0xfe0368cc
#define P_DMC_STICKY_52                            (volatile uint32_t *)0xfe0368d0
#define P_DMC_STICKY_53                            (volatile uint32_t *)0xfe0368d4
#define P_DMC_STICKY_54                            (volatile uint32_t *)0xfe0368d8
#define P_DMC_STICKY_55                            (volatile uint32_t *)0xfe0368dc
#define P_DMC_STICKY_56                            (volatile uint32_t *)0xfe0368e0
#define P_DMC_STICKY_57                            (volatile uint32_t *)0xfe0368e4
#define P_DMC_STICKY_58                            (volatile uint32_t *)0xfe0368e8
#define P_DMC_STICKY_59                            (volatile uint32_t *)0xfe0368ec
#define P_DMC_STICKY_60                            (volatile uint32_t *)0xfe0368f0
#define P_DMC_STICKY_61                            (volatile uint32_t *)0xfe0368f4
#define P_DMC_STICKY_62                            (volatile uint32_t *)0xfe0368f8
#define P_DMC_STICKY_63                            (volatile uint32_t *)0xfe0368fc
//DMC Security control registers.
//DMC use 15bits ARUSER/AWUSER bits to identify AXI input ports master ID and security requirement and the necessary subID for bandwidth monitor protection functions. .
//bit 7:0.   for upto 256 Master-ID.
//bit  14:8.  for each Master-ID, the master can use those bits to define particular security requirements or bandwidth and protection function special requirements.
//region0(RANGE0) related register.
#define P_DMC_SEC_RANGE0_STA                       (volatile uint32_t *)0xfe037000
  //bit 31:20. not used.
  //bit 19:0.   region start address AXI address [31:12] unit 4Kbyte.
#define P_DMC_SEC_RANGE0_EDA                       (volatile uint32_t *)0xfe037004
  //bit 31:20. not used.
  //bit 19:0.   region end address.for AXI address[33:12]. unit 4Kbyte.
#define P_DMC_SEC_RANGE0_CTRL                      (volatile uint32_t *)0xfe037008
  //bit 7:5.range0_security_level
  //bit 4.  range0_prot_en. range 0 protect monitor function control
  //bit 3.  range0_des_en. range 0 data scrambling enable
  //bit 2.  range0 lock.
  //bit 1.  range0 key select
  //bit 0.  range0 enable
#define P_DMC_SEC_RANGE0_RID_CTRL0                 (volatile uint32_t *)0xfe03700c
  //range_rd_sid_en[31:0];
#define P_DMC_SEC_RANGE0_RID_CTRL1                 (volatile uint32_t *)0xfe037010
  //range_rd_sid_en[63:32];
#define P_DMC_SEC_RANGE0_RID_CTRL2                 (volatile uint32_t *)0xfe037014
  //range_rd_sid_en[95:64];
#define P_DMC_SEC_RANGE0_RID_CTRL3                 (volatile uint32_t *)0xfe037018
  //not used
#define P_DMC_SEC_RANGE0_WID_CTRL0                 (volatile uint32_t *)0xfe037020
  //range_rd_sid_en[31:0];
#define P_DMC_SEC_RANGE0_WID_CTRL1                 (volatile uint32_t *)0xfe037024
  //range_rd_sid_en[63:32];
#define P_DMC_SEC_RANGE0_WID_CTRL2                 (volatile uint32_t *)0xfe037028
  //range_rd_sid_en[95:64];
#define P_DMC_SEC_RANGE0_WID_CTRL3                 (volatile uint32_t *)0xfe03702c
  //not used
//region0(RANGE1) related register.
#define P_DMC_SEC_RANGE1_STA                       (volatile uint32_t *)0xfe037040
#define P_DMC_SEC_RANGE1_EDA                       (volatile uint32_t *)0xfe037044
#define P_DMC_SEC_RANGE1_CTRL                      (volatile uint32_t *)0xfe037048
#define P_DMC_SEC_RANGE1_RID_CTRL0                 (volatile uint32_t *)0xfe03704c
#define P_DMC_SEC_RANGE1_RID_CTRL1                 (volatile uint32_t *)0xfe037050
#define P_DMC_SEC_RANGE1_RID_CTRL2                 (volatile uint32_t *)0xfe037054
#define P_DMC_SEC_RANGE1_RID_CTRL3                 (volatile uint32_t *)0xfe037058
#define P_DMC_SEC_RANGE1_WID_CTRL0                 (volatile uint32_t *)0xfe037060
#define P_DMC_SEC_RANGE1_WID_CTRL1                 (volatile uint32_t *)0xfe037064
#define P_DMC_SEC_RANGE1_WID_CTRL2                 (volatile uint32_t *)0xfe037068
#define P_DMC_SEC_RANGE1_WID_CTRL3                 (volatile uint32_t *)0xfe03706c
//region2(RANGE2) related register.
#define P_DMC_SEC_RANGE2_STA                       (volatile uint32_t *)0xfe037080
#define P_DMC_SEC_RANGE2_EDA                       (volatile uint32_t *)0xfe037084
#define P_DMC_SEC_RANGE2_CTRL                      (volatile uint32_t *)0xfe037088
#define P_DMC_SEC_RANGE2_RID_CTRL0                 (volatile uint32_t *)0xfe03708c
#define P_DMC_SEC_RANGE2_RID_CTRL1                 (volatile uint32_t *)0xfe037090
#define P_DMC_SEC_RANGE2_RID_CTRL2                 (volatile uint32_t *)0xfe037094
#define P_DMC_SEC_RANGE2_RID_CTRL3                 (volatile uint32_t *)0xfe037098
#define P_DMC_SEC_RANGE2_WID_CTRL0                 (volatile uint32_t *)0xfe0370a0
#define P_DMC_SEC_RANGE2_WID_CTRL1                 (volatile uint32_t *)0xfe0370a4
#define P_DMC_SEC_RANGE2_WID_CTRL2                 (volatile uint32_t *)0xfe0370a8
#define P_DMC_SEC_RANGE2_WID_CTRL3                 (volatile uint32_t *)0xfe0370ac
//region3(RANGE3) related register.
#define P_DMC_SEC_RANGE3_STA                       (volatile uint32_t *)0xfe0370c0
#define P_DMC_SEC_RANGE3_EDA                       (volatile uint32_t *)0xfe0370c4
#define P_DMC_SEC_RANGE3_CTRL                      (volatile uint32_t *)0xfe0370c8
#define P_DMC_SEC_RANGE3_RID_CTRL0                 (volatile uint32_t *)0xfe0370cc
#define P_DMC_SEC_RANGE3_RID_CTRL1                 (volatile uint32_t *)0xfe0370d0
#define P_DMC_SEC_RANGE3_RID_CTRL2                 (volatile uint32_t *)0xfe0370d4
#define P_DMC_SEC_RANGE3_RID_CTRL3                 (volatile uint32_t *)0xfe0370d8
#define P_DMC_SEC_RANGE3_WID_CTRL0                 (volatile uint32_t *)0xfe0370e0
#define P_DMC_SEC_RANGE3_WID_CTRL1                 (volatile uint32_t *)0xfe0370e4
#define P_DMC_SEC_RANGE3_WID_CTRL2                 (volatile uint32_t *)0xfe0370e8
#define P_DMC_SEC_RANGE3_WID_CTRL3                 (volatile uint32_t *)0xfe0370ec
//region4(RANGE4) related register.
#define P_DMC_SEC_RANGE4_STA                       (volatile uint32_t *)0xfe037100
#define P_DMC_SEC_RANGE4_EDA                       (volatile uint32_t *)0xfe037104
#define P_DMC_SEC_RANGE4_CTRL                      (volatile uint32_t *)0xfe037108
#define P_DMC_SEC_RANGE4_RID_CTRL0                 (volatile uint32_t *)0xfe03710c
#define P_DMC_SEC_RANGE4_RID_CTRL1                 (volatile uint32_t *)0xfe037110
#define P_DMC_SEC_RANGE4_RID_CTRL2                 (volatile uint32_t *)0xfe037114
#define P_DMC_SEC_RANGE4_RID_CTRL3                 (volatile uint32_t *)0xfe037118
#define P_DMC_SEC_RANGE4_WID_CTRL0                 (volatile uint32_t *)0xfe037120
#define P_DMC_SEC_RANGE4_WID_CTRL1                 (volatile uint32_t *)0xfe037124
#define P_DMC_SEC_RANGE4_WID_CTRL2                 (volatile uint32_t *)0xfe037128
#define P_DMC_SEC_RANGE4_WID_CTRL3                 (volatile uint32_t *)0xfe03712c
//region5(RANGE5) related register.
#define P_DMC_SEC_RANGE5_STA                       (volatile uint32_t *)0xfe037140
#define P_DMC_SEC_RANGE5_EDA                       (volatile uint32_t *)0xfe037144
#define P_DMC_SEC_RANGE5_CTRL                      (volatile uint32_t *)0xfe037148
#define P_DMC_SEC_RANGE5_RID_CTRL0                 (volatile uint32_t *)0xfe03714c
#define P_DMC_SEC_RANGE5_RID_CTRL1                 (volatile uint32_t *)0xfe037150
#define P_DMC_SEC_RANGE5_RID_CTRL2                 (volatile uint32_t *)0xfe037154
#define P_DMC_SEC_RANGE5_RID_CTRL3                 (volatile uint32_t *)0xfe037158
#define P_DMC_SEC_RANGE5_WID_CTRL0                 (volatile uint32_t *)0xfe037160
#define P_DMC_SEC_RANGE5_WID_CTRL1                 (volatile uint32_t *)0xfe037164
#define P_DMC_SEC_RANGE5_WID_CTRL2                 (volatile uint32_t *)0xfe037168
#define P_DMC_SEC_RANGE5_WID_CTRL3                 (volatile uint32_t *)0xfe03716c
//region6(RANGE6) related register.
#define P_DMC_SEC_RANGE6_STA                       (volatile uint32_t *)0xfe037180
#define P_DMC_SEC_RANGE6_EDA                       (volatile uint32_t *)0xfe037184
#define P_DMC_SEC_RANGE6_CTRL                      (volatile uint32_t *)0xfe037188
#define P_DMC_SEC_RANGE6_RID_CTRL0                 (volatile uint32_t *)0xfe03718c
#define P_DMC_SEC_RANGE6_RID_CTRL1                 (volatile uint32_t *)0xfe037190
#define P_DMC_SEC_RANGE6_RID_CTRL2                 (volatile uint32_t *)0xfe037194
#define P_DMC_SEC_RANGE6_RID_CTRL3                 (volatile uint32_t *)0xfe037198
#define P_DMC_SEC_RANGE6_WID_CTRL0                 (volatile uint32_t *)0xfe0371a0
#define P_DMC_SEC_RANGE6_WID_CTRL1                 (volatile uint32_t *)0xfe0371a4
#define P_DMC_SEC_RANGE6_WID_CTRL2                 (volatile uint32_t *)0xfe0371a8
#define P_DMC_SEC_RANGE6_WID_CTRL3                 (volatile uint32_t *)0xfe0371ac
//region7(RANGE7) related register.
#define P_DMC_SEC_RANGE7_STA                       (volatile uint32_t *)0xfe0371c0
#define P_DMC_SEC_RANGE7_EDA                       (volatile uint32_t *)0xfe0371c4
#define P_DMC_SEC_RANGE7_CTRL                      (volatile uint32_t *)0xfe0371c8
#define P_DMC_SEC_RANGE7_RID_CTRL0                 (volatile uint32_t *)0xfe0371cc
#define P_DMC_SEC_RANGE7_RID_CTRL1                 (volatile uint32_t *)0xfe0371d0
#define P_DMC_SEC_RANGE7_RID_CTRL2                 (volatile uint32_t *)0xfe0371d4
#define P_DMC_SEC_RANGE7_RID_CTRL3                 (volatile uint32_t *)0xfe0371d8
#define P_DMC_SEC_RANGE7_WID_CTRL0                 (volatile uint32_t *)0xfe0371e0
#define P_DMC_SEC_RANGE7_WID_CTRL1                 (volatile uint32_t *)0xfe0371e4
#define P_DMC_SEC_RANGE7_WID_CTRL2                 (volatile uint32_t *)0xfe0371e8
#define P_DMC_SEC_RANGE7_WID_CTRL3                 (volatile uint32_t *)0xfe0371ec
//region8(RANGE8) related register.
#define P_DMC_SEC_RANGE8_STA                       (volatile uint32_t *)0xfe037200
#define P_DMC_SEC_RANGE8_EDA                       (volatile uint32_t *)0xfe037204
#define P_DMC_SEC_RANGE8_CTRL                      (volatile uint32_t *)0xfe037208
#define P_DMC_SEC_RANGE8_RID_CTRL0                 (volatile uint32_t *)0xfe03720c
#define P_DMC_SEC_RANGE8_RID_CTRL1                 (volatile uint32_t *)0xfe037210
#define P_DMC_SEC_RANGE8_RID_CTRL2                 (volatile uint32_t *)0xfe037214
#define P_DMC_SEC_RANGE8_RID_CTRL3                 (volatile uint32_t *)0xfe037218
#define P_DMC_SEC_RANGE8_WID_CTRL0                 (volatile uint32_t *)0xfe037220
#define P_DMC_SEC_RANGE8_WID_CTRL1                 (volatile uint32_t *)0xfe037224
#define P_DMC_SEC_RANGE8_WID_CTRL2                 (volatile uint32_t *)0xfe037228
#define P_DMC_SEC_RANGE8_WID_CTRL3                 (volatile uint32_t *)0xfe03722c
//region9(RANGE9) related register.
#define P_DMC_SEC_RANGE9_STA                       (volatile uint32_t *)0xfe037240
#define P_DMC_SEC_RANGE9_EDA                       (volatile uint32_t *)0xfe037244
#define P_DMC_SEC_RANGE9_CTRL                      (volatile uint32_t *)0xfe037248
#define P_DMC_SEC_RANGE9_RID_CTRL0                 (volatile uint32_t *)0xfe03724c
#define P_DMC_SEC_RANGE9_RID_CTRL1                 (volatile uint32_t *)0xfe037250
#define P_DMC_SEC_RANGE9_RID_CTRL2                 (volatile uint32_t *)0xfe037254
#define P_DMC_SEC_RANGE9_RID_CTRL3                 (volatile uint32_t *)0xfe037258
#define P_DMC_SEC_RANGE9_WID_CTRL0                 (volatile uint32_t *)0xfe037260
#define P_DMC_SEC_RANGE9_WID_CTRL1                 (volatile uint32_t *)0xfe037264
#define P_DMC_SEC_RANGE9_WID_CTRL2                 (volatile uint32_t *)0xfe037268
#define P_DMC_SEC_RANGE9_WID_CTRL3                 (volatile uint32_t *)0xfe03726c
//region10(RANGE10) related register.
#define P_DMC_SEC_RANGE10_STA                      (volatile uint32_t *)0xfe037280
#define P_DMC_SEC_RANGE10_EDA                      (volatile uint32_t *)0xfe037284
#define P_DMC_SEC_RANGE10_CTRL                     (volatile uint32_t *)0xfe037288
#define P_DMC_SEC_RANGE10_RID_CTRL0                (volatile uint32_t *)0xfe03728c
#define P_DMC_SEC_RANGE10_RID_CTRL1                (volatile uint32_t *)0xfe037290
#define P_DMC_SEC_RANGE10_RID_CTRL2                (volatile uint32_t *)0xfe037294
#define P_DMC_SEC_RANGE10_RID_CTRL3                (volatile uint32_t *)0xfe037298
#define P_DMC_SEC_RANGE10_WID_CTRL0                (volatile uint32_t *)0xfe0372a0
#define P_DMC_SEC_RANGE10_WID_CTRL1                (volatile uint32_t *)0xfe0372a4
#define P_DMC_SEC_RANGE10_WID_CTRL2                (volatile uint32_t *)0xfe0372a8
#define P_DMC_SEC_RANGE10_WID_CTRL3                (volatile uint32_t *)0xfe0372ac
//region9(RANGE11) related register.
#define P_DMC_SEC_RANGE11_STA                      (volatile uint32_t *)0xfe0372c0
#define P_DMC_SEC_RANGE11_EDA                      (volatile uint32_t *)0xfe0372c4
#define P_DMC_SEC_RANGE11_CTRL                     (volatile uint32_t *)0xfe0372c8
#define P_DMC_SEC_RANGE11_RID_CTRL0                (volatile uint32_t *)0xfe0372cc
#define P_DMC_SEC_RANGE11_RID_CTRL1                (volatile uint32_t *)0xfe0372d0
#define P_DMC_SEC_RANGE11_RID_CTRL2                (volatile uint32_t *)0xfe0372d4
#define P_DMC_SEC_RANGE11_RID_CTRL3                (volatile uint32_t *)0xfe0372d8
#define P_DMC_SEC_RANGE11_WID_CTRL0                (volatile uint32_t *)0xfe0372e0
#define P_DMC_SEC_RANGE11_WID_CTRL1                (volatile uint32_t *)0xfe0372e4
#define P_DMC_SEC_RANGE11_WID_CTRL2                (volatile uint32_t *)0xfe0372e8
#define P_DMC_SEC_RANGE11_WID_CTRL3                (volatile uint32_t *)0xfe0372ec
//region12(RANGE12) related register.
#define P_DMC_SEC_RANGE12_STA                      (volatile uint32_t *)0xfe037300
#define P_DMC_SEC_RANGE12_EDA                      (volatile uint32_t *)0xfe037304
#define P_DMC_SEC_RANGE12_CTRL                     (volatile uint32_t *)0xfe037308
#define P_DMC_SEC_RANGE12_RID_CTRL0                (volatile uint32_t *)0xfe03730c
#define P_DMC_SEC_RANGE12_RID_CTRL1                (volatile uint32_t *)0xfe037310
#define P_DMC_SEC_RANGE12_RID_CTRL2                (volatile uint32_t *)0xfe037314
#define P_DMC_SEC_RANGE12_RID_CTRL3                (volatile uint32_t *)0xfe037318
#define P_DMC_SEC_RANGE12_WID_CTRL0                (volatile uint32_t *)0xfe037320
#define P_DMC_SEC_RANGE12_WID_CTRL1                (volatile uint32_t *)0xfe037324
#define P_DMC_SEC_RANGE12_WID_CTRL2                (volatile uint32_t *)0xfe037328
#define P_DMC_SEC_RANGE12_WID_CTRL3                (volatile uint32_t *)0xfe03732c
//region13(RANGE13) related register.
#define P_DMC_SEC_RANGE13_STA                      (volatile uint32_t *)0xfe037340
#define P_DMC_SEC_RANGE13_EDA                      (volatile uint32_t *)0xfe037344
#define P_DMC_SEC_RANGE13_CTRL                     (volatile uint32_t *)0xfe037348
#define P_DMC_SEC_RANGE13_RID_CTRL0                (volatile uint32_t *)0xfe03734c
#define P_DMC_SEC_RANGE13_RID_CTRL1                (volatile uint32_t *)0xfe037350
#define P_DMC_SEC_RANGE13_RID_CTRL2                (volatile uint32_t *)0xfe037354
#define P_DMC_SEC_RANGE13_RID_CTRL3                (volatile uint32_t *)0xfe037358
#define P_DMC_SEC_RANGE13_WID_CTRL0                (volatile uint32_t *)0xfe037360
#define P_DMC_SEC_RANGE13_WID_CTRL1                (volatile uint32_t *)0xfe037364
#define P_DMC_SEC_RANGE13_WID_CTRL2                (volatile uint32_t *)0xfe037368
#define P_DMC_SEC_RANGE13_WID_CTRL3                (volatile uint32_t *)0xfe03736c
//region14(RANGE14) related register.
#define P_DMC_SEC_RANGE14_STA                      (volatile uint32_t *)0xfe037380
#define P_DMC_SEC_RANGE14_EDA                      (volatile uint32_t *)0xfe037384
#define P_DMC_SEC_RANGE14_CTRL                     (volatile uint32_t *)0xfe037388
#define P_DMC_SEC_RANGE14_RID_CTRL0                (volatile uint32_t *)0xfe03738c
#define P_DMC_SEC_RANGE14_RID_CTRL1                (volatile uint32_t *)0xfe037390
#define P_DMC_SEC_RANGE14_RID_CTRL2                (volatile uint32_t *)0xfe037394
#define P_DMC_SEC_RANGE14_RID_CTRL3                (volatile uint32_t *)0xfe037398
#define P_DMC_SEC_RANGE14_WID_CTRL0                (volatile uint32_t *)0xfe0373a0
#define P_DMC_SEC_RANGE14_WID_CTRL1                (volatile uint32_t *)0xfe0373a4
#define P_DMC_SEC_RANGE14_WID_CTRL2                (volatile uint32_t *)0xfe0373a8
#define P_DMC_SEC_RANGE14_WID_CTRL3                (volatile uint32_t *)0xfe0373ac
//region15(RANGE15) related register.
#define P_DMC_SEC_RANGE15_STA                      (volatile uint32_t *)0xfe0373c0
#define P_DMC_SEC_RANGE15_EDA                      (volatile uint32_t *)0xfe0373c4
#define P_DMC_SEC_RANGE15_CTRL                     (volatile uint32_t *)0xfe0373c8
#define P_DMC_SEC_RANGE15_RID_CTRL0                (volatile uint32_t *)0xfe0373cc
#define P_DMC_SEC_RANGE15_RID_CTRL1                (volatile uint32_t *)0xfe0373d0
#define P_DMC_SEC_RANGE15_RID_CTRL2                (volatile uint32_t *)0xfe0373d4
#define P_DMC_SEC_RANGE15_RID_CTRL3                (volatile uint32_t *)0xfe0373d8
#define P_DMC_SEC_RANGE15_WID_CTRL0                (volatile uint32_t *)0xfe0373e0
#define P_DMC_SEC_RANGE15_WID_CTRL1                (volatile uint32_t *)0xfe0373e4
#define P_DMC_SEC_RANGE15_WID_CTRL2                (volatile uint32_t *)0xfe0373e8
#define P_DMC_SEC_RANGE15_WID_CTRL3                (volatile uint32_t *)0xfe0373ec
#define P_DMC_DES_PADDING                          (volatile uint32_t *)0xfe037400
  //bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.
#define P_DMC_DES_CTRL                             (volatile uint32_t *)0xfe037404
 //bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
 //bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit, DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.
#define P_DMC_DES_CTRL1                            (volatile uint32_t *)0xfe037428
 //bit 31:16 : reserved
 //bit 15 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN. 0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
 //bit 14 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && GLOBAL_DES_EN. 0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
 //bit 13 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
 //bit 12 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
 //bit 11 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN. 0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
 //bit 10 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && GLOBAL_DES_EN. 0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
 //bit  9 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
 //bit  8 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
 //bit  7 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN. 0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
 //bit  6 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
 //bit  5 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
 //bit  4 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN. 0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
 //bit  3 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
 //bit  2 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
 //bit  1 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN. 0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
 //bit  0 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && GLOBAL_DES_EN. 0 :  range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.
#define P_DMC_DES_KEY0_REG0                        (volatile uint32_t *)0xfe037408
#define P_DMC_DES_KEY0_REG1                        (volatile uint32_t *)0xfe03740c
#define P_DMC_DES_KEY0_REG2                        (volatile uint32_t *)0xfe037410
#define P_DMC_DES_KEY0_REG3                        (volatile uint32_t *)0xfe037414
#define P_DMC_DES_KEY1_REG0                        (volatile uint32_t *)0xfe037418
#define P_DMC_DES_KEY1_REG1                        (volatile uint32_t *)0xfe03741c
#define P_DMC_DES_KEY1_REG2                        (volatile uint32_t *)0xfe037420
#define P_DMC_DES_KEY1_REG3                        (volatile uint32_t *)0xfe037424
//FROM SC2, the APB bus provided Master ID through PUSER.
//after ID_REMAP, this PUSE provided 8 master ID type.
//they are:
//  8'b0000_0001 : TEE
//  8'h0000_0010 : REE
//  8'h0000_0100 : JTAG
//  8'h0000_1000 : AOCPU
//  8'h0001_0000 : DSPA
//  8'h0010_0000 : DSPB
//  no others.
//FROM SC2, the APB bus provided Master ID through PUSER signals.
//there's total 8 master IDs could access DMC non-secure registers.
//we assign 1 control bit for each APB Master and each DMC non-secure register domains
//and we added one lock bits to lock this setting can't be modified any more.
#define P_DDR_APB_SEC_CTRL0                        (volatile uint32_t *)0xfe037440
   // APB access  control for dmc REQUEST control register access control register.
   // default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL1                        (volatile uint32_t *)0xfe037444
   // APB access control for DMC DRAM timing parameter and DFI interface registers.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL2                        (volatile uint32_t *)0xfe037448
   // APB access control for DMC PLL clock frequency control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL3                        (volatile uint32_t *)0xfe03744c
   // APB access control for DMC sticky control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL4                        (volatile uint32_t *)0xfe037450
   // APB access control for DMC test control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL5                        (volatile uint32_t *)0xfe037454
   // APB access control for DMC clk reset control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL6                        (volatile uint32_t *)0xfe037458
   // APB access control for DMC protection register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL7                        (volatile uint32_t *)0xfe03745c
   // APB access control for DMC normal register.
   //default : 0x0ff
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define P_DDR_APB_SEC_CTRL8                        (volatile uint32_t *)0xfe037460
   // APB access control for DDR PHY group 0 registers.
   //default : 0x005
   //bit 23:16. PHY PRODUCTION control register enable.
   //bit 10  PHY IMEM control 1: force PHY IMEM output 0. 0: normal working mode.
   //bit 9   PHY DMEM control 1: force PHY DMEM output 0. 0: normal working mode.
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
//registers to check the security protection and watch point error information.
#define P_DMC_SEC_STATUS                           (volatile uint32_t *)0xfe037468
 //bit 31~2. not used.
 //bit 6
 //bit 5
 //bit 4
 //bit 3   1 : normal security register write violation.( APB bus WDATA not equal to the register value when APB write).  write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC security register alert function triggered. can't clean. only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.
#define P_DMC_VIO_ADDR0                            (volatile uint32_t *)0xfe03746c
  //ddr0 write secure violation address[31:0].
#define P_DMC_VIO_ADDR1                            (volatile uint32_t *)0xfe037470
  //bit 31:12 . not used. always 0.
  //11.    ddr0 write address secure check error.
  //10     ddr0 write address overflow or not in this DDR channel.
  //9:0   ddr0_write violation USER BIT.
#define P_DMC_VIO_ADDR2                            (volatile uint32_t *)0xfe037474
  //ddr0 read secure violation address[31:0]
#define P_DMC_VIO_ADDR3                            (volatile uint32_t *)0xfe037478
  //bit 31:12 not used.
  //11.    ddr0 read address secure check error.
  //10     ddr0 read address overflow or not in this DDR channel.
  //9:0   ddr0_read violation USER BIT.
//16Gbyte AXI address remap tp 4Gbyte DDR address.
#define P_DMC_AXI2DDR0                             (volatile uint32_t *)0xfe037480
  //for AXI address 0x0_2000_0000 ~ 0x0_3fff_ffff
  //bit 31:8. not used.
  //bit 7:  pure 16bit DDR SDRAM
  //bit 6.  addr_top vio enable
  //bit 5. rank_sel.  1 : rank1.  0 : rank0.
  //bit 4  16bit in 32bit DDR SDRAM.
  //bti 3:0. temp addr[31:28]
#define P_DMC_AXI2DDR1                             (volatile uint32_t *)0xfe037484
#define P_DMC_AXI2DDR2                             (volatile uint32_t *)0xfe037488
#define P_DMC_AXI2DDR3                             (volatile uint32_t *)0xfe03748c
#define P_DMC_AXI2DDR4                             (volatile uint32_t *)0xfe037490
#define P_DMC_AXI2DDR5                             (volatile uint32_t *)0xfe037494
#define P_DMC_AXI2DDR6                             (volatile uint32_t *)0xfe037498
#define P_DMC_AXI2DDR7                             (volatile uint32_t *)0xfe03749c
#define P_DMC_AXI2DDR8                             (volatile uint32_t *)0xfe0374a0
#define P_DMC_AXI2DDR9                             (volatile uint32_t *)0xfe0374a4
#define P_DMC_AXI2DDRA                             (volatile uint32_t *)0xfe0374a8
#define P_DMC_AXI2DDRB                             (volatile uint32_t *)0xfe0374ac
#define P_DMC_AXI2DDRC                             (volatile uint32_t *)0xfe0374b0
#define P_DMC_AXI2DDRD                             (volatile uint32_t *)0xfe0374b4
#define P_DMC_AXI2DDRE                             (volatile uint32_t *)0xfe0374b8
#define P_DMC_AXI2DDRF                             (volatile uint32_t *)0xfe0374bc
#define P_DMC_DDR_CTRL                             (volatile uint32_t *)0xfe037500
  //bit 24:22   3'b000 : ddr3 mode.
              //3'b001 : ddr4 mode.
              //3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. 0 : normal data interface.
   //bit 11:9:  strip pos
   //bit 8: channel 1 enable
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 384Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b1000 : DDR rank 0 is 192Mbyte.
     //4'b1001 : DDR rank 0 is 384Mbyte.
     //4'b1010 : DDR rank 0 is 768Mbyte.
     //4'b1011 : DDR rank 0 is 1.5Gbyte.
     //4'b1100 : DDR rank 0 is 3Gbyte.
     //others :  reserved.
#define P_DMC_DDR_CTRL1                            (volatile uint32_t *)0xfe037504
  //bit 8.  dmc_ba_hash_en,  1: enable bank[2:0] more disorder
  //bit 7.  dmc_fake_chan_en, in DDR3/DDR4 case, enable this feature to reuse some write read buffer for DFI1 channel in LPDDR4 mode.
  //bit 6.  strict security level control for DMA channel. 1: only sec level input == region sec level is allowed.  0:  sec_level input >= region sec level is allow to write.
#define P_DMC_RANK0_ADDRMAP_0                      (volatile uint32_t *)0xfe037508
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.
#define P_DMC_RANK0_ADDRMAP_1                      (volatile uint32_t *)0xfe03750c
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.
#define P_DMC_RANK0_ADDRMAP_2                      (volatile uint32_t *)0xfe037510
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.
#define P_DMC_RANK0_ADDRMAP_3                      (volatile uint32_t *)0xfe037514
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.
#define P_DMC_RANK0_ADDRMAP_4                      (volatile uint32_t *)0xfe037518
  //29:25 ra16
  //24:20 bg1
  //19:15 ba2.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.
#define P_DMC_RANK1_ADDRMAP_0                      (volatile uint32_t *)0xfe037520
#define P_DMC_RANK1_ADDRMAP_1                      (volatile uint32_t *)0xfe037524
#define P_DMC_RANK1_ADDRMAP_2                      (volatile uint32_t *)0xfe037528
#define P_DMC_RANK1_ADDRMAP_3                      (volatile uint32_t *)0xfe03752c
#define P_DMC_RANK1_ADDRMAP_4                      (volatile uint32_t *)0xfe037530
//DMC TEST.
#define P_DMC_TEST_STA                             (volatile uint32_t *)0xfe037940
  //test start address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                     for sha mode,      address must be in 64 bytes boundary. that mean the last 6 bits must be 0.
#define P_DMC_TEST_EDA                             (volatile uint32_t *)0xfe037944
  //test end address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                   for sha mode,       address must be in 64 bytes boundary. that mean the last 6bits must be 1.
#define P_DMC_TEST_CTRL                            (volatile uint32_t *)0xfe037948
   //bit 31.  enable test.
   //bit 30.  when enable test, enable the write to DDR function.
   //bit 29.  when enable test, enable the read from DDR function.
   //bit 28.  when enable test,  enable the sha calculation function  must be same as read enable but without write function.
   //bit 27.  enabe to compare data.  when do the read enable to enable the error comparison. suppose the read data should be same as the data in the write buffer.
   //bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
   //bit 25.  address generation type.  0: continuous increase the address in the range of test start address and test end address.
   //                                   1: test module would pick the random address from test start address  and test end address.
   //bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
   //                             for write if the write command number == the DMC_TEST_NUM, the write is done.
   //                             for read if the read command number == the DMC TEST_num, the read id done. for one read command can be repeated repeat number times.
   //                         1 : finshed at end address.
   //bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0}, then the latter is the previous data plus a pattern.( { + WD7,  + WD6, + WD5, + WD4}).
   //                         0 : the WDATA is the data in write register.
   //bit 23.  1  compare the sha result with the test sha message registers. 0 : dont compare the result.
   //bit 22:20.   read repeat times.  for non-sha function, we can define multi times of the read. the test module would repeat the same adddress repeat times.
   //bit 19.     limit write.  0: no outstanding write request limitation.
   //                          1: limit the outstanding write commands to the number of bits [15:8]
   //bit 18.     limit read.   0. no outstanding read request limitation.
   //                          1. limit the read outstanding request to the number of bits[7:0].
   //bit 17:16.  sha mode for sha function enabled.  00 : not used.  01 : sha1. 2: sha2-256. 3: sha2_224. not used in GXL fixed to be  Sha 2.
   //bit 15:8.   write outstanding commands limit.
   //bit 7:0.    read  outstanding commands limit.
#define P_DMC_TEST_NUM                             (volatile uint32_t *)0xfe03794c
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.
#define P_DMC_TEST_WDG                             (volatile uint32_t *)0xfe037950
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.
#define P_DMC_TEST_COMP_MASK                       (volatile uint32_t *)0xfe037954
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.
#define P_DMC_TEST_WSTRB0                          (volatile uint32_t *)0xfe037958
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define P_DMC_TEST_WSTRB1                          (volatile uint32_t *)0xfe03795c
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.
#define P_DMC_TEST_WD0                             (volatile uint32_t *)0xfe037980
   // write data 0 for write command. also for read back data comparison.
#define P_DMC_TEST_WD1                             (volatile uint32_t *)0xfe037984
   // write data 1 for write command. also for read back data comparison.
#define P_DMC_TEST_WD2                             (volatile uint32_t *)0xfe037988
#define P_DMC_TEST_WD3                             (volatile uint32_t *)0xfe03798c
#define P_DMC_TEST_WD4                             (volatile uint32_t *)0xfe037990
#define P_DMC_TEST_WD5                             (volatile uint32_t *)0xfe037994
#define P_DMC_TEST_WD6                             (volatile uint32_t *)0xfe037998
#define P_DMC_TEST_WD7                             (volatile uint32_t *)0xfe03799c
#define P_DMC_TEST_WD8                             (volatile uint32_t *)0xfe0379a0
#define P_DMC_TEST_WD9                             (volatile uint32_t *)0xfe0379a4
#define P_DMC_TEST_WD10                            (volatile uint32_t *)0xfe0379a8
#define P_DMC_TEST_WD11                            (volatile uint32_t *)0xfe0379ac
#define P_DMC_TEST_WD12                            (volatile uint32_t *)0xfe0379b0
#define P_DMC_TEST_WD13                            (volatile uint32_t *)0xfe0379b4
#define P_DMC_TEST_WD14                            (volatile uint32_t *)0xfe0379b8
#define P_DMC_TEST_WD15                            (volatile uint32_t *)0xfe0379bc
   // write data 15 for write command. also for read back data comparison.
#define P_DMC_TEST_RD0                             (volatile uint32_t *)0xfe0378c0
   // the read back data 0.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD1                             (volatile uint32_t *)0xfe0378c4
   // the read back data 1.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD2                             (volatile uint32_t *)0xfe0378c8
   // the read back data 2.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD3                             (volatile uint32_t *)0xfe0378cc
   // the read back data 3.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD4                             (volatile uint32_t *)0xfe0378d0
   // the read back data 4.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD5                             (volatile uint32_t *)0xfe0378d4
   // the read back data 5.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD6                             (volatile uint32_t *)0xfe0378d8
   // the read back data 6.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD7                             (volatile uint32_t *)0xfe0378dc
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD8                             (volatile uint32_t *)0xfe0378e0
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD9                             (volatile uint32_t *)0xfe0378e4
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD10                            (volatile uint32_t *)0xfe0378e8
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD11                            (volatile uint32_t *)0xfe0378ec
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD12                            (volatile uint32_t *)0xfe0378f0
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD13                            (volatile uint32_t *)0xfe0378f4
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD14                            (volatile uint32_t *)0xfe0378f8
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_RD15                            (volatile uint32_t *)0xfe0378fc
   // the read back data 7.  if error happens, it would capture the first error data.
#define P_DMC_TEST_ERR_ADDR                        (volatile uint32_t *)0xfe037900
  //read only. it capture the first error address.
#define P_DMC_TEST_ERR_CNT                         (volatile uint32_t *)0xfe037904
  //read only. how many data error happens in the whole test period.
#define P_DMC_TEST_STS                             (volatile uint32_t *)0xfe037908
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.
#define P_DMC_TEST_WRCMD_ADDR                      (volatile uint32_t *)0xfe03790c
  //read only. the current write cmd address.
#define P_DMC_TEST_RDCMD_ADDR                      (volatile uint32_t *)0xfe037910
   //read only. the current read command address.
#define P_DMC_TEST_RDRSP_ADDR                      (volatile uint32_t *)0xfe037914
  //read only. the failed read response address(for error data )
//
// Closing file:  ../dmc_v26/rtl/dmc_reg.vh
//
//
// Reading file:  dmc_clk_freq.vh
//
//dmc pll and frequency domain control registers.
//`define DMC_FREQ_REG_BASE   32'hfe036c00
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe036c00
// -----------------------------------------------
//
//              |               |            |---------->  1/(OD,OD1) -->ddr_dpll_clk_out_a
//  VCO ------> |  1/ reve[5:4] | --VCO_A--->|
//              |               |            |----inv--->  1/(OD,OD1) -->ddr_dpll_clk_out_b
#define P_AM_DDR_PLL_CNTL0                         (volatile uint32_t *)0xfe036c00
  //bit 31    : dpll_lock
  //bit 29    : dpll_reset.
  //bit 28    : dpll_en.
  //bit 27:26 : dpll_clk_en  2'b10: pll_clock output enable. 4xclk output disable..   2'b11,  pll_clock and 4xclk output enable.
                 //if set ddr_freq_sel , it would replaced by AM_DDR_FREQ_CTRL bit[11:10];
  //bit 25    : dpll_inv_sel.  4xclk inverter. if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL bit[12]
  //bit 21:19 : od1; if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[6:4]
  //bit 18:16 : od;  if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[2:0]
  //bit 14:10 : dpll_ref_div_n
  //bit 8:0   : dpll_int_num
#define P_AM_DDR_PLL_CNTL1                         (volatile uint32_t *)0xfe036c04
  //bit 18:0    : ddr_dpll_frac
#define P_AM_DDR_PLL_CNTL2                         (volatile uint32_t *)0xfe036c08
  //bit 22:20  : fref_sel
  //bit 17:16  : os_ssc
  //bit 15:12  : ssc_str_m
  //bit 8      : ssc_en
  //bit 7:4    : ssc_dep_sel
  //bit 1:0    : dpll ss_mode.
#define P_AM_DDR_PLL_CNTL3                         (volatile uint32_t *)0xfe036c0c
  //bit 31     : afc bypass
  //bit 30     : afc clk sel
  //bit 29     : code new
  //bit 28     : dco_m_en
  //bit 27     : dco_sdm_en
  //bit 26     : div2
  //bit 25     : div mode
  //bit 24     : fast_lock mode
  //bit 23     : fb_pre_div
  //bit 22     : filter_mode
  //bit 21     : fix_en
  //bit 20     : freq_shift_en
  //bit 19     : load
  //bit 18     : load_en
  //bit 17     : lock_f
  //bit 16     : pulse_width_en
  //bit 15     : sdmnc_en
  //bit 14     : sdmnc_mode
  //bit 13     : sdmnc_range
  //bit 12     : tdc_en
  //bit 11     : tdc_mode_sel
  //bit 10     :  wait_en
#define P_AM_DDR_PLL_CNTL4                         (volatile uint32_t *)0xfe036c10
  //bit 1:0    : pfd_gain
  //bit 7:4    : filter_pvt1
  //bit 11:8   : filter pvt2
  //bit 13:12  : acq_gain
  //bit 18:16  : lambda0
  //bit 27:24  : rou
  //bit 31:28  : alpha
#define P_AM_DDR_PLL_CNTL5                         (volatile uint32_t *)0xfe036c14
  //bit
  //bit 30:28  : adj_vco_ldo
  //bit 27:24  : lm_w
  //bit 21:16  : lm_s
  //bit 15:6   : reve[15:6]
  //bit 5:4.   : reve[5:4] for chan_A, chan_B phase control. if freq =1, it would replaced by AM_DDR_FREQ_CTRL bit[11:10];
  //bit 3:0    : reve[3:0]
#define P_AM_DDR_PLL_CNTL6                         (volatile uint32_t *)0xfe036c18
  //bit 31:30  : afc_hold_t
  //bit 29:28  : lkw_sel
  //bit 27:26  : dco_sdm_clk_sel
  //bit 25:24  : afc_in
  //bit 23:22  : afc_nt
  //bit 21:20  : vc_in
  //bit 19:18  : lock_long
  //bit 17:16  : freq_shift_v
  //bit 15     : not used.
  //bit 14:12  : data_sel
  //bit 10:8   : sdmnc_ulms
  //bit 6:0    : sdmnc_power
#define P_AM_DDR_PLL_STS                           (volatile uint32_t *)0xfe036c1c
  //bit 31     : DDR_PLL_LOCK
  //bit 30     : lock_a
  //bit 29     : afc_done
  //bit 22:16  : sdmnc_monitor
  //bit 9:0    : out_rsv
#define P_AM_DDR_CLK_CNTL_EXT                      (volatile uint32_t *)0xfe036c20
  //bit 31     Channel 0 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
               // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 30.    channel 0 ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 29.    pll production  clock output selection. 1: select ddr_dpll_clk_out_b. : 0 : select ddr_dpll_clk_out_a;
  //bit 28.    clock generation logic soft reset_n. 0: reset. 1: normal mode.
  //bit 27.    channel 0 phy_4xclk phase inverter..
  //bit 25.    Channel 0 DDRPHY DfiClk/DfiCtlClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 24.    Channel 0 AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 23     Channel 1 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
               // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 22.    channel 1 ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 21:20. not used.
  //bit 19.    channel 1 phy_4xclk phase inverter..
  //bit 17.    Channel 1 DDRPHY DfiClk/DfiCtlClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 16.    Channel 1 AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 12. ddr1 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
  //bit 11.  ddr1 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
  //bit 10. freq1_used_lpclk.
  //bit 9.  lpclk_sel.  1:use lp_clk
  //bit 8.  lpclk_reset.
  //bit 4.  ddr0 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
  //bit 3.  ddr0 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
  //bit 2.  enable ddr channel 0 dmc_clk.
  //bit 1.  enable LPDDR4-PHY channel 0 DfiClk.
  //bit 0.  enable LPDDR4-PHY channel 0 DfiCtlClk.
#define P_AM_DDR_PHY_CTRL                          (volatile uint32_t *)0xfe036c24
  // LPDDR4 power on reset need to special combination of PwrOkIn and phy_reset_n.
  // please check the PHY PUB data book for detail.
  //bit 31:8.  Not used.
  //bit 7.   use dmc_clk_freq to control DDR-PHY channel 1 refresh/retraining/frequency change/phy power etc.
  //bit 6.   use dmc_clk_freq to control DDR-PHY channel 0 refresh/retraining/frequency change/phy power etc.
  //bit 5.   DDR_PHY 1 PwrOkIn pin.
  //bit 4.   DDR_PHY 0 PwrOkIn pin.
  //bit 3.   DDR_PHY 1 APB soft reset_n.
  //bit 2.   DDR_PHY 1 phy_reset_n.
  //bit 1.   DDR_PHY 0 APB soft reset_n.
  //bit 0.   DDR_PHY 0 phy_reset_n.
#define P_AM_DDR_FREQ_CTRL                         (volatile uint32_t *)0xfe036c28
  //bit 31.  write trigger the DDR frequency change procedure.  read =0 the frequency change done.
  //bit 30     currunt FREQ selection.  it can forced to change to select which frequency to select, or it can auto changed by FREQ change hardware.
  //bit 29     next freq for frequency change.
  //bit 12.    ddr_dpll_inv_sel in frequency1 for 4xclk inverter.
  //bit 11:10. ddr_dpll_clk_en in frequency1 for 4xclk and clock output.
  //bit 9:8. pll_reseve in frequency1. pll_reseve[5:4] used to tune 2 DMC channel clock phase.
  //bit 6:4   OD1 number in frequency 1.
  //bit 2:0.  OD  number in frequency 1.
#define P_AM_DDR_TIMING_F0                         (volatile uint32_t *)0xfe036c2c
  //frequency 0  auto refresh timing.
  //bit 7:0. T100ns. how many clock cycle for 100ns.
  //bit15:8. refresh period in 100ns.
#define P_AM_DDR_TIMING_F1                         (volatile uint32_t *)0xfe036c30
  //frequency 1  auto refresh timing.
  //bit 7:0. T100ns. how many clock cycle for 100ns.
  //bit15:8. refresh period in 100ns.
#define P_AM_DDR_TIMING_CFG                        (volatile uint32_t *)0xfe036c34
  //bit 31.  cfg ddr timing.  write 1 to save the timing parameters to ddr clock domain.
  //bit 30.  dmc_clk_freq control the LPDDR4 retraining.
  //bit 29.  dmc_clk_freq control the auto refresh timing.
  //bit 28:24. not use.
  //bit 23:0.  lpddr4 phy retraining timer counter in 100ns.
//
// Closing file:  dmc_clk_freq.vh
//
//
// Reading file:  ddrphy_clk_freq.vh
//
//ddr deskew pll : in project s7
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfc00e000
// -----------------------------------------------
#define P_AM_DDR_CLK_CNTL_INT                      (volatile uint32_t *)0xfc00e000
  //[8] [9] [10] [30], function same as AM_DDR_CLK_CNTL_EXT
  //bit 30.     channel 0 ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 10.     freq1_used_lpclk.
  //bit 9.      lpclk_sel.  1:use lp_clk
  //bit 8.      lpclk_reset.
#define P_AM_DDR_POR                               (volatile uint32_t *)0xfc00e004
  //bit 2. r_mem_resetn_value    //1
  //bit 1. r_pwr_ok_dly_ctrl     //1
  //bit 0. r_clr_por_mem_reset   //0
#define P_AM_DDR_DESKEW_PLL0                       (volatile uint32_t *)0xfc00e008
  //bit 5. deskew_pll_en
  //bit 4. deskew_pll_dis
  //bit 3. deskew_pll_pclk_en
  //bit 2. deskew_pll_en
  //bit 1. deskew_pll_rst
  //bit 0. deskew_pll_div_rstn
#define P_AM_DDR_DESKEW_PLL1                       (volatile uint32_t *)0xfc00e00c
#define P_AM_DDR_DESKEW_PLL2                       (volatile uint32_t *)0xfc00e010
//
// Closing file:  ddrphy_clk_freq.vh
//
//========================================================================
// STARTUP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe02e000
// -----------------------------------------------
#define P_STARTUP_LOCK                             (volatile uint32_t *)0xfe02e000
#define P_STARTUP_DFU_STS                          (volatile uint32_t *)0xfe02e010
#define P_STARTUP_BOOT_SRC                         (volatile uint32_t *)0xfe02e020
#define P_STARTUP_TEE_REQ_DFU                      (volatile uint32_t *)0xfe02e024
#define P_STARTUP_BOOT_OVERRIDE                    (volatile uint32_t *)0xfe02e028
#define P_STARTUP_COLD_BOOT_CNT                    (volatile uint32_t *)0xfe02e02c
#define P_STARTUP_KEY_PRESERVE                     (volatile uint32_t *)0xfe02e030
//========================================================================
// MIPI_DSI_PHY
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01c000
// -----------------------------------------------
//`define MIPI_DSI_PHY_START      8'h00
//`define MIPI_DSI_PHY_END        16'hffff
//`define MIPI_DSI_PHY_CTRL       8'h00
  //bit 31.  soft reset for the phy. 1 = reset. 0 = dessert the reset.
  //bit 30.  clock lane soft reset.
  //bit 29.  data byte lane 3 soft reset.
  //bit 28.  data byte lane 2 soft reset.
  //bit 27.  data byte lane 1 soft reset.
  //bit 26.  data byte lane 0 soft reset.
  //bit 5.   LPDT data endian.  1 = transfer the high bit first. 0 : transfer the low bit first.
  //bit 4.   HS data endian.
  //bit 3.  force data byte lane in stop mode.
  //bit 2.  force data byte lane 0 in receiver mode.
  //bit 1. write 1 to sync the txclkesc input. the internal logic have to use txclkesc to decide Txvalid and Txready.
  //bit 0.  enalbe the MIPI DSI PHY TxDDRClk.
//`define MIPI_DSI_CHAN_CTRL      8'h01
  //bit 31.   clk lane tx_hs_en control selection.  1 = from register. 0 use clk lane state machine.
  //bit 30.   register bit for clock lane tx_hs_en.
  //bit 29.  clk lane tx_lp_en contrl selection.  1 = from register. 0 from clk lane state machine.
  //bit 28.  register bit for clock lane tx_lp_en.
  //bit 27.  chan0 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 26.  register bit for chan0 tx_hs_en.
  //bit 25.  chan0 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 24. register bit from chan0 tx_lp_en.
  //bit 23.  chan0 rx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 22. register bit from chan0 rx_lp_en.
  //bit 21.  chan0 contention detection enable control selection. 1 = from register. 0 from chan0 state machine.
  //bit 20. register bit from chan0 contention detection enable.
  //bit 19.  chan1 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 18.  register bit for chan1 tx_hs_en.
  //bit 17.  chan1 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 16. register bit from chan1 tx_lp_en.
  //bit 15.  chan2 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 14.  register bit for chan2 tx_hs_en.
  //bit 13.  chan2 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 12. register bit from chan2 tx_lp_en.
  //bit 11. chan3 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 10. register bit for chan3 tx_hs_en.
  //bit 9.  chan3 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 8. register bit from chan3 tx_lp_en.
  //bit 4.  clk chan power down. this bit is also used as the power down of the whole MIPI_DSI_PHY.
  //bit 3.  chan3 power down.
  //bit 2.  chan2 power down.
  //bit 1.  chan1 power down.
  //bit 0.  chan0 power down.
//`define MIPI_DSI_CHAN_STS       8'h02
 //bit 24.  chan0 TX->RX turn can't accept the ACK command from slave watch dog triggered.  write 1 to clear the status bit.
 //bit 23.  chan0 RX ESC command watch dog triggered. write 1 to clean this bit.
 //bit
//`define MIPI_DSI_CLK_TIM        8'h03
  //bit 31:24. TCLK_PREPARE.
  //bit 23:16. TCLK_ZERO.
  //bit 15:8.  TCLK_POST.
  //bit 7:0.   TCLK_TRAIL.
//`define MIPI_DSI_HS_TIM         8'h04
  //bit 31:24. THS_PREPARE.
  //bit 23:16. THS_ZERO.
  //bit 15:8.  THS_TRAIL.
  //bit 7:0.   THS_EXIT.
//`define MIPI_DSI_LP_TIM         8'h05
  //bit 31:24. tTA_GET.
  //bit 23:16. tTA_GO.
  //bit 15:8.  tTA_SURE.
  //bit 7:0.   tLPX.
//`define MIPI_DSI_ANA_UP_TIM         8'h06
  //wait time to  MIPI DIS analog ready.
//`define MIPI_DSI_INIT_TIM       8'h07
  // TINIT.
//`define MIPI_DSI_WAKEUP_TIM     8'h08
  //TWAKEUP.
//`define MIPI_DSI_LPOK_TIM       8'h09
  //bit 31:0 when in RxULPS state, RX receiver is in sleep mode.
  //every MIPI_DSI_ULPS_CHECK period, the receiver would be enabled once, and waiting this timer period to get the stable input.
//`define MIPI_DSI_LP_WCHDOG      8'h0a
  //bit 31:0 watch dog timer for MIPI DSI LP receive state.
//`define MIPI_DSI_ANA_CTRL       8'h0b
  //bit 31:0 tMBIAS.  timer to wait for analog mBIAS voltage stable.
//`define MIPI_DSI_CLK_TIM1       8'h0c
  //bit 31:8  not used.
  //bit 7:0    tCLK_PRE
//`define MIPI_DSI_TURN_WCHDOG    8'h0d
 //bit 31:0 watch dog timer for lane 0 LP turn around waiting time.
//`define MIPI_DSI_ULPS_CHECK     8'h0e
 //bit 31:0 when Lane0 in LP receive state,  if the another side sent Low power command,  using this timer to enable Tcheck the another size wakeup nor not.
//`define MIPI_DSI_TEST_CTRL0     8'h0f
//`define MIPI_DSI_TEST_CTRL1     8'h10
//========================================================================
//  Temp sensor PLL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe020000
// -----------------------------------------------
#define P_TS_PLL_CFG_REG1                          (volatile uint32_t *)0xfe020004
#define P_TS_PLL_CFG_REG2                          (volatile uint32_t *)0xfe020008
#define P_TS_PLL_CFG_REG3                          (volatile uint32_t *)0xfe02000c
#define P_TS_PLL_CFG_REG4                          (volatile uint32_t *)0xfe020010
#define P_TS_PLL_CFG_REG5                          (volatile uint32_t *)0xfe020014
#define P_TS_PLL_CFG_REG6                          (volatile uint32_t *)0xfe020018
#define P_TS_PLL_CFG_REG7                          (volatile uint32_t *)0xfe02001c
#define P_TS_PLL_STAT0                             (volatile uint32_t *)0xfe020040
#define P_TS_PLL_STAT1                             (volatile uint32_t *)0xfe020044
#define P_TS_PLL_STAT2                             (volatile uint32_t *)0xfe020048
#define P_TS_PLL_STAT3                             (volatile uint32_t *)0xfe02004c
#define P_TS_PLL_STAT4                             (volatile uint32_t *)0xfe020050
#define P_TS_PLL_STAT5                             (volatile uint32_t *)0xfe020054
#define P_TS_PLL_STAT6                             (volatile uint32_t *)0xfe020058
#define P_TS_PLL_STAT7                             (volatile uint32_t *)0xfe02005c
#define P_TS_PLL_STAT8                             (volatile uint32_t *)0xfe020060
#define P_TS_PLL_STAT9                             (volatile uint32_t *)0xfe020064
//========================================================================
//  Temp sensor DDR
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe022000
// -----------------------------------------------
//`define TS_DDR_CFG_REG1                         8'h01
//`define TS_DDR_CFG_REG2                         8'h02
//`define TS_DDR_CFG_REG3                         8'h03
//`define TS_DDR_CFG_REG4                         8'h04
//`define TS_DDR_CFG_REG5                         8'h05
//`define TS_DDR_CFG_REG6                         8'h06
//`define TS_DDR_CFG_REG7                         8'h07
//`define TS_DDR_STAT0                            8'h10
//`define TS_DDR_STAT1                            8'h11
//`define TS_DDR_STAT2                            8'h12
//`define TS_DDR_STAT3                            8'h13
//`define TS_DDR_STAT4                            8'h14
//`define TS_DDR_STAT5                            8'h15
//`define TS_DDR_STAT6                            8'h16
//`define TS_DDR_STAT7                            8'h17
//`define TS_DDR_STAT8                            8'h18
//`define TS_DDR_STAT9                            8'h19
//========================================================================
//  Temp sensor GPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe035000
// -----------------------------------------------
//`define TS_GPU_CFG_REG1                         8'h01
//`define TS_GPU_CFG_REG2                         8'h02
//`define TS_GPU_CFG_REG3                         8'h03
//`define TS_GPU_CFG_REG4                         8'h04
//`define TS_GPU_CFG_REG5                         8'h05
//`define TS_GPU_CFG_REG6                         8'h06
//`define TS_GPU_CFG_REG7                         8'h07
//`define TS_GPU_STAT0                            8'h10
//`define TS_GPU_STAT1                            8'h11
//`define TS_GPU_STAT2                            8'h12
//`define TS_GPU_STAT3                            8'h13
//`define TS_GPU_STAT4                            8'h14
//`define TS_GPU_STAT5                            8'h15
//`define TS_GPU_STAT6                            8'h16
//`define TS_GPU_STAT7                            8'h17
//`define TS_GPU_STAT8                            8'h18
//`define TS_GPU_STAT9                            8'h19
//========================================================================
//  RNG
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe034000
// -----------------------------------------------
//========================================================================
//  ACODEC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01a000
// -----------------------------------------------
#define P_ACODEC_0                                 (volatile uint32_t *)0xfe01a000
#define P_ACODEC_1                                 (volatile uint32_t *)0xfe01a004
#define P_ACODEC_2                                 (volatile uint32_t *)0xfe01a008
#define P_ACODEC_3                                 (volatile uint32_t *)0xfe01a00c
#define P_ACODEC_4                                 (volatile uint32_t *)0xfe01a010
#define P_ACODEC_5                                 (volatile uint32_t *)0xfe01a014
#define P_ACODEC_6                                 (volatile uint32_t *)0xfe01a018
#define P_ACODEC_7                                 (volatile uint32_t *)0xfe01a01c
//========================================================================
//  AML USB PHY A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe35c000
// -----------------------------------------------
#define P_AMLUSB_A0                                (volatile uint32_t *)0xfe35c000
#define P_AMLUSB_A1                                (volatile uint32_t *)0xfe35c004
#define P_AMLUSB_A2                                (volatile uint32_t *)0xfe35c008
#define P_AMLUSB_A3                                (volatile uint32_t *)0xfe35c00c
#define P_AMLUSB_A4                                (volatile uint32_t *)0xfe35c010
#define P_AMLUSB_A5                                (volatile uint32_t *)0xfe35c014
#define P_AMLUSB_A6                                (volatile uint32_t *)0xfe35c018
#define P_AMLUSB_A7                                (volatile uint32_t *)0xfe35c01c
#define P_AMLUSB_A8                                (volatile uint32_t *)0xfe35c020
#define P_AMLUSB_A9                                (volatile uint32_t *)0xfe35c024
#define P_AMLUSB_A10                               (volatile uint32_t *)0xfe35c028
#define P_AMLUSB_A11                               (volatile uint32_t *)0xfe35c02c
#define P_AMLUSB_A12                               (volatile uint32_t *)0xfe35c030
#define P_AMLUSB_A13                               (volatile uint32_t *)0xfe35c034
#define P_AMLUSB_A14                               (volatile uint32_t *)0xfe35c038
#define P_AMLUSB_A15                               (volatile uint32_t *)0xfe35c03c
#define P_AMLUSB_A16                               (volatile uint32_t *)0xfe35c040
#define P_AMLUSB_A17                               (volatile uint32_t *)0xfe35c044
#define P_AMLUSB_A18                               (volatile uint32_t *)0xfe35c048
#define P_AMLUSB_A19                               (volatile uint32_t *)0xfe35c04c
#define P_AMLUSB_A20                               (volatile uint32_t *)0xfe35c050
#define P_AMLUSB_A21                               (volatile uint32_t *)0xfe35c054
#define P_AMLUSB_A22                               (volatile uint32_t *)0xfe35c058
#define P_AMLUSB_A23                               (volatile uint32_t *)0xfe35c05c
#define P_AMLUSB_A24                               (volatile uint32_t *)0xfe35c060
#define P_AMLUSB_A25                               (volatile uint32_t *)0xfe35c064
#define P_AMLUSB_A26                               (volatile uint32_t *)0xfe35c068
#define P_AMLUSB_A27                               (volatile uint32_t *)0xfe35c06c
#define P_AMLUSB_A28                               (volatile uint32_t *)0xfe35c070
#define P_AMLUSB_A29                               (volatile uint32_t *)0xfe35c074
#define P_AMLUSB_A30                               (volatile uint32_t *)0xfe35c078
#define P_AMLUSB_A31                               (volatile uint32_t *)0xfe35c07c
//========================================================================
//  AML USB PHY B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe34c000
// -----------------------------------------------
#define P_AMLUSB_B0                                (volatile uint32_t *)0xfe34c000
#define P_AMLUSB_B1                                (volatile uint32_t *)0xfe34c004
#define P_AMLUSB_B2                                (volatile uint32_t *)0xfe34c008
#define P_AMLUSB_B3                                (volatile uint32_t *)0xfe34c00c
#define P_AMLUSB_B4                                (volatile uint32_t *)0xfe34c010
#define P_AMLUSB_B5                                (volatile uint32_t *)0xfe34c014
#define P_AMLUSB_B6                                (volatile uint32_t *)0xfe34c018
#define P_AMLUSB_B7                                (volatile uint32_t *)0xfe34c01c
#define P_AMLUSB_B8                                (volatile uint32_t *)0xfe34c020
#define P_AMLUSB_B9                                (volatile uint32_t *)0xfe34c024
#define P_AMLUSB_B10                               (volatile uint32_t *)0xfe34c028
#define P_AMLUSB_B11                               (volatile uint32_t *)0xfe34c02c
#define P_AMLUSB_B12                               (volatile uint32_t *)0xfe34c030
#define P_AMLUSB_B13                               (volatile uint32_t *)0xfe34c034
#define P_AMLUSB_B14                               (volatile uint32_t *)0xfe34c038
#define P_AMLUSB_B15                               (volatile uint32_t *)0xfe34c03c
#define P_AMLUSB_B16                               (volatile uint32_t *)0xfe34c040
#define P_AMLUSB_B17                               (volatile uint32_t *)0xfe34c044
#define P_AMLUSB_B18                               (volatile uint32_t *)0xfe34c048
#define P_AMLUSB_B19                               (volatile uint32_t *)0xfe34c04c
#define P_AMLUSB_B20                               (volatile uint32_t *)0xfe34c050
#define P_AMLUSB_B21                               (volatile uint32_t *)0xfe34c054
#define P_AMLUSB_B22                               (volatile uint32_t *)0xfe34c058
#define P_AMLUSB_B23                               (volatile uint32_t *)0xfe34c05c
#define P_AMLUSB_B24                               (volatile uint32_t *)0xfe34c060
#define P_AMLUSB_B25                               (volatile uint32_t *)0xfe34c064
#define P_AMLUSB_B26                               (volatile uint32_t *)0xfe34c068
#define P_AMLUSB_B27                               (volatile uint32_t *)0xfe34c06c
#define P_AMLUSB_B28                               (volatile uint32_t *)0xfe34c070
#define P_AMLUSB_B29                               (volatile uint32_t *)0xfe34c074
#define P_AMLUSB_B30                               (volatile uint32_t *)0xfe34c078
#define P_AMLUSB_B31                               (volatile uint32_t *)0xfe34c07c
//========================================================================
//  PAD_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe004000
// -----------------------------------------------
#define P_PADCTRL_PIN_MUX_REG0                     (volatile uint32_t *)0xfe004000
#define P_PADCTRL_PIN_MUX_REG1                     (volatile uint32_t *)0xfe004004
//`define PADCTRL_PIN_MUX_REG2          8'h02
#define P_PADCTRL_PIN_MUX_REG3                     (volatile uint32_t *)0xfe00400c
#define P_PADCTRL_PIN_MUX_REG4                     (volatile uint32_t *)0xfe004010
#define P_PADCTRL_PIN_MUX_REG5                     (volatile uint32_t *)0xfe004014
#define P_PADCTRL_PIN_MUX_REG6                     (volatile uint32_t *)0xfe004018
#define P_PADCTRL_PIN_MUX_REG7                     (volatile uint32_t *)0xfe00401c
//`define PADCTRL_PIN_MUX_REG8          8'h08
#define P_PADCTRL_PIN_MUX_REG9                     (volatile uint32_t *)0xfe004024
//`define PADCTRL_PIN_MUX_REGA          8'h0a
#define P_PADCTRL_PIN_MUX_REGB                     (volatile uint32_t *)0xfe00402c
#define P_PADCTRL_PIN_MUX_REGC                     (volatile uint32_t *)0xfe004030
//`define PADCTRL_PIN_MUX_REGD          8'h0d
//`define PADCTRL_PIN_MUX_REGE          8'h0e
//`define PADCTRL_PIN_MUX_REGF          8'h0f
#define P_PADCTRL_PIN_MUX_REGG                     (volatile uint32_t *)0xfe004040
#define P_PADCTRL_PIN_MUX_REGH                     (volatile uint32_t *)0xfe004044
#define P_PADCTRL_PIN_MUX_REGI                     (volatile uint32_t *)0xfe004048
//`define PADCTRL_PIN_MUX_REGJ          8'h13
#define P_PADCTRL_GPIO_IRQ_CTRL0                   (volatile uint32_t *)0xfe004080
#define P_PADCTRL_GPIO_IRQ_CTRL1                   (volatile uint32_t *)0xfe004084
#define P_PADCTRL_GPIO_IRQ_CTRL2                   (volatile uint32_t *)0xfe004088
#define P_PADCTRL_GPIO_IRQ_CTRL3                   (volatile uint32_t *)0xfe00408c
#define P_PADCTRL_GPIO_IRQ_CTRL4                   (volatile uint32_t *)0xfe004090
#define P_PADCTRL_GPIO_IRQ_CTRL5                   (volatile uint32_t *)0xfe004094
#define P_PADCTRL_GPIO_IRQ_CTRL6                   (volatile uint32_t *)0xfe004098
#define P_PADCTRL_GPIO_IRQ_CTRL7                   (volatile uint32_t *)0xfe00409c
#define P_PADCTRL_WORLD_SYNC_CTRL0                 (volatile uint32_t *)0xfe0040a0
#define P_PADCTRL_GPIO_MSR_CTRL0                   (volatile uint32_t *)0xfe0040a4
#define P_PADCTRL_MISC_CTRL0                       (volatile uint32_t *)0xfe0040a8
#define P_PADCTRL_GPIOZ_I                          (volatile uint32_t *)0xfe0040c0
#define P_PADCTRL_GPIOZ_O                          (volatile uint32_t *)0xfe0040c4
#define P_PADCTRL_GPIOZ_OEN                        (volatile uint32_t *)0xfe0040c8
#define P_PADCTRL_GPIOZ_PULL_EN                    (volatile uint32_t *)0xfe0040cc
#define P_PADCTRL_GPIOZ_PULL_UP                    (volatile uint32_t *)0xfe0040d0
#define P_PADCTRL_GPIOZ_LOCK                       (volatile uint32_t *)0xfe0040d4
#define P_PADCTRL_GPIOZ_PROT                       (volatile uint32_t *)0xfe0040d8
#define P_PADCTRL_GPIOZ_DS                         (volatile uint32_t *)0xfe0040dc
#define P_PADCTRL_GPIOX_I                          (volatile uint32_t *)0xfe004100
#define P_PADCTRL_GPIOX_O                          (volatile uint32_t *)0xfe004104
#define P_PADCTRL_GPIOX_OEN                        (volatile uint32_t *)0xfe004108
#define P_PADCTRL_GPIOX_PULL_EN                    (volatile uint32_t *)0xfe00410c
#define P_PADCTRL_GPIOX_PULL_UP                    (volatile uint32_t *)0xfe004110
#define P_PADCTRL_GPIOX_LOCK                       (volatile uint32_t *)0xfe004114
#define P_PADCTRL_GPIOX_PROT                       (volatile uint32_t *)0xfe004118
#define P_PADCTRL_GPIOX_DS                         (volatile uint32_t *)0xfe00411c
#define P_PADCTRL_GPIOX_DS_EXT                     (volatile uint32_t *)0xfe004120
#define P_PADCTRL_GPIOH_I                          (volatile uint32_t *)0xfe004140
#define P_PADCTRL_GPIOH_O                          (volatile uint32_t *)0xfe004144
#define P_PADCTRL_GPIOH_OEN                        (volatile uint32_t *)0xfe004148
#define P_PADCTRL_GPIOH_PULL_EN                    (volatile uint32_t *)0xfe00414c
#define P_PADCTRL_GPIOH_PULL_UP                    (volatile uint32_t *)0xfe004150
#define P_PADCTRL_GPIOH_LOCK                       (volatile uint32_t *)0xfe004154
#define P_PADCTRL_GPIOH_PROT                       (volatile uint32_t *)0xfe004158
#define P_PADCTRL_GPIOH_DS                         (volatile uint32_t *)0xfe00415c
#define P_PADCTRL_GPIOD_I                          (volatile uint32_t *)0xfe004180
#define P_PADCTRL_GPIOD_O                          (volatile uint32_t *)0xfe004184
#define P_PADCTRL_GPIOD_OEN                        (volatile uint32_t *)0xfe004188
#define P_PADCTRL_GPIOD_PULL_EN                    (volatile uint32_t *)0xfe00418c
#define P_PADCTRL_GPIOD_PULL_UP                    (volatile uint32_t *)0xfe004190
#define P_PADCTRL_GPIOD_LOCK                       (volatile uint32_t *)0xfe004194
#define P_PADCTRL_GPIOD_PROT                       (volatile uint32_t *)0xfe004198
#define P_PADCTRL_GPIOD_DS                         (volatile uint32_t *)0xfe00419c
#define P_PADCTRL_GPIOE_I                          (volatile uint32_t *)0xfe0041c0
#define P_PADCTRL_GPIOE_O                          (volatile uint32_t *)0xfe0041c4
#define P_PADCTRL_GPIOE_OEN                        (volatile uint32_t *)0xfe0041c8
#define P_PADCTRL_GPIOE_PULL_EN                    (volatile uint32_t *)0xfe0041cc
#define P_PADCTRL_GPIOE_PULL_UP                    (volatile uint32_t *)0xfe0041d0
#define P_PADCTRL_GPIOE_LOCK                       (volatile uint32_t *)0xfe0041d4
#define P_PADCTRL_GPIOE_PROT                       (volatile uint32_t *)0xfe0041d8
#define P_PADCTRL_GPIOE_DS                         (volatile uint32_t *)0xfe0041dc
#define P_PADCTRL_GPIOC_I                          (volatile uint32_t *)0xfe004200
#define P_PADCTRL_GPIOC_O                          (volatile uint32_t *)0xfe004204
#define P_PADCTRL_GPIOC_OEN                        (volatile uint32_t *)0xfe004208
#define P_PADCTRL_GPIOC_PULL_EN                    (volatile uint32_t *)0xfe00420c
#define P_PADCTRL_GPIOC_PULL_UP                    (volatile uint32_t *)0xfe004210
#define P_PADCTRL_GPIOC_LOCK                       (volatile uint32_t *)0xfe004214
#define P_PADCTRL_GPIOC_PROT                       (volatile uint32_t *)0xfe004218
#define P_PADCTRL_GPIOC_DS                         (volatile uint32_t *)0xfe00421c
#define P_PADCTRL_GPIOB_I                          (volatile uint32_t *)0xfe004240
#define P_PADCTRL_GPIOB_O                          (volatile uint32_t *)0xfe004244
#define P_PADCTRL_GPIOB_OEN                        (volatile uint32_t *)0xfe004248
#define P_PADCTRL_GPIOB_PULL_EN                    (volatile uint32_t *)0xfe00424c
#define P_PADCTRL_GPIOB_PULL_UP                    (volatile uint32_t *)0xfe004250
#define P_PADCTRL_GPIOB_LOCK                       (volatile uint32_t *)0xfe004254
#define P_PADCTRL_GPIOB_PROT                       (volatile uint32_t *)0xfe004258
#define P_PADCTRL_GPIOB_DS                         (volatile uint32_t *)0xfe00425c
//`define PADCTRL_GPIOA_I               8'hA0
//`define PADCTRL_GPIOA_O               8'hA1
//`define PADCTRL_GPIOA_OEN             8'hA2
//`define PADCTRL_GPIOA_PULL_EN         8'hA3
//`define PADCTRL_GPIOA_PULL_UP         8'hA4
//`define PADCTRL_GPIOA_LOCK            8'hA5
//`define PADCTRL_GPIOA_PROT            8'hA6
//`define PADCTRL_GPIOA_DS              8'hA7
#define P_PADCTRL_TESTN_I                          (volatile uint32_t *)0xfe0042c0
#define P_PADCTRL_TESTN_O                          (volatile uint32_t *)0xfe0042c4
#define P_PADCTRL_TESTN_OEN                        (volatile uint32_t *)0xfe0042c8
#define P_PADCTRL_TESTN_PULL_EN                    (volatile uint32_t *)0xfe0042cc
#define P_PADCTRL_TESTN_PULL_UP                    (volatile uint32_t *)0xfe0042d0
#define P_PADCTRL_TESTN_LOCK                       (volatile uint32_t *)0xfe0042d4
#define P_PADCTRL_TESTN_PROT                       (volatile uint32_t *)0xfe0042d8
#define P_PADCTRL_TESTN_DS                         (volatile uint32_t *)0xfe0042dc
//`define PADCTRL_ANALOG_I              8'hC0
//`define PADCTRL_ANALOG_EN             8'hC1
// CC
#define P_CC_GPIO_I                                (volatile uint32_t *)0xfe004300
#define P_CC_GPIO_O                                (volatile uint32_t *)0xfe004304
#define P_CC_GPIO_OEN                              (volatile uint32_t *)0xfe004308
#define P_CC_GPIO_PROT                             (volatile uint32_t *)0xfe00430c
#define P_CC_GPIO_LOCK                             (volatile uint32_t *)0xfe004310
#define P_PADCTRL_LOCK_PIN_MUX0                    (volatile uint32_t *)0xfe004340
#define P_PADCTRL_LOCK_PIN_MUX1                    (volatile uint32_t *)0xfe004344
#define P_PADCTRL_LOCK_PIN_MUX2                    (volatile uint32_t *)0xfe004348
#define P_PADCTRL_LOCK_PIN_MUX3                    (volatile uint32_t *)0xfe00434c
#define P_PADCTRL_LOCK_PIN_MUX4                    (volatile uint32_t *)0xfe004350
#define P_PADCTRL_PROT_PIN_MUX0                    (volatile uint32_t *)0xfe004360
#define P_PADCTRL_PROT_PIN_MUX1                    (volatile uint32_t *)0xfe004364
#define P_PADCTRL_PROT_PIN_MUX2                    (volatile uint32_t *)0xfe004368
#define P_PADCTRL_PROT_PIN_MUX3                    (volatile uint32_t *)0xfe00436c
#define P_PADCTRL_PROT_PIN_MUX4                    (volatile uint32_t *)0xfe004370
#define P_PADCTRL_MUTE_CTRL                        (volatile uint32_t *)0xfe004380
#define P_PADCTRL_MUTE_TDM_DISA                    (volatile uint32_t *)0xfe004384
#define P_PADCTRL_DEBUG_SEL                        (volatile uint32_t *)0xfe004388
//========================================================================
//  SYS_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe010000
// -----------------------------------------------
#define P_SYSCTRL_METAL_REV0                       (volatile uint32_t *)0xfe010000
#define P_SYSCTRL_METAL_REV1                       (volatile uint32_t *)0xfe010004
#define P_SYSCTRL_METAL_REV2                       (volatile uint32_t *)0xfe010008
#define P_SYSCTRL_CHIP_ID                          (volatile uint32_t *)0xfe01002c
#define P_SYSCTRL_WRITEONCE1_REG0                  (volatile uint32_t *)0xfe010040
#define P_SYSCTRL_WRITEONCE1_STICKY_REG0           (volatile uint32_t *)0xfe010044
#define P_SYSCTRL_WRITEONCE1_SEC_REG0              (volatile uint32_t *)0xfe010048
#define P_SYSCTRL_WRITEONCE1_STICKY_SEC_REG0       (volatile uint32_t *)0xfe01004c
#define P_SYSCTRL_WRITEONCE_REG0                   (volatile uint32_t *)0xfe010050
#define P_SYSCTRL_WRITEONCE_REG1                   (volatile uint32_t *)0xfe010054
#define P_SYSCTRL_WRITEONCE_SEC_REG0               (volatile uint32_t *)0xfe010058
#define P_SYSCTRL_WRITEONCE_STICKY_REG0            (volatile uint32_t *)0xfe01005c
#define P_SYSCTRL_WRITEONCE_STICKY_REG1            (volatile uint32_t *)0xfe010060
#define P_SYSCTRL_WRITEONCE_STICKY_SEC_REG0        (volatile uint32_t *)0xfe010064
#define P_SYSCTRL_TIMERA_CTRL                      (volatile uint32_t *)0xfe0100c0
#define P_SYSCTRL_TIMERA                           (volatile uint32_t *)0xfe0100c4
#define P_SYSCTRL_TIMERB_CTRL                      (volatile uint32_t *)0xfe0100c8
#define P_SYSCTRL_TIMERB                           (volatile uint32_t *)0xfe0100cc
#define P_SYSCTRL_TIMERC_CTRL                      (volatile uint32_t *)0xfe0100d0
#define P_SYSCTRL_TIMERC                           (volatile uint32_t *)0xfe0100d4
#define P_SYSCTRL_TIMERD_CTRL                      (volatile uint32_t *)0xfe0100d8
#define P_SYSCTRL_TIMERD                           (volatile uint32_t *)0xfe0100dc
#define P_SYSCTRL_SEC_TIMERA_CTRL                  (volatile uint32_t *)0xfe0100e0
#define P_SYSCTRL_SEC_TIMERA                       (volatile uint32_t *)0xfe0100e4
#define P_SYSCTRL_TIMERE_CTRL                      (volatile uint32_t *)0xfe0100e8
#define P_SYSCTRL_TIMERE                           (volatile uint32_t *)0xfe0100ec
#define P_SYSCTRL_TIMERE_HI                        (volatile uint32_t *)0xfe0100f0
#define P_SYSCTRL_TIMERF_CTRL                      (volatile uint32_t *)0xfe0100f4
#define P_SYSCTRL_TIMERF                           (volatile uint32_t *)0xfe0100f8
#define P_SYSCTRL_TIMERF_HI                        (volatile uint32_t *)0xfe0100fc
#define P_SYSCTRL_TIMERG_CTRL                      (volatile uint32_t *)0xfe010100
#define P_SYSCTRL_TIMERG                           (volatile uint32_t *)0xfe010104
#define P_SYSCTRL_TIMERH_CTRL                      (volatile uint32_t *)0xfe010108
#define P_SYSCTRL_TIMERH                           (volatile uint32_t *)0xfe01010c
#define P_SYSCTRL_TIMERI_CTRL                      (volatile uint32_t *)0xfe010110
#define P_SYSCTRL_TIMERI                           (volatile uint32_t *)0xfe010114
#define P_SYSCTRL_TIMERJ_CTRL                      (volatile uint32_t *)0xfe010118
#define P_SYSCTRL_TIMERJ                           (volatile uint32_t *)0xfe01011c
#define P_SYSCTRL_SEC_TIMERE_CTRL                  (volatile uint32_t *)0xfe010120
#define P_SYSCTRL_SEC_TIMERE                       (volatile uint32_t *)0xfe010124
#define P_SYSCTRL_SEC_TIMERE_HI                    (volatile uint32_t *)0xfe010128
#define P_SYSCTRL_OSC_RING_CTRL0                   (volatile uint32_t *)0xfe010140
#define P_SYSCTRL_OSC_RING_CTRL1                   (volatile uint32_t *)0xfe010144
#define P_SYSCTRL_AM2AXI_CTRL0                     (volatile uint32_t *)0xfe010148
#define P_SYSCTRL_AM2AXI_STS                       (volatile uint32_t *)0xfe01014c
#define P_SYSCTRL_AXI_PIPE_CTRL0                   (volatile uint32_t *)0xfe010154
#define P_SYSCTRL_AXI_PIPE_CTRL1                   (volatile uint32_t *)0xfe010158
#define P_SYSCTRL_TIMER90K                         (volatile uint32_t *)0xfe01015c
#define P_SYSCTRL_SCR                              (volatile uint32_t *)0xfe010160
#define P_SYSCTRL_HPG_TIMER                        (volatile uint32_t *)0xfe010164
//`define SYSCTRL_VIPNANOQ_CTRL0                  10'h5A
#define P_SYSCTRL_AHB2DDR_CTRL0                    (volatile uint32_t *)0xfe01016c
#define P_SYSCTRL_AHB2DDR_CTRL1                    (volatile uint32_t *)0xfe010170
#define P_SYSCTRL_POC                              (volatile uint32_t *)0xfe010180
#define P_SYSCTRL_VPU_SECURE_REG0                  (volatile uint32_t *)0xfe010184
#define P_SYSCTRL_VPU_SECURE_REG1                  (volatile uint32_t *)0xfe010188
//`define SYSCTRL_NIC_CFG0                        10'h63
#define P_SYSCTRL_ALERT_STS_STICKY                 (volatile uint32_t *)0xfe010190
#define P_SYSCTRL_ALERT_ENABLE                     (volatile uint32_t *)0xfe010198
#define P_SYSCTRL_ENABLE_SPIFC                     (volatile uint32_t *)0xfe0101a0
#define P_SYSCTRL_DEBUG_REG0                       (volatile uint32_t *)0xfe010240
#define P_SYSCTRL_DEBUG_REG1                       (volatile uint32_t *)0xfe010244
#define P_SYSCTRL_DEBUG_REG2                       (volatile uint32_t *)0xfe010248
#define P_SYSCTRL_DEBUG_REG3                       (volatile uint32_t *)0xfe01024c
#define P_SYSCTRL_DEBUG_REG4                       (volatile uint32_t *)0xfe010250
#define P_SYSCTRL_DEBUG_REG5                       (volatile uint32_t *)0xfe010254
#define P_SYSCTRL_DEBUG_REG6                       (volatile uint32_t *)0xfe010258
#define P_SYSCTRL_DEBUG_REG7                       (volatile uint32_t *)0xfe01025c
#define P_SYSCTRL_STATUS_REG0                      (volatile uint32_t *)0xfe010280
#define P_SYSCTRL_STATUS_REG1                      (volatile uint32_t *)0xfe010284
#define P_SYSCTRL_STATUS_REG2                      (volatile uint32_t *)0xfe010288
#define P_SYSCTRL_STATUS_REG3                      (volatile uint32_t *)0xfe01028c
#define P_SYSCTRL_STATUS_REG4                      (volatile uint32_t *)0xfe010290
#define P_SYSCTRL_STATUS_REG5                      (volatile uint32_t *)0xfe010294
#define P_SYSCTRL_STATUS_REG6                      (volatile uint32_t *)0xfe010298
#define P_SYSCTRL_STATUS_REG7                      (volatile uint32_t *)0xfe01029c
#define P_SYSCTRL_STICKY_REG0                      (volatile uint32_t *)0xfe0102c0
#define P_SYSCTRL_STICKY_REG1                      (volatile uint32_t *)0xfe0102c4
#define P_SYSCTRL_STICKY_REG2                      (volatile uint32_t *)0xfe0102c8
#define P_SYSCTRL_STICKY_REG3                      (volatile uint32_t *)0xfe0102cc
#define P_SYSCTRL_STICKY_REG4                      (volatile uint32_t *)0xfe0102d0
#define P_SYSCTRL_STICKY_REG5                      (volatile uint32_t *)0xfe0102d4
#define P_SYSCTRL_STICKY_REG6                      (volatile uint32_t *)0xfe0102d8
#define P_SYSCTRL_STICKY_REG7                      (volatile uint32_t *)0xfe0102dc
#define P_SYSCTRL_SEC_STATUS_REG0                  (volatile uint32_t *)0xfe010300
#define P_SYSCTRL_SEC_STATUS_REG1                  (volatile uint32_t *)0xfe010304
#define P_SYSCTRL_SEC_STATUS_REG2                  (volatile uint32_t *)0xfe010308
#define P_SYSCTRL_SEC_STATUS_REG3                  (volatile uint32_t *)0xfe01030c
#define P_SYSCTRL_SEC_STATUS_REG4                  (volatile uint32_t *)0xfe010310
#define P_SYSCTRL_SEC_STATUS_REG5                  (volatile uint32_t *)0xfe010314
#define P_SYSCTRL_SEC_STATUS_REG6                  (volatile uint32_t *)0xfe010318
#define P_SYSCTRL_SEC_STATUS_REG7                  (volatile uint32_t *)0xfe01031c
#define P_SYSCTRL_SEC_STATUS_REG8                  (volatile uint32_t *)0xfe010320
#define P_SYSCTRL_SEC_STATUS_REG9                  (volatile uint32_t *)0xfe010324
#define P_SYSCTRL_SEC_STATUS_REG10                 (volatile uint32_t *)0xfe010328
#define P_SYSCTRL_SEC_STATUS_REG11                 (volatile uint32_t *)0xfe01032c
#define P_SYSCTRL_SEC_STATUS_REG12                 (volatile uint32_t *)0xfe010330
#define P_SYSCTRL_SEC_STATUS_REG13                 (volatile uint32_t *)0xfe010334
#define P_SYSCTRL_SEC_STATUS_REG14                 (volatile uint32_t *)0xfe010338
#define P_SYSCTRL_SEC_STATUS_REG15                 (volatile uint32_t *)0xfe01033c
#define P_SYSCTRL_SEC_STATUS_REG16                 (volatile uint32_t *)0xfe010340
#define P_SYSCTRL_SEC_STATUS_REG17                 (volatile uint32_t *)0xfe010344
#define P_SYSCTRL_SEC_STATUS_REG18                 (volatile uint32_t *)0xfe010348
#define P_SYSCTRL_SEC_STATUS_REG19                 (volatile uint32_t *)0xfe01034c
#define P_SYSCTRL_SEC_STATUS_REG20                 (volatile uint32_t *)0xfe010350
#define P_SYSCTRL_SEC_STATUS_REG21                 (volatile uint32_t *)0xfe010354
#define P_SYSCTRL_SEC_STATUS_REG22                 (volatile uint32_t *)0xfe010358
#define P_SYSCTRL_SEC_STATUS_REG23                 (volatile uint32_t *)0xfe01035c
#define P_SYSCTRL_SEC_STATUS_REG24                 (volatile uint32_t *)0xfe010360
#define P_SYSCTRL_SEC_STATUS_REG25                 (volatile uint32_t *)0xfe010364
#define P_SYSCTRL_SEC_STATUS_REG26                 (volatile uint32_t *)0xfe010368
#define P_SYSCTRL_SEC_STATUS_REG27                 (volatile uint32_t *)0xfe01036c
#define P_SYSCTRL_SEC_STATUS_REG28                 (volatile uint32_t *)0xfe010370
#define P_SYSCTRL_SEC_STATUS_REG29                 (volatile uint32_t *)0xfe010374
#define P_SYSCTRL_SEC_STATUS_REG30                 (volatile uint32_t *)0xfe010378
#define P_SYSCTRL_SEC_STATUS_REG31                 (volatile uint32_t *)0xfe01037c
#define P_SYSCTRL_SEC_STICKY_REG0                  (volatile uint32_t *)0xfe010380
#define P_SYSCTRL_SEC_STICKY_REG1                  (volatile uint32_t *)0xfe010384
#define P_SYSCTRL_SEC_STICKY_REG2                  (volatile uint32_t *)0xfe010388
#define P_SYSCTRL_SEC_STICKY_REG3                  (volatile uint32_t *)0xfe01038c
#define P_SYSCTRL_SEC_STICKY_REG4                  (volatile uint32_t *)0xfe010390
#define P_SYSCTRL_SEC_STICKY_REG5                  (volatile uint32_t *)0xfe010394
#define P_SYSCTRL_SEC_STICKY_REG6                  (volatile uint32_t *)0xfe010398
#define P_SYSCTRL_SEC_STICKY_REG7                  (volatile uint32_t *)0xfe01039c
#define P_SYSCTRL_MSG_INDEX0_STICKY                (volatile uint32_t *)0xfe0103c0
#define P_SYSCTRL_MSG_INDEX1_STICKY                (volatile uint32_t *)0xfe0103c4
#define P_SYSCTRL_MSG_INDEX2_STICKY                (volatile uint32_t *)0xfe0103c8
#define P_SYSCTRL_MSG_INDEX3_STICKY                (volatile uint32_t *)0xfe0103cc
//`define SYSCTRL_MALI_TEXFMTENABLE               10'h100
//`define SYSCTRL_MALI_CONFIG                     10'h101
#define P_SYSCTRL_CPU_RAM_EMA_CTRL                 (volatile uint32_t *)0xfe010440
//========================================================================
//  CLK_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe000000
// -----------------------------------------------
#define P_CLKCTRL_OSCIN_CTRL                       (volatile uint32_t *)0xfe000004
#define P_CLKCTRL_RTC_BY_OSCIN_CTRL0               (volatile uint32_t *)0xfe000008
#define P_CLKCTRL_RTC_BY_OSCIN_CTRL1               (volatile uint32_t *)0xfe00000c
#define P_CLKCTRL_RTC_CTRL                         (volatile uint32_t *)0xfe000010
#define P_CLKCTRL_CHECK_CLK_RESULT                 (volatile uint32_t *)0xfe000014
#define P_CLKCTRL_MBIST_ATSPEED_CTRL               (volatile uint32_t *)0xfe000018
#define P_CLKCTRL_LOCK_BIT_REG0                    (volatile uint32_t *)0xfe000020
#define P_CLKCTRL_LOCK_BIT_REG1                    (volatile uint32_t *)0xfe000024
#define P_CLKCTRL_LOCK_BIT_REG2                    (volatile uint32_t *)0xfe000028
#define P_CLKCTRL_LOCK_BIT_REG3                    (volatile uint32_t *)0xfe00002c
#define P_CLKCTRL_PROT_BIT_REG0                    (volatile uint32_t *)0xfe000030
#define P_CLKCTRL_PROT_BIT_REG1                    (volatile uint32_t *)0xfe000034
#define P_CLKCTRL_PROT_BIT_REG2                    (volatile uint32_t *)0xfe000038
#define P_CLKCTRL_PROT_BIT_REG3                    (volatile uint32_t *)0xfe00003c
#define P_CLKCTRL_SYS_CLK_CTRL0                    (volatile uint32_t *)0xfe000040
#define P_CLKCTRL_SYS_CLK_EN0_REG0                 (volatile uint32_t *)0xfe000044
#define P_CLKCTRL_SYS_CLK_EN0_REG1                 (volatile uint32_t *)0xfe000048
#define P_CLKCTRL_SYS_CLK_EN0_REG2                 (volatile uint32_t *)0xfe00004c
#define P_CLKCTRL_SYS_CLK_EN0_REG3                 (volatile uint32_t *)0xfe000050
#define P_CLKCTRL_SYS_CLK_EN1_REG0                 (volatile uint32_t *)0xfe000054
#define P_CLKCTRL_SYS_CLK_EN1_REG1                 (volatile uint32_t *)0xfe000058
#define P_CLKCTRL_SYS_CLK_EN1_REG2                 (volatile uint32_t *)0xfe00005c
#define P_CLKCTRL_SYS_CLK_EN1_REG3                 (volatile uint32_t *)0xfe000060
#define P_CLKCTRL_SYS_CLK_VPU_EN0                  (volatile uint32_t *)0xfe000064
#define P_CLKCTRL_SYS_CLK_VPU_EN1                  (volatile uint32_t *)0xfe000068
#define P_CLKCTRL_AXI_CLK_CTRL0                    (volatile uint32_t *)0xfe00006c
#define P_CLKCTRL_TST_CTRL0                        (volatile uint32_t *)0xfe000080
#define P_CLKCTRL_TST_CTRL1                        (volatile uint32_t *)0xfe000084
//`define CLKCTRL_CECA_CTRL0              10'h22
//`define CLKCTRL_CECA_CTRL1              10'h23
#define P_CLKCTRL_CECB_CTRL0                       (volatile uint32_t *)0xfe000090
#define P_CLKCTRL_CECB_CTRL1                       (volatile uint32_t *)0xfe000094
#define P_CLKCTRL_SC_CLK_CTRL                      (volatile uint32_t *)0xfe000098
//`define CLKCTRL_DSPA_CLK_CTRL0          10'h27
//`define CLKCTRL_DSPB_CLK_CTRL0          10'h28
//`define CLKCTRL_RAMA_CLK_CTRL0          10'h29
#define P_CLKCTRL_CLK12_24_CTRL                    (volatile uint32_t *)0xfe0000a8
#define P_CLKCTRL_AXI_CLK_EN0                      (volatile uint32_t *)0xfe0000ac
#define P_CLKCTRL_AXI_CLK_EN1                      (volatile uint32_t *)0xfe0000b0
#define P_CLKCTRL_VID_CLK_CTRL                     (volatile uint32_t *)0xfe0000c0
#define P_CLKCTRL_VID_CLK_CTRL2                    (volatile uint32_t *)0xfe0000c4
#define P_CLKCTRL_VID_CLK_DIV                      (volatile uint32_t *)0xfe0000c8
#define P_CLKCTRL_VIID_CLK_DIV                     (volatile uint32_t *)0xfe0000cc
#define P_CLKCTRL_VIID_CLK_CTRL                    (volatile uint32_t *)0xfe0000d0
#define P_CLKCTRL_HDMI_CLK_CTRL                    (volatile uint32_t *)0xfe0000e0
#define P_CLKCTRL_VID_PLL_CLK_DIV                  (volatile uint32_t *)0xfe0000e4
#define P_CLKCTRL_VPU_CLK_CTRL                     (volatile uint32_t *)0xfe0000e8
#define P_CLKCTRL_VPU_CLKB_CTRL                    (volatile uint32_t *)0xfe0000ec
#define P_CLKCTRL_VPU_CLKC_CTRL                    (volatile uint32_t *)0xfe0000f0
#define P_CLKCTRL_VID_LOCK_CLK_CTRL                (volatile uint32_t *)0xfe0000f4
#define P_CLKCTRL_VDIN_MEAS_CLK_CTRL               (volatile uint32_t *)0xfe0000f8
#define P_CLKCTRL_VAPBCLK_CTRL                     (volatile uint32_t *)0xfe0000fc
//`define CLKCTRL_HDCP22_CLK_CTRL         10'h40 // HDMI HDCP2.2 clock control
//`define CLKCTRL_MIPIDSI_PHY_CLK_CTRL    10'h41
#define P_CLKCTRL_CDAC_CLK_CTRL                    (volatile uint32_t *)0xfe000108
//`define CLKCTRL_MIPI_CSI_PHY_CLK_CTRL   10'h43
//`define CLKCTRL_CSI2_ADAPT_CLK_CTRL     10'h44
#define P_CLKCTRL_HTX_CLK_CTRL0                    (volatile uint32_t *)0xfe00011c
#define P_CLKCTRL_HTX_CLK_CTRL1                    (volatile uint32_t *)0xfe000120
#define P_CLKCTRL_VDEC_CLK_CTRL                    (volatile uint32_t *)0xfe000140
#define P_CLKCTRL_VDEC2_CLK_CTRL                   (volatile uint32_t *)0xfe000144
#define P_CLKCTRL_VDEC3_CLK_CTRL                   (volatile uint32_t *)0xfe000148
#define P_CLKCTRL_VDEC4_CLK_CTRL                   (volatile uint32_t *)0xfe00014c
//`define CLKCTRL_WAVE420L_CLK_CTRL       10'h54
//`define CLKCTRL_WAVE420L_CLK_CTRL2      10'h55
#define P_CLKCTRL_TS_CLK_CTRL                      (volatile uint32_t *)0xfe000158
#define P_CLKCTRL_MALI_CLK_CTRL                    (volatile uint32_t *)0xfe00015c
//`define CLKCTRL_VIPNANOQ_CLK_CTRL       10'h58
#define P_CLKCTRL_ETH_CLK_CTRL                     (volatile uint32_t *)0xfe000164
#define P_CLKCTRL_NAND_CLK_CTRL                    (volatile uint32_t *)0xfe000168
#define P_CLKCTRL_SD_EMMC_CLK_CTRL                 (volatile uint32_t *)0xfe00016c
//`define CLKCTRL_BT656_CLK_CTRL          10'h5C
#define P_CLKCTRL_SPICC_CLK_CTRL                   (volatile uint32_t *)0xfe000174
#define P_CLKCTRL_GEN_CLK_CTRL                     (volatile uint32_t *)0xfe000178
#define P_CLKCTRL_SAR_CLK_CTRL0                    (volatile uint32_t *)0xfe00017c
#define P_CLKCTRL_PWM_CLK_AB_CTRL                  (volatile uint32_t *)0xfe000180
#define P_CLKCTRL_PWM_CLK_CD_CTRL                  (volatile uint32_t *)0xfe000184
#define P_CLKCTRL_PWM_CLK_EF_CTRL                  (volatile uint32_t *)0xfe000188
#define P_CLKCTRL_PWM_CLK_GH_CTRL                  (volatile uint32_t *)0xfe00018c
#define P_CLKCTRL_PWM_CLK_IJ_CTRL                  (volatile uint32_t *)0xfe000190
//`define CLKCTRL_DEMOD_CLK_CTRL          10'h80
//`define CLKCTRL_DEMOD_CLK_CTRL1         10'h81
//`define CLKCTRL_DEMOD_32K_CTRL0         10'h82
//`define CLKCTRL_DEMOD_32K_CTRL1         10'h83
#define P_CLKCTRL_TIMESTAMP_CTRL                   (volatile uint32_t *)0xfe000400
#define P_CLKCTRL_TIMESTAMP_CTRL1                  (volatile uint32_t *)0xfe000404
#define P_CLKCTRL_TIMESTAMP_CTRL2                  (volatile uint32_t *)0xfe00040c
#define P_CLKCTRL_TIMESTAMP_RD0                    (volatile uint32_t *)0xfe000410
#define P_CLKCTRL_TIMESTAMP_RD1                    (volatile uint32_t *)0xfe000414
#define P_CLKCTRL_TIMEBASE_CTRL0                   (volatile uint32_t *)0xfe000418
#define P_CLKCTRL_TIMEBASE_CTRL1                   (volatile uint32_t *)0xfe00041c
#define P_CLKCTRL_EFUSE_CPU_CFG01                  (volatile uint32_t *)0xfe000480
#define P_CLKCTRL_EFUSE_CPU_CFG2                   (volatile uint32_t *)0xfe000484
#define P_CLKCTRL_EFUSE_ENCP_CFG0                  (volatile uint32_t *)0xfe000488
#define P_CLKCTRL_EFUSE_MALI_CFG01                 (volatile uint32_t *)0xfe00048c
#define P_CLKCTRL_EFUSE_HEVCB_CFG01                (volatile uint32_t *)0xfe000490
#define P_CLKCTRL_EFUSE_HEVCB_CFG2                 (volatile uint32_t *)0xfe000494
#define P_CLKCTRL_EFUSE_LOCK                       (volatile uint32_t *)0xfe000498
//========================================================================
//  PWR_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00c000
// -----------------------------------------------
#define P_PWRCTRL_PWR_ACK0                         (volatile uint32_t *)0xfe00c000
#define P_PWRCTRL_PWR_ACK1                         (volatile uint32_t *)0xfe00c004
#define P_PWRCTRL_PWR_OFF0                         (volatile uint32_t *)0xfe00c010
#define P_PWRCTRL_PWR_OFF1                         (volatile uint32_t *)0xfe00c014
#define P_PWRCTRL_ISO_EN0                          (volatile uint32_t *)0xfe00c020
#define P_PWRCTRL_ISO_EN1                          (volatile uint32_t *)0xfe00c024
#define P_PWRCTRL_FOCRST0                          (volatile uint32_t *)0xfe00c030
#define P_PWRCTRL_FOCRST1                          (volatile uint32_t *)0xfe00c034
#define P_PWRCTRL_MEM_PD0                          (volatile uint32_t *)0xfe00c040
#define P_PWRCTRL_MEM_PD1                          (volatile uint32_t *)0xfe00c044
#define P_PWRCTRL_MEM_PD2                          (volatile uint32_t *)0xfe00c048
#define P_PWRCTRL_MEM_PD3                          (volatile uint32_t *)0xfe00c04c
#define P_PWRCTRL_MEM_PD4                          (volatile uint32_t *)0xfe00c050
#define P_PWRCTRL_MEM_PD5                          (volatile uint32_t *)0xfe00c054
#define P_PWRCTRL_MEM_PD6                          (volatile uint32_t *)0xfe00c058
#define P_PWRCTRL_MEM_PD7                          (volatile uint32_t *)0xfe00c05c
#define P_PWRCTRL_MEM_PD8                          (volatile uint32_t *)0xfe00c060
#define P_PWRCTRL_MEM_PD9                          (volatile uint32_t *)0xfe00c064
#define P_PWRCTRL_MEM_PD10                         (volatile uint32_t *)0xfe00c068
#define P_PWRCTRL_MEM_PD11                         (volatile uint32_t *)0xfe00c06c
#define P_PWRCTRL_MEM_PD12                         (volatile uint32_t *)0xfe00c070
#define P_PWRCTRL_MEM_PD13                         (volatile uint32_t *)0xfe00c074
#define P_PWRCTRL_MEM_PD14                         (volatile uint32_t *)0xfe00c078
#define P_PWRCTRL_MEM_PD15                         (volatile uint32_t *)0xfe00c07c
#define P_PWRCTRL_DDRPHY_CTRL                      (volatile uint32_t *)0xfe00c080
#define P_PWRCTRL_ETHMAC_CTRL                      (volatile uint32_t *)0xfe00c084
#define P_PWRCTRL_CPU0_AUTO_OFF_CTRL0              (volatile uint32_t *)0xfe00c100
#define P_PWRCTRL_CPU0_AUTO_OFF_CTRL1              (volatile uint32_t *)0xfe00c104
#define P_PWRCTRL_CPU0_AUTO_OFF_CTRL2              (volatile uint32_t *)0xfe00c108
#define P_PWRCTRL_CPU0_AUTO_OFF_CTRL3              (volatile uint32_t *)0xfe00c10c
#define P_PWRCTRL_CPU0_AUTO_OFF_CTRL4              (volatile uint32_t *)0xfe00c110
#define P_PWRCTRL_CPU0_TIMER_TH_01                 (volatile uint32_t *)0xfe00c120
#define P_PWRCTRL_CPU0_TIMER_TH_23                 (volatile uint32_t *)0xfe00c124
#define P_PWRCTRL_CPU0_TIMER_TH_45                 (volatile uint32_t *)0xfe00c128
#define P_PWRCTRL_CPU0_TIMER_TH_67                 (volatile uint32_t *)0xfe00c12c
#define P_PWRCTRL_CPU0_TIMER_TH_89                 (volatile uint32_t *)0xfe00c130
#define P_PWRCTRL_CPU0_IRQ_MASK0                   (volatile uint32_t *)0xfe00c140
#define P_PWRCTRL_CPU0_IRQ_MASK1                   (volatile uint32_t *)0xfe00c144
#define P_PWRCTRL_CPU0_IRQ_MASK2                   (volatile uint32_t *)0xfe00c148
#define P_PWRCTRL_CPU0_IRQ_MASK3                   (volatile uint32_t *)0xfe00c14c
#define P_PWRCTRL_CPU0_IRQ_MASK4                   (volatile uint32_t *)0xfe00c150
#define P_PWRCTRL_CPU0_IRQ_MASK5                   (volatile uint32_t *)0xfe00c154
#define P_PWRCTRL_CPU0_IRQ_MASK6                   (volatile uint32_t *)0xfe00c158
#define P_PWRCTRL_CPU0_IRQ_MASK7                   (volatile uint32_t *)0xfe00c15c
#define P_PWRCTRL_CPU0_MEMPD_INIT_SET              (volatile uint32_t *)0xfe00c180
#define P_PWRCTRL_CPU0_MEMPD_OFF_SET               (volatile uint32_t *)0xfe00c184
#define P_PWRCTRL_CPU0_MEMPD_ON_A_SET              (volatile uint32_t *)0xfe00c188
#define P_PWRCTRL_CPU0_MEMPD_ON_B_SET              (volatile uint32_t *)0xfe00c18c
#define P_PWRCTRL_CPU0_MEMPD_ON_C_SET              (volatile uint32_t *)0xfe00c190
#define P_PWRCTRL_CPU0_MEMPD_ON_D_SET              (volatile uint32_t *)0xfe00c194
#define P_PWRCTRL_CPU0_MEMPD_STS                   (volatile uint32_t *)0xfe00c198
#define P_PWRCTRL_CPU0_FSM_STS0                    (volatile uint32_t *)0xfe00c19c
#define P_PWRCTRL_CPU0_FSM_STS1                    (volatile uint32_t *)0xfe00c1a0
#define P_PWRCTRL_CPU0_FSM_STS2                    (volatile uint32_t *)0xfe00c1a4
#define P_PWRCTRL_CPU0_FSM_START_OFF               (volatile uint32_t *)0xfe00c1b4
#define P_PWRCTRL_CPU0_FSM_START_ON                (volatile uint32_t *)0xfe00c1b8
#define P_PWRCTRL_CPU0_FSM_JUMP                    (volatile uint32_t *)0xfe00c1bc
#define P_PWRCTRL_CPU1_AUTO_OFF_CTRL0              (volatile uint32_t *)0xfe00c1c0
#define P_PWRCTRL_CPU1_AUTO_OFF_CTRL1              (volatile uint32_t *)0xfe00c1c4
#define P_PWRCTRL_CPU1_AUTO_OFF_CTRL2              (volatile uint32_t *)0xfe00c1c8
#define P_PWRCTRL_CPU1_AUTO_OFF_CTRL3              (volatile uint32_t *)0xfe00c1cc
#define P_PWRCTRL_CPU1_AUTO_OFF_CTRL4              (volatile uint32_t *)0xfe00c1d0
#define P_PWRCTRL_CPU1_TIMER_TH_01                 (volatile uint32_t *)0xfe00c1e0
#define P_PWRCTRL_CPU1_TIMER_TH_23                 (volatile uint32_t *)0xfe00c1e4
#define P_PWRCTRL_CPU1_TIMER_TH_45                 (volatile uint32_t *)0xfe00c1e8
#define P_PWRCTRL_CPU1_TIMER_TH_67                 (volatile uint32_t *)0xfe00c1ec
#define P_PWRCTRL_CPU1_TIMER_TH_89                 (volatile uint32_t *)0xfe00c1f0
#define P_PWRCTRL_CPU1_IRQ_MASK0                   (volatile uint32_t *)0xfe00c200
#define P_PWRCTRL_CPU1_IRQ_MASK1                   (volatile uint32_t *)0xfe00c204
#define P_PWRCTRL_CPU1_IRQ_MASK2                   (volatile uint32_t *)0xfe00c208
#define P_PWRCTRL_CPU1_IRQ_MASK3                   (volatile uint32_t *)0xfe00c20c
#define P_PWRCTRL_CPU1_IRQ_MASK4                   (volatile uint32_t *)0xfe00c210
#define P_PWRCTRL_CPU1_IRQ_MASK5                   (volatile uint32_t *)0xfe00c214
#define P_PWRCTRL_CPU1_IRQ_MASK6                   (volatile uint32_t *)0xfe00c218
#define P_PWRCTRL_CPU1_IRQ_MASK7                   (volatile uint32_t *)0xfe00c21c
#define P_PWRCTRL_CPU1_MEMPD_INIT_SET              (volatile uint32_t *)0xfe00c240
#define P_PWRCTRL_CPU1_MEMPD_OFF_SET               (volatile uint32_t *)0xfe00c244
#define P_PWRCTRL_CPU1_MEMPD_ON_A_SET              (volatile uint32_t *)0xfe00c248
#define P_PWRCTRL_CPU1_MEMPD_ON_B_SET              (volatile uint32_t *)0xfe00c24c
#define P_PWRCTRL_CPU1_MEMPD_ON_C_SET              (volatile uint32_t *)0xfe00c250
#define P_PWRCTRL_CPU1_MEMPD_ON_D_SET              (volatile uint32_t *)0xfe00c254
#define P_PWRCTRL_CPU1_MEMPD_STS                   (volatile uint32_t *)0xfe00c258
#define P_PWRCTRL_CPU1_FSM_STS0                    (volatile uint32_t *)0xfe00c25c
#define P_PWRCTRL_CPU1_FSM_STS1                    (volatile uint32_t *)0xfe00c260
#define P_PWRCTRL_CPU1_FSM_STS2                    (volatile uint32_t *)0xfe00c264
#define P_PWRCTRL_CPU1_FSM_START_OFF               (volatile uint32_t *)0xfe00c274
#define P_PWRCTRL_CPU1_FSM_START_ON                (volatile uint32_t *)0xfe00c278
#define P_PWRCTRL_CPU1_FSM_JUMP                    (volatile uint32_t *)0xfe00c27c
#define P_PWRCTRL_CPU2_AUTO_OFF_CTRL0              (volatile uint32_t *)0xfe00c280
#define P_PWRCTRL_CPU2_AUTO_OFF_CTRL1              (volatile uint32_t *)0xfe00c284
#define P_PWRCTRL_CPU2_AUTO_OFF_CTRL2              (volatile uint32_t *)0xfe00c288
#define P_PWRCTRL_CPU2_AUTO_OFF_CTRL3              (volatile uint32_t *)0xfe00c28c
#define P_PWRCTRL_CPU2_AUTO_OFF_CTRL4              (volatile uint32_t *)0xfe00c290
#define P_PWRCTRL_CPU2_TIMER_TH_01                 (volatile uint32_t *)0xfe00c2a0
#define P_PWRCTRL_CPU2_TIMER_TH_23                 (volatile uint32_t *)0xfe00c2a4
#define P_PWRCTRL_CPU2_TIMER_TH_45                 (volatile uint32_t *)0xfe00c2a8
#define P_PWRCTRL_CPU2_TIMER_TH_67                 (volatile uint32_t *)0xfe00c2ac
#define P_PWRCTRL_CPU2_TIMER_TH_89                 (volatile uint32_t *)0xfe00c2b0
#define P_PWRCTRL_CPU2_IRQ_MASK0                   (volatile uint32_t *)0xfe00c2c0
#define P_PWRCTRL_CPU2_IRQ_MASK1                   (volatile uint32_t *)0xfe00c2c4
#define P_PWRCTRL_CPU2_IRQ_MASK2                   (volatile uint32_t *)0xfe00c2c8
#define P_PWRCTRL_CPU2_IRQ_MASK3                   (volatile uint32_t *)0xfe00c2cc
#define P_PWRCTRL_CPU2_IRQ_MASK4                   (volatile uint32_t *)0xfe00c2d0
#define P_PWRCTRL_CPU2_IRQ_MASK5                   (volatile uint32_t *)0xfe00c2d4
#define P_PWRCTRL_CPU2_IRQ_MASK6                   (volatile uint32_t *)0xfe00c2d8
#define P_PWRCTRL_CPU2_IRQ_MASK7                   (volatile uint32_t *)0xfe00c2dc
#define P_PWRCTRL_CPU2_MEMPD_INIT_SET              (volatile uint32_t *)0xfe00c300
#define P_PWRCTRL_CPU2_MEMPD_OFF_SET               (volatile uint32_t *)0xfe00c304
#define P_PWRCTRL_CPU2_MEMPD_ON_A_SET              (volatile uint32_t *)0xfe00c308
#define P_PWRCTRL_CPU2_MEMPD_ON_B_SET              (volatile uint32_t *)0xfe00c30c
#define P_PWRCTRL_CPU2_MEMPD_ON_C_SET              (volatile uint32_t *)0xfe00c310
#define P_PWRCTRL_CPU2_MEMPD_ON_D_SET              (volatile uint32_t *)0xfe00c314
#define P_PWRCTRL_CPU2_MEMPD_STS                   (volatile uint32_t *)0xfe00c318
#define P_PWRCTRL_CPU2_FSM_STS0                    (volatile uint32_t *)0xfe00c31c
#define P_PWRCTRL_CPU2_FSM_STS1                    (volatile uint32_t *)0xfe00c320
#define P_PWRCTRL_CPU2_FSM_STS2                    (volatile uint32_t *)0xfe00c324
#define P_PWRCTRL_CPU2_FSM_START_OFF               (volatile uint32_t *)0xfe00c334
#define P_PWRCTRL_CPU2_FSM_START_ON                (volatile uint32_t *)0xfe00c338
#define P_PWRCTRL_CPU2_FSM_JUMP                    (volatile uint32_t *)0xfe00c33c
#define P_PWRCTRL_CPU3_AUTO_OFF_CTRL0              (volatile uint32_t *)0xfe00c340
#define P_PWRCTRL_CPU3_AUTO_OFF_CTRL1              (volatile uint32_t *)0xfe00c344
#define P_PWRCTRL_CPU3_AUTO_OFF_CTRL2              (volatile uint32_t *)0xfe00c348
#define P_PWRCTRL_CPU3_AUTO_OFF_CTRL3              (volatile uint32_t *)0xfe00c34c
#define P_PWRCTRL_CPU3_AUTO_OFF_CTRL4              (volatile uint32_t *)0xfe00c350
#define P_PWRCTRL_CPU3_TIMER_TH_01                 (volatile uint32_t *)0xfe00c360
#define P_PWRCTRL_CPU3_TIMER_TH_23                 (volatile uint32_t *)0xfe00c364
#define P_PWRCTRL_CPU3_TIMER_TH_45                 (volatile uint32_t *)0xfe00c368
#define P_PWRCTRL_CPU3_TIMER_TH_67                 (volatile uint32_t *)0xfe00c36c
#define P_PWRCTRL_CPU3_TIMER_TH_89                 (volatile uint32_t *)0xfe00c370
#define P_PWRCTRL_CPU3_IRQ_MASK0                   (volatile uint32_t *)0xfe00c380
#define P_PWRCTRL_CPU3_IRQ_MASK1                   (volatile uint32_t *)0xfe00c384
#define P_PWRCTRL_CPU3_IRQ_MASK2                   (volatile uint32_t *)0xfe00c388
#define P_PWRCTRL_CPU3_IRQ_MASK3                   (volatile uint32_t *)0xfe00c38c
#define P_PWRCTRL_CPU3_IRQ_MASK4                   (volatile uint32_t *)0xfe00c390
#define P_PWRCTRL_CPU3_IRQ_MASK5                   (volatile uint32_t *)0xfe00c394
#define P_PWRCTRL_CPU3_IRQ_MASK6                   (volatile uint32_t *)0xfe00c398
#define P_PWRCTRL_CPU3_IRQ_MASK7                   (volatile uint32_t *)0xfe00c39c
#define P_PWRCTRL_CPU3_MEMPD_INIT_SET              (volatile uint32_t *)0xfe00c3c0
#define P_PWRCTRL_CPU3_MEMPD_OFF_SET               (volatile uint32_t *)0xfe00c3c4
#define P_PWRCTRL_CPU3_MEMPD_ON_A_SET              (volatile uint32_t *)0xfe00c3c8
#define P_PWRCTRL_CPU3_MEMPD_ON_B_SET              (volatile uint32_t *)0xfe00c3cc
#define P_PWRCTRL_CPU3_MEMPD_ON_C_SET              (volatile uint32_t *)0xfe00c3d0
#define P_PWRCTRL_CPU3_MEMPD_ON_D_SET              (volatile uint32_t *)0xfe00c3d4
#define P_PWRCTRL_CPU3_MEMPD_STS                   (volatile uint32_t *)0xfe00c3d8
#define P_PWRCTRL_CPU3_FSM_STS0                    (volatile uint32_t *)0xfe00c3dc
#define P_PWRCTRL_CPU3_FSM_STS1                    (volatile uint32_t *)0xfe00c3e0
#define P_PWRCTRL_CPU3_FSM_STS2                    (volatile uint32_t *)0xfe00c3e4
#define P_PWRCTRL_CPU3_FSM_START_OFF               (volatile uint32_t *)0xfe00c3f4
#define P_PWRCTRL_CPU3_FSM_START_ON                (volatile uint32_t *)0xfe00c3f8
#define P_PWRCTRL_CPU3_FSM_JUMP                    (volatile uint32_t *)0xfe00c3fc
#define P_PWRCTRL_CPUTOP_AUTO_OFF_CTRL0            (volatile uint32_t *)0xfe00c400
#define P_PWRCTRL_CPUTOP_AUTO_OFF_CTRL1            (volatile uint32_t *)0xfe00c404
#define P_PWRCTRL_CPUTOP_AUTO_OFF_CTRL2            (volatile uint32_t *)0xfe00c408
#define P_PWRCTRL_CPUTOP_AUTO_OFF_CTRL3            (volatile uint32_t *)0xfe00c40c
#define P_PWRCTRL_CPUTOP_AUTO_OFF_CTRL4            (volatile uint32_t *)0xfe00c410
#define P_PWRCTRL_CPUTOP_TIMER_TH_01               (volatile uint32_t *)0xfe00c420
#define P_PWRCTRL_CPUTOP_TIMER_TH_23               (volatile uint32_t *)0xfe00c424
#define P_PWRCTRL_CPUTOP_TIMER_TH_45               (volatile uint32_t *)0xfe00c428
#define P_PWRCTRL_CPUTOP_TIMER_TH_67               (volatile uint32_t *)0xfe00c42c
#define P_PWRCTRL_CPUTOP_TIMER_TH_89               (volatile uint32_t *)0xfe00c430
#define P_PWRCTRL_CPUTOP_IRQ_MASK0                 (volatile uint32_t *)0xfe00c440
#define P_PWRCTRL_CPUTOP_IRQ_MASK1                 (volatile uint32_t *)0xfe00c444
#define P_PWRCTRL_CPUTOP_IRQ_MASK2                 (volatile uint32_t *)0xfe00c448
#define P_PWRCTRL_CPUTOP_IRQ_MASK3                 (volatile uint32_t *)0xfe00c44c
#define P_PWRCTRL_CPUTOP_IRQ_MASK4                 (volatile uint32_t *)0xfe00c450
#define P_PWRCTRL_CPUTOP_IRQ_MASK5                 (volatile uint32_t *)0xfe00c454
#define P_PWRCTRL_CPUTOP_IRQ_MASK6                 (volatile uint32_t *)0xfe00c458
#define P_PWRCTRL_CPUTOP_IRQ_MASK7                 (volatile uint32_t *)0xfe00c45c
#define P_PWRCTRL_CPUTOP_MEMPD_INIT_SET            (volatile uint32_t *)0xfe00c480
#define P_PWRCTRL_CPUTOP_MEMPD_OFF_SET             (volatile uint32_t *)0xfe00c484
#define P_PWRCTRL_CPUTOP_MEMPD_ON_A_SET            (volatile uint32_t *)0xfe00c488
#define P_PWRCTRL_CPUTOP_MEMPD_ON_B_SET            (volatile uint32_t *)0xfe00c48c
#define P_PWRCTRL_CPUTOP_MEMPD_ON_C_SET            (volatile uint32_t *)0xfe00c490
#define P_PWRCTRL_CPUTOP_MEMPD_ON_D_SET            (volatile uint32_t *)0xfe00c494
#define P_PWRCTRL_CPUTOP_MEMPD_STS                 (volatile uint32_t *)0xfe00c498
#define P_PWRCTRL_CPUTOP_FSM_STS0                  (volatile uint32_t *)0xfe00c49c
#define P_PWRCTRL_CPUTOP_FSM_STS1                  (volatile uint32_t *)0xfe00c4a0
#define P_PWRCTRL_CPUTOP_FSM_STS2                  (volatile uint32_t *)0xfe00c4a4
#define P_PWRCTRL_CPUTOP_FSM_START_OFF             (volatile uint32_t *)0xfe00c4b4
#define P_PWRCTRL_CPUTOP_FSM_START_ON              (volatile uint32_t *)0xfe00c4b8
#define P_PWRCTRL_CPUTOP_FSM_JUMP                  (volatile uint32_t *)0xfe00c4bc
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL0      10'h130
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL1      10'h131
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL2      10'h132
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL3      10'h133
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL4      10'h134
//`define PWRCTRL_DSPA_TIMER_TH_01         10'h138
//`define PWRCTRL_DSPA_TIMER_TH_23         10'h139
//`define PWRCTRL_DSPA_TIMER_TH_45         10'h13A
//`define PWRCTRL_DSPA_TIMER_TH_67         10'h13B
//`define PWRCTRL_DSPA_TIMER_TH_89         10'h13C
//`define PWRCTRL_DSPA_IRQ_MASK0           10'h140
//`define PWRCTRL_DSPA_IRQ_MASK1           10'h141
//`define PWRCTRL_DSPA_IRQ_MASK2           10'h142
//`define PWRCTRL_DSPA_IRQ_MASK3           10'h143
//`define PWRCTRL_DSPA_IRQ_MASK4           10'h144
//`define PWRCTRL_DSPA_IRQ_MASK5           10'h145
//`define PWRCTRL_DSPA_IRQ_MASK6           10'h146
//`define PWRCTRL_DSPA_IRQ_MASK7           10'h147
//`define PWRCTRL_DSPA_MEMPD_INIT_SET      10'h150
//`define PWRCTRL_DSPA_MEMPD_OFF_SET       10'h151
//`define PWRCTRL_DSPA_MEMPD_ON_A_SET      10'h152
//`define PWRCTRL_DSPA_MEMPD_ON_B_SET      10'h153
//`define PWRCTRL_DSPA_MEMPD_ON_C_SET      10'h154
//`define PWRCTRL_DSPA_MEMPD_ON_D_SET      10'h155
//`define PWRCTRL_DSPA_MEMPD_STS           10'h156
//`define PWRCTRL_DSPA_FSM_STS0            10'h157
//`define PWRCTRL_DSPA_FSM_STS1            10'h158
//`define PWRCTRL_DSPA_FSM_STS2            10'h159
//`define PWRCTRL_DSPA_FSM_START_OFF       10'h15D
//`define PWRCTRL_DSPA_FSM_START_ON        10'h15E
//`define PWRCTRL_DSPA_FSM_JUMP            10'h15F
//`define PWRCTRL_DSPB_AUTO_OFF_CTRL0      10'h160
//`define PWRCTRL_DSPB_AUTO_OFF_CTRL1      10'h161
//`define PWRCTRL_DSPB_AUTO_OFF_CTRL2      10'h162
//`define PWRCTRL_DSPB_AUTO_OFF_CTRL3      10'h163
//`define PWRCTRL_DSPB_AUTO_OFF_CTRL4      10'h164
//`define PWRCTRL_DSPB_TIMER_TH_01         10'h168
//`define PWRCTRL_DSPB_TIMER_TH_23         10'h169
//`define PWRCTRL_DSPB_TIMER_TH_45         10'h16A
//`define PWRCTRL_DSPB_TIMER_TH_67         10'h16B
//`define PWRCTRL_DSPB_TIMER_TH_89         10'h16C
//`define PWRCTRL_DSPB_IRQ_MASK0           10'h170
//`define PWRCTRL_DSPB_IRQ_MASK1           10'h171
//`define PWRCTRL_DSPB_IRQ_MASK2           10'h172
//`define PWRCTRL_DSPB_IRQ_MASK3           10'h173
//`define PWRCTRL_DSPB_IRQ_MASK4           10'h174
//`define PWRCTRL_DSPB_IRQ_MASK5           10'h175
//`define PWRCTRL_DSPB_IRQ_MASK6           10'h176
//`define PWRCTRL_DSPB_IRQ_MASK7           10'h177
//`define PWRCTRL_DSPB_MEMPD_INIT_SET      10'h180
//`define PWRCTRL_DSPB_MEMPD_OFF_SET       10'h181
//`define PWRCTRL_DSPB_MEMPD_ON_A_SET      10'h182
//`define PWRCTRL_DSPB_MEMPD_ON_B_SET      10'h183
//`define PWRCTRL_DSPB_MEMPD_ON_C_SET      10'h184
//`define PWRCTRL_DSPB_MEMPD_ON_D_SET      10'h185
//`define PWRCTRL_DSPB_MEMPD_STS           10'h186
//`define PWRCTRL_DSPB_FSM_STS0            10'h187
//`define PWRCTRL_DSPB_FSM_STS1            10'h188
//`define PWRCTRL_DSPB_FSM_STS2            10'h189
//`define PWRCTRL_DSPB_FSM_START_OFF       10'h18D
//`define PWRCTRL_DSPB_FSM_START_ON        10'h18E
//`define PWRCTRL_DSPB_FSM_JUMP            10'h18F
//========================================================================
// RSA
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe448000
// -----------------------------------------------
#define P_RSA_BASE                                 (volatile uint32_t *)0xfe448000
//========================================================================
//  AOCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09c000
// -----------------------------------------------
#define P_AOCPU_CPU_CTRL0                          (volatile uint32_t *)0xfe09c000
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_CTRL1                          (volatile uint32_t *)0xfe09c004
//Bit 31:11-       0   - n205 address shift, 1: 0x8000_0000~0x4000_0000
//Bit 30:11-       0   - reserved
//Bit 10   -       0   - gate by sleep, 1: gate, 0: free run
//Bit  9   -       0   - RXEV for riscv input refer riscv doc
//Bit  8   -       0   - reserved
//Bit   7:6-       0   - n205_debug_sel,aocpu_core_status0 info select
//Bit   5:2-       0   - reserved
//Bit 1    -       0   - n205_i_dbg_stop
//Bit 0    -       0   - n205_pc_enable
#define P_AOCPU_CPU_CTRL2                          (volatile uint32_t *)0xfe09c008
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_CTRL3                          (volatile uint32_t *)0xfe09c00c
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_CTRL4                          (volatile uint32_t *)0xfe09c010
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_CTRL5                          (volatile uint32_t *)0xfe09c014
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_STS0                           (volatile uint32_t *)0xfe09c028
//Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
#define P_AOCPU_CPU_STS1                           (volatile uint32_t *)0xfe09c02c
//Bit 31   -       0   - n205_core_sleep_value
//Bit 30:29-       0   - n205_trace_priv
//Bit 28:20-       0   - reserved
//Bit 19   -       0   - n205_core_wfi_mode
//Bit 18   -       0   - n205_trace_i_valid
//Bit 17   -       0   - n205_trace_i_exception
//Bit 16   -       0   - n205_trace_interrupt
//Bit 15:0 -       0   - reserved
#define P_AOCPU_CPU_STS2                           (volatile uint32_t *)0xfe09c030
//Bit 31:0-       0   - reserved
#define P_AOCPU_CPU_STS3                           (volatile uint32_t *)0xfe09c034
//Bit 31   -       0   - n205_hart_halted
//Bit 30   -       0   - n205_ndmreset
//Bit 29   -       0   - n205_dmactive
//Bit 28:0 -       0   - reserved
#define P_AOCPU_CPU_VECTOR                         (volatile uint32_t *)0xfe09c03c
//Bit 31:0-   0x1000_0000   - reserved
#define P_AOCPU_IRQ_SEL0                           (volatile uint32_t *)0xfe09c040
//Bit 31:24-       0   - INTISR03 interrupt source select in int_map
//Bit 23:16-       0   - INTISR02 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR01 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR00 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL1                           (volatile uint32_t *)0xfe09c044
//Bit 31:24-       0   - INTISR07 interrupt source select in int_map
//Bit 23:16-       0   - INTISR06 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR05 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR04 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL2                           (volatile uint32_t *)0xfe09c048
//Bit 31:24-       0   - INTISR11 interrupt source select in int_map
//Bit 23:16-       0   - INTISR10 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR09 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR08 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL3                           (volatile uint32_t *)0xfe09c04c
//Bit 31:24-       0   - INTISR15 interrupt source select in int_map
//Bit 23:16-       0   - INTISR14 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR13 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR12 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL4                           (volatile uint32_t *)0xfe09c050
//Bit 31:24-       0   - INTISR19 interrupt source select in int_map
//Bit 23:16-       0   - INTISR18 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR17 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR16 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL5                           (volatile uint32_t *)0xfe09c054
//Bit 31:24-       0   - INTISR23 interrupt source select in int_map
//Bit 23:16-       0   - INTISR22 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR21 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR20 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL6                           (volatile uint32_t *)0xfe09c058
//Bit 31:24-       0   - INTISR27 interrupt source select in int_map
//Bit 23:16-       0   - INTISR26 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR25 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR24 interrupt source select in int_map
#define P_AOCPU_IRQ_SEL7                           (volatile uint32_t *)0xfe09c05c
//Bit 31:24-       0   - INTISR31 interrupt source select in int_map
//Bit 23:16-       0   - INTISR30 interrupt source select in int_map
//Bit 15:8 -       0   - INTISR29 interrupt source select in int_map
//Bit  7:0 -       0   - INTISR28 interrupt source select in int_map
#define P_AOCPU_STS00_BYCPU                        (volatile uint32_t *)0xfe09c060
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS01_BYCPU                        (volatile uint32_t *)0xfe09c064
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS02_BYCPU                        (volatile uint32_t *)0xfe09c068
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS03_BYCPU                        (volatile uint32_t *)0xfe09c06c
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS04_BYCPU                        (volatile uint32_t *)0xfe09c070
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS05_BYCPU                        (volatile uint32_t *)0xfe09c074
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS06_BYCPU                        (volatile uint32_t *)0xfe09c078
//Bit 31:0-       0   - reserved
#define P_AOCPU_STS07_BYCPU                        (volatile uint32_t *)0xfe09c07c
//Bit 31:0-       0   - reserved
#define P_AOCPU_TIMER_DIV                          (volatile uint32_t *)0xfe09c080
//========================================================================
//  AUCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09e000
// -----------------------------------------------
#define P_AUCPU_CPU_CTRL0                          (volatile uint32_t *)0xfe09e000
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_CTRL1                          (volatile uint32_t *)0xfe09e004
//Bit 31:11-       0   - reserved
//Bit 10   -       0   - gate by sleep
//Bit 9    -       0   - RXEV
//Bit 8    -       0   - reserved
//Bit 7:6  -       0   - n205_debug_sel,aucpu_core_status0 info select
//Bit 5:2  -       0   - reserved
//Bit 1    -       0   - n205_i_dbg_stop
//Bit 0    -       0   - n205_pc_enable
#define P_AUCPU_CPU_CTRL2                          (volatile uint32_t *)0xfe09e008
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_CTRL3                          (volatile uint32_t *)0xfe09e00c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_CTRL4                          (volatile uint32_t *)0xfe09e010
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_CTRL5                          (volatile uint32_t *)0xfe09e014
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_STS0                           (volatile uint32_t *)0xfe09e028
//Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
#define P_AUCPU_CPU_STS1                           (volatile uint32_t *)0xfe09e02c
//Bit 31   -       0   - n205_core_sleep_value
//Bit 30:29-       0   - n205_trace_priv
//Bit 28:20-       0   - reserved
//Bit 19   -       0   - n205_core_wfi_mode
//Bit 18   -       0   - n205_trace_i_valid
//Bit 17   -       0   - n205_trace_i_exception
//Bit 16   -       0   - n205_trace_interrupt
//Bit 15:0 -       0   - reserved
#define P_AUCPU_CPU_STS2                           (volatile uint32_t *)0xfe09e030
//Bit 31:0 -       0   - reserved
#define P_AUCPU_CPU_STS3                           (volatile uint32_t *)0xfe09e034
//Bit 31   -       0   - n205_hart_halted
//Bit 30   -       0   - n205_ndmreset
//Bit 29   -       0   - n205_dmactive
//Bit 28:0 -       0   - reserved
#define P_AUCPU_DMA_APB_SEL                        (volatile uint32_t *)0xfe09e040
//Bit 31:30-       0   - reserved
//Bit 0    -       0   - 1: riscv control dma, 0: ap control dma
#define P_AUCPU_IRQ_AP2RISCV                       (volatile uint32_t *)0xfe09e044
//Bit 31:0 -       0   - AP cpu send irq to riscv
#define P_AUCPU_IRQ_RISCV2AP                       (volatile uint32_t *)0xfe09e048
//Bit 31:0 -       0   - riscv send irq to AP
#define P_AUCPU_STS00_BY_AP                        (volatile uint32_t *)0xfe09e080
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS01_BY_AP                        (volatile uint32_t *)0xfe09e084
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS02_BY_AP                        (volatile uint32_t *)0xfe09e088
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS03_BY_AP                        (volatile uint32_t *)0xfe09e08c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS04_BY_AP                        (volatile uint32_t *)0xfe09e090
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS05_BY_AP                        (volatile uint32_t *)0xfe09e094
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS06_BY_AP                        (volatile uint32_t *)0xfe09e098
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS07_BY_AP                        (volatile uint32_t *)0xfe09e09c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS08_BY_AP                        (volatile uint32_t *)0xfe09e0a0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS09_BY_AP                        (volatile uint32_t *)0xfe09e0a4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS10_BY_AP                        (volatile uint32_t *)0xfe09e0a8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS11_BY_AP                        (volatile uint32_t *)0xfe09e0ac
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS12_BY_AP                        (volatile uint32_t *)0xfe09e0b0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS13_BY_AP                        (volatile uint32_t *)0xfe09e0b4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS14_BY_AP                        (volatile uint32_t *)0xfe09e0b8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS15_BY_AP                        (volatile uint32_t *)0xfe09e0bc
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS16_BY_AP                        (volatile uint32_t *)0xfe09e0c0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS17_BY_AP                        (volatile uint32_t *)0xfe09e0c4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS18_BY_AP                        (volatile uint32_t *)0xfe09e0c8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS19_BY_AP                        (volatile uint32_t *)0xfe09e0cc
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS20_BY_AP                        (volatile uint32_t *)0xfe09e0d0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS21_BY_AP                        (volatile uint32_t *)0xfe09e0d4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS22_BY_AP                        (volatile uint32_t *)0xfe09e0d8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS23_BY_AP                        (volatile uint32_t *)0xfe09e0dc
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS24_BY_AP                        (volatile uint32_t *)0xfe09e0e0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS25_BY_AP                        (volatile uint32_t *)0xfe09e0e4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS26_BY_AP                        (volatile uint32_t *)0xfe09e0e8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS27_BY_AP                        (volatile uint32_t *)0xfe09e0ec
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS28_BY_AP                        (volatile uint32_t *)0xfe09e0f0
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS29_BY_AP                        (volatile uint32_t *)0xfe09e0f4
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS30_BY_AP                        (volatile uint32_t *)0xfe09e0f8
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS31_BY_AP                        (volatile uint32_t *)0xfe09e0fc
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS00_BY_RISCV                     (volatile uint32_t *)0xfe09e100
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS01_BY_RISCV                     (volatile uint32_t *)0xfe09e104
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS02_BY_RISCV                     (volatile uint32_t *)0xfe09e108
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS03_BY_RISCV                     (volatile uint32_t *)0xfe09e10c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS04_BY_RISCV                     (volatile uint32_t *)0xfe09e110
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS05_BY_RISCV                     (volatile uint32_t *)0xfe09e114
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS06_BY_RISCV                     (volatile uint32_t *)0xfe09e118
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS07_BY_RISCV                     (volatile uint32_t *)0xfe09e11c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS08_BY_RISCV                     (volatile uint32_t *)0xfe09e120
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS09_BY_RISCV                     (volatile uint32_t *)0xfe09e124
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS10_BY_RISCV                     (volatile uint32_t *)0xfe09e128
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS11_BY_RISCV                     (volatile uint32_t *)0xfe09e12c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS12_BY_RISCV                     (volatile uint32_t *)0xfe09e130
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS13_BY_RISCV                     (volatile uint32_t *)0xfe09e134
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS14_BY_RISCV                     (volatile uint32_t *)0xfe09e138
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS15_BY_RISCV                     (volatile uint32_t *)0xfe09e13c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS16_BY_RISCV                     (volatile uint32_t *)0xfe09e140
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS17_BY_RISCV                     (volatile uint32_t *)0xfe09e144
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS18_BY_RISCV                     (volatile uint32_t *)0xfe09e148
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS19_BY_RISCV                     (volatile uint32_t *)0xfe09e14c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS20_BY_RISCV                     (volatile uint32_t *)0xfe09e150
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS21_BY_RISCV                     (volatile uint32_t *)0xfe09e154
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS22_BY_RISCV                     (volatile uint32_t *)0xfe09e158
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS23_BY_RISCV                     (volatile uint32_t *)0xfe09e15c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS24_BY_RISCV                     (volatile uint32_t *)0xfe09e160
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS25_BY_RISCV                     (volatile uint32_t *)0xfe09e164
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS26_BY_RISCV                     (volatile uint32_t *)0xfe09e168
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS27_BY_RISCV                     (volatile uint32_t *)0xfe09e16c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS28_BY_RISCV                     (volatile uint32_t *)0xfe09e170
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS29_BY_RISCV                     (volatile uint32_t *)0xfe09e174
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS30_BY_RISCV                     (volatile uint32_t *)0xfe09e178
//Bit 31:0 -       0   - reserved
#define P_AUCPU_STS31_BY_RISCV                     (volatile uint32_t *)0xfe09e17c
//Bit 31:0 -       0   - reserved
#define P_AUCPU_DEMUX_STS_BY_RISCV                 (volatile uint32_t *)0xfe09e180
//Bit 31   -       0   - read only, demux status updated
//Bit 31:8 -       0   - reserved
//Bit  7:0 -       0   - read demux chn select
#define P_AUCPU_DEMUX_STS0                         (volatile uint32_t *)0xfe09e184
//Bit 31:0 -       0   - demux status 0
#define P_AUCPU_DEMUX_STS1                         (volatile uint32_t *)0xfe09e188
//Bit 31:0 -       0   - demux status 1
//========================================================================
//  AXI_SRAM
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe090000
// -----------------------------------------------
#define P_SRAM_RANGE0_STA                          (volatile uint32_t *)0xfe090000
#define P_SRAM_RANGE1_STA                          (volatile uint32_t *)0xfe090004
#define P_SRAM_RANGE2_STA                          (volatile uint32_t *)0xfe090008
#define P_SRAM_RANGE3_STA                          (volatile uint32_t *)0xfe09000c
#define P_SRAM_RANGE4_STA                          (volatile uint32_t *)0xfe090010
#define P_SRAM_RANGE5_STA                          (volatile uint32_t *)0xfe090014
#define P_SRAM_RANGE6_STA                          (volatile uint32_t *)0xfe090018
#define P_SRAM_RANGE7_STA                          (volatile uint32_t *)0xfe09001c
#define P_SRAM_RANGE8_STA                          (volatile uint32_t *)0xfe090020
#define P_SRAM_RANGE9_STA                          (volatile uint32_t *)0xfe090024
#define P_SRAM_RANGE10_STA                         (volatile uint32_t *)0xfe090028
#define P_SRAM_RANGE11_STA                         (volatile uint32_t *)0xfe09002c
#define P_SRAM_RANGE12_STA                         (volatile uint32_t *)0xfe090030
#define P_SRAM_RANGE13_STA                         (volatile uint32_t *)0xfe090034
#define P_SRAM_RANGE14_STA                         (volatile uint32_t *)0xfe090038
#define P_SRAM_RANGE0_EDA                          (volatile uint32_t *)0xfe09003c
#define P_SRAM_RANGE1_EDA                          (volatile uint32_t *)0xfe090040
#define P_SRAM_RANGE2_EDA                          (volatile uint32_t *)0xfe090044
#define P_SRAM_RANGE3_EDA                          (volatile uint32_t *)0xfe090048
#define P_SRAM_RANGE4_EDA                          (volatile uint32_t *)0xfe09004c
#define P_SRAM_RANGE5_EDA                          (volatile uint32_t *)0xfe090050
#define P_SRAM_RANGE6_EDA                          (volatile uint32_t *)0xfe090054
#define P_SRAM_RANGE7_EDA                          (volatile uint32_t *)0xfe090058
#define P_SRAM_RANGE8_EDA                          (volatile uint32_t *)0xfe09005c
#define P_SRAM_RANGE9_EDA                          (volatile uint32_t *)0xfe090060
#define P_SRAM_RANGE10_EDA                         (volatile uint32_t *)0xfe090064
#define P_SRAM_RANGE11_EDA                         (volatile uint32_t *)0xfe090068
#define P_SRAM_RANGE12_EDA                         (volatile uint32_t *)0xfe09006c
#define P_SRAM_RANGE13_EDA                         (volatile uint32_t *)0xfe090070
#define P_SRAM_RANGE14_EDA                         (volatile uint32_t *)0xfe090074
#define P_SRAM_RANGE0_READ_CTRL0                   (volatile uint32_t *)0xfe090078
#define P_SRAM_RANGE1_READ_CTRL0                   (volatile uint32_t *)0xfe09007c
#define P_SRAM_RANGE2_READ_CTRL0                   (volatile uint32_t *)0xfe090080
#define P_SRAM_RANGE3_READ_CTRL0                   (volatile uint32_t *)0xfe090084
#define P_SRAM_RANGE4_READ_CTRL0                   (volatile uint32_t *)0xfe090088
#define P_SRAM_RANGE5_READ_CTRL0                   (volatile uint32_t *)0xfe09008c
#define P_SRAM_RANGE6_READ_CTRL0                   (volatile uint32_t *)0xfe090090
#define P_SRAM_RANGE7_READ_CTRL0                   (volatile uint32_t *)0xfe090094
#define P_SRAM_RANGE8_READ_CTRL0                   (volatile uint32_t *)0xfe090098
#define P_SRAM_RANGE9_READ_CTRL0                   (volatile uint32_t *)0xfe09009c
#define P_SRAM_RANGE10_READ_CTRL0                  (volatile uint32_t *)0xfe0900a0
#define P_SRAM_RANGE11_READ_CTRL0                  (volatile uint32_t *)0xfe0900a4
#define P_SRAM_RANGE12_READ_CTRL0                  (volatile uint32_t *)0xfe0900a8
#define P_SRAM_RANGE13_READ_CTRL0                  (volatile uint32_t *)0xfe0900ac
#define P_SRAM_RANGE14_READ_CTRL0                  (volatile uint32_t *)0xfe0900b0
#define P_SRAM_RANGE15_READ_CTRL0                  (volatile uint32_t *)0xfe0900b4
#define P_SRAM_RANGE0_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900b8
#define P_SRAM_RANGE1_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900bc
#define P_SRAM_RANGE2_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900c0
#define P_SRAM_RANGE3_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900c4
#define P_SRAM_RANGE4_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900c8
#define P_SRAM_RANGE5_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900cc
#define P_SRAM_RANGE6_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900d0
#define P_SRAM_RANGE7_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900d4
#define P_SRAM_RANGE8_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900d8
#define P_SRAM_RANGE9_WRITE_CTRL0                  (volatile uint32_t *)0xfe0900dc
#define P_SRAM_RANGE10_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900e0
#define P_SRAM_RANGE11_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900e4
#define P_SRAM_RANGE12_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900e8
#define P_SRAM_RANGE13_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900ec
#define P_SRAM_RANGE14_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900f0
#define P_SRAM_RANGE15_WRITE_CTRL0                 (volatile uint32_t *)0xfe0900f4
#define P_SRAM_RANGE0_READ_CTRL1                   (volatile uint32_t *)0xfe0900f8
#define P_SRAM_RANGE1_READ_CTRL1                   (volatile uint32_t *)0xfe0900fc
#define P_SRAM_RANGE2_READ_CTRL1                   (volatile uint32_t *)0xfe090100
#define P_SRAM_RANGE3_READ_CTRL1                   (volatile uint32_t *)0xfe090104
#define P_SRAM_RANGE4_READ_CTRL1                   (volatile uint32_t *)0xfe090108
#define P_SRAM_RANGE5_READ_CTRL1                   (volatile uint32_t *)0xfe09010c
#define P_SRAM_RANGE6_READ_CTRL1                   (volatile uint32_t *)0xfe090110
#define P_SRAM_RANGE7_READ_CTRL1                   (volatile uint32_t *)0xfe090114
#define P_SRAM_RANGE8_READ_CTRL1                   (volatile uint32_t *)0xfe090118
#define P_SRAM_RANGE9_READ_CTRL1                   (volatile uint32_t *)0xfe09011c
#define P_SRAM_RANGE10_READ_CTRL1                  (volatile uint32_t *)0xfe090120
#define P_SRAM_RANGE11_READ_CTRL1                  (volatile uint32_t *)0xfe090124
#define P_SRAM_RANGE12_READ_CTRL1                  (volatile uint32_t *)0xfe090128
#define P_SRAM_RANGE13_READ_CTRL1                  (volatile uint32_t *)0xfe09012c
#define P_SRAM_RANGE14_READ_CTRL1                  (volatile uint32_t *)0xfe090130
#define P_SRAM_RANGE15_READ_CTRL1                  (volatile uint32_t *)0xfe090134
#define P_SRAM_RANGE0_WRITE_CTRL1                  (volatile uint32_t *)0xfe090138
#define P_SRAM_RANGE1_WRITE_CTRL1                  (volatile uint32_t *)0xfe09013c
#define P_SRAM_RANGE2_WRITE_CTRL1                  (volatile uint32_t *)0xfe090140
#define P_SRAM_RANGE3_WRITE_CTRL1                  (volatile uint32_t *)0xfe090144
#define P_SRAM_RANGE4_WRITE_CTRL1                  (volatile uint32_t *)0xfe090148
#define P_SRAM_RANGE5_WRITE_CTRL1                  (volatile uint32_t *)0xfe09014c
#define P_SRAM_RANGE6_WRITE_CTRL1                  (volatile uint32_t *)0xfe090150
#define P_SRAM_RANGE7_WRITE_CTRL1                  (volatile uint32_t *)0xfe090154
#define P_SRAM_RANGE8_WRITE_CTRL1                  (volatile uint32_t *)0xfe090158
#define P_SRAM_RANGE9_WRITE_CTRL1                  (volatile uint32_t *)0xfe09015c
#define P_SRAM_RANGE10_WRITE_CTRL1                 (volatile uint32_t *)0xfe090160
#define P_SRAM_RANGE11_WRITE_CTRL1                 (volatile uint32_t *)0xfe090164
#define P_SRAM_RANGE12_WRITE_CTRL1                 (volatile uint32_t *)0xfe090168
#define P_SRAM_RANGE13_WRITE_CTRL1                 (volatile uint32_t *)0xfe09016c
#define P_SRAM_RANGE14_WRITE_CTRL1                 (volatile uint32_t *)0xfe090170
#define P_SRAM_RANGE15_WRITE_CTRL1                 (volatile uint32_t *)0xfe090174
#define P_SRAM_GLOBAL_READ_CTRL0                   (volatile uint32_t *)0xfe090178
#define P_SRAM_GLOBAL_READ_CTRL1                   (volatile uint32_t *)0xfe09017c
#define P_SRAM_GLOBAL_WRITE_CTRL0                  (volatile uint32_t *)0xfe090180
#define P_SRAM_GLOBAL_WRITE_CTRL1                  (volatile uint32_t *)0xfe090184
#define P_SRAM_SEC_CTRL0                           (volatile uint32_t *)0xfe090188
#define P_SRAM_REG_LOCK0                           (volatile uint32_t *)0xfe09018c
#define P_SRAM_REG_LOCK1                           (volatile uint32_t *)0xfe090190
#define P_SRAM_REG_LOCK2                           (volatile uint32_t *)0xfe090194
#define P_SRAM_GLOBAL_READ_CTRL0_LOCK              (volatile uint32_t *)0xfe090198
#define P_SRAM_GLOBAL_READ_CTRL1_LOCK              (volatile uint32_t *)0xfe09019c
#define P_SRAM_GLOBAL_WRITE_CTRL0_LOCK             (volatile uint32_t *)0xfe0901a0
#define P_SRAM_GLOBAL_WRITE_CTRL1_LOCK             (volatile uint32_t *)0xfe0901a4
#define P_SRAM_SEC_CTRL0_LOCK                      (volatile uint32_t *)0xfe0901a8
#define P_SRAM_STATUS_REG                          (volatile uint32_t *)0xfe0901ac
#define P_SRAM_INIT_DLY_TCNT                       (volatile uint32_t *)0xfe0901b0
//========================================================================
//  MAILBOX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe006000
// -----------------------------------------------
#define P_MAILBOX_WR_MBOX00                        (volatile uint32_t *)0xfe006000
#define P_MAILBOX_WR_MBOX01                        (volatile uint32_t *)0xfe006080
#define P_MAILBOX_WR_MBOX02                        (volatile uint32_t *)0xfe006100
#define P_MAILBOX_WR_MBOX03                        (volatile uint32_t *)0xfe006180
#define P_MAILBOX_WR_MBOX04                        (volatile uint32_t *)0xfe006200
#define P_MAILBOX_WR_MBOX05                        (volatile uint32_t *)0xfe006280
#define P_MAILBOX_WR_MBOX06                        (volatile uint32_t *)0xfe006300
#define P_MAILBOX_WR_MBOX07                        (volatile uint32_t *)0xfe006380
#define P_MAILBOX_WR_MBOX08                        (volatile uint32_t *)0xfe006400
#define P_MAILBOX_WR_MBOX09                        (volatile uint32_t *)0xfe006480
#define P_MAILBOX_WR_MBOX10                        (volatile uint32_t *)0xfe006500
#define P_MAILBOX_WR_MBOX11                        (volatile uint32_t *)0xfe006580
#define P_MAILBOX_WR_MBOX12                        (volatile uint32_t *)0xfe006600
#define P_MAILBOX_WR_MBOX13                        (volatile uint32_t *)0xfe006680
#define P_MAILBOX_WR_MBOX14                        (volatile uint32_t *)0xfe006700
#define P_MAILBOX_WR_MBOX15                        (volatile uint32_t *)0xfe006780
#define P_MAILBOX_RD_MBOX00                        (volatile uint32_t *)0xfe006800
#define P_MAILBOX_RD_MBOX01                        (volatile uint32_t *)0xfe006880
#define P_MAILBOX_RD_MBOX02                        (volatile uint32_t *)0xfe006900
#define P_MAILBOX_RD_MBOX03                        (volatile uint32_t *)0xfe006980
#define P_MAILBOX_RD_MBOX04                        (volatile uint32_t *)0xfe006a00
#define P_MAILBOX_RD_MBOX05                        (volatile uint32_t *)0xfe006a80
#define P_MAILBOX_RD_MBOX06                        (volatile uint32_t *)0xfe006b00
#define P_MAILBOX_RD_MBOX07                        (volatile uint32_t *)0xfe006b80
#define P_MAILBOX_RD_MBOX08                        (volatile uint32_t *)0xfe006c00
#define P_MAILBOX_RD_MBOX09                        (volatile uint32_t *)0xfe006c80
#define P_MAILBOX_RD_MBOX10                        (volatile uint32_t *)0xfe006d00
#define P_MAILBOX_RD_MBOX11                        (volatile uint32_t *)0xfe006d80
#define P_MAILBOX_RD_MBOX12                        (volatile uint32_t *)0xfe006e00
#define P_MAILBOX_RD_MBOX13                        (volatile uint32_t *)0xfe006e80
#define P_MAILBOX_RD_MBOX14                        (volatile uint32_t *)0xfe006f00
#define P_MAILBOX_RD_MBOX15                        (volatile uint32_t *)0xfe006f80
#define P_MAILBOX_LOCK_BIT0                        (volatile uint32_t *)0xfe007000
#define P_MAILBOX_LOCK_BIT1                        (volatile uint32_t *)0xfe007004
#define P_MAILBOX_PROT_BIT0                        (volatile uint32_t *)0xfe007008
#define P_MAILBOX_PROT_BIT1                        (volatile uint32_t *)0xfe00700c
#define P_MAILBOX_ACCESS_EN_IRQA_CLR               (volatile uint32_t *)0xfe007010
#define P_MAILBOX_ACCESS_EN_IRQB_CLR               (volatile uint32_t *)0xfe007014
#define P_MAILBOX_ACCESS_EN_IRQC_CLR               (volatile uint32_t *)0xfe007018
#define P_MAILBOX_ACCESS_EN_IRQD_CLR               (volatile uint32_t *)0xfe00701c
#define P_MAILBOX_IRQA_MASK                        (volatile uint32_t *)0xfe007020
#define P_MAILBOX_IRQB_MASK                        (volatile uint32_t *)0xfe007024
#define P_MAILBOX_IRQC_MASK                        (volatile uint32_t *)0xfe007028
#define P_MAILBOX_IRQD_MASK                        (volatile uint32_t *)0xfe00702c
#define P_MAILBOX_IRQ_TYPE                         (volatile uint32_t *)0xfe007030
#define P_MAILBOX_IRQA_CLR                         (volatile uint32_t *)0xfe007040
#define P_MAILBOX_IRQB_CLR                         (volatile uint32_t *)0xfe007044
#define P_MAILBOX_IRQC_CLR                         (volatile uint32_t *)0xfe007048
#define P_MAILBOX_IRQD_CLR                         (volatile uint32_t *)0xfe00704c
#define P_MAILBOX_IRQA_STS                         (volatile uint32_t *)0xfe007050
#define P_MAILBOX_IRQB_STS                         (volatile uint32_t *)0xfe007054
#define P_MAILBOX_IRQC_STS                         (volatile uint32_t *)0xfe007058
#define P_MAILBOX_IRQD_STS                         (volatile uint32_t *)0xfe00705c
#define P_MAILBOX_ACCESS_EN_MBOX00                 (volatile uint32_t *)0xfe007080
#define P_MAILBOX_ACCESS_EN_MBOX01                 (volatile uint32_t *)0xfe007084
#define P_MAILBOX_ACCESS_EN_MBOX02                 (volatile uint32_t *)0xfe007088
#define P_MAILBOX_ACCESS_EN_MBOX03                 (volatile uint32_t *)0xfe00708c
#define P_MAILBOX_ACCESS_EN_MBOX04                 (volatile uint32_t *)0xfe007090
#define P_MAILBOX_ACCESS_EN_MBOX05                 (volatile uint32_t *)0xfe007094
#define P_MAILBOX_ACCESS_EN_MBOX06                 (volatile uint32_t *)0xfe007098
#define P_MAILBOX_ACCESS_EN_MBOX07                 (volatile uint32_t *)0xfe00709c
#define P_MAILBOX_ACCESS_EN_MBOX08                 (volatile uint32_t *)0xfe0070a0
#define P_MAILBOX_ACCESS_EN_MBOX09                 (volatile uint32_t *)0xfe0070a4
#define P_MAILBOX_ACCESS_EN_MBOX10                 (volatile uint32_t *)0xfe0070a8
#define P_MAILBOX_ACCESS_EN_MBOX11                 (volatile uint32_t *)0xfe0070ac
#define P_MAILBOX_ACCESS_EN_MBOX12                 (volatile uint32_t *)0xfe0070b0
#define P_MAILBOX_ACCESS_EN_MBOX13                 (volatile uint32_t *)0xfe0070b4
#define P_MAILBOX_ACCESS_EN_MBOX14                 (volatile uint32_t *)0xfe0070b8
#define P_MAILBOX_ACCESS_EN_MBOX15                 (volatile uint32_t *)0xfe0070bc
#define P_MAILBOX_SET_MBOX00                       (volatile uint32_t *)0xfe0070c0
#define P_MAILBOX_SET_MBOX01                       (volatile uint32_t *)0xfe0070c4
#define P_MAILBOX_SET_MBOX02                       (volatile uint32_t *)0xfe0070c8
#define P_MAILBOX_SET_MBOX03                       (volatile uint32_t *)0xfe0070cc
#define P_MAILBOX_SET_MBOX04                       (volatile uint32_t *)0xfe0070d0
#define P_MAILBOX_SET_MBOX05                       (volatile uint32_t *)0xfe0070d4
#define P_MAILBOX_SET_MBOX06                       (volatile uint32_t *)0xfe0070d8
#define P_MAILBOX_SET_MBOX07                       (volatile uint32_t *)0xfe0070dc
#define P_MAILBOX_SET_MBOX08                       (volatile uint32_t *)0xfe0070e0
#define P_MAILBOX_SET_MBOX09                       (volatile uint32_t *)0xfe0070e4
#define P_MAILBOX_SET_MBOX10                       (volatile uint32_t *)0xfe0070e8
#define P_MAILBOX_SET_MBOX11                       (volatile uint32_t *)0xfe0070ec
#define P_MAILBOX_SET_MBOX12                       (volatile uint32_t *)0xfe0070f0
#define P_MAILBOX_SET_MBOX13                       (volatile uint32_t *)0xfe0070f4
#define P_MAILBOX_SET_MBOX14                       (volatile uint32_t *)0xfe0070f8
#define P_MAILBOX_SET_MBOX15                       (volatile uint32_t *)0xfe0070fc
#define P_MAILBOX_CLR_MBOX00                       (volatile uint32_t *)0xfe007100
#define P_MAILBOX_CLR_MBOX01                       (volatile uint32_t *)0xfe007104
#define P_MAILBOX_CLR_MBOX02                       (volatile uint32_t *)0xfe007108
#define P_MAILBOX_CLR_MBOX03                       (volatile uint32_t *)0xfe00710c
#define P_MAILBOX_CLR_MBOX04                       (volatile uint32_t *)0xfe007110
#define P_MAILBOX_CLR_MBOX05                       (volatile uint32_t *)0xfe007114
#define P_MAILBOX_CLR_MBOX06                       (volatile uint32_t *)0xfe007118
#define P_MAILBOX_CLR_MBOX07                       (volatile uint32_t *)0xfe00711c
#define P_MAILBOX_CLR_MBOX08                       (volatile uint32_t *)0xfe007120
#define P_MAILBOX_CLR_MBOX09                       (volatile uint32_t *)0xfe007124
#define P_MAILBOX_CLR_MBOX10                       (volatile uint32_t *)0xfe007128
#define P_MAILBOX_CLR_MBOX11                       (volatile uint32_t *)0xfe00712c
#define P_MAILBOX_CLR_MBOX12                       (volatile uint32_t *)0xfe007130
#define P_MAILBOX_CLR_MBOX13                       (volatile uint32_t *)0xfe007134
#define P_MAILBOX_CLR_MBOX14                       (volatile uint32_t *)0xfe007138
#define P_MAILBOX_CLR_MBOX15                       (volatile uint32_t *)0xfe00713c
#define P_MAILBOX_STS_MBOX00                       (volatile uint32_t *)0xfe007140
#define P_MAILBOX_STS_MBOX01                       (volatile uint32_t *)0xfe007144
#define P_MAILBOX_STS_MBOX02                       (volatile uint32_t *)0xfe007148
#define P_MAILBOX_STS_MBOX03                       (volatile uint32_t *)0xfe00714c
#define P_MAILBOX_STS_MBOX04                       (volatile uint32_t *)0xfe007150
#define P_MAILBOX_STS_MBOX05                       (volatile uint32_t *)0xfe007154
#define P_MAILBOX_STS_MBOX06                       (volatile uint32_t *)0xfe007158
#define P_MAILBOX_STS_MBOX07                       (volatile uint32_t *)0xfe00715c
#define P_MAILBOX_STS_MBOX08                       (volatile uint32_t *)0xfe007160
#define P_MAILBOX_STS_MBOX09                       (volatile uint32_t *)0xfe007164
#define P_MAILBOX_STS_MBOX10                       (volatile uint32_t *)0xfe007168
#define P_MAILBOX_STS_MBOX11                       (volatile uint32_t *)0xfe00716c
#define P_MAILBOX_STS_MBOX12                       (volatile uint32_t *)0xfe007170
#define P_MAILBOX_STS_MBOX13                       (volatile uint32_t *)0xfe007174
#define P_MAILBOX_STS_MBOX14                       (volatile uint32_t *)0xfe007178
#define P_MAILBOX_STS_MBOX15                       (volatile uint32_t *)0xfe00717c
//========================================================================
//  IRQ_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00a000
// -----------------------------------------------
#define P_IRQCTRL_IRQ_INV0                         (volatile uint32_t *)0xfe00a000
#define P_IRQCTRL_IRQ_INV1                         (volatile uint32_t *)0xfe00a004
#define P_IRQCTRL_IRQ_INV2                         (volatile uint32_t *)0xfe00a008
#define P_IRQCTRL_IRQ_INV3                         (volatile uint32_t *)0xfe00a00c
#define P_IRQCTRL_IRQ_INV4                         (volatile uint32_t *)0xfe00a010
#define P_IRQCTRL_IRQ_INV5                         (volatile uint32_t *)0xfe00a014
#define P_IRQCTRL_IRQ_INV6                         (volatile uint32_t *)0xfe00a018
#define P_IRQCTRL_IRQ_INV7                         (volatile uint32_t *)0xfe00a01c
#define P_IRQCTRL_MASK0_GIC                        (volatile uint32_t *)0xfe00a040
#define P_IRQCTRL_MASK1_GIC                        (volatile uint32_t *)0xfe00a044
#define P_IRQCTRL_MASK2_GIC                        (volatile uint32_t *)0xfe00a048
#define P_IRQCTRL_MASK3_GIC                        (volatile uint32_t *)0xfe00a04c
#define P_IRQCTRL_MASK4_GIC                        (volatile uint32_t *)0xfe00a050
#define P_IRQCTRL_MASK5_GIC                        (volatile uint32_t *)0xfe00a054
#define P_IRQCTRL_MASK6_GIC                        (volatile uint32_t *)0xfe00a058
#define P_IRQCTRL_MASK7_GIC                        (volatile uint32_t *)0xfe00a05c
//`define IRQCTRL_MASK0_DSP       8'h20
//`define IRQCTRL_MASK1_DSP       8'h21
//`define IRQCTRL_MASK2_DSP       8'h22
//`define IRQCTRL_MASK3_DSP       8'h23
//`define IRQCTRL_MASK4_DSP       8'h24
//`define IRQCTRL_MASK5_DSP       8'h25
//`define IRQCTRL_MASK6_DSP       8'h26
//`define IRQCTRL_MASK7_DSP       8'h27
#define P_IRQCTRL_MASK0_PWRCTRL                    (volatile uint32_t *)0xfe00a0c0
#define P_IRQCTRL_MASK1_PWRCTRL                    (volatile uint32_t *)0xfe00a0c4
#define P_IRQCTRL_MASK2_PWRCTRL                    (volatile uint32_t *)0xfe00a0c8
#define P_IRQCTRL_MASK3_PWRCTRL                    (volatile uint32_t *)0xfe00a0cc
#define P_IRQCTRL_MASK4_PWRCTRL                    (volatile uint32_t *)0xfe00a0d0
#define P_IRQCTRL_MASK5_PWRCTRL                    (volatile uint32_t *)0xfe00a0d4
#define P_IRQCTRL_MASK6_PWRCTRL                    (volatile uint32_t *)0xfe00a0d8
#define P_IRQCTRL_MASK7_PWRCTRL                    (volatile uint32_t *)0xfe00a0dc
#define P_IRQCTRL_MASK0_AOCPU                      (volatile uint32_t *)0xfe00a100
#define P_IRQCTRL_MASK1_AOCPU                      (volatile uint32_t *)0xfe00a104
#define P_IRQCTRL_MASK2_AOCPU                      (volatile uint32_t *)0xfe00a108
#define P_IRQCTRL_MASK3_AOCPU                      (volatile uint32_t *)0xfe00a10c
#define P_IRQCTRL_MASK4_AOCPU                      (volatile uint32_t *)0xfe00a110
#define P_IRQCTRL_MASK5_AOCPU                      (volatile uint32_t *)0xfe00a114
#define P_IRQCTRL_MASK6_AOCPU                      (volatile uint32_t *)0xfe00a118
#define P_IRQCTRL_MASK7_AOCPU                      (volatile uint32_t *)0xfe00a11c
#define P_IRQCTRL_IRQ_MODE0                        (volatile uint32_t *)0xfe00a140
#define P_IRQCTRL_IRQ_MODE1                        (volatile uint32_t *)0xfe00a144
#define P_IRQCTRL_IRQ_MODE2                        (volatile uint32_t *)0xfe00a148
#define P_IRQCTRL_IRQ_MODE3                        (volatile uint32_t *)0xfe00a14c
#define P_IRQCTRL_IRQ_MODE4                        (volatile uint32_t *)0xfe00a150
#define P_IRQCTRL_IRQ_MODE5                        (volatile uint32_t *)0xfe00a154
#define P_IRQCTRL_IRQ_MODE6                        (volatile uint32_t *)0xfe00a158
#define P_IRQCTRL_IRQ_MODE7                        (volatile uint32_t *)0xfe00a15c
#define P_IRQCTRL_IRQ_LATCH0                       (volatile uint32_t *)0xfe00a180
#define P_IRQCTRL_IRQ_LATCH1                       (volatile uint32_t *)0xfe00a184
#define P_IRQCTRL_IRQ_LATCH2                       (volatile uint32_t *)0xfe00a188
#define P_IRQCTRL_IRQ_LATCH3                       (volatile uint32_t *)0xfe00a18c
#define P_IRQCTRL_IRQ_LATCH4                       (volatile uint32_t *)0xfe00a190
#define P_IRQCTRL_IRQ_LATCH5                       (volatile uint32_t *)0xfe00a194
#define P_IRQCTRL_IRQ_LATCH6                       (volatile uint32_t *)0xfe00a198
#define P_IRQCTRL_IRQ_LATCH7                       (volatile uint32_t *)0xfe00a19c
#define P_IRQCTRL_IRQ_LATCH_CLR0                   (volatile uint32_t *)0xfe00a1c0
#define P_IRQCTRL_IRQ_LATCH_CLR1                   (volatile uint32_t *)0xfe00a1c4
#define P_IRQCTRL_IRQ_LATCH_CLR2                   (volatile uint32_t *)0xfe00a1c8
#define P_IRQCTRL_IRQ_LATCH_CLR3                   (volatile uint32_t *)0xfe00a1cc
#define P_IRQCTRL_IRQ_LATCH_CLR4                   (volatile uint32_t *)0xfe00a1d0
#define P_IRQCTRL_IRQ_LATCH_CLR5                   (volatile uint32_t *)0xfe00a1d4
#define P_IRQCTRL_IRQ_LATCH_CLR6                   (volatile uint32_t *)0xfe00a1d8
#define P_IRQCTRL_IRQ_LATCH_CLR7                   (volatile uint32_t *)0xfe00a1dc
#define P_IRQCTRL_LOCK_BIT                         (volatile uint32_t *)0xfe00a200
#define P_IRQCTRL_PROT_BIT                         (volatile uint32_t *)0xfe00a204
//========================================================================
//  RESET_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe002000
// -----------------------------------------------
#define P_RESETCTRL_RESET0                         (volatile uint32_t *)0xfe002000
#define P_RESETCTRL_RESET1                         (volatile uint32_t *)0xfe002004
#define P_RESETCTRL_RESET2                         (volatile uint32_t *)0xfe002008
#define P_RESETCTRL_RESET3                         (volatile uint32_t *)0xfe00200c
#define P_RESETCTRL_RESET4                         (volatile uint32_t *)0xfe002010
#define P_RESETCTRL_RESET5                         (volatile uint32_t *)0xfe002014
#define P_RESETCTRL_RESET0_LEVEL                   (volatile uint32_t *)0xfe002040
#define P_RESETCTRL_RESET1_LEVEL                   (volatile uint32_t *)0xfe002044
#define P_RESETCTRL_RESET2_LEVEL                   (volatile uint32_t *)0xfe002048
#define P_RESETCTRL_RESET3_LEVEL                   (volatile uint32_t *)0xfe00204c
#define P_RESETCTRL_RESET4_LEVEL                   (volatile uint32_t *)0xfe002050
#define P_RESETCTRL_RESET5_LEVEL                   (volatile uint32_t *)0xfe002054
#define P_RESETCTRL_RESET0_MASK                    (volatile uint32_t *)0xfe002080
#define P_RESETCTRL_RESET1_MASK                    (volatile uint32_t *)0xfe002084
#define P_RESETCTRL_RESET2_MASK                    (volatile uint32_t *)0xfe002088
#define P_RESETCTRL_RESET3_MASK                    (volatile uint32_t *)0xfe00208c
#define P_RESETCTRL_RESET4_MASK                    (volatile uint32_t *)0xfe002090
#define P_RESETCTRL_RESET5_MASK                    (volatile uint32_t *)0xfe002094
#define P_RESETCTRL_RESET_HOLD_CYC                 (volatile uint32_t *)0xfe0020c0
#define P_RESETCTRL_WATCHDOG_CTRL0                 (volatile uint32_t *)0xfe002100
#define P_RESETCTRL_WATCHDOG_CTRL1                 (volatile uint32_t *)0xfe002104
#define P_RESETCTRL_WATCHDOG_CNT                   (volatile uint32_t *)0xfe002108
#define P_RESETCTRL_WATCHDOG_CLR                   (volatile uint32_t *)0xfe00210c
#define P_RESETCTRL_SEC_WATCHDOG_CTRL0             (volatile uint32_t *)0xfe002110
#define P_RESETCTRL_SEC_WATCHDOG_CTRL1             (volatile uint32_t *)0xfe002114
#define P_RESETCTRL_SEC_WATCHDOG_CNT               (volatile uint32_t *)0xfe002118
#define P_RESETCTRL_SEC_WATCHDOG_CLR               (volatile uint32_t *)0xfe00211c
#define P_RESETCTRL_SEC_WATCHDOG_IRQ_OFFSET        (volatile uint32_t *)0xfe002120
#define P_RESETCTRL_WATCHDOG_IRQ_OFFSET            (volatile uint32_t *)0xfe002124
#define P_RESETCTRL_WATCHDOG_DLY_CNT               (volatile uint32_t *)0xfe002128
#define P_RESETCTRL_SEC_RESET0                     (volatile uint32_t *)0xfe002140
#define P_RESETCTRL_SEC_RESET1                     (volatile uint32_t *)0xfe002144
#define P_RESETCTRL_SEC_RESET0_LEVEL               (volatile uint32_t *)0xfe002180
#define P_RESETCTRL_SEC_RESET1_LEVEL               (volatile uint32_t *)0xfe002184
#define P_RESETCTRL_SEC_RESET0_MASK                (volatile uint32_t *)0xfe0021c0
#define P_RESETCTRL_SEC_RESET1_MASK                (volatile uint32_t *)0xfe0021c4
#define P_RESETCTRL_RESET0_LOCK                    (volatile uint32_t *)0xfe002200
#define P_RESETCTRL_RESET1_LOCK                    (volatile uint32_t *)0xfe002204
#define P_RESETCTRL_RESET2_LOCK                    (volatile uint32_t *)0xfe002208
#define P_RESETCTRL_RESET3_LOCK                    (volatile uint32_t *)0xfe00220c
#define P_RESETCTRL_RESET4_LOCK                    (volatile uint32_t *)0xfe002210
#define P_RESETCTRL_RESET5_LOCK                    (volatile uint32_t *)0xfe002214
#define P_RESETCTRL_SEC_RESET0_LOCK                (volatile uint32_t *)0xfe002220
#define P_RESETCTRL_SEC_RESET1_LOCK                (volatile uint32_t *)0xfe002224
#define P_RESETCTRL_RESET0_PROT                    (volatile uint32_t *)0xfe002240
#define P_RESETCTRL_RESET1_PROT                    (volatile uint32_t *)0xfe002244
#define P_RESETCTRL_RESET2_PROT                    (volatile uint32_t *)0xfe002248
#define P_RESETCTRL_RESET3_PROT                    (volatile uint32_t *)0xfe00224c
#define P_RESETCTRL_RESET4_PROT                    (volatile uint32_t *)0xfe002250
#define P_RESETCTRL_RESET5_PROT                    (volatile uint32_t *)0xfe002254
#define P_RESETCTRL_SEC_RESET0_PROT                (volatile uint32_t *)0xfe002260
#define P_RESETCTRL_SEC_RESET1_PROT                (volatile uint32_t *)0xfe002264
//========================================================================
//  CPU_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00e000
// -----------------------------------------------
#define P_CPUCTRL_SYS_CPU_RESET_CNTL               (volatile uint32_t *)0xfe00e140
#define P_CPUCTRL_SYS_CPU_CLK_CTRL                 (volatile uint32_t *)0xfe00e144
#define P_CPUCTRL_SYS_CPU_CLK_CTRL1                (volatile uint32_t *)0xfe00e148
#define P_CPUCTRL_SYS_CPU_CLK_CTRL2                (volatile uint32_t *)0xfe00e14c
#define P_CPUCTRL_SYS_CPU_CLK_CTRL3                (volatile uint32_t *)0xfe00e150
#define P_CPUCTRL_SYS_CPU_CLK_CTRL4                (volatile uint32_t *)0xfe00e154
#define P_CPUCTRL_SYS_CPU_CLK_CTRL5                (volatile uint32_t *)0xfe00e158
#define P_CPUCTRL_SYS_CPU_CLK_CTRL6                (volatile uint32_t *)0xfe00e15c
#define P_CPUCTRL_SYS_CPU_CLK_RESULT               (volatile uint32_t *)0xfe00e160
#define P_CPUCTRL_ROM_DISABLE                      (volatile uint32_t *)0xfe00e180
#define P_CPUCTRL_SYS_CPU_POR_CFG0                 (volatile uint32_t *)0xfe00e240
#define P_CPUCTRL_SYS_CPU_POR_CFG1                 (volatile uint32_t *)0xfe00e244
#define P_CPUCTRL_SYS_CPU_CFG0                     (volatile uint32_t *)0xfe00e248
#define P_CPUCTRL_SYS_CPU_CFG1                     (volatile uint32_t *)0xfe00e24c
#define P_CPUCTRL_SYS_CPU_CFG2                     (volatile uint32_t *)0xfe00e250
#define P_CPUCTRL_SYS_CPU_CFG3                     (volatile uint32_t *)0xfe00e254
#define P_CPUCTRL_SYS_CPU_CFG4                     (volatile uint32_t *)0xfe00e258
#define P_CPUCTRL_SYS_CPU_CFG5                     (volatile uint32_t *)0xfe00e25c
#define P_CPUCTRL_SYS_CPU_CFG6                     (volatile uint32_t *)0xfe00e260
#define P_CPUCTRL_SYS_CPU_CFG7                     (volatile uint32_t *)0xfe00e264
#define P_CPUCTRL_SYS_CPU_CFG8                     (volatile uint32_t *)0xfe00e268
#define P_CPUCTRL_SYS_CPU_CFG9                     (volatile uint32_t *)0xfe00e26c
#define P_CPUCTRL_SYS_CPU_CFG10                    (volatile uint32_t *)0xfe00e270
#define P_CPUCTRL_SYS_CPU_CFG11                    (volatile uint32_t *)0xfe00e274
#define P_CPUCTRL_SYS_CPU_CFG12                    (volatile uint32_t *)0xfe00e278
#define P_CPUCTRL_SYS_CPU_CFG13                    (volatile uint32_t *)0xfe00e27c
#define P_CPUCTRL_SYS_CPU_STATUS0                  (volatile uint32_t *)0xfe00e280
#define P_CPUCTRL_SYS_CPU_STATUS1                  (volatile uint32_t *)0xfe00e284
#define P_CPUCTRL_SYS_CPU_STATUS2                  (volatile uint32_t *)0xfe00e288
#define P_CPUCTRL_SYS_CPU_STATUS3                  (volatile uint32_t *)0xfe00e28c
#define P_CPUCTRL_SYS_CPU_STATUS4                  (volatile uint32_t *)0xfe00e290
#define P_CPUCTRL_SYS_CPU_STATUS5                  (volatile uint32_t *)0xfe00e294
#define P_CPUCTRL_SYS_CPU_STATUS6                  (volatile uint32_t *)0xfe00e298
#define P_CPUCTRL_SYS_CPU_STATUS7                  (volatile uint32_t *)0xfe00e29c
//`define SYS_CPU_MISC                        8'ha8
//========================================================================
//  SAR_ADC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe026000
// -----------------------------------------------
#define P_SAR_ADC_REG0                             (volatile uint32_t *)0xfe026000
#define P_SAR_ADC_CHAN_LIST                        (volatile uint32_t *)0xfe026004
#define P_SAR_ADC_AVG_CNTL                         (volatile uint32_t *)0xfe026008
#define P_SAR_ADC_REG3                             (volatile uint32_t *)0xfe02600c
#define P_SAR_ADC_DELAY                            (volatile uint32_t *)0xfe026010
#define P_SAR_ADC_LAST_RD                          (volatile uint32_t *)0xfe026014
#define P_SAR_ADC_FIFO_RD                          (volatile uint32_t *)0xfe026018
#define P_SAR_ADC_AUX_SW                           (volatile uint32_t *)0xfe02601c
#define P_SAR_ADC_CHAN_10_SW                       (volatile uint32_t *)0xfe026020
#define P_SAR_ADC_DETECT_IDLE_SW                   (volatile uint32_t *)0xfe026024
#define P_SAR_ADC_DELTA_10                         (volatile uint32_t *)0xfe026028
#define P_SAR_ADC_REG11                            (volatile uint32_t *)0xfe02602c
#define P_SAR_ADC_REG12                            (volatile uint32_t *)0xfe026030
#define P_SAR_ADC_REG13                            (volatile uint32_t *)0xfe026034
#define P_SAR_ADC_CHNL01                           (volatile uint32_t *)0xfe026038
#define P_SAR_ADC_CHNL23                           (volatile uint32_t *)0xfe02603c
#define P_SAR_ADC_CHNL45                           (volatile uint32_t *)0xfe026040
#define P_SAR_ADC_CHNL67                           (volatile uint32_t *)0xfe026044
#define P_SAR_ADC_RDY                              (volatile uint32_t *)0xfe026080
//========================================================================
//  ANA_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe008000
// -----------------------------------------------
#define P_ANACTRL_SYS0PLL_CTRL0                    (volatile uint32_t *)0xfe008000
#define P_ANACTRL_SYS0PLL_CTRL1                    (volatile uint32_t *)0xfe008004
#define P_ANACTRL_SYS1PLL_CTRL0                    (volatile uint32_t *)0xfe008008
#define P_ANACTRL_SYS1PLL_CTRL1                    (volatile uint32_t *)0xfe00800c
//`define ANACTRL_SYSPLL_CTRL4    8'h04
//`define ANACTRL_SYSPLL_CTRL5    8'h05
//`define ANACTRL_SYSPLL_CTRL6    8'h06
#define P_ANACTRL_SYS0PLL_STS                      (volatile uint32_t *)0xfe00801c
#define P_ANACTRL_SYS1PLL_STS                      (volatile uint32_t *)0xfe008020
#define P_ANACTRL_FIXPLL_CTRL0                     (volatile uint32_t *)0xfe008040
#define P_ANACTRL_FIXPLL_CTRL1                     (volatile uint32_t *)0xfe008044
//`define ANACTRL_FIXPLL_CTRL2    8'h12
//`define ANACTRL_FIXPLL_CTRL3    8'h13
//`define ANACTRL_FIXPLL_CTRL4    8'h14
//`define ANACTRL_FIXPLL_CTRL5    8'h15
//`define ANACTRL_FIXPLL_CTRL6    8'h16
#define P_ANACTRL_FIXPLL_STS                       (volatile uint32_t *)0xfe00805c
#define P_ANACTRL_GP0PLL_CTRL0                     (volatile uint32_t *)0xfe008080
#define P_ANACTRL_GP0PLL_CTRL1                     (volatile uint32_t *)0xfe008084
#define P_ANACTRL_GP0PLL_CTRL2                     (volatile uint32_t *)0xfe008088
#define P_ANACTRL_GP0PLL_CTRL3                     (volatile uint32_t *)0xfe00808c
//`define ANACTRL_GP0PLL_CTRL4    8'h24
//`define ANACTRL_GP0PLL_CTRL5    8'h25
//`define ANACTRL_GP0PLL_CTRL6    8'h26
#define P_ANACTRL_GP0PLL_STS                       (volatile uint32_t *)0xfe00809c
#define P_ANACTRL_GP1PLL_CTRL0                     (volatile uint32_t *)0xfe0080c0
#define P_ANACTRL_GP1PLL_CTRL1                     (volatile uint32_t *)0xfe0080c4
//`define ANACTRL_GP1PLL_CTRL2    8'h32
//`define ANACTRL_GP1PLL_CTRL3    8'h33
//`define ANACTRL_GP1PLL_CTRL4    8'h34
//`define ANACTRL_GP1PLL_CTRL5    8'h35
//`define ANACTRL_GP1PLL_CTRL6    8'h36
#define P_ANACTRL_GP1PLL_STS                       (volatile uint32_t *)0xfe0080dc
#define P_ANACTRL_HIFI0PLL_CTRL0                   (volatile uint32_t *)0xfe008100
#define P_ANACTRL_HIFI0PLL_CTRL1                   (volatile uint32_t *)0xfe008104
#define P_ANACTRL_HIFI0PLL_CTRL2                   (volatile uint32_t *)0xfe008108
#define P_ANACTRL_HIFI0PLL_CTRL3                   (volatile uint32_t *)0xfe00810c
#define P_ANACTRL_HIFI1PLL_CTRL0                   (volatile uint32_t *)0xfe008110
#define P_ANACTRL_HIFI1PLL_CTRL1                   (volatile uint32_t *)0xfe008114
#define P_ANACTRL_HIFI1PLL_CTRL2                   (volatile uint32_t *)0xfe008118
#define P_ANACTRL_HIFI1PLL_CTRL3                   (volatile uint32_t *)0xfe00811c
#define P_ANACTRL_HIFI0PLL_STS                     (volatile uint32_t *)0xfe008120
#define P_ANACTRL_HIFI1PLL_STS                     (volatile uint32_t *)0xfe008124
//`define ANACTRL_PCIEPLL_CTRL0    8'h50
//`define ANACTRL_PCIEPLL_CTRL1    8'h51
//`define ANACTRL_PCIEPLL_CTRL2    8'h52
//`define ANACTRL_PCIEPLL_CTRL3    8'h53
//`define ANACTRL_PCIEPLL_CTRL4    8'h54
//`define ANACTRL_PCIEPLL_CTRL5    8'h55
//`define ANACTRL_PCIEPLL_STS      8'h56
//`define ANACTRL_MPLL_CTRL0       8'h60
//`define ANACTRL_MPLL_CTRL1       8'h61
//`define ANACTRL_MPLL_CTRL2       8'h62
//`define ANACTRL_MPLL_CTRL3       8'h63
//`define ANACTRL_MPLL_CTRL4       8'h64
//`define ANACTRL_MPLL_CTRL5       8'h65
//`define ANACTRL_MPLL_CTRL6       8'h66
//`define ANACTRL_MPLL_CTRL7       8'h67
//`define ANACTRL_MPLL_CTRL8       8'h68
//`define ANACTRL_MPLL_STS         8'h69
#define P_ANACTRL_HDMIPLL_CTRL0                    (volatile uint32_t *)0xfe0081c0
#define P_ANACTRL_HDMIPLL_CTRL1                    (volatile uint32_t *)0xfe0081c4
#define P_ANACTRL_HDMIPLL_CTRL2                    (volatile uint32_t *)0xfe0081c8
#define P_ANACTRL_HDMIPLL_CTRL3                    (volatile uint32_t *)0xfe0081cc
//`define ANACTRL_HDMIPLL_CTRL4    8'h74
//`define ANACTRL_HDMIPLL_CTRL5    8'h75
//`define ANACTRL_HDMIPLL_CTRL6    8'h76
#define P_ANACTRL_HDMIPLL_STS                      (volatile uint32_t *)0xfe0081dc
#define P_ANACTRL_HDMIPLL_VLOCK                    (volatile uint32_t *)0xfe0081e4
#define P_ANACTRL_HDMIPHY_CTRL0                    (volatile uint32_t *)0xfe008200
#define P_ANACTRL_HDMIPHY_CTRL1                    (volatile uint32_t *)0xfe008204
#define P_ANACTRL_HDMIPHY_CTRL2                    (volatile uint32_t *)0xfe008208
#define P_ANACTRL_HDMIPHY_CTRL3                    (volatile uint32_t *)0xfe00820c
#define P_ANACTRL_HDMIPHY_CTRL4                    (volatile uint32_t *)0xfe008210
#define P_ANACTRL_HDMIPHY_CTRL5                    (volatile uint32_t *)0xfe008214
#define P_ANACTRL_HDMIPHY_STS                      (volatile uint32_t *)0xfe008218
//`define ANACTRL_MIPICSI_CTRL0    8'h90
//`define ANACTRL_MIPICSI_CTRL1    8'h91
//`define ANACTRL_MIPICSI_CTRL2    8'h92
//`define ANACTRL_MIPICSI_CTRL3    8'h93
//`define ANACTRL_MIPICSI_CTRL4    8'h94
//`define ANACTRL_MIPICSI_CTRL5    8'h95
//`define ANACTRL_MIPIDSI_CTRL0    8'hA0
//`define ANACTRL_MIPIDSI_CTRL1    8'hA1
//`define ANACTRL_MIPIDSI_CTRL2    8'hA2
//`define ANACTRL_MIPIDSI_STS      8'hA3
#define P_ANACTRL_VDAC_CTRL0                       (volatile uint32_t *)0xfe0082c0
#define P_ANACTRL_VDAC_CTRL1                       (volatile uint32_t *)0xfe0082c4
#define P_ANACTRL_POR_CTRL                         (volatile uint32_t *)0xfe0082d8
#define P_ANACTRL_LOCK_BIT                         (volatile uint32_t *)0xfe0082e0
#define P_ANACTRL_PROT_BIT                         (volatile uint32_t *)0xfe0082e4
//`define ANACTRL_ADC_PLL_CTRL     8'hC0
//`define ANACTRL_ADC_PLL_CTRL1    8'hC1
//`define ANACTRL_ADC_PLL_CTRL2    8'hC2
//`define ANACTRL_ADC_PLL_CTRL3    8'hC3
//`define ANACTRL_ADC_PLL_CTRL4    8'hC4
//`define ANACTRL_ADC_PLL_CTRL5    8'hC5
//`define ANACTRL_ADC_PLL_CTRL6    8'hC6
//`define ANACTRL_ADC_PLL_STS      8'hC7
//`define ANACTRL_S2_DADC_CTRL     8'hD0
//`define ANACTRL_S2_DADC_CTRL2    8'hD1
#define P_ANACTRL_DDR_LDO_CTRL                     (volatile uint32_t *)0xfe00834c
#define P_ANACTRL_MISC_PZQ_CTRL                    (volatile uint32_t *)0xfe008350
#define P_ANACTRL_CHIP_TEST_STS                    (volatile uint32_t *)0xfe008380
//========================================================================
//  Ethernet Phy
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe360000
// -----------------------------------------------
#define P_ETH_PHY_DBG_CTL0                         (volatile uint32_t *)0xfe360000
#define P_ETH_PHY_DBG_CTL1                         (volatile uint32_t *)0xfe360004
#define P_ETH_PHY_DBG_CFG0                         (volatile uint32_t *)0xfe360008
#define P_ETH_PHY_DBG_CFG1                         (volatile uint32_t *)0xfe36000c
#define P_ETH_PHY_DBG_CFG2                         (volatile uint32_t *)0xfe360010
#define P_ETH_PHY_DBG_CFG3                         (volatile uint32_t *)0xfe360014
#define P_ETH_PHY_DBG_CFG4                         (volatile uint32_t *)0xfe360018
#define P_ETH_PLL_STS                              (volatile uint32_t *)0xfe360040
#define P_ETH_PLL_CTL0                             (volatile uint32_t *)0xfe360044
#define P_ETH_PLL_CTL1                             (volatile uint32_t *)0xfe360048
#define P_ETH_PLL_CTL2                             (volatile uint32_t *)0xfe36004c
#define P_ETH_PLL_CTL3                             (volatile uint32_t *)0xfe360050
#define P_ETH_PLL_CTL4                             (volatile uint32_t *)0xfe360054
#define P_ETH_PLL_CTL5                             (volatile uint32_t *)0xfe360058
#define P_ETH_PLL_CTL6                             (volatile uint32_t *)0xfe36005c
#define P_ETH_PLL_CTL7                             (volatile uint32_t *)0xfe360060
#define P_ETH_PHY_CNTL0                            (volatile uint32_t *)0xfe360080
#define P_ETH_PHY_CNTL1                            (volatile uint32_t *)0xfe360084
#define P_ETH_PHY_CNTL2                            (volatile uint32_t *)0xfe360088
#define P_ETH_PHY_CNTL3                            (volatile uint32_t *)0xfe36008c
#define P_ETH_PHY_STS0                             (volatile uint32_t *)0xfe360094
#define P_ETH_PHY_STS1                             (volatile uint32_t *)0xfe360098
#define P_ETH_PHY_STS2                             (volatile uint32_t *)0xfe36009c
#define P_ETH_PHY_DBG_REG                          (volatile uint32_t *)0xfe3600a0
//========================================================================
//  Ethernet TOP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe364000
// -----------------------------------------------
#define P_ETHTOP_CNTL0                             (volatile uint32_t *)0xfe364000
#define P_ETHTOP_CNTL1                             (volatile uint32_t *)0xfe364004
//========================================================================
//  I2C Slave A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe064000
// -----------------------------------------------
#define P_I2C_S_A_CONTROL_REG                      (volatile uint32_t *)0xfe064000
#define P_I2C_S_A_SEND_REG                         (volatile uint32_t *)0xfe064004
#define P_I2C_S_A_RECV_REG                         (volatile uint32_t *)0xfe064008
#define P_I2C_S_A_CNTL1_REG                        (volatile uint32_t *)0xfe06400c
//========================================================================
//  IR RX/TX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe084000
// -----------------------------------------------
#define P_IRCTRL_IR_DEC_LDR_ACTIVE                 (volatile uint32_t *)0xfe084000
#define P_IRCTRL_IR_DEC_LDR_IDLE                   (volatile uint32_t *)0xfe084004
#define P_IRCTRL_IR_DEC_LDR_REPEAT                 (volatile uint32_t *)0xfe084008
#define P_IRCTRL_IR_DEC_BIT_0                      (volatile uint32_t *)0xfe08400c
#define P_IRCTRL_IR_DEC_REG0                       (volatile uint32_t *)0xfe084010
#define P_IRCTRL_IR_DEC_FRAME                      (volatile uint32_t *)0xfe084014
#define P_IRCTRL_IR_DEC_STATUS                     (volatile uint32_t *)0xfe084018
#define P_IRCTRL_IR_DEC_REG1                       (volatile uint32_t *)0xfe08401c
#define P_IRCTRL_MF_IR_DEC_LDR_ACTIVE              (volatile uint32_t *)0xfe084040
#define P_IRCTRL_MF_IR_DEC_LDR_IDLE                (volatile uint32_t *)0xfe084044
#define P_IRCTRL_MF_IR_DEC_LDR_REPEAT              (volatile uint32_t *)0xfe084048
#define P_IRCTRL_MF_IR_DEC_BIT_0                   (volatile uint32_t *)0xfe08404c
#define P_IRCTRL_MF_IR_DEC_REG0                    (volatile uint32_t *)0xfe084050
#define P_IRCTRL_MF_IR_DEC_FRAME                   (volatile uint32_t *)0xfe084054
#define P_IRCTRL_MF_IR_DEC_STATUS                  (volatile uint32_t *)0xfe084058
#define P_IRCTRL_MF_IR_DEC_REG1                    (volatile uint32_t *)0xfe08405c
#define P_IRCTRL_MF_IR_DEC_REG2                    (volatile uint32_t *)0xfe084060
#define P_IRCTRL_MF_IR_DEC_DURATN2                 (volatile uint32_t *)0xfe084064
#define P_IRCTRL_MF_IR_DEC_DURATN3                 (volatile uint32_t *)0xfe084068
#define P_IRCTRL_MF_IR_DEC_FRAME1                  (volatile uint32_t *)0xfe08406c
#define P_IRCTRL_MF_IR_DEC_STATUS1                 (volatile uint32_t *)0xfe084070
#define P_IRCTRL_MF_IR_DEC_STATUS2                 (volatile uint32_t *)0xfe084074
#define P_IRCTRL_MF_IR_DEC_REG3                    (volatile uint32_t *)0xfe084078
#define P_IRCTRL_MF_IR_DEC_FRAME_RSV0              (volatile uint32_t *)0xfe08407c
#define P_IRCTRL_MF_IR_DEC_FRAME_RSV1              (volatile uint32_t *)0xfe084080
#define P_IRCTRL_MF_IR_DEC_FILTE                   (volatile uint32_t *)0xfe084084
#define P_IRCTRL_MF_IR_DEC_IRQ_CTL                 (volatile uint32_t *)0xfe084088
#define P_IRCTRL_MF_IR_DEC_FIFO_CTL                (volatile uint32_t *)0xfe08408c
#define P_IRCTRL_MF_IR_DEC_WIDTH_NEW               (volatile uint32_t *)0xfe084090
#define P_IRCTRL_MF_IR_DEC_REPEAT_DET              (volatile uint32_t *)0xfe084094
#define P_IRCTRL_IR_DEC_DEMOD_CNTL0                (volatile uint32_t *)0xfe0840c0
#define P_IRCTRL_IR_DEC_DEMOD_CNTL1                (volatile uint32_t *)0xfe0840c4
#define P_IRCTRL_IR_DEC_DEMOD_IIR_THD              (volatile uint32_t *)0xfe0840c8
#define P_IRCTRL_IR_DEC_DEMOD_THD0                 (volatile uint32_t *)0xfe0840cc
#define P_IRCTRL_IR_DEC_DEMOD_THD1                 (volatile uint32_t *)0xfe0840d0
#define P_IRCTRL_IR_DEC_DEMOD_SUM_CNT0             (volatile uint32_t *)0xfe0840d4
#define P_IRCTRL_IR_DEC_DEMOD_SUM_CNT1             (volatile uint32_t *)0xfe0840d8
#define P_IRCTRL_IR_DEC_DEMOD_CNT0                 (volatile uint32_t *)0xfe0840dc
#define P_IRCTRL_IR_DEC_DEMOD_CNT1                 (volatile uint32_t *)0xfe0840e0
#define P_IRCTRL_IR_DEC_DEMOD_FILTER               (volatile uint32_t *)0xfe0840e4
#define P_IRCTRL_IR_BLASTER_ADDR0                  (volatile uint32_t *)0xfe08410c
#define P_IRCTRL_IR_BLASTER_ADDR1                  (volatile uint32_t *)0xfe084110
#define P_IRCTRL_IR_BLASTER_ADDR2                  (volatile uint32_t *)0xfe084114
#define P_IRCTRL_IR_BLASTER_ADDR3                  (volatile uint32_t *)0xfe084118
//========================================================================
//  I2C Master A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066000
// -----------------------------------------------
#define P_I2C_M_A_CONTROL_REG                      (volatile uint32_t *)0xfe066000
#define P_I2C_M_A_SLAVE_ADDR                       (volatile uint32_t *)0xfe066004
#define P_I2C_M_A_TOKEN_LIST0                      (volatile uint32_t *)0xfe066008
#define P_I2C_M_A_TOKEN_LIST1                      (volatile uint32_t *)0xfe06600c
#define P_I2C_M_A_WDATA_REG0                       (volatile uint32_t *)0xfe066010
#define P_I2C_M_A_WDATA_REG1                       (volatile uint32_t *)0xfe066014
#define P_I2C_M_A_RDATA_REG0                       (volatile uint32_t *)0xfe066018
#define P_I2C_M_A_RDATA_REG1                       (volatile uint32_t *)0xfe06601c
#define P_I2C_M_A_TIMEOUT_TH                       (volatile uint32_t *)0xfe066020
#define P_I2C_M_A_CNTL_DELY1                       (volatile uint32_t *)0xfe066024
#define P_I2C_M_A_CNTL_DELY2                       (volatile uint32_t *)0xfe066028
#define P_I2C_M_A_LOW_DELY                         (volatile uint32_t *)0xfe06602c
#define P_I2C_M_A_HIGH_DELY                        (volatile uint32_t *)0xfe066030
#define P_I2C_M_A_FIFO_CTRL0                       (volatile uint32_t *)0xfe066034
#define P_I2C_M_A_FIFO_CTRL1                       (volatile uint32_t *)0xfe066038
#define P_I2C_M_A_FIFO_PENDING                     (volatile uint32_t *)0xfe06603c
#define P_I2C_M_A_FIFO_PENDING_MASK                (volatile uint32_t *)0xfe066040
#define P_I2C_M_A_FIFO_ST0                         (volatile uint32_t *)0xfe066044
#define P_I2C_M_A_TEE_ONLY                         (volatile uint32_t *)0xfe066048
//========================================================================
//  I2C Master B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066400
// -----------------------------------------------
#define P_I2C_M_B_CONTROL_REG                      (volatile uint32_t *)0xfe066400
#define P_I2C_M_B_SLAVE_ADDR                       (volatile uint32_t *)0xfe066404
#define P_I2C_M_B_TOKEN_LIST0                      (volatile uint32_t *)0xfe066408
#define P_I2C_M_B_TOKEN_LIST1                      (volatile uint32_t *)0xfe06640c
#define P_I2C_M_B_WDATA_REG0                       (volatile uint32_t *)0xfe066410
#define P_I2C_M_B_WDATA_REG1                       (volatile uint32_t *)0xfe066414
#define P_I2C_M_B_RDATA_REG0                       (volatile uint32_t *)0xfe066418
#define P_I2C_M_B_RDATA_REG1                       (volatile uint32_t *)0xfe06641c
#define P_I2C_M_B_TIMEOUT_TH                       (volatile uint32_t *)0xfe066420
#define P_I2C_M_B_CNTL_DELY1                       (volatile uint32_t *)0xfe066424
#define P_I2C_M_B_CNTL_DELY2                       (volatile uint32_t *)0xfe066428
#define P_I2C_M_B_LOW_DELY                         (volatile uint32_t *)0xfe06642c
#define P_I2C_M_B_HIGH_DELY                        (volatile uint32_t *)0xfe066430
#define P_I2C_M_B_FIFO_CTRL0                       (volatile uint32_t *)0xfe066434
#define P_I2C_M_B_FIFO_CTRL1                       (volatile uint32_t *)0xfe066438
#define P_I2C_M_B_FIFO_PENDING                     (volatile uint32_t *)0xfe06643c
#define P_I2C_M_B_FIFO_PENDING_MASK                (volatile uint32_t *)0xfe066440
#define P_I2C_M_B_FIFO_ST0                         (volatile uint32_t *)0xfe066444
#define P_I2C_M_B_TEE_ONLY                         (volatile uint32_t *)0xfe066448
//========================================================================
//  I2C Master C
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066800
// -----------------------------------------------
#define P_I2C_M_C_CONTROL_REG                      (volatile uint32_t *)0xfe066800
#define P_I2C_M_C_SLAVE_ADDR                       (volatile uint32_t *)0xfe066804
#define P_I2C_M_C_TOKEN_LIST0                      (volatile uint32_t *)0xfe066808
#define P_I2C_M_C_TOKEN_LIST1                      (volatile uint32_t *)0xfe06680c
#define P_I2C_M_C_WDATA_REG0                       (volatile uint32_t *)0xfe066810
#define P_I2C_M_C_WDATA_REG1                       (volatile uint32_t *)0xfe066814
#define P_I2C_M_C_RDATA_REG0                       (volatile uint32_t *)0xfe066818
#define P_I2C_M_C_RDATA_REG1                       (volatile uint32_t *)0xfe06681c
#define P_I2C_M_C_TIMEOUT_TH                       (volatile uint32_t *)0xfe066820
#define P_I2C_M_C_CNTL_DELY1                       (volatile uint32_t *)0xfe066824
#define P_I2C_M_C_CNTL_DELY2                       (volatile uint32_t *)0xfe066828
#define P_I2C_M_C_LOW_DELY                         (volatile uint32_t *)0xfe06682c
#define P_I2C_M_C_HIGH_DELY                        (volatile uint32_t *)0xfe066830
#define P_I2C_M_C_FIFO_CTRL0                       (volatile uint32_t *)0xfe066834
#define P_I2C_M_C_FIFO_CTRL1                       (volatile uint32_t *)0xfe066838
#define P_I2C_M_C_FIFO_PENDING                     (volatile uint32_t *)0xfe06683c
#define P_I2C_M_C_FIFO_PENDING_MASK                (volatile uint32_t *)0xfe066840
#define P_I2C_M_C_FIFO_ST0                         (volatile uint32_t *)0xfe066844
#define P_I2C_M_C_TEE_ONLY                         (volatile uint32_t *)0xfe066848
//========================================================================
//  I2C Master D
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066c00
// -----------------------------------------------
#define P_I2C_M_D_CONTROL_REG                      (volatile uint32_t *)0xfe066c00
#define P_I2C_M_D_SLAVE_ADDR                       (volatile uint32_t *)0xfe066c04
#define P_I2C_M_D_TOKEN_LIST0                      (volatile uint32_t *)0xfe066c08
#define P_I2C_M_D_TOKEN_LIST1                      (volatile uint32_t *)0xfe066c0c
#define P_I2C_M_D_WDATA_REG0                       (volatile uint32_t *)0xfe066c10
#define P_I2C_M_D_WDATA_REG1                       (volatile uint32_t *)0xfe066c14
#define P_I2C_M_D_RDATA_REG0                       (volatile uint32_t *)0xfe066c18
#define P_I2C_M_D_RDATA_REG1                       (volatile uint32_t *)0xfe066c1c
#define P_I2C_M_D_TIMEOUT_TH                       (volatile uint32_t *)0xfe066c20
#define P_I2C_M_D_CNTL_DELY1                       (volatile uint32_t *)0xfe066c24
#define P_I2C_M_D_CNTL_DELY2                       (volatile uint32_t *)0xfe066c28
#define P_I2C_M_D_LOW_DELY                         (volatile uint32_t *)0xfe066c2c
#define P_I2C_M_D_HIGH_DELY                        (volatile uint32_t *)0xfe066c30
#define P_I2C_M_D_FIFO_CTRL0                       (volatile uint32_t *)0xfe066c34
#define P_I2C_M_D_FIFO_CTRL1                       (volatile uint32_t *)0xfe066c38
#define P_I2C_M_D_FIFO_PENDING                     (volatile uint32_t *)0xfe066c3c
#define P_I2C_M_D_FIFO_PENDING_MASK                (volatile uint32_t *)0xfe066c40
#define P_I2C_M_D_FIFO_ST0                         (volatile uint32_t *)0xfe066c44
#define P_I2C_M_D_TEE_ONLY                         (volatile uint32_t *)0xfe066c48
//========================================================================
//  I2C Master E
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe067000
// -----------------------------------------------
#define P_I2C_M_E_CONTROL_REG                      (volatile uint32_t *)0xfe067000
#define P_I2C_M_E_SLAVE_ADDR                       (volatile uint32_t *)0xfe067004
#define P_I2C_M_E_TOKEN_LIST0                      (volatile uint32_t *)0xfe067008
#define P_I2C_M_E_TOKEN_LIST1                      (volatile uint32_t *)0xfe06700c
#define P_I2C_M_E_WDATA_REG0                       (volatile uint32_t *)0xfe067010
#define P_I2C_M_E_WDATA_REG1                       (volatile uint32_t *)0xfe067014
#define P_I2C_M_E_RDATA_REG0                       (volatile uint32_t *)0xfe067018
#define P_I2C_M_E_RDATA_REG1                       (volatile uint32_t *)0xfe06701c
#define P_I2C_M_E_TIMEOUT_TH                       (volatile uint32_t *)0xfe067020
#define P_I2C_M_E_CNTL_DELY1                       (volatile uint32_t *)0xfe067024
#define P_I2C_M_E_CNTL_DELY2                       (volatile uint32_t *)0xfe067028
#define P_I2C_M_E_LOW_DELY                         (volatile uint32_t *)0xfe06702c
#define P_I2C_M_E_HIGH_DELY                        (volatile uint32_t *)0xfe067030
#define P_I2C_M_E_FIFO_CTRL0                       (volatile uint32_t *)0xfe067034
#define P_I2C_M_E_FIFO_CTRL1                       (volatile uint32_t *)0xfe067038
#define P_I2C_M_E_FIFO_PENDING                     (volatile uint32_t *)0xfe06703c
#define P_I2C_M_E_FIFO_PENDING_MASK                (volatile uint32_t *)0xfe067040
#define P_I2C_M_E_FIFO_ST0                         (volatile uint32_t *)0xfe067044
#define P_I2C_M_E_TEE_ONLY                         (volatile uint32_t *)0xfe067048
//========================================================================
//  I2C Master F
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe070000
// -----------------------------------------------
#define P_I2C_M_F_CONTROL_REG                      (volatile uint32_t *)0xfe070000
#define P_I2C_M_F_SLAVE_ADDR                       (volatile uint32_t *)0xfe070004
#define P_I2C_M_F_TOKEN_LIST0                      (volatile uint32_t *)0xfe070008
#define P_I2C_M_F_TOKEN_LIST1                      (volatile uint32_t *)0xfe07000c
#define P_I2C_M_F_WDATA_REG0                       (volatile uint32_t *)0xfe070010
#define P_I2C_M_F_WDATA_REG1                       (volatile uint32_t *)0xfe070014
#define P_I2C_M_F_RDATA_REG0                       (volatile uint32_t *)0xfe070018
#define P_I2C_M_F_RDATA_REG1                       (volatile uint32_t *)0xfe07001c
#define P_I2C_M_F_TIMEOUT_TH                       (volatile uint32_t *)0xfe070020
#define P_I2C_M_F_CNTL_DELY1                       (volatile uint32_t *)0xfe070024
#define P_I2C_M_F_CNTL_DELY2                       (volatile uint32_t *)0xfe070028
#define P_I2C_M_F_LOW_DELY                         (volatile uint32_t *)0xfe07002c
#define P_I2C_M_F_HIGH_DELY                        (volatile uint32_t *)0xfe070030
#define P_I2C_M_F_FIFO_CTRL_REG                    (volatile uint32_t *)0xfe070034
#define P_I2C_M_F_STATE_REG                        (volatile uint32_t *)0xfe070038
#define P_I2C_M_F_TEE_ONLY                         (volatile uint32_t *)0xfe070048
//========================================================================
//  APB0_UART_A - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe078000
// -----------------------------------------------
#define P_UART_A_WFIFO                             (volatile uint32_t *)0xfe078000
#define P_UART_A_RFIFO                             (volatile uint32_t *)0xfe078004
#define P_UART_A_CONTROL                           (volatile uint32_t *)0xfe078008
#define P_UART_A_STATUS                            (volatile uint32_t *)0xfe07800c
#define P_UART_A_MISC                              (volatile uint32_t *)0xfe078010
#define P_UART_A_REG5                              (volatile uint32_t *)0xfe078014
//========================================================================
//  APB0_UART_B - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07a000
// -----------------------------------------------
#define P_UART_B_WFIFO                             (volatile uint32_t *)0xfe07a000
#define P_UART_B_RFIFO                             (volatile uint32_t *)0xfe07a004
#define P_UART_B_CONTROL                           (volatile uint32_t *)0xfe07a008
#define P_UART_B_STATUS                            (volatile uint32_t *)0xfe07a00c
#define P_UART_B_MISC                              (volatile uint32_t *)0xfe07a010
#define P_UART_B_REG5                              (volatile uint32_t *)0xfe07a014
//========================================================================
//  APB0_UART_C - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07c000
// -----------------------------------------------
#define P_UART_C_WFIFO                             (volatile uint32_t *)0xfe07c000
#define P_UART_C_RFIFO                             (volatile uint32_t *)0xfe07c004
#define P_UART_C_CONTROL                           (volatile uint32_t *)0xfe07c008
#define P_UART_C_STATUS                            (volatile uint32_t *)0xfe07c00c
#define P_UART_C_MISC                              (volatile uint32_t *)0xfe07c010
#define P_UART_C_REG5                              (volatile uint32_t *)0xfe07c014
//========================================================================
//  APB0_UART_D - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07e000
// -----------------------------------------------
#define P_UART_D_WFIFO                             (volatile uint32_t *)0xfe07e000
#define P_UART_D_RFIFO                             (volatile uint32_t *)0xfe07e004
#define P_UART_D_CONTROL                           (volatile uint32_t *)0xfe07e008
#define P_UART_D_STATUS                            (volatile uint32_t *)0xfe07e00c
#define P_UART_D_MISC                              (volatile uint32_t *)0xfe07e010
#define P_UART_D_REG5                              (volatile uint32_t *)0xfe07e014
//========================================================================
//  APB0_UART_E - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe080000
// -----------------------------------------------
#define P_UART_E_WFIFO                             (volatile uint32_t *)0xfe080000
#define P_UART_E_RFIFO                             (volatile uint32_t *)0xfe080004
#define P_UART_E_CONTROL                           (volatile uint32_t *)0xfe080008
#define P_UART_E_STATUS                            (volatile uint32_t *)0xfe08000c
#define P_UART_E_MISC                              (volatile uint32_t *)0xfe080010
#define P_UART_E_REG5                              (volatile uint32_t *)0xfe080014
//========================================================================
//  PWM_A - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058000
// -----------------------------------------------
#define P_PWM_PWM_A                                (volatile uint32_t *)0xfe058000
//`define PWM_PWM_B                8'h01
#define P_PWM_MISC_REG_A                           (volatile uint32_t *)0xfe058008
#define P_PWM_DELTA_SIGMA_A                        (volatile uint32_t *)0xfe05800c
#define P_PWM_TIME_A                               (volatile uint32_t *)0xfe058010
#define P_PWM_A2                                   (volatile uint32_t *)0xfe058014
//`define PWM_B2                   8'h06
#define P_PWM_BLINK_A                              (volatile uint32_t *)0xfe05801c
#define P_PWM_LOCK_A                               (volatile uint32_t *)0xfe058020
#define P_PWM_TEE_ONLY_A                           (volatile uint32_t *)0xfe058024
//========================================================================
//  PWM_B - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058200
// -----------------------------------------------
#define P_PWM_PWM_B                                (volatile uint32_t *)0xfe058200
#define P_PWM_MISC_REG_B                           (volatile uint32_t *)0xfe058208
#define P_PWM_DELTA_SIGMA_B                        (volatile uint32_t *)0xfe05820c
#define P_PWM_TIME_B                               (volatile uint32_t *)0xfe058210
#define P_PWM_B2                                   (volatile uint32_t *)0xfe058214
#define P_PWM_BLINK_B                              (volatile uint32_t *)0xfe05821c
#define P_PWM_LOCK_B                               (volatile uint32_t *)0xfe058220
#define P_PWM_TEE_ONLY_B                           (volatile uint32_t *)0xfe058224
//========================================================================
//  PWM_C - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058400
// -----------------------------------------------
#define P_PWM_PWM_C                                (volatile uint32_t *)0xfe058400
#define P_PWM_MISC_REG_C                           (volatile uint32_t *)0xfe058408
#define P_PWM_DELTA_SIGMA_C                        (volatile uint32_t *)0xfe05840c
#define P_PWM_TIME_C                               (volatile uint32_t *)0xfe058410
#define P_PWM_C2                                   (volatile uint32_t *)0xfe058414
#define P_PWM_BLINK_C                              (volatile uint32_t *)0xfe05841c
#define P_PWM_LOCK_C                               (volatile uint32_t *)0xfe058420
#define P_PWM_TEE_ONLY_C                           (volatile uint32_t *)0xfe058424
//========================================================================
//  PWM_D - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058600
// -----------------------------------------------
#define P_PWM_PWM_D                                (volatile uint32_t *)0xfe058600
#define P_PWM_MISC_REG_D                           (volatile uint32_t *)0xfe058608
#define P_PWM_DELTA_SIGMA_D                        (volatile uint32_t *)0xfe05860c
#define P_PWM_TIME_D                               (volatile uint32_t *)0xfe058610
#define P_PWM_D2                                   (volatile uint32_t *)0xfe058614
#define P_PWM_BLINK_D                              (volatile uint32_t *)0xfe05861c
#define P_PWM_LOCK_D                               (volatile uint32_t *)0xfe058620
#define P_PWM_TEE_ONLY_D                           (volatile uint32_t *)0xfe058624
//========================================================================
//  PWM_E - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058800
// -----------------------------------------------
#define P_PWM_PWM_E                                (volatile uint32_t *)0xfe058800
#define P_PWM_MISC_REG_E                           (volatile uint32_t *)0xfe058808
#define P_PWM_DELTA_SIGMA_E                        (volatile uint32_t *)0xfe05880c
#define P_PWM_TIME_E                               (volatile uint32_t *)0xfe058810
#define P_PWM_E2                                   (volatile uint32_t *)0xfe058814
#define P_PWM_BLINK_E                              (volatile uint32_t *)0xfe05881c
#define P_PWM_LOCK_E                               (volatile uint32_t *)0xfe058820
#define P_PWM_TEE_ONLY_E                           (volatile uint32_t *)0xfe058824
//========================================================================
//  PWM_F - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058a00
// -----------------------------------------------
#define P_PWM_PWM_F                                (volatile uint32_t *)0xfe058a00
#define P_PWM_MISC_REG_F                           (volatile uint32_t *)0xfe058a08
#define P_PWM_DELTA_SIGMA_F                        (volatile uint32_t *)0xfe058a0c
#define P_PWM_TIME_F                               (volatile uint32_t *)0xfe058a10
#define P_PWM_F2                                   (volatile uint32_t *)0xfe058a14
#define P_PWM_BLINK_F                              (volatile uint32_t *)0xfe058a1c
#define P_PWM_LOCK_F                               (volatile uint32_t *)0xfe058a20
#define P_PWM_TEE_ONLY_F                           (volatile uint32_t *)0xfe058a24
//========================================================================
//  PWM_G - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058c00
// -----------------------------------------------
#define P_PWM_PWM_G                                (volatile uint32_t *)0xfe058c00
#define P_PWM_MISC_REG_G                           (volatile uint32_t *)0xfe058c08
#define P_PWM_DELTA_SIGMA_G                        (volatile uint32_t *)0xfe058c0c
#define P_PWM_TIME_G                               (volatile uint32_t *)0xfe058c10
#define P_PWM_G2                                   (volatile uint32_t *)0xfe058c14
#define P_PWM_BLINK_G                              (volatile uint32_t *)0xfe058c1c
#define P_PWM_LOCK_G                               (volatile uint32_t *)0xfe058c20
#define P_PWM_TEE_ONLY_G                           (volatile uint32_t *)0xfe058c24
//========================================================================
//  PWM_H - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058e00
// -----------------------------------------------
#define P_PWM_PWM_H                                (volatile uint32_t *)0xfe058e00
#define P_PWM_MISC_REG_H                           (volatile uint32_t *)0xfe058e08
#define P_PWM_DELTA_SIGMA_H                        (volatile uint32_t *)0xfe058e0c
#define P_PWM_TIME_H                               (volatile uint32_t *)0xfe058e10
#define P_PWM_H2                                   (volatile uint32_t *)0xfe058e14
#define P_PWM_BLINK_H                              (volatile uint32_t *)0xfe058e1c
#define P_PWM_LOCK_H                               (volatile uint32_t *)0xfe058e20
#define P_PWM_TEE_ONLY_H                           (volatile uint32_t *)0xfe058e24
//========================================================================
//  PWM_I - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe059000
// -----------------------------------------------
#define P_PWM_PWM_I                                (volatile uint32_t *)0xfe059000
#define P_PWM_MISC_REG_I                           (volatile uint32_t *)0xfe059008
#define P_PWM_DELTA_SIGMA_I                        (volatile uint32_t *)0xfe05900c
#define P_PWM_TIME_I                               (volatile uint32_t *)0xfe059010
#define P_PWM_I2                                   (volatile uint32_t *)0xfe059014
#define P_PWM_BLINK_I                              (volatile uint32_t *)0xfe05901c
#define P_PWM_LOCK_I                               (volatile uint32_t *)0xfe059020
#define P_PWM_TEE_ONLY_I                           (volatile uint32_t *)0xfe059024
//========================================================================
////  PWM_J - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe059200
// -----------------------------------------------
#define P_PWM_PWM_J                                (volatile uint32_t *)0xfe059200
#define P_PWM_MISC_REG_J                           (volatile uint32_t *)0xfe059208
#define P_PWM_DELTA_SIGMA_J                        (volatile uint32_t *)0xfe05920c
#define P_PWM_TIME_J                               (volatile uint32_t *)0xfe059210
#define P_PWM_J2                                   (volatile uint32_t *)0xfe059214
#define P_PWM_BLINK_J                              (volatile uint32_t *)0xfe05921c
#define P_PWM_LOCK_J                               (volatile uint32_t *)0xfe059220
#define P_PWM_TEE_ONLY_J                           (volatile uint32_t *)0xfe059224
//========================================================================
//  SPICC_0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe050000
// -----------------------------------------------
#define P_SPICC0_CFG_READY                         (volatile uint32_t *)0xfe050000
#define P_SPICC0_CFG_SPI                           (volatile uint32_t *)0xfe050004
#define P_SPICC0_CFG_START                         (volatile uint32_t *)0xfe050008
#define P_SPICC0_CFG_BUS                           (volatile uint32_t *)0xfe05000c
#define P_SPICC0_TX_DESC0                          (volatile uint32_t *)0xfe050010
#define P_SPICC0_TX_DESC1                          (volatile uint32_t *)0xfe050014
#define P_SPICC0_RX_DESC0                          (volatile uint32_t *)0xfe050018
#define P_SPICC0_RX_DESC1                          (volatile uint32_t *)0xfe05001c
#define P_SPICC0_DESC_LIST0                        (volatile uint32_t *)0xfe050020
#define P_SPICC0_DESC_LIST1                        (volatile uint32_t *)0xfe050024
#define P_SPICC0_DESC_CURR0                        (volatile uint32_t *)0xfe050028
#define P_SPICC0_DESC_CURR1                        (volatile uint32_t *)0xfe05002c
#define P_SPICC0_IRQ_STS                           (volatile uint32_t *)0xfe050030
#define P_SPICC0_IRQ_ENABLE                        (volatile uint32_t *)0xfe050034
//========================================================================
//  AIFIFO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe046000
// -----------------------------------------------
//`define AIU_AIFIFO_CTRL                 8'h00
//`define AIU_AIFIFO_STATUS               8'h01
//`define AIU_AIFIFO_GBIT                 8'h02
//`define AIU_AIFIFO_CLB                  8'h03
//`define AIU_MEM_AIFIFO_START_PTR        8'h04
//`define AIU_MEM_AIFIFO_CURR_PTR         8'h05
//`define AIU_MEM_AIFIFO_END_PTR          8'h06
//`define AIU_MEM_AIFIFO_BYTES_AVAIL      8'h07
//`define AIU_MEM_AIFIFO_CONTROL          8'h08
//`define AIU_MEM_AIFIFO_MAN_WP           8'h09 // Manual or Parser write pointer
//`define AIU_MEM_AIFIFO_MAN_RP           8'h0a
//`define AIU_MEM_AIFIFO_LEVEL            8'h0b // must be low first to shadow low/high 16-bit words
//`define AIU_MEM_AIFIFO_BUF_CNTL         8'h0c
//`define AIU_MEM_AIFIFO_BUF_WRAP_COUNT   8'h0d
//`define AIU_MEM_AIFIFO_MEM_CTL          8'h0f
//`define AIFIFO_TIME_STAMP_CNTL          8'h10
//`define AIFIFO_TIME_STAMP_SYNC_0        8'h11
//`define AIFIFO_TIME_STAMP_SYNC_1        8'h12
//`define AIFIFO_TIME_STAMP_0             8'h13
//`define AIFIFO_TIME_STAMP_1             8'h14
//`define AIFIFO_TIME_STAMP_2             8'h15
//`define AIFIFO_TIME_STAMP_3             8'h16
//`define AIFIFO_TIME_STAMP_LENGTH        8'h17
//========================================================================
//  MSR_CLK - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe048000
// -----------------------------------------------
#define P_MSR_CLK_REG0                             (volatile uint32_t *)0xfe048000
#define P_MSR_CLK_REG1                             (volatile uint32_t *)0xfe048004
#define P_MSR_CLK_REG2                             (volatile uint32_t *)0xfe048008
#define P_MSR_CLK_REG3                             (volatile uint32_t *)0xfe04800c
#define P_MSR_CLK_REG4                             (volatile uint32_t *)0xfe048010
#define P_MSR_CLK_REG5                             (volatile uint32_t *)0xfe048014
#define P_MSR_CLK_DUTY                             (volatile uint32_t *)0xfe048018
//========================================================================
//  SPIFC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe056000
// -----------------------------------------------
//`define SPI_FLASH_CMD                   8'h00
    // SPI_FLASH_READ    31
    // SPI_FLASH_WREN    30
    // SPI_FLASH_WRDI    29
    // SPI_FLASH_RDID    28
    // SPI_FLASH_RDSR    27
    // SPI_FLASH_WRSR    26
    // SPI_FLASH_PP      25
    // SPI_FLASH_SE      24
    // SPI_FLASH_BE      23
    // SPI_FLASH_CE      22
    // SPI_FLASH_DP      21
    // SPI_FLASH_RES     20
    // SPI_HPM           19
    // SPI_FLASH_USR     18
    // SPI_FLASH_USR_ADDR 15
    // SPI_FLASH_USR_DUMMY 14
    // SPI_FLASH_USR_DIN   13
    // SPI_FLASH_USR_DOUT   12
    // SPI_FLASH_USR_DUMMY_BLEN   10
    // SPI_FLASH_USR_CMD     0
//`define SPI_FLASH_ADDR                  8'h01
    // SPI_FLASH_BYTES_LEN 24
    // SPI_FLASH_ADDR_START 0
//`define SPI_FLASH_CTRL                  8'h02
    // SPI_ENABLE_AHB    17
    // SPI_SST_AAI       16
    // SPI_RES_RID       15
    // SPI_FREAD_DUAL    14
    // SPI_READ_READ_EN  13
    // SPI_CLK_DIV0      12
    // SPI_CLKCNT_N      8
    // SPI_CLKCNT_H      4
    // SPI_CLKCNT_L      0
//`define SPI_FLASH_CTRL1         8'h03
//`define SPI_FLASH_STATUS        8'h04
//`define SPI_FLASH_CTRL2         8'h05
//`define SPI_FLASH_CLOCK         8'h06
//`define SPI_FLASH_USER          8'h07
//`define SPI_FLASH_USER1         8'h08
//`define SPI_FLASH_USER2         8'h09
//`define SPI_FLASH_USER3         8'h0a
//`define SPI_FLASH_USER4         8'h0b
//`define SPI_FLASH_SLAVE         8'h0c
//`define SPI_FLASH_SLAVE1        8'h0d
//`define SPI_FLASH_SLAVE2        8'h0e
//`define SPI_FLASH_SLAVE3        8'h0f
//`define SPI_FLASH_C0            8'h10
//`define SPI_FLASH_C1            8'h11
//`define SPI_FLASH_C2            8'h12
//`define SPI_FLASH_C3            8'h13
//`define SPI_FLASH_C4            8'h14
//`define SPI_FLASH_C5            8'h15
//`define SPI_FLASH_C6            8'h16
//`define SPI_FLASH_C7            8'h17
//`define SPI_FLASH_B8            8'h18
//`define SPI_FLASH_B9            8'h19
//`define SPI_FLASH_B10           8'h1a
//`define SPI_FLASH_B11           8'h1b
//`define SPI_FLASH_B12           8'h1c
//`define SPI_FLASH_B13           8'h1d
//`define SPI_FLASH_B14           8'h1e
//`define SPI_FLASH_B15           8'h1f
//========================================================================
//  CEC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe044000
// -----------------------------------------------
//`define CECA_GEN_CNTL                   8'h00
//`define CECA_RW_REG                     8'h01
//`define CECA_INTR_MASKN                 8'h02
//`define CECA_INTR_CLR                   8'h03
//`define CECA_INTR_STAT                  8'h04
#define P_CECB_GEN_CNTL                            (volatile uint32_t *)0xfe044040
#define P_CECB_RW_REG                              (volatile uint32_t *)0xfe044044
#define P_CECB_INTR_MASKN                          (volatile uint32_t *)0xfe044048
#define P_CECB_INTR_CLR                            (volatile uint32_t *)0xfe04404c
#define P_CECB_INTR_STAT                           (volatile uint32_t *)0xfe044050
//========================================================================
//  SMART CARD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe038000
// -----------------------------------------------
#define P_SMARTCARD_REG0                           (volatile uint32_t *)0xfe038000
#define P_SMARTCARD_REG1                           (volatile uint32_t *)0xfe038004
#define P_SMARTCARD_REG2                           (volatile uint32_t *)0xfe038008
#define P_SMARTCARD_STATUS                         (volatile uint32_t *)0xfe03800c
#define P_SMARTCARD_INTR                           (volatile uint32_t *)0xfe038010
#define P_SMARTCARD_REG5                           (volatile uint32_t *)0xfe038014
#define P_SMARTCARD_REG6                           (volatile uint32_t *)0xfe038018
#define P_SMARTCARD_FIFO                           (volatile uint32_t *)0xfe03801c
#define P_SMARTCARD_REG8                           (volatile uint32_t *)0xfe038020
//========================================================================
//  CAPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe012000
// -----------------------------------------------
#define P_CAPU_RANGE7_EDA                          (volatile uint32_t *)0xfe0123a0
#define P_CAPU_RANGE6_EDA                          (volatile uint32_t *)0xfe01239c
#define P_CAPU_RANGE5_EDA                          (volatile uint32_t *)0xfe012398
#define P_CAPU_RANGE4_EDA                          (volatile uint32_t *)0xfe012394
#define P_CAPU_RANGE3_EDA                          (volatile uint32_t *)0xfe012390
#define P_CAPU_RANGE2_EDA                          (volatile uint32_t *)0xfe01238c
#define P_CAPU_RANGE1_EDA                          (volatile uint32_t *)0xfe012388
#define P_CAPU_RANGE0_EDA                          (volatile uint32_t *)0xfe012384
#define P_CAPU_RANGE7_STA                          (volatile uint32_t *)0xfe012380
#define P_CAPU_RANGE6_STA                          (volatile uint32_t *)0xfe01237c
#define P_CAPU_RANGE5_STA                          (volatile uint32_t *)0xfe012378
#define P_CAPU_RANGE4_STA                          (volatile uint32_t *)0xfe012374
#define P_CAPU_RANGE3_STA                          (volatile uint32_t *)0xfe012370
#define P_CAPU_RANGE2_STA                          (volatile uint32_t *)0xfe01236c
#define P_CAPU_RANGE1_STA                          (volatile uint32_t *)0xfe012368
#define P_CAPU_RANGE0_STA                          (volatile uint32_t *)0xfe012364
#define P_CAPU_RANGE8_CTRL                         (volatile uint32_t *)0xfe012360
#define P_CAPU_RANGE7_CTRL                         (volatile uint32_t *)0xfe01235c
#define P_CAPU_RANGE6_CTRL                         (volatile uint32_t *)0xfe012358
#define P_CAPU_RANGE5_CTRL                         (volatile uint32_t *)0xfe012354
#define P_CAPU_RANGE4_CTRL                         (volatile uint32_t *)0xfe012350
#define P_CAPU_RANGE3_CTRL                         (volatile uint32_t *)0xfe01234c
#define P_CAPU_RANGE2_CTRL                         (volatile uint32_t *)0xfe012348
#define P_CAPU_RANGE1_CTRL                         (volatile uint32_t *)0xfe012344
#define P_CAPU_RANGE0_CTRL                         (volatile uint32_t *)0xfe012340
//`define CAPU_ACCESS_EN_AHB_ETH                        8'hC2
//`define CAPU_ACCESS_EN_AHB_USB0                       8'hC1
//`define CAPU_ACCESS_EN_AHB_USB1                       8'hC0
#define P_CAPU_ACCESS_EN_16M_SLOT0                 (volatile uint32_t *)0xfe0122c0
#define P_CAPU_ACCESS_EN_256K_SLOT1                (volatile uint32_t *)0xfe012284
#define P_CAPU_ACCESS_EN_256K_SLOT0                (volatile uint32_t *)0xfe012280
#define P_CAPU_ACCESS_EN_64K_SLOT6                 (volatile uint32_t *)0xfe012218
#define P_CAPU_ACCESS_EN_64K_SLOT5                 (volatile uint32_t *)0xfe012214
#define P_CAPU_ACCESS_EN_64K_SLOT4                 (volatile uint32_t *)0xfe012210
#define P_CAPU_ACCESS_EN_64K_SLOT3                 (volatile uint32_t *)0xfe01220c
#define P_CAPU_ACCESS_EN_64K_SLOT2                 (volatile uint32_t *)0xfe012208
#define P_CAPU_ACCESS_EN_64K_SLOT1                 (volatile uint32_t *)0xfe012204
#define P_CAPU_ACCESS_EN_64K_SLOT0                 (volatile uint32_t *)0xfe012200
#define P_CAPU_ACCESS_EN_8K_SLOT4F                 (volatile uint32_t *)0xfe01213c
#define P_CAPU_ACCESS_EN_8K_SLOT4E                 (volatile uint32_t *)0xfe012138
#define P_CAPU_ACCESS_EN_8K_SLOT4D                 (volatile uint32_t *)0xfe012134
#define P_CAPU_ACCESS_EN_8K_SLOT4C                 (volatile uint32_t *)0xfe012130
#define P_CAPU_ACCESS_EN_8K_SLOT4B                 (volatile uint32_t *)0xfe01212c
#define P_CAPU_ACCESS_EN_8K_SLOT4A                 (volatile uint32_t *)0xfe012128
#define P_CAPU_ACCESS_EN_8K_SLOT49                 (volatile uint32_t *)0xfe012124
#define P_CAPU_ACCESS_EN_8K_SLOT48                 (volatile uint32_t *)0xfe012120
#define P_CAPU_ACCESS_EN_8K_SLOT47                 (volatile uint32_t *)0xfe01211c
#define P_CAPU_ACCESS_EN_8K_SLOT46                 (volatile uint32_t *)0xfe012118
#define P_CAPU_ACCESS_EN_8K_SLOT45                 (volatile uint32_t *)0xfe012114
#define P_CAPU_ACCESS_EN_8K_SLOT44                 (volatile uint32_t *)0xfe012110
#define P_CAPU_ACCESS_EN_8K_SLOT43                 (volatile uint32_t *)0xfe01210c
#define P_CAPU_ACCESS_EN_8K_SLOT42                 (volatile uint32_t *)0xfe012108
#define P_CAPU_ACCESS_EN_8K_SLOT41                 (volatile uint32_t *)0xfe012104
#define P_CAPU_ACCESS_EN_8K_SLOT40                 (volatile uint32_t *)0xfe012100
#define P_CAPU_ACCESS_EN_8K_SLOT3F                 (volatile uint32_t *)0xfe0120fc
#define P_CAPU_ACCESS_EN_8K_SLOT3E                 (volatile uint32_t *)0xfe0120f8
#define P_CAPU_ACCESS_EN_8K_SLOT3D                 (volatile uint32_t *)0xfe0120f4
#define P_CAPU_ACCESS_EN_8K_SLOT3C                 (volatile uint32_t *)0xfe0120f0
#define P_CAPU_ACCESS_EN_8K_SLOT3B                 (volatile uint32_t *)0xfe0120ec
#define P_CAPU_ACCESS_EN_8K_SLOT3A                 (volatile uint32_t *)0xfe0120e8
#define P_CAPU_ACCESS_EN_8K_SLOT39                 (volatile uint32_t *)0xfe0120e4
#define P_CAPU_ACCESS_EN_8K_SLOT38                 (volatile uint32_t *)0xfe0120e0
#define P_CAPU_ACCESS_EN_8K_SLOT37                 (volatile uint32_t *)0xfe0120dc
#define P_CAPU_ACCESS_EN_8K_SLOT36                 (volatile uint32_t *)0xfe0120d8
#define P_CAPU_ACCESS_EN_8K_SLOT35                 (volatile uint32_t *)0xfe0120d4
#define P_CAPU_ACCESS_EN_8K_SLOT34                 (volatile uint32_t *)0xfe0120d0
#define P_CAPU_ACCESS_EN_8K_SLOT33                 (volatile uint32_t *)0xfe0120cc
#define P_CAPU_ACCESS_EN_8K_SLOT32                 (volatile uint32_t *)0xfe0120c8
#define P_CAPU_ACCESS_EN_8K_SLOT31                 (volatile uint32_t *)0xfe0120c4
#define P_CAPU_ACCESS_EN_8K_SLOT30                 (volatile uint32_t *)0xfe0120c0
#define P_CAPU_ACCESS_EN_8K_SLOT2F                 (volatile uint32_t *)0xfe0120bc
#define P_CAPU_ACCESS_EN_8K_SLOT2E                 (volatile uint32_t *)0xfe0120b8
#define P_CAPU_ACCESS_EN_8K_SLOT2D                 (volatile uint32_t *)0xfe0120b4
#define P_CAPU_ACCESS_EN_8K_SLOT2C                 (volatile uint32_t *)0xfe0120b0
#define P_CAPU_ACCESS_EN_8K_SLOT2B                 (volatile uint32_t *)0xfe0120ac
#define P_CAPU_ACCESS_EN_8K_SLOT2A                 (volatile uint32_t *)0xfe0120a8
#define P_CAPU_ACCESS_EN_8K_SLOT29                 (volatile uint32_t *)0xfe0120a4
#define P_CAPU_ACCESS_EN_8K_SLOT28                 (volatile uint32_t *)0xfe0120a0
#define P_CAPU_ACCESS_EN_8K_SLOT27                 (volatile uint32_t *)0xfe01209c
#define P_CAPU_ACCESS_EN_8K_SLOT26                 (volatile uint32_t *)0xfe012098
#define P_CAPU_ACCESS_EN_8K_SLOT25                 (volatile uint32_t *)0xfe012094
#define P_CAPU_ACCESS_EN_8K_SLOT24                 (volatile uint32_t *)0xfe012090
#define P_CAPU_ACCESS_EN_8K_SLOT23                 (volatile uint32_t *)0xfe01208c
#define P_CAPU_ACCESS_EN_8K_SLOT22                 (volatile uint32_t *)0xfe012088
#define P_CAPU_ACCESS_EN_8K_SLOT21                 (volatile uint32_t *)0xfe012084
#define P_CAPU_ACCESS_EN_8K_SLOT20                 (volatile uint32_t *)0xfe012080
#define P_CAPU_ACCESS_EN_8K_SLOT1F                 (volatile uint32_t *)0xfe01207c
#define P_CAPU_ACCESS_EN_8K_SLOT1E                 (volatile uint32_t *)0xfe012078
#define P_CAPU_ACCESS_EN_8K_SLOT1D                 (volatile uint32_t *)0xfe012074
#define P_CAPU_ACCESS_EN_8K_SLOT1C                 (volatile uint32_t *)0xfe012070
#define P_CAPU_ACCESS_EN_8K_SLOT1B                 (volatile uint32_t *)0xfe01206c
#define P_CAPU_ACCESS_EN_8K_SLOT1A                 (volatile uint32_t *)0xfe012068
#define P_CAPU_ACCESS_EN_8K_SLOT19                 (volatile uint32_t *)0xfe012064
#define P_CAPU_ACCESS_EN_8K_SLOT18                 (volatile uint32_t *)0xfe012060
#define P_CAPU_ACCESS_EN_8K_SLOT17                 (volatile uint32_t *)0xfe01205c
#define P_CAPU_ACCESS_EN_8K_SLOT16                 (volatile uint32_t *)0xfe012058
#define P_CAPU_ACCESS_EN_8K_SLOT15                 (volatile uint32_t *)0xfe012054
#define P_CAPU_ACCESS_EN_8K_SLOT14                 (volatile uint32_t *)0xfe012050
#define P_CAPU_ACCESS_EN_8K_SLOT13                 (volatile uint32_t *)0xfe01204c
#define P_CAPU_ACCESS_EN_8K_SLOT12                 (volatile uint32_t *)0xfe012048
#define P_CAPU_ACCESS_EN_8K_SLOT11                 (volatile uint32_t *)0xfe012044
#define P_CAPU_ACCESS_EN_8K_SLOT10                 (volatile uint32_t *)0xfe012040
#define P_CAPU_ACCESS_EN_8K_SLOT0F                 (volatile uint32_t *)0xfe01203c
#define P_CAPU_ACCESS_EN_8K_SLOT0E                 (volatile uint32_t *)0xfe012038
#define P_CAPU_ACCESS_EN_8K_SLOT0D                 (volatile uint32_t *)0xfe012034
#define P_CAPU_ACCESS_EN_8K_SLOT0C                 (volatile uint32_t *)0xfe012030
#define P_CAPU_ACCESS_EN_8K_SLOT0B                 (volatile uint32_t *)0xfe01202c
#define P_CAPU_ACCESS_EN_8K_SLOT0A                 (volatile uint32_t *)0xfe012028
#define P_CAPU_ACCESS_EN_8K_SLOT09                 (volatile uint32_t *)0xfe012024
#define P_CAPU_ACCESS_EN_8K_SLOT08                 (volatile uint32_t *)0xfe012020
#define P_CAPU_ACCESS_EN_8K_SLOT07                 (volatile uint32_t *)0xfe01201c
#define P_CAPU_ACCESS_EN_8K_SLOT06                 (volatile uint32_t *)0xfe012018
#define P_CAPU_ACCESS_EN_8K_SLOT05                 (volatile uint32_t *)0xfe012014
#define P_CAPU_ACCESS_EN_8K_SLOT04                 (volatile uint32_t *)0xfe012010
#define P_CAPU_ACCESS_EN_8K_SLOT03                 (volatile uint32_t *)0xfe01200c
#define P_CAPU_ACCESS_EN_8K_SLOT02                 (volatile uint32_t *)0xfe012008
#define P_CAPU_ACCESS_EN_8K_SLOT01                 (volatile uint32_t *)0xfe012004
#define P_CAPU_ACCESS_EN_8K_SLOT00                 (volatile uint32_t *)0xfe012000
//========================================================================
//  HDMI20_AES
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09a000
// -----------------------------------------------
#define P_HDMI20_AES_CNTL0                         (volatile uint32_t *)0xfe09a000
#define P_HDMI20_AES_DATA                          (volatile uint32_t *)0xfe09a004
#define P_HDMI20_AES_STAT0                         (volatile uint32_t *)0xfe09a008
#define P_HDMI20_AES_RESET                         (volatile uint32_t *)0xfe09a00c
#define P_HDMI20_AES_IV0                           (volatile uint32_t *)0xfe09a010
#define P_HDMI20_AES_IV1                           (volatile uint32_t *)0xfe09a014
#define P_HDMI20_AES_IV2                           (volatile uint32_t *)0xfe09a018
#define P_HDMI20_AES_IV3                           (volatile uint32_t *)0xfe09a01c
#define P_HDMI20_AES_IV_LOAD                       (volatile uint32_t *)0xfe09a020
#define P_HDMI20_AES_KEY_WORD0                     (volatile uint32_t *)0xfe09a024
#define P_HDMI20_AES_KEY_WORD1                     (volatile uint32_t *)0xfe09a028
#define P_HDMI20_AES_KEY_WORD2                     (volatile uint32_t *)0xfe09a02c
#define P_HDMI20_AES_KEY_WORD3                     (volatile uint32_t *)0xfe09a030
//========================================================================
//  BT656
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe030000
// -----------------------------------------------
//`define BT_CTRL                         8'h00
//    `define BT_SOFT_RESET           31      // Soft reset
//    `define BT_JPEG_START           30
//    `define BT_JPEG_IGNORE_BYTES    18     //20:18
//    `define BT_JPEG_IGNORE_LAST     17
//    `define BT_UPDATE_ST_SEL        16
//    `define BT_COLOR_REPEAT         15
//    `define BT_VIDEO_MODE           13     // 14:13
//    `define BT_AUTO_FMT             12
//    `define BT_PROG_MODE            11
//    `define BT_JPEG_MODE            10
//    `define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
//    `define BT_FID_EN_BIT           8       // 1 : enable use FID port.
//    `define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
//    `define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
//    `define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
//    `define BT_SLICE_MODE_BIT       4       // 1 : no ancillary flag     0 : with ancillary flag.
//    `define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
//    `define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
//    `define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
//    `define BT_EN_BIT               0       // 1 : enable.
//`define BT_VBISTART                     8'h01
//`define BT_VBIEND                       8'h02
//`define BT_FIELDSADR                    8'h03
//`define BT_LINECTRL                     8'h04
//`define BT_VIDEOSTART                   8'h05
//`define BT_VIDEOEND                     8'h06
//`define BT_SLICELINE0                   8'h07
//`define BT_SLICELINE1                   8'h08
//`define BT_PORT_CTRL                    8'h09
//  `define BT_HSYNC_PHASE           0
//  `define BT_VSYNC_PHASE           1
//  `define BT_HSYNC_PULSE           2
//  `define BT_VSYNC_PULSE           3
//  `define BT_FID_PHASE             4
//  `define BT_FID_HSVS              5
//  `define BT_IDQ_EN                6
//  `define BT_IDQ_PHASE             7
//  `define BT_D8B                   8
//  `define BT_10BTO8B               9
//  `define BT_FID_DELAY            10    //12:10
//  `define BT_VSYNC_DELAY          13    //
//  `define BT_HSYNC_DELAY          16
//  `define BT_FID_HSVS_PCNT        19
//  `define BT_FID_HSVS_VS_RISING   20
//  `define BT_FID_HSVS_VS_FALLING  21
//  `define BT_VREF_FROM_VS_ONLY    22
//  `define BT_PORT_ACTIVE_HMODE    23
//  `define BT_DUAL_EDGE_CLK_EN     24
//  `define BT_CLK_INV_SEL          25
//  `define BT_DATA_ENDIAN          26
//
//`define BT_SWAP_CTRL                    8'h0a
//`define BT_601_CTRL0                    8'h0e
//`define BT_601_CTRL1                    8'h0f
//`define BT_601_CTRL2                    8'h10
//`define BT_601_CTRL3                    8'h11
//`define BT_FIELD_LUMA                   8'h12
//`define BT_RAW_CTRL                     8'h13
//`define BT_STATUS                       8'h14
//`define BT_INT_CTRL                     8'h15
//`define BT_VLINE_STATUS                 8'h17
//`define BT_ERR_CNT                      8'h19
//`define BT_LCNT_STATUS                  8'h1a
//`define BT_PCNT_STATUS                  8'h1c
//`define BT_DELAY_CTRL                   8'h1d
//
//`define BT_REF_000                      8'h20
//`define BT_REF_001                      8'h21
//`define BT_REF_010                      8'h22
//`define BT_REF_011                      8'h23
//`define BT_REF_100                      8'h24
//`define BT_REF_101                      8'h25
//`define BT_REF_110                      8'h26
//`define BT_REF_111                      8'h27
//========================================================================
//  PDM
//========================================================================
//`include "../audio/rtl/pdm_reg.vh"
//
// Reading file:  REG_LIST_AUDIO_RTL.h
//
//========================================================================
//  AUDIO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe330000
// -----------------------------------------------
#define P_EE_AUDIO_CLK_GATE_EN0                    (volatile uint32_t *)0xfe330000
#define P_EE_AUDIO_CLK_GATE_EN1                    (volatile uint32_t *)0xfe330004
#define P_EE_AUDIO_MCLK_A_CTRL                     (volatile uint32_t *)0xfe330008
#define P_EE_AUDIO_MCLK_B_CTRL                     (volatile uint32_t *)0xfe33000c
#define P_EE_AUDIO_MCLK_C_CTRL                     (volatile uint32_t *)0xfe330010
#define P_EE_AUDIO_MCLK_D_CTRL                     (volatile uint32_t *)0xfe330014
#define P_EE_AUDIO_MCLK_E_CTRL                     (volatile uint32_t *)0xfe330018
#define P_EE_AUDIO_MCLK_F_CTRL                     (volatile uint32_t *)0xfe33001c
#define P_EE_AUDIO_SW_RESET0                       (volatile uint32_t *)0xfe330028
#define P_EE_AUDIO_SW_RESET1                       (volatile uint32_t *)0xfe33002c
#define P_EE_AUDIO_CLK81_CTRL                      (volatile uint32_t *)0xfe330030
#define P_EE_AUDIO_CLK81_EN                        (volatile uint32_t *)0xfe330034
#define P_EE_AUDIO_MST_A_SCLK_CTRL0                (volatile uint32_t *)0xfe330040
#define P_EE_AUDIO_MST_A_SCLK_CTRL1                (volatile uint32_t *)0xfe330044
#define P_EE_AUDIO_MST_B_SCLK_CTRL0                (volatile uint32_t *)0xfe330048
#define P_EE_AUDIO_MST_B_SCLK_CTRL1                (volatile uint32_t *)0xfe33004c
#define P_EE_AUDIO_MST_C_SCLK_CTRL0                (volatile uint32_t *)0xfe330050
#define P_EE_AUDIO_MST_C_SCLK_CTRL1                (volatile uint32_t *)0xfe330054
#define P_EE_AUDIO_MST_D_SCLK_CTRL0                (volatile uint32_t *)0xfe330058
#define P_EE_AUDIO_MST_D_SCLK_CTRL1                (volatile uint32_t *)0xfe33005c
#define P_EE_AUDIO_MST_E_SCLK_CTRL0                (volatile uint32_t *)0xfe330060
#define P_EE_AUDIO_MST_E_SCLK_CTRL1                (volatile uint32_t *)0xfe330064
#define P_EE_AUDIO_MST_F_SCLK_CTRL0                (volatile uint32_t *)0xfe330068
#define P_EE_AUDIO_MST_F_SCLK_CTRL1                (volatile uint32_t *)0xfe33006c
#define P_EE_AUDIO_MST_DLY_CTRL0                   (volatile uint32_t *)0xfe330070
#define P_EE_AUDIO_MST_DLY_CTRL1                   (volatile uint32_t *)0xfe330074
#define P_EE_AUDIO_CLK_TDMIN_A_CTRL                (volatile uint32_t *)0xfe330080
#define P_EE_AUDIO_CLK_TDMIN_B_CTRL                (volatile uint32_t *)0xfe330084
#define P_EE_AUDIO_CLK_TDMIN_C_CTRL                (volatile uint32_t *)0xfe330088
#define P_EE_AUDIO_CLK_TDMIN_LB_CTRL               (volatile uint32_t *)0xfe33008c
#define P_EE_AUDIO_CLK_TDMOUT_A_CTRL               (volatile uint32_t *)0xfe330090
#define P_EE_AUDIO_CLK_TDMOUT_B_CTRL               (volatile uint32_t *)0xfe330094
#define P_EE_AUDIO_CLK_TDMOUT_C_CTRL               (volatile uint32_t *)0xfe330098
#define P_EE_AUDIO_CLK_SPDIFIN_CTRL                (volatile uint32_t *)0xfe33009c
#define P_EE_AUDIO_CLK_SPDIFOUT_CTRL               (volatile uint32_t *)0xfe3300a0
#define P_EE_AUDIO_CLK_RESAMPLEA_CTRL              (volatile uint32_t *)0xfe3300a4
#define P_EE_AUDIO_CLK_LOCKER_CTRL                 (volatile uint32_t *)0xfe3300a8
#define P_EE_AUDIO_CLK_PDMIN_CTRL0                 (volatile uint32_t *)0xfe3300ac
#define P_EE_AUDIO_CLK_PDMIN_CTRL1                 (volatile uint32_t *)0xfe3300b0
#define P_EE_AUDIO_CLK_SPDIFOUT_B_CTRL             (volatile uint32_t *)0xfe3300b4
#define P_EE_AUDIO_CLK_RESAMPLEB_CTRL              (volatile uint32_t *)0xfe3300b8
#define P_EE_AUDIO_CLK_SPDIFIN_LB_CTRL             (volatile uint32_t *)0xfe3300bc
#define P_EE_AUDIO_CLK_EQDRC_CTRL0                 (volatile uint32_t *)0xfe3300c0
#define P_EE_AUDIO_VAD_CLK_CTRL                    (volatile uint32_t *)0xfe3300c4
#define P_EE_AUDIO_EARCTX_CMDC_CLK_CTRL            (volatile uint32_t *)0xfe3300c8
#define P_EE_AUDIO_EARCTX_DMAC_CLK_CTRL            (volatile uint32_t *)0xfe3300cc
#define P_EE_AUDIO_EARCRX_CMDC_CLK_CTRL            (volatile uint32_t *)0xfe3300d0
#define P_EE_AUDIO_EARCRX_DMAC_CLK_CTRL            (volatile uint32_t *)0xfe3300d4
#define P_EE_AUDIO_CLK_LOCKERB_CTRL                (volatile uint32_t *)0xfe3300d8
#define P_EE_AUDIO_TODDR_A_CTRL0                   (volatile uint32_t *)0xfe330100
#define P_EE_AUDIO_TODDR_A_CTRL1                   (volatile uint32_t *)0xfe330104
#define P_EE_AUDIO_TODDR_A_START_ADDR              (volatile uint32_t *)0xfe330108
#define P_EE_AUDIO_TODDR_A_FINISH_ADDR             (volatile uint32_t *)0xfe33010c
#define P_EE_AUDIO_TODDR_A_INT_ADDR                (volatile uint32_t *)0xfe330110
#define P_EE_AUDIO_TODDR_A_STATUS1                 (volatile uint32_t *)0xfe330114
#define P_EE_AUDIO_TODDR_A_STATUS2                 (volatile uint32_t *)0xfe330118
#define P_EE_AUDIO_TODDR_A_START_ADDRB             (volatile uint32_t *)0xfe33011c
#define P_EE_AUDIO_TODDR_A_FINISH_ADDRB            (volatile uint32_t *)0xfe330120
#define P_EE_AUDIO_TODDR_A_INIT_ADDR               (volatile uint32_t *)0xfe330124
#define P_EE_AUDIO_TODDR_A_CTRL2                   (volatile uint32_t *)0xfe330128
#define P_EE_AUDIO_TODDR_B_CTRL0                   (volatile uint32_t *)0xfe330140
#define P_EE_AUDIO_TODDR_B_CTRL1                   (volatile uint32_t *)0xfe330144
#define P_EE_AUDIO_TODDR_B_START_ADDR              (volatile uint32_t *)0xfe330148
#define P_EE_AUDIO_TODDR_B_FINISH_ADDR             (volatile uint32_t *)0xfe33014c
#define P_EE_AUDIO_TODDR_B_INT_ADDR                (volatile uint32_t *)0xfe330150
#define P_EE_AUDIO_TODDR_B_STATUS1                 (volatile uint32_t *)0xfe330154
#define P_EE_AUDIO_TODDR_B_STATUS2                 (volatile uint32_t *)0xfe330158
#define P_EE_AUDIO_TODDR_B_START_ADDRB             (volatile uint32_t *)0xfe33015c
#define P_EE_AUDIO_TODDR_B_FINISH_ADDRB            (volatile uint32_t *)0xfe330160
#define P_EE_AUDIO_TODDR_B_INIT_ADDR               (volatile uint32_t *)0xfe330164
#define P_EE_AUDIO_TODDR_B_CTRL2                   (volatile uint32_t *)0xfe330168
#define P_EE_AUDIO_TODDR_C_CTRL0                   (volatile uint32_t *)0xfe330180
#define P_EE_AUDIO_TODDR_C_CTRL1                   (volatile uint32_t *)0xfe330184
#define P_EE_AUDIO_TODDR_C_START_ADDR              (volatile uint32_t *)0xfe330188
#define P_EE_AUDIO_TODDR_C_FINISH_ADDR             (volatile uint32_t *)0xfe33018c
#define P_EE_AUDIO_TODDR_C_INT_ADDR                (volatile uint32_t *)0xfe330190
#define P_EE_AUDIO_TODDR_C_STATUS1                 (volatile uint32_t *)0xfe330194
#define P_EE_AUDIO_TODDR_C_STATUS2                 (volatile uint32_t *)0xfe330198
#define P_EE_AUDIO_TODDR_C_START_ADDRB             (volatile uint32_t *)0xfe33019c
#define P_EE_AUDIO_TODDR_C_FINISH_ADDRB            (volatile uint32_t *)0xfe3301a0
#define P_EE_AUDIO_TODDR_C_INIT_ADDR               (volatile uint32_t *)0xfe3301a4
#define P_EE_AUDIO_TODDR_C_CTRL2                   (volatile uint32_t *)0xfe3301a8
#define P_EE_AUDIO_FRDDR_A_CTRL0                   (volatile uint32_t *)0xfe3301c0
#define P_EE_AUDIO_FRDDR_A_CTRL1                   (volatile uint32_t *)0xfe3301c4
#define P_EE_AUDIO_FRDDR_A_START_ADDR              (volatile uint32_t *)0xfe3301c8
#define P_EE_AUDIO_FRDDR_A_FINISH_ADDR             (volatile uint32_t *)0xfe3301cc
#define P_EE_AUDIO_FRDDR_A_INT_ADDR                (volatile uint32_t *)0xfe3301d0
#define P_EE_AUDIO_FRDDR_A_STATUS1                 (volatile uint32_t *)0xfe3301d4
#define P_EE_AUDIO_FRDDR_A_STATUS2                 (volatile uint32_t *)0xfe3301d8
#define P_EE_AUDIO_FRDDR_A_START_ADDRB             (volatile uint32_t *)0xfe3301dc
#define P_EE_AUDIO_FRDDR_A_FINISH_ADDRB            (volatile uint32_t *)0xfe3301e0
#define P_EE_AUDIO_FRDDR_A_INIT_ADDR               (volatile uint32_t *)0xfe3301e4
#define P_EE_AUDIO_FRDDR_A_CTRL2                   (volatile uint32_t *)0xfe3301e8
#define P_EE_AUDIO_FRDDR_B_CTRL0                   (volatile uint32_t *)0xfe330200
#define P_EE_AUDIO_FRDDR_B_CTRL1                   (volatile uint32_t *)0xfe330204
#define P_EE_AUDIO_FRDDR_B_START_ADDR              (volatile uint32_t *)0xfe330208
#define P_EE_AUDIO_FRDDR_B_FINISH_ADDR             (volatile uint32_t *)0xfe33020c
#define P_EE_AUDIO_FRDDR_B_INT_ADDR                (volatile uint32_t *)0xfe330210
#define P_EE_AUDIO_FRDDR_B_STATUS1                 (volatile uint32_t *)0xfe330214
#define P_EE_AUDIO_FRDDR_B_STATUS2                 (volatile uint32_t *)0xfe330218
#define P_EE_AUDIO_FRDDR_B_START_ADDRB             (volatile uint32_t *)0xfe33021c
#define P_EE_AUDIO_FRDDR_B_FINISH_ADDRB            (volatile uint32_t *)0xfe330220
#define P_EE_AUDIO_FRDDR_B_INIT_ADDR               (volatile uint32_t *)0xfe330224
#define P_EE_AUDIO_FRDDR_B_CTRL2                   (volatile uint32_t *)0xfe330228
#define P_EE_AUDIO_FRDDR_C_CTRL0                   (volatile uint32_t *)0xfe330240
#define P_EE_AUDIO_FRDDR_C_CTRL1                   (volatile uint32_t *)0xfe330244
#define P_EE_AUDIO_FRDDR_C_START_ADDR              (volatile uint32_t *)0xfe330248
#define P_EE_AUDIO_FRDDR_C_FINISH_ADDR             (volatile uint32_t *)0xfe33024c
#define P_EE_AUDIO_FRDDR_C_INT_ADDR                (volatile uint32_t *)0xfe330250
#define P_EE_AUDIO_FRDDR_C_STATUS1                 (volatile uint32_t *)0xfe330254
#define P_EE_AUDIO_FRDDR_C_STATUS2                 (volatile uint32_t *)0xfe330258
#define P_EE_AUDIO_FRDDR_C_START_ADDRB             (volatile uint32_t *)0xfe33025c
#define P_EE_AUDIO_FRDDR_C_FINISH_ADDRB            (volatile uint32_t *)0xfe330260
#define P_EE_AUDIO_FRDDR_C_INIT_ADDR               (volatile uint32_t *)0xfe330264
#define P_EE_AUDIO_FRDDR_C_CTRL2                   (volatile uint32_t *)0xfe330268
#define P_EE_AUDIO_ARB_CTRL0                       (volatile uint32_t *)0xfe330280
#define P_EE_AUDIO_ARB_CTRL1                       (volatile uint32_t *)0xfe330284
#define P_EE_AUDIO_ARB_STS                         (volatile uint32_t *)0xfe3302a0
#define P_EE_AUDIO_LB_A_CTRL0                      (volatile uint32_t *)0xfe3302c0
#define P_EE_AUDIO_LB_A_CTRL1                      (volatile uint32_t *)0xfe3302c4
#define P_EE_AUDIO_LB_A_CTRL2                      (volatile uint32_t *)0xfe3302c8
#define P_EE_AUDIO_LB_A_CTRL3                      (volatile uint32_t *)0xfe3302cc
#define P_EE_AUDIO_LB_A_DAT_CH_ID0                 (volatile uint32_t *)0xfe3302d0
#define P_EE_AUDIO_LB_A_DAT_CH_ID1                 (volatile uint32_t *)0xfe3302d4
#define P_EE_AUDIO_LB_A_DAT_CH_ID2                 (volatile uint32_t *)0xfe3302d8
#define P_EE_AUDIO_LB_A_DAT_CH_ID3                 (volatile uint32_t *)0xfe3302dc
#define P_EE_AUDIO_LB_A_LB_CH_ID0                  (volatile uint32_t *)0xfe3302e0
#define P_EE_AUDIO_LB_A_LB_CH_ID1                  (volatile uint32_t *)0xfe3302e4
#define P_EE_AUDIO_LB_A_LB_CH_ID2                  (volatile uint32_t *)0xfe3302e8
#define P_EE_AUDIO_LB_A_LB_CH_ID3                  (volatile uint32_t *)0xfe3302ec
#define P_EE_AUDIO_LB_A_STS                        (volatile uint32_t *)0xfe3302f0
#define P_EE_AUDIO_LB_A_CHSYNC_CTRL_INSERT         (volatile uint32_t *)0xfe3302f4
#define P_EE_AUDIO_LB_A_CHSYNC_CTRL_ORIG           (volatile uint32_t *)0xfe3302f8
#define P_EE_AUDIO_LB_A_CTRL4                      (volatile uint32_t *)0xfe3302fc
#define P_EE_AUDIO_TDMIN_A_CTRL                    (volatile uint32_t *)0xfe330300
#define P_EE_AUDIO_TDMIN_A_SWAP0                   (volatile uint32_t *)0xfe330304
#define P_EE_AUDIO_TDMIN_A_MASK0                   (volatile uint32_t *)0xfe330308
#define P_EE_AUDIO_TDMIN_A_MASK1                   (volatile uint32_t *)0xfe33030c
#define P_EE_AUDIO_TDMIN_A_MASK2                   (volatile uint32_t *)0xfe330310
#define P_EE_AUDIO_TDMIN_A_MASK3                   (volatile uint32_t *)0xfe330314
#define P_EE_AUDIO_TDMIN_A_STAT                    (volatile uint32_t *)0xfe330318
#define P_EE_AUDIO_TDMIN_A_MUTE_VAL                (volatile uint32_t *)0xfe33031c
#define P_EE_AUDIO_TDMIN_A_MUTE0                   (volatile uint32_t *)0xfe330320
#define P_EE_AUDIO_TDMIN_A_MUTE1                   (volatile uint32_t *)0xfe330324
#define P_EE_AUDIO_TDMIN_A_MUTE2                   (volatile uint32_t *)0xfe330328
#define P_EE_AUDIO_TDMIN_A_MUTE3                   (volatile uint32_t *)0xfe33032c
#define P_EE_AUDIO_TDMIN_B_CTRL                    (volatile uint32_t *)0xfe330340
#define P_EE_AUDIO_TDMIN_B_SWAP0                   (volatile uint32_t *)0xfe330344
#define P_EE_AUDIO_TDMIN_B_MASK0                   (volatile uint32_t *)0xfe330348
#define P_EE_AUDIO_TDMIN_B_MASK1                   (volatile uint32_t *)0xfe33034c
#define P_EE_AUDIO_TDMIN_B_MASK2                   (volatile uint32_t *)0xfe330350
#define P_EE_AUDIO_TDMIN_B_MASK3                   (volatile uint32_t *)0xfe330354
#define P_EE_AUDIO_TDMIN_B_STAT                    (volatile uint32_t *)0xfe330358
#define P_EE_AUDIO_TDMIN_B_MUTE_VAL                (volatile uint32_t *)0xfe33035c
#define P_EE_AUDIO_TDMIN_B_MUTE0                   (volatile uint32_t *)0xfe330360
#define P_EE_AUDIO_TDMIN_B_MUTE1                   (volatile uint32_t *)0xfe330364
#define P_EE_AUDIO_TDMIN_B_MUTE2                   (volatile uint32_t *)0xfe330368
#define P_EE_AUDIO_TDMIN_B_MUTE3                   (volatile uint32_t *)0xfe33036c
#define P_EE_AUDIO_TDMIN_C_CTRL                    (volatile uint32_t *)0xfe330380
#define P_EE_AUDIO_TDMIN_C_SWAP0                   (volatile uint32_t *)0xfe330384
#define P_EE_AUDIO_TDMIN_C_MASK0                   (volatile uint32_t *)0xfe330388
#define P_EE_AUDIO_TDMIN_C_MASK1                   (volatile uint32_t *)0xfe33038c
#define P_EE_AUDIO_TDMIN_C_MASK2                   (volatile uint32_t *)0xfe330390
#define P_EE_AUDIO_TDMIN_C_MASK3                   (volatile uint32_t *)0xfe330394
#define P_EE_AUDIO_TDMIN_C_STAT                    (volatile uint32_t *)0xfe330398
#define P_EE_AUDIO_TDMIN_C_MUTE_VAL                (volatile uint32_t *)0xfe33039c
#define P_EE_AUDIO_TDMIN_C_MUTE0                   (volatile uint32_t *)0xfe3303a0
#define P_EE_AUDIO_TDMIN_C_MUTE1                   (volatile uint32_t *)0xfe3303a4
#define P_EE_AUDIO_TDMIN_C_MUTE2                   (volatile uint32_t *)0xfe3303a8
#define P_EE_AUDIO_TDMIN_C_MUTE3                   (volatile uint32_t *)0xfe3303ac
#define P_EE_AUDIO_TDMIN_LB_CTRL                   (volatile uint32_t *)0xfe3303c0
#define P_EE_AUDIO_TDMIN_LB_SWAP0                  (volatile uint32_t *)0xfe3303c4
#define P_EE_AUDIO_TDMIN_LB_MASK0                  (volatile uint32_t *)0xfe3303c8
#define P_EE_AUDIO_TDMIN_LB_MASK1                  (volatile uint32_t *)0xfe3303cc
#define P_EE_AUDIO_TDMIN_LB_MASK2                  (volatile uint32_t *)0xfe3303d0
#define P_EE_AUDIO_TDMIN_LB_MASK3                  (volatile uint32_t *)0xfe3303d4
#define P_EE_AUDIO_TDMIN_LB_STAT                   (volatile uint32_t *)0xfe3303d8
#define P_EE_AUDIO_TDMIN_LB_MUTE_VAL               (volatile uint32_t *)0xfe3303dc
#define P_EE_AUDIO_TDMIN_LB_MUTE0                  (volatile uint32_t *)0xfe3303e0
#define P_EE_AUDIO_TDMIN_LB_MUTE1                  (volatile uint32_t *)0xfe3303e4
#define P_EE_AUDIO_TDMIN_LB_MUTE2                  (volatile uint32_t *)0xfe3303e8
#define P_EE_AUDIO_TDMIN_LB_MUTE3                  (volatile uint32_t *)0xfe3303ec
#define P_EE_AUDIO_SPDIFIN_CTRL0                   (volatile uint32_t *)0xfe330400
#define P_EE_AUDIO_SPDIFIN_CTRL1                   (volatile uint32_t *)0xfe330404
#define P_EE_AUDIO_SPDIFIN_CTRL2                   (volatile uint32_t *)0xfe330408
#define P_EE_AUDIO_SPDIFIN_CTRL3                   (volatile uint32_t *)0xfe33040c
#define P_EE_AUDIO_SPDIFIN_CTRL4                   (volatile uint32_t *)0xfe330410
#define P_EE_AUDIO_SPDIFIN_CTRL5                   (volatile uint32_t *)0xfe330414
#define P_EE_AUDIO_SPDIFIN_CTRL6                   (volatile uint32_t *)0xfe330418
#define P_EE_AUDIO_SPDIFIN_STAT0                   (volatile uint32_t *)0xfe33041c
#define P_EE_AUDIO_SPDIFIN_STAT1                   (volatile uint32_t *)0xfe330420
#define P_EE_AUDIO_SPDIFIN_STAT2                   (volatile uint32_t *)0xfe330424
#define P_EE_AUDIO_SPDIFIN_MUTE_VAL                (volatile uint32_t *)0xfe330428
#define P_EE_AUDIO_SPDIFIN_CTRL7                   (volatile uint32_t *)0xfe33042c
#define P_EE_AUDIO_RESAMPLEA_CTRL0                 (volatile uint32_t *)0xfe330440
#define P_EE_AUDIO_RESAMPLEA_CTRL1                 (volatile uint32_t *)0xfe330444
#define P_EE_AUDIO_RESAMPLEA_CTRL2                 (volatile uint32_t *)0xfe330448
#define P_EE_AUDIO_RESAMPLEA_CTRL3                 (volatile uint32_t *)0xfe33044c
#define P_EE_AUDIO_RESAMPLEA_COEF0                 (volatile uint32_t *)0xfe330450
#define P_EE_AUDIO_RESAMPLEA_COEF1                 (volatile uint32_t *)0xfe330454
#define P_EE_AUDIO_RESAMPLEA_COEF2                 (volatile uint32_t *)0xfe330458
#define P_EE_AUDIO_RESAMPLEA_COEF3                 (volatile uint32_t *)0xfe33045c
#define P_EE_AUDIO_RESAMPLEA_COEF4                 (volatile uint32_t *)0xfe330460
#define P_EE_AUDIO_RESAMPLEA_STATUS1               (volatile uint32_t *)0xfe330464
#define P_EE_AUDIO_SPDIFOUT_STAT                   (volatile uint32_t *)0xfe330480
#define P_EE_AUDIO_SPDIFOUT_GAIN0                  (volatile uint32_t *)0xfe330484
#define P_EE_AUDIO_SPDIFOUT_GAIN1                  (volatile uint32_t *)0xfe330488
#define P_EE_AUDIO_SPDIFOUT_CTRL0                  (volatile uint32_t *)0xfe33048c
#define P_EE_AUDIO_SPDIFOUT_CTRL1                  (volatile uint32_t *)0xfe330490
#define P_EE_AUDIO_SPDIFOUT_PREAMB                 (volatile uint32_t *)0xfe330494
#define P_EE_AUDIO_SPDIFOUT_SWAP                   (volatile uint32_t *)0xfe330498
#define P_EE_AUDIO_SPDIFOUT_CHSTS0                 (volatile uint32_t *)0xfe33049c
#define P_EE_AUDIO_SPDIFOUT_CHSTS1                 (volatile uint32_t *)0xfe3304a0
#define P_EE_AUDIO_SPDIFOUT_CHSTS2                 (volatile uint32_t *)0xfe3304a4
#define P_EE_AUDIO_SPDIFOUT_CHSTS3                 (volatile uint32_t *)0xfe3304a8
#define P_EE_AUDIO_SPDIFOUT_CHSTS4                 (volatile uint32_t *)0xfe3304ac
#define P_EE_AUDIO_SPDIFOUT_CHSTS5                 (volatile uint32_t *)0xfe3304b0
#define P_EE_AUDIO_SPDIFOUT_CHSTS6                 (volatile uint32_t *)0xfe3304b4
#define P_EE_AUDIO_SPDIFOUT_CHSTS7                 (volatile uint32_t *)0xfe3304b8
#define P_EE_AUDIO_SPDIFOUT_CHSTS8                 (volatile uint32_t *)0xfe3304bc
#define P_EE_AUDIO_SPDIFOUT_CHSTS9                 (volatile uint32_t *)0xfe3304c0
#define P_EE_AUDIO_SPDIFOUT_CHSTSA                 (volatile uint32_t *)0xfe3304c4
#define P_EE_AUDIO_SPDIFOUT_CHSTSB                 (volatile uint32_t *)0xfe3304c8
#define P_EE_AUDIO_SPDIFOUT_MUTE_VAL               (volatile uint32_t *)0xfe3304cc
#define P_EE_AUDIO_SPDIFOUT_GAIN2                  (volatile uint32_t *)0xfe3304d0
#define P_EE_AUDIO_SPDIFOUT_GAIN3                  (volatile uint32_t *)0xfe3304d4
#define P_EE_AUDIO_SPDIFOUT_GAIN_EN                (volatile uint32_t *)0xfe3304d8
#define P_EE_AUDIO_SPDIFOUT_GAIN_CTRL              (volatile uint32_t *)0xfe3304dc
#define P_EE_AUDIO_TDMOUT_A_CTRL0                  (volatile uint32_t *)0xfe330500
#define P_EE_AUDIO_TDMOUT_A_CTRL1                  (volatile uint32_t *)0xfe330504
#define P_EE_AUDIO_TDMOUT_A_SWAP0                  (volatile uint32_t *)0xfe330508
#define P_EE_AUDIO_TDMOUT_A_MASK0                  (volatile uint32_t *)0xfe33050c
#define P_EE_AUDIO_TDMOUT_A_MASK1                  (volatile uint32_t *)0xfe330510
#define P_EE_AUDIO_TDMOUT_A_MASK2                  (volatile uint32_t *)0xfe330514
#define P_EE_AUDIO_TDMOUT_A_MASK3                  (volatile uint32_t *)0xfe330518
#define P_EE_AUDIO_TDMOUT_A_STAT                   (volatile uint32_t *)0xfe33051c
#define P_EE_AUDIO_TDMOUT_A_GAIN0                  (volatile uint32_t *)0xfe330520
#define P_EE_AUDIO_TDMOUT_A_GAIN1                  (volatile uint32_t *)0xfe330524
#define P_EE_AUDIO_TDMOUT_A_MUTE_VAL               (volatile uint32_t *)0xfe330528
#define P_EE_AUDIO_TDMOUT_A_MUTE0                  (volatile uint32_t *)0xfe33052c
#define P_EE_AUDIO_TDMOUT_A_MUTE1                  (volatile uint32_t *)0xfe330530
#define P_EE_AUDIO_TDMOUT_A_MUTE2                  (volatile uint32_t *)0xfe330534
#define P_EE_AUDIO_TDMOUT_A_MUTE3                  (volatile uint32_t *)0xfe330538
#define P_EE_AUDIO_TDMOUT_A_MASK_VAL               (volatile uint32_t *)0xfe33053c
#define P_EE_AUDIO_TDMOUT_B_CTRL0                  (volatile uint32_t *)0xfe330540
#define P_EE_AUDIO_TDMOUT_B_CTRL1                  (volatile uint32_t *)0xfe330544
#define P_EE_AUDIO_TDMOUT_B_SWAP0                  (volatile uint32_t *)0xfe330548
#define P_EE_AUDIO_TDMOUT_B_MASK0                  (volatile uint32_t *)0xfe33054c
#define P_EE_AUDIO_TDMOUT_B_MASK1                  (volatile uint32_t *)0xfe330550
#define P_EE_AUDIO_TDMOUT_B_MASK2                  (volatile uint32_t *)0xfe330554
#define P_EE_AUDIO_TDMOUT_B_MASK3                  (volatile uint32_t *)0xfe330558
#define P_EE_AUDIO_TDMOUT_B_STAT                   (volatile uint32_t *)0xfe33055c
#define P_EE_AUDIO_TDMOUT_B_GAIN0                  (volatile uint32_t *)0xfe330560
#define P_EE_AUDIO_TDMOUT_B_GAIN1                  (volatile uint32_t *)0xfe330564
#define P_EE_AUDIO_TDMOUT_B_MUTE_VAL               (volatile uint32_t *)0xfe330568
#define P_EE_AUDIO_TDMOUT_B_MUTE0                  (volatile uint32_t *)0xfe33056c
#define P_EE_AUDIO_TDMOUT_B_MUTE1                  (volatile uint32_t *)0xfe330570
#define P_EE_AUDIO_TDMOUT_B_MUTE2                  (volatile uint32_t *)0xfe330574
#define P_EE_AUDIO_TDMOUT_B_MUTE3                  (volatile uint32_t *)0xfe330578
#define P_EE_AUDIO_TDMOUT_B_MASK_VAL               (volatile uint32_t *)0xfe33057c
#define P_EE_AUDIO_TDMOUT_C_CTRL0                  (volatile uint32_t *)0xfe330580
#define P_EE_AUDIO_TDMOUT_C_CTRL1                  (volatile uint32_t *)0xfe330584
#define P_EE_AUDIO_TDMOUT_C_SWAP0                  (volatile uint32_t *)0xfe330588
#define P_EE_AUDIO_TDMOUT_C_MASK0                  (volatile uint32_t *)0xfe33058c
#define P_EE_AUDIO_TDMOUT_C_MASK1                  (volatile uint32_t *)0xfe330590
#define P_EE_AUDIO_TDMOUT_C_MASK2                  (volatile uint32_t *)0xfe330594
#define P_EE_AUDIO_TDMOUT_C_MASK3                  (volatile uint32_t *)0xfe330598
#define P_EE_AUDIO_TDMOUT_C_STAT                   (volatile uint32_t *)0xfe33059c
#define P_EE_AUDIO_TDMOUT_C_GAIN0                  (volatile uint32_t *)0xfe3305a0
#define P_EE_AUDIO_TDMOUT_C_GAIN1                  (volatile uint32_t *)0xfe3305a4
#define P_EE_AUDIO_TDMOUT_C_MUTE_VAL               (volatile uint32_t *)0xfe3305a8
#define P_EE_AUDIO_TDMOUT_C_MUTE0                  (volatile uint32_t *)0xfe3305ac
#define P_EE_AUDIO_TDMOUT_C_MUTE1                  (volatile uint32_t *)0xfe3305b0
#define P_EE_AUDIO_TDMOUT_C_MUTE2                  (volatile uint32_t *)0xfe3305b4
#define P_EE_AUDIO_TDMOUT_C_MUTE3                  (volatile uint32_t *)0xfe3305b8
#define P_EE_AUDIO_TDMOUT_C_MASK_VAL               (volatile uint32_t *)0xfe3305bc
//`define EE_AUDIO_POW_DET_CTRL0          10'h180
//`define EE_AUDIO_POW_DET_CTRL1          10'h181
//`define EE_AUDIO_POW_DET_TH_HI          10'h182
//`define EE_AUDIO_POW_DET_TH_LO          10'h183
//`define EE_AUDIO_POW_DET_VALUE          10'h184
#define P_EE_AUDIO_SECURITY_CTRL0                  (volatile uint32_t *)0xfe330640
#define P_EE_AUDIO_SECURITY_CTRL1                  (volatile uint32_t *)0xfe330644
#define P_EE_AUDIO_SECURITY_CTRL2                  (volatile uint32_t *)0xfe330648
#define P_EE_AUDIO_SPDIFOUT_B_STAT                 (volatile uint32_t *)0xfe330680
#define P_EE_AUDIO_SPDIFOUT_B_GAIN0                (volatile uint32_t *)0xfe330684
#define P_EE_AUDIO_SPDIFOUT_B_GAIN1                (volatile uint32_t *)0xfe330688
#define P_EE_AUDIO_SPDIFOUT_B_CTRL0                (volatile uint32_t *)0xfe33068c
#define P_EE_AUDIO_SPDIFOUT_B_CTRL1                (volatile uint32_t *)0xfe330690
#define P_EE_AUDIO_SPDIFOUT_B_PREAMB               (volatile uint32_t *)0xfe330694
#define P_EE_AUDIO_SPDIFOUT_B_SWAP                 (volatile uint32_t *)0xfe330698
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS0               (volatile uint32_t *)0xfe33069c
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS1               (volatile uint32_t *)0xfe3306a0
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS2               (volatile uint32_t *)0xfe3306a4
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS3               (volatile uint32_t *)0xfe3306a8
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS4               (volatile uint32_t *)0xfe3306ac
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS5               (volatile uint32_t *)0xfe3306b0
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS6               (volatile uint32_t *)0xfe3306b4
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS7               (volatile uint32_t *)0xfe3306b8
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS8               (volatile uint32_t *)0xfe3306bc
#define P_EE_AUDIO_SPDIFOUT_B_CHSTS9               (volatile uint32_t *)0xfe3306c0
#define P_EE_AUDIO_SPDIFOUT_B_CHSTSA               (volatile uint32_t *)0xfe3306c4
#define P_EE_AUDIO_SPDIFOUT_B_CHSTSB               (volatile uint32_t *)0xfe3306c8
#define P_EE_AUDIO_SPDIFOUT_B_MUTE_VAL             (volatile uint32_t *)0xfe3306cc
#define P_EE_AUDIO_SPDIFOUT_B_GAIN2                (volatile uint32_t *)0xfe3306d0
#define P_EE_AUDIO_SPDIFOUT_B_GAIN3                (volatile uint32_t *)0xfe3306d4
#define P_EE_AUDIO_SPDIFOUT_B_GAIN_EN              (volatile uint32_t *)0xfe3306d8
#define P_EE_AUDIO_SPDIFOUT_B_GAIN_CTRL            (volatile uint32_t *)0xfe3306dc
#define P_EE_AUDIO_TORAM_CTRL0                     (volatile uint32_t *)0xfe330700
#define P_EE_AUDIO_TORAM_CTRL1                     (volatile uint32_t *)0xfe330704
#define P_EE_AUDIO_TORAM_START_ADDR                (volatile uint32_t *)0xfe330708
#define P_EE_AUDIO_TORAM_FINISH_ADDR               (volatile uint32_t *)0xfe33070c
#define P_EE_AUDIO_TORAM_INT_ADDR                  (volatile uint32_t *)0xfe330710
#define P_EE_AUDIO_TORAM_STATUS1                   (volatile uint32_t *)0xfe330714
#define P_EE_AUDIO_TORAM_STATUS2                   (volatile uint32_t *)0xfe330718
#define P_EE_AUDIO_TORAM_INIT_ADDR                 (volatile uint32_t *)0xfe33071c
#define P_EE_AUDIO_TOACODEC_CTRL0                  (volatile uint32_t *)0xfe330740
#define P_EE_AUDIO_TOHDMITX_CTRL0                  (volatile uint32_t *)0xfe330744
#define P_EE_AUDIO_TOVAD_CTRL0                     (volatile uint32_t *)0xfe330748
#define P_EE_AUDIO_FRATV_CTRL0                     (volatile uint32_t *)0xfe33074c
#define P_EE_AUDIO_RESAMPLEB_CTRL0                 (volatile uint32_t *)0xfe330780
#define P_EE_AUDIO_RESAMPLEB_CTRL1                 (volatile uint32_t *)0xfe330784
#define P_EE_AUDIO_RESAMPLEB_CTRL2                 (volatile uint32_t *)0xfe330788
#define P_EE_AUDIO_RESAMPLEB_CTRL3                 (volatile uint32_t *)0xfe33078c
#define P_EE_AUDIO_RESAMPLEB_COEF0                 (volatile uint32_t *)0xfe330790
#define P_EE_AUDIO_RESAMPLEB_COEF1                 (volatile uint32_t *)0xfe330794
#define P_EE_AUDIO_RESAMPLEB_COEF2                 (volatile uint32_t *)0xfe330798
#define P_EE_AUDIO_RESAMPLEB_COEF3                 (volatile uint32_t *)0xfe33079c
#define P_EE_AUDIO_RESAMPLEB_COEF4                 (volatile uint32_t *)0xfe3307a0
#define P_EE_AUDIO_RESAMPLEB_STATUS1               (volatile uint32_t *)0xfe3307a4
#define P_EE_AUDIO_SPDIFIN_LB_CTRL0                (volatile uint32_t *)0xfe3307c0
#define P_EE_AUDIO_SPDIFIN_LB_CTRL1                (volatile uint32_t *)0xfe3307c4
#define P_EE_AUDIO_SPDIFIN_LB_CTRL6                (volatile uint32_t *)0xfe3307d8
#define P_EE_AUDIO_SPDIFIN_LB_STAT0                (volatile uint32_t *)0xfe3307dc
#define P_EE_AUDIO_SPDIFIN_LB_STAT1                (volatile uint32_t *)0xfe3307e0
#define P_EE_AUDIO_SPDIFIN_LB_MUTE_VAL             (volatile uint32_t *)0xfe3307e8
#define P_EE_AUDIO_FRHDMIRX_CTRL0                  (volatile uint32_t *)0xfe330800
#define P_EE_AUDIO_FRHDMIRX_CTRL1                  (volatile uint32_t *)0xfe330804
#define P_EE_AUDIO_FRHDMIRX_CTRL2                  (volatile uint32_t *)0xfe330808
#define P_EE_AUDIO_FRHDMIRX_CTRL3                  (volatile uint32_t *)0xfe33080c
#define P_EE_AUDIO_FRHDMIRX_CTRL4                  (volatile uint32_t *)0xfe330810
#define P_EE_AUDIO_FRHDMIRX_CTRL5                  (volatile uint32_t *)0xfe330814
#define P_EE_AUDIO_FRHDMIRX_CTRL6                  (volatile uint32_t *)0xfe330818
#define P_EE_AUDIO_FRHDMIRX_CTRL7                  (volatile uint32_t *)0xfe33081c
#define P_EE_AUDIO_FRHDMIRX_STAT0                  (volatile uint32_t *)0xfe330828
#define P_EE_AUDIO_FRHDMIRX_STAT1                  (volatile uint32_t *)0xfe33082c
#define P_EE_AUDIO_TODDR_D_CTRL0                   (volatile uint32_t *)0xfe330840
#define P_EE_AUDIO_TODDR_D_CTRL1                   (volatile uint32_t *)0xfe330844
#define P_EE_AUDIO_TODDR_D_START_ADDR              (volatile uint32_t *)0xfe330848
#define P_EE_AUDIO_TODDR_D_FINISH_ADDR             (volatile uint32_t *)0xfe33084c
#define P_EE_AUDIO_TODDR_D_INT_ADDR                (volatile uint32_t *)0xfe330850
#define P_EE_AUDIO_TODDR_D_STATUS1                 (volatile uint32_t *)0xfe330854
#define P_EE_AUDIO_TODDR_D_STATUS2                 (volatile uint32_t *)0xfe330858
#define P_EE_AUDIO_TODDR_D_START_ADDRB             (volatile uint32_t *)0xfe33085c
#define P_EE_AUDIO_TODDR_D_FINISH_ADDRB            (volatile uint32_t *)0xfe330860
#define P_EE_AUDIO_TODDR_D_INIT_ADDR               (volatile uint32_t *)0xfe330864
#define P_EE_AUDIO_TODDR_D_CTRL2                   (volatile uint32_t *)0xfe330868
#define P_EE_AUDIO_FRDDR_D_CTRL0                   (volatile uint32_t *)0xfe330880
#define P_EE_AUDIO_FRDDR_D_CTRL1                   (volatile uint32_t *)0xfe330884
#define P_EE_AUDIO_FRDDR_D_START_ADDR              (volatile uint32_t *)0xfe330888
#define P_EE_AUDIO_FRDDR_D_FINISH_ADDR             (volatile uint32_t *)0xfe33088c
#define P_EE_AUDIO_FRDDR_D_INT_ADDR                (volatile uint32_t *)0xfe330890
#define P_EE_AUDIO_FRDDR_D_STATUS1                 (volatile uint32_t *)0xfe330894
#define P_EE_AUDIO_FRDDR_D_STATUS2                 (volatile uint32_t *)0xfe330898
#define P_EE_AUDIO_FRDDR_D_START_ADDRB             (volatile uint32_t *)0xfe33089c
#define P_EE_AUDIO_FRDDR_D_FINISH_ADDRB            (volatile uint32_t *)0xfe3308a0
#define P_EE_AUDIO_FRDDR_D_INIT_ADDR               (volatile uint32_t *)0xfe3308a4
#define P_EE_AUDIO_FRDDR_D_CTRL2                   (volatile uint32_t *)0xfe3308a8
#define P_EE_AUDIO_LB_B_CTRL0                      (volatile uint32_t *)0xfe3308c0
#define P_EE_AUDIO_LB_B_CTRL1                      (volatile uint32_t *)0xfe3308c4
#define P_EE_AUDIO_LB_B_CTRL2                      (volatile uint32_t *)0xfe3308c8
#define P_EE_AUDIO_LB_B_CTRL3                      (volatile uint32_t *)0xfe3308cc
#define P_EE_AUDIO_LB_B_DAT_CH_ID0                 (volatile uint32_t *)0xfe3308d0
#define P_EE_AUDIO_LB_B_DAT_CH_ID1                 (volatile uint32_t *)0xfe3308d4
#define P_EE_AUDIO_LB_B_DAT_CH_ID2                 (volatile uint32_t *)0xfe3308d8
#define P_EE_AUDIO_LB_B_DAT_CH_ID3                 (volatile uint32_t *)0xfe3308dc
#define P_EE_AUDIO_LB_B_LB_CH_ID0                  (volatile uint32_t *)0xfe3308e0
#define P_EE_AUDIO_LB_B_LB_CH_ID1                  (volatile uint32_t *)0xfe3308e4
#define P_EE_AUDIO_LB_B_LB_CH_ID2                  (volatile uint32_t *)0xfe3308e8
#define P_EE_AUDIO_LB_B_LB_CH_ID3                  (volatile uint32_t *)0xfe3308ec
#define P_EE_AUDIO_LB_B_STS                        (volatile uint32_t *)0xfe3308f0
#define P_EE_AUDIO_LB_B_CHSYNC_CTRL_INSERT         (volatile uint32_t *)0xfe3308f4
#define P_EE_AUDIO_LB_B_CHSYNC_CTRL_ORIG           (volatile uint32_t *)0xfe3308f8
#define P_EE_AUDIO_LB_B_CTRL4                      (volatile uint32_t *)0xfe3308fc
#define P_EE_AUDIO_TODDR_E_CTRL0                   (volatile uint32_t *)0xfe330900
#define P_EE_AUDIO_TODDR_E_CTRL1                   (volatile uint32_t *)0xfe330904
#define P_EE_AUDIO_TODDR_E_START_ADDR              (volatile uint32_t *)0xfe330908
#define P_EE_AUDIO_TODDR_E_FINISH_ADDR             (volatile uint32_t *)0xfe33090c
#define P_EE_AUDIO_TODDR_E_INT_ADDR                (volatile uint32_t *)0xfe330910
#define P_EE_AUDIO_TODDR_E_STATUS1                 (volatile uint32_t *)0xfe330914
#define P_EE_AUDIO_TODDR_E_STATUS2                 (volatile uint32_t *)0xfe330918
#define P_EE_AUDIO_TODDR_E_START_ADDRB             (volatile uint32_t *)0xfe33091c
#define P_EE_AUDIO_TODDR_E_FINISH_ADDRB            (volatile uint32_t *)0xfe330920
#define P_EE_AUDIO_TODDR_E_INIT_ADDR               (volatile uint32_t *)0xfe330924
#define P_EE_AUDIO_TODDR_E_CTRL2                   (volatile uint32_t *)0xfe330928
#define P_EE_AUDIO_FRDDR_E_CTRL0                   (volatile uint32_t *)0xfe330940
#define P_EE_AUDIO_FRDDR_E_CTRL1                   (volatile uint32_t *)0xfe330944
#define P_EE_AUDIO_FRDDR_E_START_ADDR              (volatile uint32_t *)0xfe330948
#define P_EE_AUDIO_FRDDR_E_FINISH_ADDR             (volatile uint32_t *)0xfe33094c
#define P_EE_AUDIO_FRDDR_E_INT_ADDR                (volatile uint32_t *)0xfe330950
#define P_EE_AUDIO_FRDDR_E_STATUS1                 (volatile uint32_t *)0xfe330954
#define P_EE_AUDIO_FRDDR_E_STATUS2                 (volatile uint32_t *)0xfe330958
#define P_EE_AUDIO_FRDDR_E_START_ADDRB             (volatile uint32_t *)0xfe33095c
#define P_EE_AUDIO_FRDDR_E_FINISH_ADDRB            (volatile uint32_t *)0xfe330960
#define P_EE_AUDIO_FRDDR_E_INIT_ADDR               (volatile uint32_t *)0xfe330964
#define P_EE_AUDIO_FRDDR_E_CTRL2                   (volatile uint32_t *)0xfe330968
#define P_EE_AUDIO_TDMIN_A_SWAP1                   (volatile uint32_t *)0xfe330980
#define P_EE_AUDIO_TDMIN_A_MASK4                   (volatile uint32_t *)0xfe330984
#define P_EE_AUDIO_TDMIN_A_MASK5                   (volatile uint32_t *)0xfe330988
#define P_EE_AUDIO_TDMIN_A_MASK6                   (volatile uint32_t *)0xfe33098c
#define P_EE_AUDIO_TDMIN_A_MASK7                   (volatile uint32_t *)0xfe330990
#define P_EE_AUDIO_TDMIN_A_MUTE4                   (volatile uint32_t *)0xfe330994
#define P_EE_AUDIO_TDMIN_A_MUTE5                   (volatile uint32_t *)0xfe330998
#define P_EE_AUDIO_TDMIN_A_MUTE6                   (volatile uint32_t *)0xfe33099c
#define P_EE_AUDIO_TDMIN_A_MUTE7                   (volatile uint32_t *)0xfe3309a0
#define P_EE_AUDIO_TDMIN_B_SWAP1                   (volatile uint32_t *)0xfe3309c0
#define P_EE_AUDIO_TDMIN_B_MASK4                   (volatile uint32_t *)0xfe3309c4
#define P_EE_AUDIO_TDMIN_B_MASK5                   (volatile uint32_t *)0xfe3309c8
#define P_EE_AUDIO_TDMIN_B_MASK6                   (volatile uint32_t *)0xfe3309cc
#define P_EE_AUDIO_TDMIN_B_MASK7                   (volatile uint32_t *)0xfe3309d0
#define P_EE_AUDIO_TDMIN_B_MUTE4                   (volatile uint32_t *)0xfe3309d4
#define P_EE_AUDIO_TDMIN_B_MUTE5                   (volatile uint32_t *)0xfe3309d8
#define P_EE_AUDIO_TDMIN_B_MUTE6                   (volatile uint32_t *)0xfe3309dc
#define P_EE_AUDIO_TDMIN_B_MUTE7                   (volatile uint32_t *)0xfe3309e0
#define P_EE_AUDIO_TDMIN_C_SWAP1                   (volatile uint32_t *)0xfe330a00
#define P_EE_AUDIO_TDMIN_C_MASK4                   (volatile uint32_t *)0xfe330a04
#define P_EE_AUDIO_TDMIN_C_MASK5                   (volatile uint32_t *)0xfe330a08
#define P_EE_AUDIO_TDMIN_C_MASK6                   (volatile uint32_t *)0xfe330a0c
#define P_EE_AUDIO_TDMIN_C_MASK7                   (volatile uint32_t *)0xfe330a10
#define P_EE_AUDIO_TDMIN_C_MUTE4                   (volatile uint32_t *)0xfe330a14
#define P_EE_AUDIO_TDMIN_C_MUTE5                   (volatile uint32_t *)0xfe330a18
#define P_EE_AUDIO_TDMIN_C_MUTE6                   (volatile uint32_t *)0xfe330a1c
#define P_EE_AUDIO_TDMIN_C_MUTE7                   (volatile uint32_t *)0xfe330a20
#define P_EE_AUDIO_TDMIN_LB_SWAP1                  (volatile uint32_t *)0xfe330a40
#define P_EE_AUDIO_TDMIN_LB_MASK4                  (volatile uint32_t *)0xfe330a44
#define P_EE_AUDIO_TDMIN_LB_MASK5                  (volatile uint32_t *)0xfe330a48
#define P_EE_AUDIO_TDMIN_LB_MASK6                  (volatile uint32_t *)0xfe330a4c
#define P_EE_AUDIO_TDMIN_LB_MASK7                  (volatile uint32_t *)0xfe330a50
#define P_EE_AUDIO_TDMIN_LB_MUTE4                  (volatile uint32_t *)0xfe330a54
#define P_EE_AUDIO_TDMIN_LB_MUTE5                  (volatile uint32_t *)0xfe330a58
#define P_EE_AUDIO_TDMIN_LB_MUTE6                  (volatile uint32_t *)0xfe330a5c
#define P_EE_AUDIO_TDMIN_LB_MUTE7                  (volatile uint32_t *)0xfe330a60
#define P_EE_AUDIO_TDMOUT_A_CTRL2                  (volatile uint32_t *)0xfe330a80
#define P_EE_AUDIO_TDMOUT_A_SWAP1                  (volatile uint32_t *)0xfe330a84
#define P_EE_AUDIO_TDMOUT_A_GAIN2                  (volatile uint32_t *)0xfe330a88
#define P_EE_AUDIO_TDMOUT_A_GAIN3                  (volatile uint32_t *)0xfe330a8c
#define P_EE_AUDIO_TDMOUT_A_MASK4                  (volatile uint32_t *)0xfe330a90
#define P_EE_AUDIO_TDMOUT_A_MASK5                  (volatile uint32_t *)0xfe330a94
#define P_EE_AUDIO_TDMOUT_A_MASK6                  (volatile uint32_t *)0xfe330a98
#define P_EE_AUDIO_TDMOUT_A_MASK7                  (volatile uint32_t *)0xfe330a9c
#define P_EE_AUDIO_TDMOUT_A_MUTE4                  (volatile uint32_t *)0xfe330aa0
#define P_EE_AUDIO_TDMOUT_A_MUTE5                  (volatile uint32_t *)0xfe330aa4
#define P_EE_AUDIO_TDMOUT_A_MUTE6                  (volatile uint32_t *)0xfe330aa8
#define P_EE_AUDIO_TDMOUT_A_MUTE7                  (volatile uint32_t *)0xfe330aac
#define P_EE_AUDIO_TDMOUT_A_GAIN_EN                (volatile uint32_t *)0xfe330ab0
#define P_EE_AUDIO_TDMOUT_A_GAIN_CTRL              (volatile uint32_t *)0xfe330ab4
#define P_EE_AUDIO_TDMOUT_B_CTRL2                  (volatile uint32_t *)0xfe330ac0
#define P_EE_AUDIO_TDMOUT_B_SWAP1                  (volatile uint32_t *)0xfe330ac4
#define P_EE_AUDIO_TDMOUT_B_GAIN2                  (volatile uint32_t *)0xfe330ac8
#define P_EE_AUDIO_TDMOUT_B_GAIN3                  (volatile uint32_t *)0xfe330acc
#define P_EE_AUDIO_TDMOUT_B_MASK4                  (volatile uint32_t *)0xfe330ad0
#define P_EE_AUDIO_TDMOUT_B_MASK5                  (volatile uint32_t *)0xfe330ad4
#define P_EE_AUDIO_TDMOUT_B_MASK6                  (volatile uint32_t *)0xfe330ad8
#define P_EE_AUDIO_TDMOUT_B_MASK7                  (volatile uint32_t *)0xfe330adc
#define P_EE_AUDIO_TDMOUT_B_MUTE4                  (volatile uint32_t *)0xfe330ae0
#define P_EE_AUDIO_TDMOUT_B_MUTE5                  (volatile uint32_t *)0xfe330ae4
#define P_EE_AUDIO_TDMOUT_B_MUTE6                  (volatile uint32_t *)0xfe330ae8
#define P_EE_AUDIO_TDMOUT_B_MUTE7                  (volatile uint32_t *)0xfe330aec
#define P_EE_AUDIO_TDMOUT_B_GAIN_EN                (volatile uint32_t *)0xfe330af0
#define P_EE_AUDIO_TDMOUT_B_GAIN_CTRL              (volatile uint32_t *)0xfe330af4
#define P_EE_AUDIO_TDMOUT_C_CTRL2                  (volatile uint32_t *)0xfe330b00
#define P_EE_AUDIO_TDMOUT_C_SWAP1                  (volatile uint32_t *)0xfe330b04
#define P_EE_AUDIO_TDMOUT_C_GAIN2                  (volatile uint32_t *)0xfe330b08
#define P_EE_AUDIO_TDMOUT_C_GAIN3                  (volatile uint32_t *)0xfe330b0c
#define P_EE_AUDIO_TDMOUT_C_MASK4                  (volatile uint32_t *)0xfe330b10
#define P_EE_AUDIO_TDMOUT_C_MASK5                  (volatile uint32_t *)0xfe330b14
#define P_EE_AUDIO_TDMOUT_C_MASK6                  (volatile uint32_t *)0xfe330b18
#define P_EE_AUDIO_TDMOUT_C_MASK7                  (volatile uint32_t *)0xfe330b1c
#define P_EE_AUDIO_TDMOUT_C_MUTE4                  (volatile uint32_t *)0xfe330b20
#define P_EE_AUDIO_TDMOUT_C_MUTE5                  (volatile uint32_t *)0xfe330b24
#define P_EE_AUDIO_TDMOUT_C_MUTE6                  (volatile uint32_t *)0xfe330b28
#define P_EE_AUDIO_TDMOUT_C_MUTE7                  (volatile uint32_t *)0xfe330b2c
#define P_EE_AUDIO_TDMOUT_C_GAIN_EN                (volatile uint32_t *)0xfe330b30
#define P_EE_AUDIO_TDMOUT_C_GAIN_CTRL              (volatile uint32_t *)0xfe330b34
#define P_EE_AUDIO_TODDR_A_CHNUM_ID0               (volatile uint32_t *)0xfe330c00
#define P_EE_AUDIO_TODDR_A_CHNUM_ID1               (volatile uint32_t *)0xfe330c04
#define P_EE_AUDIO_TODDR_A_CHNUM_ID2               (volatile uint32_t *)0xfe330c08
#define P_EE_AUDIO_TODDR_A_CHNUM_ID3               (volatile uint32_t *)0xfe330c0c
#define P_EE_AUDIO_TODDR_A_CHNUM_ID4               (volatile uint32_t *)0xfe330c10
#define P_EE_AUDIO_TODDR_A_CHNUM_ID5               (volatile uint32_t *)0xfe330c14
#define P_EE_AUDIO_TODDR_A_CHNUM_ID6               (volatile uint32_t *)0xfe330c18
#define P_EE_AUDIO_TODDR_A_CHNUM_ID7               (volatile uint32_t *)0xfe330c1c
#define P_EE_AUDIO_TODDR_A_CHSYNC_CTRL             (volatile uint32_t *)0xfe330c3c
#define P_EE_AUDIO_TODDR_B_CHNUM_ID0               (volatile uint32_t *)0xfe330c40
#define P_EE_AUDIO_TODDR_B_CHNUM_ID1               (volatile uint32_t *)0xfe330c44
#define P_EE_AUDIO_TODDR_B_CHNUM_ID2               (volatile uint32_t *)0xfe330c48
#define P_EE_AUDIO_TODDR_B_CHNUM_ID3               (volatile uint32_t *)0xfe330c4c
#define P_EE_AUDIO_TODDR_B_CHNUM_ID4               (volatile uint32_t *)0xfe330c50
#define P_EE_AUDIO_TODDR_B_CHNUM_ID5               (volatile uint32_t *)0xfe330c54
#define P_EE_AUDIO_TODDR_B_CHNUM_ID6               (volatile uint32_t *)0xfe330c58
#define P_EE_AUDIO_TODDR_B_CHNUM_ID7               (volatile uint32_t *)0xfe330c5c
#define P_EE_AUDIO_TODDR_B_CHSYNC_CTRL             (volatile uint32_t *)0xfe330c7c
#define P_EE_AUDIO_TODDR_C_CHNUM_ID0               (volatile uint32_t *)0xfe330c80
#define P_EE_AUDIO_TODDR_C_CHNUM_ID1               (volatile uint32_t *)0xfe330c84
#define P_EE_AUDIO_TODDR_C_CHNUM_ID2               (volatile uint32_t *)0xfe330c88
#define P_EE_AUDIO_TODDR_C_CHNUM_ID3               (volatile uint32_t *)0xfe330c8c
#define P_EE_AUDIO_TODDR_C_CHNUM_ID4               (volatile uint32_t *)0xfe330c90
#define P_EE_AUDIO_TODDR_C_CHNUM_ID5               (volatile uint32_t *)0xfe330c94
#define P_EE_AUDIO_TODDR_C_CHNUM_ID6               (volatile uint32_t *)0xfe330c98
#define P_EE_AUDIO_TODDR_C_CHNUM_ID7               (volatile uint32_t *)0xfe330c9c
#define P_EE_AUDIO_TODDR_C_CHSYNC_CTRL             (volatile uint32_t *)0xfe330cbc
#define P_EE_AUDIO_TODDR_D_CHNUM_ID0               (volatile uint32_t *)0xfe330cc0
#define P_EE_AUDIO_TODDR_D_CHNUM_ID1               (volatile uint32_t *)0xfe330cc4
#define P_EE_AUDIO_TODDR_D_CHNUM_ID2               (volatile uint32_t *)0xfe330cc8
#define P_EE_AUDIO_TODDR_D_CHNUM_ID3               (volatile uint32_t *)0xfe330ccc
#define P_EE_AUDIO_TODDR_D_CHNUM_ID4               (volatile uint32_t *)0xfe330cd0
#define P_EE_AUDIO_TODDR_D_CHNUM_ID5               (volatile uint32_t *)0xfe330cd4
#define P_EE_AUDIO_TODDR_D_CHNUM_ID6               (volatile uint32_t *)0xfe330cd8
#define P_EE_AUDIO_TODDR_D_CHNUM_ID7               (volatile uint32_t *)0xfe330cdc
#define P_EE_AUDIO_TODDR_D_CHSYNC_CTRL             (volatile uint32_t *)0xfe330cfc
#define P_EE_AUDIO_TODDR_E_CHNUM_ID0               (volatile uint32_t *)0xfe330d00
#define P_EE_AUDIO_TODDR_E_CHNUM_ID1               (volatile uint32_t *)0xfe330d04
#define P_EE_AUDIO_TODDR_E_CHNUM_ID2               (volatile uint32_t *)0xfe330d08
#define P_EE_AUDIO_TODDR_E_CHNUM_ID3               (volatile uint32_t *)0xfe330d0c
#define P_EE_AUDIO_TODDR_E_CHNUM_ID4               (volatile uint32_t *)0xfe330d10
#define P_EE_AUDIO_TODDR_E_CHNUM_ID5               (volatile uint32_t *)0xfe330d14
#define P_EE_AUDIO_TODDR_E_CHNUM_ID6               (volatile uint32_t *)0xfe330d18
#define P_EE_AUDIO_TODDR_E_CHNUM_ID7               (volatile uint32_t *)0xfe330d1c
#define P_EE_AUDIO_TODDR_E_CHSYNC_CTRL             (volatile uint32_t *)0xfe330d3c
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID0               (volatile uint32_t *)0xfe330d40
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID1               (volatile uint32_t *)0xfe330d44
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID2               (volatile uint32_t *)0xfe330d48
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID3               (volatile uint32_t *)0xfe330d4c
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID4               (volatile uint32_t *)0xfe330d50
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID5               (volatile uint32_t *)0xfe330d54
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID6               (volatile uint32_t *)0xfe330d58
#define P_EE_AUDIO_RSAMP_A_CHNUM_ID7               (volatile uint32_t *)0xfe330d5c
#define P_EE_AUDIO_RSAMP_CHSYNC_MASK               (volatile uint32_t *)0xfe330d78
#define P_EE_AUDIO_RSAMP_A_CHSYNC_CTRL             (volatile uint32_t *)0xfe330d7c
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID0               (volatile uint32_t *)0xfe330d80
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID1               (volatile uint32_t *)0xfe330d84
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID2               (volatile uint32_t *)0xfe330d88
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID3               (volatile uint32_t *)0xfe330d8c
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID4               (volatile uint32_t *)0xfe330d90
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID5               (volatile uint32_t *)0xfe330d94
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID6               (volatile uint32_t *)0xfe330d98
#define P_EE_AUDIO_RSAMP_B_CHNUM_ID7               (volatile uint32_t *)0xfe330d9c
#define P_EE_AUDIO_RSAMP_B_CHSYNC_CTRL             (volatile uint32_t *)0xfe330dbc
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID0               (volatile uint32_t *)0xfe330dc0
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID1               (volatile uint32_t *)0xfe330dc4
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID2               (volatile uint32_t *)0xfe330dc8
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID3               (volatile uint32_t *)0xfe330dcc
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID4               (volatile uint32_t *)0xfe330dd0
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID5               (volatile uint32_t *)0xfe330dd4
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID6               (volatile uint32_t *)0xfe330dd8
#define P_EE_AUDIO_RSAMP_C_CHNUM_ID7               (volatile uint32_t *)0xfe330ddc
#define P_EE_AUDIO_RSAMP_C_CHSYNC_CTRL             (volatile uint32_t *)0xfe330dfc
#define P_EE_AUDIO_EXCEPTION_IRQ_STS0              (volatile uint32_t *)0xfe330e00
#define P_EE_AUDIO_EXCEPTION_IRQ_STS1              (volatile uint32_t *)0xfe330e04
#define P_EE_AUDIO_EXCEPTION_IRQ_MASK0             (volatile uint32_t *)0xfe330e08
#define P_EE_AUDIO_EXCEPTION_IRQ_MASK1             (volatile uint32_t *)0xfe330e0c
#define P_EE_AUDIO_EXCEPTION_IRQ_MODE0             (volatile uint32_t *)0xfe330e10
#define P_EE_AUDIO_EXCEPTION_IRQ_MODE1             (volatile uint32_t *)0xfe330e14
#define P_EE_AUDIO_EXCEPTION_IRQ_CLR0              (volatile uint32_t *)0xfe330e18
#define P_EE_AUDIO_EXCEPTION_IRQ_CLR1              (volatile uint32_t *)0xfe330e1c
#define P_EE_AUDIO_EXCEPTION_IRQ_INV0              (volatile uint32_t *)0xfe330e20
#define P_EE_AUDIO_EXCEPTION_IRQ_INV1              (volatile uint32_t *)0xfe330e24
#define P_EE_AUDIO_DAT_PAD_CTRL0                   (volatile uint32_t *)0xfe330e40
#define P_EE_AUDIO_DAT_PAD_CTRL1                   (volatile uint32_t *)0xfe330e44
#define P_EE_AUDIO_DAT_PAD_CTRL2                   (volatile uint32_t *)0xfe330e48
#define P_EE_AUDIO_DAT_PAD_CTRL3                   (volatile uint32_t *)0xfe330e4c
#define P_EE_AUDIO_DAT_PAD_CTRL4                   (volatile uint32_t *)0xfe330e50
#define P_EE_AUDIO_DAT_PAD_CTRL5                   (volatile uint32_t *)0xfe330e54
#define P_EE_AUDIO_DAT_PAD_CTRL6                   (volatile uint32_t *)0xfe330e58
#define P_EE_AUDIO_DAT_PAD_CTRL7                   (volatile uint32_t *)0xfe330e5c
#define P_EE_AUDIO_DAT_PAD_CTRL8                   (volatile uint32_t *)0xfe330e60
#define P_EE_AUDIO_DAT_PAD_CTRL9                   (volatile uint32_t *)0xfe330e64
#define P_EE_AUDIO_DAT_PAD_CTRLA                   (volatile uint32_t *)0xfe330e68
#define P_EE_AUDIO_DAT_PAD_CTRLB                   (volatile uint32_t *)0xfe330e6c
#define P_EE_AUDIO_DAT_PAD_CTRLC                   (volatile uint32_t *)0xfe330e70
#define P_EE_AUDIO_DAT_PAD_CTRLD                   (volatile uint32_t *)0xfe330e74
#define P_EE_AUDIO_DAT_PAD_CTRLE                   (volatile uint32_t *)0xfe330e78
#define P_EE_AUDIO_DAT_PAD_CTRLF                   (volatile uint32_t *)0xfe330e7c
#define P_EE_AUDIO_MCLK_PAD_CTRL0                  (volatile uint32_t *)0xfe330e80
#define P_EE_AUDIO_MCLK_PAD_CTRL1                  (volatile uint32_t *)0xfe330e84
#define P_EE_AUDIO_SCLK_PAD_CTRL0                  (volatile uint32_t *)0xfe330e88
#define P_EE_AUDIO_LRCLK_PAD_CTRL0                 (volatile uint32_t *)0xfe330e8c
//========================================================================
//  PDM - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331000
// -----------------------------------------------
#define P_PDM_CTRL                                 (volatile uint32_t *)0xfe331000
  //bit 31:   PDM enable.
  //bit 30:   invert the PDM_DCLK.
  //bit 29:   output mode:  1: 24bits. 0: 32 bits.
  //bit 28:   bypass mode. 1: bypass all filter. directly output the PDM input to DDR. 0: normal mode.
  //bit 27~9: not used.
  //bit 16:.   PDM Asynchronous FIFO soft reset.  write 1 to soft reset AFIFO.
  //bit 15:8   PDM channel reset.  0: to reset each PDM channel.  1: normal mode.
  //bit 7:0.  PDM channel enable. each bit for one channel.
#define P_PDM_HCIC_CTRL1                           (volatile uint32_t *)0xfe331004
  //bit 31      hcic filter enable.  1 use sinc filter. 0 bypass input to output.
  //bit 29:24.  hcic final gain shift parameter.
  //bit 23:16   hcic final gain multiplier.
  //bit 8:4     hcic  down sample rate.
  //bit 3:0     hcic  stage number. must be between 3 to 9.
#define P_PDM_HCIC_CTRL2                           (volatile uint32_t *)0xfe331008
  //Not used.
#define P_PDM_F1_CTRL                              (volatile uint32_t *)0xfe33100c
  //bit 31 .   filter 1 enable.
  //bit 16:15. f1 round mode.  2'b00 : sign bit at bit 49.  28bits output [49:22] round at bit 21. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b01 : sign bit at bit 50.  28bits output [50:23] round at bit 22. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b10 : sign bit at bit 51.  28bits output [51:24] round at bit 23 32bits output [49:18]. 24bits output [49:26].
  //bit 15:12. filter 1 down sample rate.
  //bit 8:0.   filter 1 stage number.
#define P_PDM_F2_CTRL                              (volatile uint32_t *)0xfe331010
  //bit 31 .   filter 2 enable.
  //bit 16:15. f2 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 2 down sample rate.
  //bit 8:0.   filter 2 stage number.
#define P_PDM_F3_CTRL                              (volatile uint32_t *)0xfe331014
  //bit 31 .   filter 3 enable.
  //bit 16:15. f3 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 3 down sample rate.
  //bit 8:0.   filter 3 stage number.
#define P_PDM_HPF_CTRL                             (volatile uint32_t *)0xfe331018
  //bit 31  High pass filter enable.
  //bit 20:16 high pass filter shift steps. 6~19 steps.
  //bit 15:0 high pass filter output factor.
#define P_PDM_CHAN_CTRL                            (volatile uint32_t *)0xfe33101c
  //bit 31:24.  chan3 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan2 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan1 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan0 data sample pointer vs edge of the PDM_DCLK.
#define P_PDM_CHAN_CTRL1                           (volatile uint32_t *)0xfe331020
  //bit 31:24.  chan7 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan6 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan5 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan4 data sample pointer vs edge of the PDM_DCLK.
#define P_PDM_COEFF_ADDR                           (volatile uint32_t *)0xfe331024
  // address of the write/read of coeff data.
#define P_PDM_COEFF_DATA                           (volatile uint32_t *)0xfe331028
  //write/read data to coeff memory.
#define P_PDM_CLKG_CTRL                            (volatile uint32_t *)0xfe33102c
  // auto clock gating control.  1: disable the clock gating function. the clock will awlays enabled. 0 : use RTL auto clock gating.
  //31:7 not used.
  //bit 6  filt_ctrl module auto clock gating control.
  //bit 5  sinc fifo module auto clock gating control.
  //bit 4  filter module auto clock gating control.
  //bit 3  apb module auto clock gating control.
  //bit 2  coeff memory module auto clock gating control.
  //bit 1  each channel module auto clock gating control.
  //bit 0 cts_pdm_clk   auto clock gating control.
#define P_PDM_STS                                  (volatile uint32_t *)0xfe331030
//bit 1  HPF filter output overflow.  means the PCLK is too slow.
//bit 0  HCIC filter output overflow. means the CTS_PDM_CLK is too slow. can't finished the filter function.
#define P_PDM_MUTE_VALUE                           (volatile uint32_t *)0xfe331034
#define P_PDM_MASK_NUM                             (volatile uint32_t *)0xfe331038
#define P_PDM_CHAN_CTRL2                           (volatile uint32_t *)0xfe33103c
  //bit 7:0    second sample and start FSM point vs rise edge of PDM_DCLK
#define P_PDM_HPF_GAIN_CTRL                        (volatile uint32_t *)0xfe331040
//bit 31   Bypass hpf gain (HPF to async fifo directly)
//bit 19:0 unsigned gain on pdm_dout (after HPF so that mic DC bias would not be amplified) u20.7
//========================================================================
//  EQ DRC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe332000
// -----------------------------------------------
#define P_AED_COEF_RAM_CNTL                        (volatile uint32_t *)0xfe332000
#define P_AED_COEF_RAM_DATA                        (volatile uint32_t *)0xfe332004
#define P_AED_EQ_EN                                (volatile uint32_t *)0xfe332008
#define P_AED_EQ_TAP_CNTL                          (volatile uint32_t *)0xfe33200c
#define P_AED_EQ_VOLUME                            (volatile uint32_t *)0xfe332010
#define P_AED_EQ_VOLUME_SLEW_CNT                   (volatile uint32_t *)0xfe332014
#define P_AED_MUTE                                 (volatile uint32_t *)0xfe332018
#define P_AED_DRC_CNTL                             (volatile uint32_t *)0xfe33201c
#define P_AED_DRC_RMS_COEF0                        (volatile uint32_t *)0xfe332020
#define P_AED_DRC_RMS_COEF1                        (volatile uint32_t *)0xfe332024
#define P_AED_DRC_THD0                             (volatile uint32_t *)0xfe332028
#define P_AED_DRC_THD1                             (volatile uint32_t *)0xfe33202c
#define P_AED_DRC_THD2                             (volatile uint32_t *)0xfe332030
#define P_AED_DRC_THD3                             (volatile uint32_t *)0xfe332034
#define P_AED_DRC_THD4                             (volatile uint32_t *)0xfe332038
#define P_AED_DRC_K0                               (volatile uint32_t *)0xfe33203c
#define P_AED_DRC_K1                               (volatile uint32_t *)0xfe332040
#define P_AED_DRC_K2                               (volatile uint32_t *)0xfe332044
#define P_AED_DRC_K3                               (volatile uint32_t *)0xfe332048
#define P_AED_DRC_K4                               (volatile uint32_t *)0xfe33204c
#define P_AED_DRC_K5                               (volatile uint32_t *)0xfe332050
#define P_AED_DRC_THD_OUT0                         (volatile uint32_t *)0xfe332054
#define P_AED_DRC_THD_OUT1                         (volatile uint32_t *)0xfe332058
#define P_AED_DRC_THD_OUT2                         (volatile uint32_t *)0xfe33205c
#define P_AED_DRC_THD_OUT3                         (volatile uint32_t *)0xfe332060
#define P_AED_DRC_OFFSET                           (volatile uint32_t *)0xfe332064
#define P_AED_DRC_RELEASE_COEF00                   (volatile uint32_t *)0xfe332068
#define P_AED_DRC_RELEASE_COEF01                   (volatile uint32_t *)0xfe33206c
#define P_AED_DRC_RELEASE_COEF10                   (volatile uint32_t *)0xfe332070
#define P_AED_DRC_RELEASE_COEF11                   (volatile uint32_t *)0xfe332074
#define P_AED_DRC_RELEASE_COEF20                   (volatile uint32_t *)0xfe332078
#define P_AED_DRC_RELEASE_COEF21                   (volatile uint32_t *)0xfe33207c
#define P_AED_DRC_RELEASE_COEF30                   (volatile uint32_t *)0xfe332080
#define P_AED_DRC_RELEASE_COEF31                   (volatile uint32_t *)0xfe332084
#define P_AED_DRC_RELEASE_COEF40                   (volatile uint32_t *)0xfe332088
#define P_AED_DRC_RELEASE_COEF41                   (volatile uint32_t *)0xfe33208c
#define P_AED_DRC_RELEASE_COEF50                   (volatile uint32_t *)0xfe332090
#define P_AED_DRC_RELEASE_COEF51                   (volatile uint32_t *)0xfe332094
#define P_AED_DRC_ATTACK_COEF00                    (volatile uint32_t *)0xfe332098
#define P_AED_DRC_ATTACK_COEF01                    (volatile uint32_t *)0xfe33209c
#define P_AED_DRC_ATTACK_COEF10                    (volatile uint32_t *)0xfe3320a0
#define P_AED_DRC_ATTACK_COEF11                    (volatile uint32_t *)0xfe3320a4
#define P_AED_DRC_ATTACK_COEF20                    (volatile uint32_t *)0xfe3320a8
#define P_AED_DRC_ATTACK_COEF21                    (volatile uint32_t *)0xfe3320ac
#define P_AED_DRC_ATTACK_COEF30                    (volatile uint32_t *)0xfe3320b0
#define P_AED_DRC_ATTACK_COEF31                    (volatile uint32_t *)0xfe3320b4
#define P_AED_DRC_ATTACK_COEF40                    (volatile uint32_t *)0xfe3320b8
#define P_AED_DRC_ATTACK_COEF41                    (volatile uint32_t *)0xfe3320bc
#define P_AED_DRC_ATTACK_COEF50                    (volatile uint32_t *)0xfe3320c0
#define P_AED_DRC_ATTACK_COEF51                    (volatile uint32_t *)0xfe3320c4
#define P_AED_DRC_LOOPBACK_CNTL                    (volatile uint32_t *)0xfe3320c8
#define P_AED_MDRC_CNTL                            (volatile uint32_t *)0xfe3320cc
#define P_AED_MDRC_RMS_COEF00                      (volatile uint32_t *)0xfe3320d0
#define P_AED_MDRC_RMS_COEF01                      (volatile uint32_t *)0xfe3320d4
#define P_AED_MDRC_RELEASE_COEF00                  (volatile uint32_t *)0xfe3320d8
#define P_AED_MDRC_RELEASE_COEF01                  (volatile uint32_t *)0xfe3320dc
#define P_AED_MDRC_ATTACK_COEF00                   (volatile uint32_t *)0xfe3320e0
#define P_AED_MDRC_ATTACK_COEF01                   (volatile uint32_t *)0xfe3320e4
#define P_AED_MDRC_THD0                            (volatile uint32_t *)0xfe3320e8
#define P_AED_MDRC_K0                              (volatile uint32_t *)0xfe3320ec
#define P_AED_MDRC_LOW_GAIN                        (volatile uint32_t *)0xfe3320f0
#define P_AED_MDRC_OFFSET0                         (volatile uint32_t *)0xfe3320f4
#define P_AED_MDRC_RMS_COEF10                      (volatile uint32_t *)0xfe3320f8
#define P_AED_MDRC_RMS_COEF11                      (volatile uint32_t *)0xfe3320fc
#define P_AED_MDRC_RELEASE_COEF10                  (volatile uint32_t *)0xfe332100
#define P_AED_MDRC_RELEASE_COEF11                  (volatile uint32_t *)0xfe332104
#define P_AED_MDRC_ATTACK_COEF10                   (volatile uint32_t *)0xfe332108
#define P_AED_MDRC_ATTACK_COEF11                   (volatile uint32_t *)0xfe33210c
#define P_AED_MDRC_THD1                            (volatile uint32_t *)0xfe332110
#define P_AED_MDRC_K1                              (volatile uint32_t *)0xfe332114
#define P_AED_MDRC_OFFSET1                         (volatile uint32_t *)0xfe332118
#define P_AED_MDRC_MID_GAIN                        (volatile uint32_t *)0xfe33211c
#define P_AED_MDRC_RMS_COEF20                      (volatile uint32_t *)0xfe332120
#define P_AED_MDRC_RMS_COEF21                      (volatile uint32_t *)0xfe332124
#define P_AED_MDRC_RELEASE_COEF20                  (volatile uint32_t *)0xfe332128
#define P_AED_MDRC_RELEASE_COEF21                  (volatile uint32_t *)0xfe33212c
#define P_AED_MDRC_ATTACK_COEF20                   (volatile uint32_t *)0xfe332130
#define P_AED_MDRC_ATTACK_COEF21                   (volatile uint32_t *)0xfe332134
#define P_AED_MDRC_THD2                            (volatile uint32_t *)0xfe332138
#define P_AED_MDRC_K2                              (volatile uint32_t *)0xfe33213c
#define P_AED_MDRC_OFFSET2                         (volatile uint32_t *)0xfe332140
#define P_AED_MDRC_HIGH_GAIN                       (volatile uint32_t *)0xfe332144
#define P_AED_ED_CNTL                              (volatile uint32_t *)0xfe332148
#define P_AED_DC_EN                                (volatile uint32_t *)0xfe33214c
#define P_AED_ND_LOW_THD                           (volatile uint32_t *)0xfe332150
#define P_AED_ND_HIGH_THD                          (volatile uint32_t *)0xfe332154
#define P_AED_ND_CNT_THD                           (volatile uint32_t *)0xfe332158
#define P_AED_ND_SUM_NUM                           (volatile uint32_t *)0xfe33215c
#define P_AED_ND_CZ_NUM                            (volatile uint32_t *)0xfe332160
#define P_AED_ND_SUM_THD0                          (volatile uint32_t *)0xfe332164
#define P_AED_ND_SUM_THD1                          (volatile uint32_t *)0xfe332168
#define P_AED_ND_CZ_THD0                           (volatile uint32_t *)0xfe33216c
#define P_AED_ND_CZ_THD1                           (volatile uint32_t *)0xfe332170
#define P_AED_ND_COND_CNTL                         (volatile uint32_t *)0xfe332174
#define P_AED_ND_RELEASE_COEF0                     (volatile uint32_t *)0xfe332178
#define P_AED_ND_RELEASE_COEF1                     (volatile uint32_t *)0xfe33217c
#define P_AED_ND_ATTACK_COEF0                      (volatile uint32_t *)0xfe332180
#define P_AED_ND_ATTACK_COEF1                      (volatile uint32_t *)0xfe332184
#define P_AED_ND_CNTL                              (volatile uint32_t *)0xfe332188
#define P_AED_MIX0_LL                              (volatile uint32_t *)0xfe33218c
#define P_AED_MIX0_RL                              (volatile uint32_t *)0xfe332190
#define P_AED_MIX0_LR                              (volatile uint32_t *)0xfe332194
#define P_AED_MIX0_RR                              (volatile uint32_t *)0xfe332198
#define P_AED_CLIP_THD                             (volatile uint32_t *)0xfe33219c
#define P_AED_CH1_ND_SUM_OUT                       (volatile uint32_t *)0xfe3321a0
#define P_AED_CH2_ND_SUM_OUT                       (volatile uint32_t *)0xfe3321a4
#define P_AED_CH1_ND_CZ_OUT                        (volatile uint32_t *)0xfe3321a8
#define P_AED_CH2_ND_CZ_OUT                        (volatile uint32_t *)0xfe3321ac
#define P_AED_NOISE_STATUS                         (volatile uint32_t *)0xfe3321b0
#define P_AED_POW_CURRENT_S0                       (volatile uint32_t *)0xfe3321b4
#define P_AED_POW_CURRENT_S1                       (volatile uint32_t *)0xfe3321b8
#define P_AED_POW_CURRENT_S2                       (volatile uint32_t *)0xfe3321bc
#define P_AED_POW_OUT0                             (volatile uint32_t *)0xfe3321c0
#define P_AED_POW_OUT1                             (volatile uint32_t *)0xfe3321c4
#define P_AED_POW_OUT2                             (volatile uint32_t *)0xfe3321c8
#define P_AED_POW_ADJ_INDEX0                       (volatile uint32_t *)0xfe3321cc
#define P_AED_POW_ADJ_INDEX1                       (volatile uint32_t *)0xfe3321d0
#define P_AED_POW_ADJ_INDEX2                       (volatile uint32_t *)0xfe3321d4
#define P_AED_DRC_GAIN_INDEX0                      (volatile uint32_t *)0xfe3321d8
#define P_AED_DRC_GAIN_INDEX1                      (volatile uint32_t *)0xfe3321dc
#define P_AED_DRC_GAIN_INDEX2                      (volatile uint32_t *)0xfe3321e0
#define P_AED_CH1_VOLUME_STATE                     (volatile uint32_t *)0xfe3321e4
#define P_AED_CH2_VOLUME_STATE                     (volatile uint32_t *)0xfe3321e8
#define P_AED_CH1_VOLUME_GAIN                      (volatile uint32_t *)0xfe3321ec
#define P_AED_CH2_VOLUME_GAIN                      (volatile uint32_t *)0xfe3321f0
#define P_AED_FULL_POW_CURRENT                     (volatile uint32_t *)0xfe3321f4
#define P_AED_FULL_POW_OUT                         (volatile uint32_t *)0xfe3321f8
#define P_AED_FULL_POW_ADJ                         (volatile uint32_t *)0xfe3321fc
#define P_AED_FULL_DRC_GAIN                        (volatile uint32_t *)0xfe332200
#define P_AED_MASTER_VOLUME_STATE                  (volatile uint32_t *)0xfe332204
#define P_AED_MASTER_VOLUME_GAIN                   (volatile uint32_t *)0xfe332208
#define P_AED_TOP_CTL0                             (volatile uint32_t *)0xfe33220c
#define P_AED_TOP_CTL1                             (volatile uint32_t *)0xfe332210
#define P_AED_TOP_CTL2                             (volatile uint32_t *)0xfe332214
#define P_AED_TOP_ST0                              (volatile uint32_t *)0xfe332218
#define P_AED_TOP_ST1                              (volatile uint32_t *)0xfe33221c
//`define   AED_EQDRC_DYNAMIC_CNTL           10'h90
//`define   AED_COEF_RAM_CNTL_B              10'h91
//`define   AED_COEF_RAM_DATA_B              10'h92
//`define   AED_DRC_RMS_COEF0_B              10'h93
//`define   AED_DRC_RMS_COEF1_B              10'h94
//`define   AED_DRC_THD0_B                   10'h95
//`define   AED_DRC_THD1_B                   10'h96
//`define   AED_DRC_THD2_B                   10'h97
//`define   AED_DRC_THD3_B                   10'h98
//`define   AED_DRC_THD4_B                   10'h99
//`define   AED_DRC_K0_B                     10'h9a
//`define   AED_DRC_K1_B                     10'h9b
//`define   AED_DRC_K2_B                     10'h9c
//`define   AED_DRC_K3_B                     10'h9d
//`define   AED_DRC_K4_B                     10'h9e
//`define   AED_DRC_K5_B                     10'h9f
//`define   AED_DRC_THD_OUT0_B               10'ha0
//`define   AED_DRC_THD_OUT1_B               10'ha1
//`define   AED_DRC_THD_OUT2_B               10'ha2
//`define   AED_DRC_THD_OUT3_B               10'ha3
//`define   AED_DRC_OFFSET_B                 10'ha4
//`define   AED_DRC_RELEASE_COEF00_B         10'ha5
//`define   AED_DRC_RELEASE_COEF01_B         10'ha6
//`define   AED_DRC_RELEASE_COEF10_B         10'ha7
//`define   AED_DRC_RELEASE_COEF11_B         10'ha8
//`define   AED_DRC_RELEASE_COEF20_B         10'ha9
//`define   AED_DRC_RELEASE_COEF21_B         10'haa
//`define   AED_DRC_RELEASE_COEF30_B         10'hab
//`define   AED_DRC_RELEASE_COEF31_B         10'hac
//`define   AED_DRC_RELEASE_COEF40_B         10'had
//`define   AED_DRC_RELEASE_COEF41_B         10'hae
//`define   AED_DRC_RELEASE_COEF50_B         10'haf
//`define   AED_DRC_RELEASE_COEF51_B         10'hb0
//`define   AED_DRC_ATTACK_COEF00_B          10'hb1
//`define   AED_DRC_ATTACK_COEF01_B          10'hb2
//`define   AED_DRC_ATTACK_COEF10_B          10'hb3
//`define   AED_DRC_ATTACK_COEF11_B          10'hb4
//`define   AED_DRC_ATTACK_COEF20_B          10'hb5
//`define   AED_DRC_ATTACK_COEF21_B          10'hb6
//`define   AED_DRC_ATTACK_COEF30_B          10'hb7
//`define   AED_DRC_ATTACK_COEF31_B          10'hb8
//`define   AED_DRC_ATTACK_COEF40_B          10'hb9
//`define   AED_DRC_ATTACK_COEF41_B          10'hba
//`define   AED_DRC_ATTACK_COEF50_B          10'hbb
//`define   AED_DRC_ATTACK_COEF51_B          10'hbc
//`define   AED_MDRC_RMS_COEF00_B            10'hbd
//`define   AED_MDRC_RMS_COEF01_B            10'hbe
//`define   AED_MDRC_RMS_COEF10_B            10'hbf
//`define   AED_MDRC_RMS_COEF11_B            10'hc0
//`define   AED_MDRC_RMS_COEF20_B            10'hc1
//`define   AED_MDRC_RMS_COEF21_B            10'hc2
//`define   AED_MDRC_RELEASE_COEF00_B        10'hc3
//`define   AED_MDRC_RELEASE_COEF01_B        10'hc4
//`define   AED_MDRC_RELEASE_COEF10_B        10'hc5
//`define   AED_MDRC_RELEASE_COEF11_B        10'hc6
//`define   AED_MDRC_RELEASE_COEF20_B        10'hc7
//`define   AED_MDRC_RELEASE_COEF21_B        10'hc8
//`define   AED_MDRC_ATTACK_COEF00_B         10'hc9
//`define   AED_MDRC_ATTACK_COEF01_B         10'hca
//`define   AED_MDRC_ATTACK_COEF10_B         10'hcb
//`define   AED_MDRC_ATTACK_COEF11_B         10'hcc
//`define   AED_MDRC_ATTACK_COEF20_B         10'hcd
//`define   AED_MDRC_ATTACK_COEF21_B         10'hce
//`define   AED_MDRC_THD0_B                  10'hcf
//`define   AED_MDRC_THD1_B                  10'hd0
//`define   AED_MDRC_THD2_B                  10'hd1
//`define   AED_MDRC_K0_B                    10'hd2
//`define   AED_MDRC_K1_B                    10'hd3
//`define   AED_MDRC_K2_B                    10'hd4
//`define   AED_MDRC_OFFSET0_B               10'hd5
//`define   AED_MDRC_OFFSET1_B               10'hd6
//`define   AED_MDRC_OFFSET2_B               10'hd7
//`define   AED_MDRC_LOW_GAIN_B              10'hd8
//`define   AED_MDRC_MID_GAIN_B              10'hd9
//`define   AED_MDRC_HIGH_GAIN_B             10'hda
//`define   AED_DRC_CNTL_B                   10'hdb
//`define   AED_DRC_LOOPBACK_CNTL_B          10'hdc
//`define   AED_MDRC_CNTL_B                  10'hdd
//`define   AED_STATUS_REG                   10'hde
//========================================================================
//  AUDIO locker - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331400
// -----------------------------------------------
#define P_AUD_LOCK_EN                              (volatile uint32_t *)0xfe331400
#define P_AUD_LOCK_SW_RESET                        (volatile uint32_t *)0xfe331404
#define P_AUD_LOCK_SW_LATCH                        (volatile uint32_t *)0xfe331408
#define P_AUD_LOCK_HW_LATCH                        (volatile uint32_t *)0xfe33140c
#define P_AUD_LOCK_REFCLK_SRC                      (volatile uint32_t *)0xfe331410
#define P_AUD_LOCK_REFCLK_LAT_INT                  (volatile uint32_t *)0xfe331414
#define P_AUD_LOCK_IMCLK_LAT_INT                   (volatile uint32_t *)0xfe331418
#define P_AUD_LOCK_OMCLK_LAT_INT                   (volatile uint32_t *)0xfe33141c
#define P_AUD_LOCK_REFCLK_DS_INT                   (volatile uint32_t *)0xfe331420
#define P_AUD_LOCK_IMCLK_DS_INT                    (volatile uint32_t *)0xfe331424
#define P_AUD_LOCK_OMCLK_DS_INT                    (volatile uint32_t *)0xfe331428
#define P_AUD_LOCK_INT_CLR                         (volatile uint32_t *)0xfe33142c
#define P_AUD_LOCK_GCLK_CTRL                       (volatile uint32_t *)0xfe331430
#define P_AUD_LOCK_INT_CTRL                        (volatile uint32_t *)0xfe331434
#define P_RO_REF2IMCLK_CNT_L                       (volatile uint32_t *)0xfe331440
#define P_RO_REF2IMCLK_CNT_H                       (volatile uint32_t *)0xfe331444
#define P_RO_REF2OMCLK_CNT_L                       (volatile uint32_t *)0xfe331448
#define P_RO_REF2OMCLK_CNT_H                       (volatile uint32_t *)0xfe33144c
#define P_RO_IMCLK2REF_CNT_L                       (volatile uint32_t *)0xfe331450
#define P_RO_IMCLK2REF_CNT_H                       (volatile uint32_t *)0xfe331454
#define P_RO_OMCLK2REF_CNT_L                       (volatile uint32_t *)0xfe331458
#define P_RO_OMCLK2REF_CNT_H                       (volatile uint32_t *)0xfe33145c
#define P_RO_REFCLK_PKG_CNT                        (volatile uint32_t *)0xfe331460
#define P_RO_IMCLK_PKG_CNT                         (volatile uint32_t *)0xfe331464
#define P_RO_OMCLK_PKG_CNT                         (volatile uint32_t *)0xfe331468
#define P_RO_AUD_LOCK_INT_STATUS                   (volatile uint32_t *)0xfe33146c
//========================================================================
//  AUDIO lockerB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334400
// -----------------------------------------------
#define P_AUD_LOCKB_EN                             (volatile uint32_t *)0xfe334400
#define P_AUD_LOCKB_SW_RESET                       (volatile uint32_t *)0xfe334404
#define P_AUD_LOCKB_SW_LATCH                       (volatile uint32_t *)0xfe334408
#define P_AUD_LOCKB_HW_LATCH                       (volatile uint32_t *)0xfe33440c
#define P_AUD_LOCKB_REFCLK_SRC                     (volatile uint32_t *)0xfe334410
#define P_AUD_LOCKB_REFCLK_LAT_INT                 (volatile uint32_t *)0xfe334414
#define P_AUD_LOCKB_IMCLK_LAT_INT                  (volatile uint32_t *)0xfe334418
#define P_AUD_LOCKB_OMCLK_LAT_INT                  (volatile uint32_t *)0xfe33441c
#define P_AUD_LOCKB_REFCLK_DS_INT                  (volatile uint32_t *)0xfe334420
#define P_AUD_LOCKB_IMCLK_DS_INT                   (volatile uint32_t *)0xfe334424
#define P_AUD_LOCKB_OMCLK_DS_INT                   (volatile uint32_t *)0xfe334428
#define P_AUD_LOCKB_INT_CLR                        (volatile uint32_t *)0xfe33442c
#define P_AUD_LOCKB_GCLK_CTRL                      (volatile uint32_t *)0xfe334430
#define P_AUD_LOCKB_INT_CTRL                       (volatile uint32_t *)0xfe334434
#define P_ROB_REF2IMCLK_CNT_L                      (volatile uint32_t *)0xfe334440
#define P_ROB_REF2IMCLK_CNT_H                      (volatile uint32_t *)0xfe334444
#define P_ROB_REF2OMCLK_CNT_L                      (volatile uint32_t *)0xfe334448
#define P_ROB_REF2OMCLK_CNT_H                      (volatile uint32_t *)0xfe33444c
#define P_ROB_IMCLK2REF_CNT_L                      (volatile uint32_t *)0xfe334450
#define P_ROB_IMCLK2REF_CNT_H                      (volatile uint32_t *)0xfe334454
#define P_ROB_OMCLK2REF_CNT_L                      (volatile uint32_t *)0xfe334458
#define P_ROB_OMCLK2REF_CNT_H                      (volatile uint32_t *)0xfe33445c
#define P_ROB_REFCLK_PKG_CNT                       (volatile uint32_t *)0xfe334460
#define P_ROB_IMCLK_PKG_CNT                        (volatile uint32_t *)0xfe334464
#define P_ROB_OMCLK_PKG_CNT                        (volatile uint32_t *)0xfe334468
#define P_ROB_AUD_LOCK_INT_STATUS                  (volatile uint32_t *)0xfe33446c
//========================================================================
//  AUDIO VAD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331800
// -----------------------------------------------
//
// Reading file:  VAD_REG.h
//
#define P_VAD_TOP_CTRL0                            (volatile uint32_t *)0xfe331800
#define P_VAD_TOP_CTRL1                            (volatile uint32_t *)0xfe331804
#define P_VAD_TOP_CTRL2                            (volatile uint32_t *)0xfe331808
#define P_VAD_FIR_CTRL                             (volatile uint32_t *)0xfe33180c
#define P_VAD_FIR_EMP                              (volatile uint32_t *)0xfe331810
#define P_VAD_FIR_COEF0                            (volatile uint32_t *)0xfe331814
#define P_VAD_FIR_COEF1                            (volatile uint32_t *)0xfe331818
#define P_VAD_FIR_COEF2                            (volatile uint32_t *)0xfe33181c
#define P_VAD_FIR_COEF3                            (volatile uint32_t *)0xfe331820
#define P_VAD_FIR_COEF4                            (volatile uint32_t *)0xfe331824
#define P_VAD_FIR_COEF5                            (volatile uint32_t *)0xfe331828
#define P_VAD_FIR_COEF6                            (volatile uint32_t *)0xfe33182c
#define P_VAD_FIR_COEF7                            (volatile uint32_t *)0xfe331830
#define P_VAD_FIR_COEF8                            (volatile uint32_t *)0xfe331834
#define P_VAD_FIR_COEF9                            (volatile uint32_t *)0xfe331838
#define P_VAD_FIR_COEF10                           (volatile uint32_t *)0xfe33183c
#define P_VAD_FIR_COEF11                           (volatile uint32_t *)0xfe331840
#define P_VAD_FIR_COEF12                           (volatile uint32_t *)0xfe331844
#define P_VAD_FRAME_CTRL0                          (volatile uint32_t *)0xfe331848
#define P_VAD_FRAME_CTRL1                          (volatile uint32_t *)0xfe33184c
#define P_VAD_FRAME_CTRL2                          (volatile uint32_t *)0xfe331850
#define P_VAD_CEP_CTRL0                            (volatile uint32_t *)0xfe331854
#define P_VAD_CEP_CTRL1                            (volatile uint32_t *)0xfe331858
#define P_VAD_CEP_CTRL2                            (volatile uint32_t *)0xfe33185c
#define P_VAD_CEP_CTRL3                            (volatile uint32_t *)0xfe331860
#define P_VAD_CEP_CTRL4                            (volatile uint32_t *)0xfe331864
#define P_VAD_CEP_CTRL5                            (volatile uint32_t *)0xfe331868
#define P_VAD_DEC_CTRL                             (volatile uint32_t *)0xfe33186c
#define P_VAD_TOP_STS0                             (volatile uint32_t *)0xfe331870
#define P_VAD_TOP_STS1                             (volatile uint32_t *)0xfe331874
#define P_VAD_TOP_STS2                             (volatile uint32_t *)0xfe331878
#define P_VAD_FIR_STS0                             (volatile uint32_t *)0xfe33187c
#define P_VAD_FIR_STS1                             (volatile uint32_t *)0xfe331880
#define P_VAD_POW_STS0                             (volatile uint32_t *)0xfe331884
#define P_VAD_POW_STS1                             (volatile uint32_t *)0xfe331888
#define P_VAD_POW_STS2                             (volatile uint32_t *)0xfe33188c
#define P_VAD_FFT_STS0                             (volatile uint32_t *)0xfe331890
#define P_VAD_FFT_STS1                             (volatile uint32_t *)0xfe331894
#define P_VAD_SPE_STS0                             (volatile uint32_t *)0xfe331898
#define P_VAD_SPE_STS1                             (volatile uint32_t *)0xfe33189c
#define P_VAD_SPE_STS2                             (volatile uint32_t *)0xfe3318a0
#define P_VAD_SPE_STS3                             (volatile uint32_t *)0xfe3318a4
#define P_VAD_DEC_STS0                             (volatile uint32_t *)0xfe3318a8
#define P_VAD_DEC_STS1                             (volatile uint32_t *)0xfe3318ac
#define P_VAD_LUT_CTRL                             (volatile uint32_t *)0xfe3318b0
#define P_VAD_LUT_WR                               (volatile uint32_t *)0xfe3318b4
#define P_VAD_LUT_RD                               (volatile uint32_t *)0xfe3318b8
#define P_VAD_IN_SEL0                              (volatile uint32_t *)0xfe3318bc
#define P_VAD_IN_SEL1                              (volatile uint32_t *)0xfe3318c0
#define P_VAD_TO_DDR                               (volatile uint32_t *)0xfe3318c4
#define P_VAD_SYNC_CTRL0                           (volatile uint32_t *)0xfe3318c8
#define P_VAD_SYNC_CHNUM_ID0                       (volatile uint32_t *)0xfe3318cc
#define P_VAD_SYNC_CHNUM_ID1                       (volatile uint32_t *)0xfe3318d0
#define P_VAD_SYNC_CHNUM_ID2                       (volatile uint32_t *)0xfe3318d4
#define P_VAD_SYNC_CHNUM_ID3                       (volatile uint32_t *)0xfe3318d8
#define P_VAD_SYNC_CHNUM_ID4                       (volatile uint32_t *)0xfe3318dc
#define P_VAD_SYNC_CHNUM_ID5                       (volatile uint32_t *)0xfe3318e0
#define P_VAD_SYNC_CHNUM_ID6                       (volatile uint32_t *)0xfe3318e4
#define P_VAD_SYNC_CHNUM_ID7                       (volatile uint32_t *)0xfe3318e8
//
// Closing file:  VAD_REG.h
//
//========================================================================
//  AUDIO RESAMPLEA - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331c00
// -----------------------------------------------
//
// Reading file:  RESAMPLE.h
//
#define P_AUDIO_RSAMP_CTRL0                        (volatile uint32_t *)0xfe331c00
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define P_AUDIO_RSAMP_CTRL1                        (volatile uint32_t *)0xfe331c04
//Bit   31:27      reg_in_lsb        //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:5        reserved          //unsigned  , default =2;
//Bit   4:0        reg_inp_mux       //unsigned  , default =0;
#define P_AUDIO_RSAMP_CTRL2                        (volatile uint32_t *)0xfe331c08
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define P_AUDIO_RSAMP_PHSINIT                      (volatile uint32_t *)0xfe331c0c
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define P_AUDIO_RSAMP_PHSSTEP                      (volatile uint32_t *)0xfe331c10
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define P_AUDIO_RSAMP_SHIFT                        (volatile uint32_t *)0xfe331c14
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define P_AUDIO_RSAMP_ADJ_CTRL0                    (volatile uint32_t *)0xfe331c18
//Bit   31:7        reserved                //unsigned
//Bit   6           reg_lock_vld_sel        //unsigned , default = 0;
//Bit   5           reg_loop_dif_clr_en     //unsigned , default = 0;
//Bit   4           reg_aout_force_en       //unsigned , default = 0;
//Bit   3           reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define P_AUDIO_RSAMP_ADJ_CTRL1                    (volatile uint32_t *)0xfe331c1c
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define P_AUDIO_RSAMP_ADJ_SFT                      (volatile uint32_t *)0xfe331c20
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define P_AUDIO_RSAMP_ADJ_IDET_LEN                 (volatile uint32_t *)0xfe331c24
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define P_AUDIO_RSAMP_ADJ_FORCE                    (volatile uint32_t *)0xfe331c28
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define P_AUDIO_RSAMP_ADJ_KI_FORCE                 (volatile uint32_t *)0xfe331c2c
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define P_AUDIO_RSAMP_WATCHDOG_THRD                (volatile uint32_t *)0xfe331c30
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define P_AUDIO_RSAMP_DBG_INFO                     (volatile uint32_t *)0xfe331c34
//Bit   31:16      reg_aout_force_hi        //unsigned , default = 0;
//Bit   15:7       reserved                 //unsigned , default = 0;
//Bit   6          reg_rsamp_dbgcnt_clr     //unsigned , default = 0;
//Bit   5          reg_rsamp_dbgcnt_vldsel  //unsigned , default = 0;
//Bit   4          reg_rsamp_dbgcnt_en      //unsigned , default = 0;
//Bit   3          reserved                 //unsigned , default = 0;
//Bit   2:0        reg_watchdog_rstsel      //unsigned , default = 4;
#define P_AUDIO_RSAMP_AOUT_FORCE                   (volatile uint32_t *)0xfe331c38
//Bit   31:0       reg_aout_force_lo        //unsigned , default = 0;
#define P_AUDIO_RSAMP_IRQ_CTRL                     (volatile uint32_t *)0xfe331c3c
//Bit   31:16      reg_irq_thrd             //unsigned , default = 0;
//Bit   15:12      reserved                 //unsigned , default = 0;
//Bit   11:8       reg_irq_sel              //unsigned , default = 0;
//Bit   7:4        reg_irq_clr              //unsigned , default = 0;
//Bit   3:0        reg_irq_en               //unsigned , default = 0;
#define P_AUDIO_RSAMP_RO_STATUS                    (volatile uint32_t *)0xfe331c40
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define P_AUDIO_RSAMP_RO_ADJ_FREQ                  (volatile uint32_t *)0xfe331c44
//Bit   31:0       ro_rsamp_adj_freq
#define P_AUDIO_RSAMP_RO_ADJ_DIFF_BAK              (volatile uint32_t *)0xfe331c48
//Bit   31:0       ro_det_diff_bak
#define P_AUDIO_RSAMP_RO_ADJ_DIFF_DLT              (volatile uint32_t *)0xfe331c4c
//Bit   31:0       ro_det_diff_dlt
#define P_AUDIO_RSAMP_RO_ADJ_PHS_ERR               (volatile uint32_t *)0xfe331c50
//Bit   31:0       ro_det_phase_err
#define P_AUDIO_RSAMP_RO_ADJ_KI_OUT                (volatile uint32_t *)0xfe331c54
//Bit   31:0       ro_rsamp_ki_out
#define P_AUDIO_RSAMP_RO_IN_CNT                    (volatile uint32_t *)0xfe331c58
//Bit   31:0       ro_rsamp_in_cnt
#define P_AUDIO_RSAMP_RO_OUT_CNT                   (volatile uint32_t *)0xfe331c5c
//Bit   31:0       ro_rsamp_out_cnt
#define P_AUDIO_RSAMP_RO_ADJ_PHS_ERR_VAR           (volatile uint32_t *)0xfe331c60
//Bit   31:0       ro_det_phase_err_var
#define P_AUDIO_RSAMP_POST_COEF0                   (volatile uint32_t *)0xfe331c80
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define P_AUDIO_RSAMP_POST_COEF1                   (volatile uint32_t *)0xfe331c84
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define P_AUDIO_RSAMP_POST_COEF2                   (volatile uint32_t *)0xfe331c88
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define P_AUDIO_RSAMP_POST_COEF3                   (volatile uint32_t *)0xfe331c8c
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define P_AUDIO_RSAMP_POST_COEF4                   (volatile uint32_t *)0xfe331c90
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define P_AUDIO_RSAMP_AA_COEF_ADDR                 (volatile uint32_t *)0xfe331cc0
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define P_AUDIO_RSAMP_AA_COEF_DATA                 (volatile uint32_t *)0xfe331cc4
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define P_AUDIO_RSAMP_SINC_COEF_ADDR               (volatile uint32_t *)0xfe331d00
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define P_AUDIO_RSAMP_SINC_COEF_DATA               (volatile uint32_t *)0xfe331d04
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  RESAMPLE.h
//
//========================================================================
//  AUDIO EARCTX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333000
// -----------------------------------------------
//
// Reading file:  earc_tx_cmdc.h
//
#define P_EARC_TX_CMDC_TOP_CTRL0                   (volatile uint32_t *)0xfe3330c0
//Bit   31   ,      idle2_int          unsigned, default = 0, 1: enable
//Bit   30   ,      idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,      disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,      disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,      earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,      hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,      losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,      timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,      status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,      int_recv_finished  unsigned, default = 0, 1: enable
//Bit   21   ,      int_rdata          unsigned, default = 0, 1: enable
//Bit   20   ,      int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,      int_recv_norsp     unsigned, default = 0, 1: enable
//Bit   18   ,      int_recv_unexp     unsigned, default = 0, 1: enable
//Bit   17   ,      int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,      int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,      int_recv_ecc_err   unsigned, default = 0, 1: enable
//Bit   14   ,      int_recv_packet    unsigned, default = 0, 1: enable
//Bit   13:0 ,      reserved
#define P_EARC_TX_CMDC_TOP_CTRL1                   (volatile uint32_t *)0xfe3330c4
//Bit      31:0,     cmdc_top_ctrl1     //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_TOP_CTRL2                   (volatile uint32_t *)0xfe3330c8
//Bit   31   ,     reset_idle2_int              unsigned, default = 0, 1: enable
//Bit   30   ,     reset_idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,     reset_disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,     reset_disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,     reset_earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,     reset_hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,     reset_losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,     reset_timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,     reset_status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,     reset_int_recv_finished        unsigned, default = 0, 1: enable
//Bit   21   ,     reset_int_rdata              unsigned, default = 0, 1: enable
//Bit   20   ,     reset_int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,     reset_int_recv_norsp         unsigned, default = 0, 1: enable
//Bit   18   ,     reset_int_recv_unexp         unsigned, default = 0, 1: enable
//Bit   17   ,     reset_int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,     reset_int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,     reset_int_recv_ecc_err       unsigned, default = 0, 1: enable
//Bit   14   ,     reset_int_recv_packet        unsigned, default = 0, 1: enable
//Bit 13:0   ,     reserved
#define P_EARC_TX_CMDC_TIMER_CTRL0                 (volatile uint32_t *)0xfe3330cc
//Bit      31:0,     cmdc_timer_ctrl0   //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_TIMER_CTRL1                 (volatile uint32_t *)0xfe3330d0
//Bit      31:0,     cmdc_timer_ctrl1  //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_TIMER_CTRL2                 (volatile uint32_t *)0xfe3330d4
//Bit      31:0,     cmdc_timer_ctrl2  //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_TIMER_CTRL3                 (volatile uint32_t *)0xfe3330d8
//Bit      31:0,     cmdc_timer_ctrl3  //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_VSM_CTRL0                   (volatile uint32_t *)0xfe3330dc
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state                 unsigned, default = 0,  XX
//Bit      27,      arc_initiated             unsigned, default = 0,  XX
//Bit      26,      arc_terminated             unsigned, default = 0,  XX
//Bit      25,      arc_enable                 unsigned, default = 1,  XX
//Bit      24,      man_hpd                 unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel                 unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state_en           unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en             unsigned, default = 0,  XX
//Bit      13,      noack_repeat_en            unsigned, default = 0,  XX
//Bit    12:0,      reserved
#define P_EARC_TX_CMDC_VSM_CTRL1                   (volatile uint32_t *)0xfe3330e0
//Bit    31:9,      reserved
//Bit       8,      cntl_hpd_sel            unsigned, default = 0, 0:sel hd_hpd,1:sel hdmirx_hpd
//Bit     7:0,      comma_cnt_th            unsigned, default = 0, should bigger than 3 and small than 10
#define P_EARC_TX_CMDC_VSM_CTRL2                   (volatile uint32_t *)0xfe3330e4
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc1 hpd_val timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc1 hpd_val timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc1 hpd_val timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc1 hpd_val timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc1 hpd_val timing
#define P_EARC_TX_CMDC_VSM_CTRL3                   (volatile uint32_t *)0xfe3330e8
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc2 heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc2 heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc2 heartbeat act timing
#define P_EARC_TX_CMDC_VSM_CTRL4                   (volatile uint32_t *)0xfe3330ec
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc2, no heartbeat ack timing
#define P_EARC_TX_CMDC_VSM_CTRL5                   (volatile uint32_t *)0xfe3330f0
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc1 and disc2 timing out
#define P_EARC_TX_CMDC_VSM_CTRL6                   (volatile uint32_t *)0xfe3330f4
//Bit    31:12,      max_count_th          unsigned, default = 0,  in earc heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in earc heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat act timing
#define P_EARC_TX_CMDC_VSM_CTRL7                   (volatile uint32_t *)0xfe3330f8
//Bit    31:16,      reserved
//Bit     15:8,      status_soft_val       unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define P_EARC_TX_CMDC_VSM_CTRL8                   (volatile uint32_t *)0xfe3330fc
//Bit      31:0,     cmdc_vsm_ctrl8        //unsigned, RW, default = 0,
#define P_EARC_TX_CMDC_VSM_CTRL9                   (volatile uint32_t *)0xfe333104
//Bit      31:0,     cmdc_vsm_ctrl9        //unsigned, RW, default = 0
#define P_EARC_TX_CMDC_SENDER_CTRL0                (volatile uint32_t *)0xfe333108
//Bit      31:2,     sender_ctrl0                 unsigned,  default = 0,
//Bit      1,        hb_chg_conf_auto             unsigned,  default = 1,
//Bit      0,        hb_chg_auto                  unsigned,  default = 0,
#define P_EARC_TX_CMDC_PACKET_CTRL0                (volatile uint32_t *)0xfe33310c
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst                    unsigned, default = 0,  packet control
//Bit     28:24,      tx_ready_threshold          unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_threshold          unsigned, default = 0,  packet control
//Bit       7:6,      reserved
//Bit         5,      state_auto_en               unsigned, default = 0, packet control
//Bit         4,      sw_state_update_en          unsigned, default = 0,  packet control
//Bit       3:0,      sw_state_value              unsigned, default = 0,  packet control
#define P_EARC_TX_CMDC_PACKET_CTRL1                (volatile uint32_t *)0xfe333110
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_start_value             unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_threshold              unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_threshold               unsigned, default = 0,  XX
//Bit       7:0,      post_flag                   unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_PACKET_CTRL2                (volatile uint32_t *)0xfe333114
//Bit      31:0,      pre_flag                    unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_PACKET_CTRL3                (volatile uint32_t *)0xfe333118
//Bit      31,       recv_en                      unsigned, default = 0,  XX
//Bit      30,       recv_parity_mask             unsigned, default = 0,  XX
//Bit      29,       recv_timeout_en              unsigned, default = 0,  XX
//Bit      28,       bch_ecc_en                   unsigned, default = 0, xx
//Bit     27:16,     reserved
//Bit      15:0,     recv_timeout_threshold       unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_PACKET_CTRL4                (volatile uint32_t *)0xfe33311c
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head             unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_PACKET_CTRL5                (volatile uint32_t *)0xfe333120
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head_mask        unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_PACKET_CTRL6                (volatile uint32_t *)0xfe333124
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:7,     reserved
//Bit         6,     recv_finished_int            unsigned, default = 0,  XX
//Bit         5,     recv_ecc_err_int             unsigned, default = 0,  XX
//Bit         4,     recv_ack_int                 unsigned, default = 0,  XX
//Bit         3,     recv_data_int                unsigned, default = 0,  XX
//Bit         2,     recv_unexp_int               unsigned, default = 0,  XX
//Bit         1,     recv_norsp_int               unsigned, default = 0,  XX
//Bit         0,     recv_nack_int                unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_BIPHASE_CTRL0               (volatile uint32_t *)0xfe333128
//Bit     31:24,     reserved
//Bit     23:16,     ack delay threshold           unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define P_EARC_TX_CMDC_BIPHASE_CTRL1               (volatile uint32_t *)0xfe33312c
//Bit     31:16,     reserved
//Bit        15,     ack_enable                    unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     wait_threshold before ack     unsigned, default = 0,  send
#define P_EARC_TX_CMDC_BIPHASE_CTRL2               (volatile uint32_t *)0xfe333130
//Bit        31,     comma_detection_enable        unsigned, default = 0, comma detection
//Bit        30,     manual_reset_enable           unsigned, default = 0, manual reset select, 1: manual
//Bit        29,     manual_reset_value            unsigned, default = 0, manual reset control
//Bit     28:16,     reserved
//Bit      15:0,     comma_detection_threshold     unsigned, default = 0,
#define P_EARC_TX_CMDC_BIPHASE_CTRL3               (volatile uint32_t *)0xfe333134
//Bit      31:0,     cmdc_biphase_ctrl3            unsigned, default = 0,
#define P_EARC_TX_CMDC_DEVICE_ID_CTRL              (volatile uint32_t *)0xfe333138
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_rw_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_rw_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:17,     reserved
//Bit        16,     hpb_rst_enable               unsigned, default = 1, hpd rst enable
//Bit      15:8,     apb_rwid                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apbrw_start_addr            unsigned, default = 0, apb bus wr/read
#define P_EARC_TX_CMDC_DEVICE_WDATA                (volatile uint32_t *)0xfe33313c
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/read
#define P_EARC_TX_CMDC_DEVICE_RDATA                (volatile uint32_t *)0xfe333140
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/read
#define P_EARC_TX_CMDC_MASTER_CTRL                 (volatile uint32_t *)0xfe333144
//Bit        31,     master_cmd_rw                 unsigned, default = 0, 1 write 0 read
//Bit        30,     master_hb_ignore              unsigned, default =0, 0:wait hb issued before pkt cmd, 1: pkt cmd issued immediately
//Bit        29,     master_idle                   unsigned, default = 0, master status
//Bit        28,     master_cmd_soft_rst           unsigned, default= 0,
//Bit     27:24,     hb_cmd_cal_th                 unsigned, default= 0,
//Bit     23:16,     master_cmd_count              unsigned, default = 0, cmd count -1
//Bit      15:8,     master_cmd_id                 unsigned, default = 0,
//Bit       7:0,     master_cmd_address            unsigned, default = 0,
#define P_EARC_TX_ANA_CTRL0                        (volatile uint32_t *)0xfe333148
//Bit      31:0,      reg_earctx_ana_ctrl0       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_CTRL1                        (volatile uint32_t *)0xfe33314c
//Bit      31:0,      reg_earctx_ana_ctrl1       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_CTRL2                        (volatile uint32_t *)0xfe333150
//Bit      31:0,      reg_earctx_ana_ctrl2       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_CTRL3                        (volatile uint32_t *)0xfe333154
//Bit      31:0,      reg_earctx_ana_ctrl3       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_CTRL4                        (volatile uint32_t *)0xfe333158
//Bit      31:0,      reg_earctx_ana_ctrl4       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_CTRL5                        (volatile uint32_t *)0xfe33315c
//Bit      31:0,      reg_earctx_ana_ctrl5       //unsigned, RW, default = 0,
#define P_EARC_TX_ANA_STAT0                        (volatile uint32_t *)0xfe333160
//Bit      31:0,     ro_ANA_status0              //unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS0                     (volatile uint32_t *)0xfe333164
//Bit      31:0,     ro_cmdc_status0              //unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS1                     (volatile uint32_t *)0xfe333168
//Bit      31:0,     ro_cmdc_status1              ///unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS2                     (volatile uint32_t *)0xfe33316c
//Bit      31:0,     ro_cmdc_status2              ///unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS3                     (volatile uint32_t *)0xfe333170
//Bit      31:0,     ro_cmdc_status3              ///unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS4                     (volatile uint32_t *)0xfe333174
//Bit      31:0,     ro_cmdc_status4              ///unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS5                     (volatile uint32_t *)0xfe333178
//Bit      31:0,     ro_cmdc_status5              ///unsigned, RO, default = 0,
#define P_EARC_TX_CMDC_STATUS6                     (volatile uint32_t *)0xfe33317c
//Bit   31   ,     ro_idle2_int            unsigned, RO, default = 0
//Bit   30   ,     ro_idle1_int            unsigned, RO, default = 0
//Bit   29   ,     ro_disc2_int            unsigned, RO, default = 0
//Bit   28   ,     ro_disc1_int            unsigned, RO, default = 0
//Bit   27   ,     ro_earc_int             unsigned, RO, default = 0
//Bit   26   ,     ro_hb_status_int        unsigned, RO, default = 0
//Bit   25   ,     ro_losthb_int           unsigned, RO, default = 0
//Bit   24   ,     ro_timeout_int          unsigned, RO, default = 0
//Bit   23   ,     ro_status_ch_int        unsigned, RO, default = 0
//Bit   22   ,     ro_int_recv_finished    unsigned, RO, default = 0
//Bit   21   ,     ro_int_rdata            unsigned, RO, default = 0
//Bit   20   ,     ro_int_recv_nack        unsigned, RO, default = 0
//Bit   19   ,     ro_int_recv_norsp       unsigned, RO, default = 0
//Bit   18   ,     ro_int_recv_unexp       unsigned, RO, default = 0
//Bit   17   ,     ro_int_recv_data        unsigned, RO, default = 0
//Bit   16   ,     ro_int_recv_ack         unsigned, RO, default = 0
//Bit   15   ,     ro_int_recv_ecc_err     unsigned, RO, default = 0
//Bit   14   ,     ro_int_recv_packet      unsigned, RO, default = 0
//Bit 13:0   ,     reserved
//
// Closing file:  earc_tx_cmdc.h
//
//========================================================================
//  AUDIO EARCTX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333400
// -----------------------------------------------
//
// Reading file:  earctx_dmac.h
//
#define P_EARCTX_DMAC_TOP_CTRL0                    (volatile uint32_t *)0xfe333400
//Bit 31,       reg_top_reg_sync             ,default = 0,Bit 3:0 sync to clk10m,pluse auto clear
//Bit 30,       reg_top_soft_rst             ,default = 0
//Bit 29:26,    reserved
//Bit 25:24,    reg_debug_mux                ,default = 0
//Bit 23:21,    reserved
//Bit 20,       reg_slow_sync_scan_reg       ,default = 0
//Bit 19,       reg_fe_sf_scan_reg           ,default = 0
//Bit 18,       reg_fe_slow_sync_scan_reg    ,default = 0
//Bit 17,       reg_top_sf_scan_reg          ,default = 0
//Bit 16,       reg_top_slow_sync_scan_reg   ,default = 0
//Bit 15:4,     reserved
//Bit 3,        reg_spdif_tx_en_force        ,default = 0,spdif_tx_en force enable
//Bit 2,        reg_spdif_tx_en_force_value  ,default = 0,spdif_tx_en force value
//Bit 1,        reg_dmac_tx_en_force         ,default = 0,dmac_tx_en force enable
//Bit 0,        reg_dmac_tx_en_force_value   ,default = 0,dmac_tx_en force value
#define P_EARCTX_MUTE_VAL                          (volatile uint32_t *)0xfe333404
//Bit 31:0,     reg_spdif_mute_val     ,default = 0,when biahpase encode mute,the channel value,with reg_mute_l/reg_mute_r
#define P_EARCTX_SPDIFOUT_GAIN0                    (volatile uint32_t *)0xfe333408
//Bit 31:24,    reg_gain_ch3     ,default = 0,channel 3 gain
//Bit 23:16,    reg_gain_ch2     ,default = 0,channel 2 gain
//Bit 15:8,     reg_gain_ch1     ,default = 0,channel 1 gain
//Bit 7:0,      reg_gain_ch0     ,default = 0,channel 0 gain
#define P_EARCTX_SPDIFOUT_GAIN1                    (volatile uint32_t *)0xfe33340c
//Bit 31:24,    reg_gain_ch7     ,default = 0,channel 7 gain
//Bit 23:16,    reg_gain_ch6     ,default = 0,channel 6 gain
//Bit 15:8,     reg_gain_ch5     ,default = 0,channel 5 gain
//Bit 7:0,      reg_gain_ch4     ,default = 0,channel 4 gain
#define P_EARCTX_SPDIFOUT_CTRL0                    (volatile uint32_t *)0xfe333410
//Bit 31,     reg_work_start      ,default = 0,biphase work start,pluse
//Bit 30,     reg_work_clr        ,default = 0,biphase work clear,pluse
//Bit 29,     reg_rst_afifo_out_n ,default = 0,afifo out reset
//Bit 28,     reg_rst_afifo_in_n  ,default = 0,afifo in reset
//Bit 27,     reg_hold_for_tdm    ,default = 0,add delay to mathc TDM out when share buff
//Bit 26,     reg_userdata_sel    ,default = 0,user Bit select : 0 from reg_userdata_set 1 from data[29]
//Bit 25,     reg_userdata_set    ,default = 0
//Bit 24,     reg_chdata_sel      ,default = 0,0 :from reg_chstst 1 from data[30]
//Bit 23,     reserved
//Bit 22,     reg_mute_l          ,default = 0,r channel mute ,with reg_mute_val
//Bit 21,     reg_mute_r          ,default = 0,l channel mute ,with reg_mute_val
//Bit 20,     reg_data_sel        ,default = 0,0 data from 31Bit 1 data from 27bit
//Bit 19,     reg_out_msb_first   ,default = 0,0 lsb first 1 msb first
//Bit 18,     reg_valid_sel       ,default = 0,biphase encode valid Bit value sel : 0 from data 1 from reg_valid_set
//Bit 17,     reg_valid_set       ,default = 0,biphase encode valid Bit value
//Bit 16,     reg_mute_hold_init_en  ,default = 0,when c_mute_hold_last_err_corrt valid,clear work enable, initial biphase encode
//Bit 15:12,  reserved
//Bit 0,      reg_parity_mask     ,default = 0,Bit 0 is initial parity value
#define P_EARCTX_SPDIFOUT_CTRL1                    (volatile uint32_t *)0xfe333414
//Bit 31,     reg_eq_drc_sel      ,default = 0,set 1 select eq_drc data
//Bit 30,     reg_keep_req_ddr_init ,default = 0,reg_keep_req_ddr_init
//Bit 29:28,  reserved
//Bit 27,     reg_gain_en         ,default = 0,gain enable
//Bit 26:24,  reg_frddr_sel       ,default = 0,from ddr select
//Bit 23:16,  reg_wait_cnt        ,default = 0,wait some time when enable set to 1
//Bit 15:13,  reserved
//Bit 12:8,   reg_frddr_msb       ,default = 0,msb position of data
//Bit 7,      reg_force_start     ,default = 0,set 1 no need ack from frddr to transmit channel status
//Bit 6:4,    reg_frddr_type      ,default = 0
//Bit 3:0,    reserved
#define P_EARCTX_SPDIFOUT_PREAMB                   (volatile uint32_t *)0xfe333418
//Bit 31,     reg_preamble_Z_set      ,default = 0,user 8'b11101000 1 user 7:0
//Bit 30,     reg_preamble_Y_set      ,default = 0,user 8'b11100100 1 user 15:8
//Bit 29,     reg_preamble_X_set      ,default = 0,user 8'b11100010 1 user 23:16
//Bit 28:24,  reserved
//Bit 23:16,  reg_preamble_X_value    ,default = 0
//Bit 15:8,   reg_preamble_Y_value    ,default = 0
//Bit 7:0,    reg_preamble_Z_value    ,default = 0
#define P_EARCTX_SPDIFOUT_SWAP                     (volatile uint32_t *)0xfe33341c
//Bit 31:16,  reg_hold_cnt        ,default = 0,hold start cnt ,valid when reg_hold_for_tdm set 1
//Bit 15,     reg_init_send_en    ,default = 0,send 01 sequence some times after initial done from frddr set
//Bit 14:0,   reg_init_send_cnt   ,default = 0,send 01 sequence time ,valid when reg_init_send_en set 1
#define P_EARCTX_ERR_CORRT_CTRL0                   (volatile uint32_t *)0xfe333420
//Bit 31:24,  reserved
//Bit 23,     reg_bch_in_reverse       ,default = 0,bch input data generate in 24it data reverse
//Bit 22,     reg_bch_out_ecc_reverse  ,default = 0,bch output ecc  reverse
//Bit 21,     reg_bch_out_data_reverse ,default = 0,bch output data reverse
//Bit 20,     reg_bch_out_ecc_msb      ,default = 0,bch output ecc position
//Bit 19:17,  reserved
//Bit 16,     reg_ubit_fifo_init_n,default = 0,fifo in  initial
//Bit 15:14,  reserved
//Bit 13:12,  reg_gain_shift      ,default = 0,gain x 1/2/4/8
//Bit 11,     reg_mix_lr          ,default = 0,l/r mix
//Bit 10:8,   reg_spdifout_r_sel  ,default = 0,r channel select
//Bit 7,      reserved
//Bit 6:4,    reg_spdifout_l_sel  ,default = 0,l channel select
//Bit 3:0,    reg_iu_interval     ,default = 0,iu transmit interval
#define P_EARCTX_ERR_CORRT_CTRL1                   (volatile uint32_t *)0xfe333424
//Bit 31,     reg_ubit_fifo_wr    ,default = 0,iu data write enable,pluse,auto clr in reg.v
//Bit 30:8,   reserved
//Bit 7:0,    reg_ubit_fifo_wdata ,default = 0,iu data
#define P_EARCTX_ERR_CORRT_CTRL2                   (volatile uint32_t *)0xfe333428
//Bit 31,     reg_mute_clear       ,default = 0,mute clear,pluse,auto clr in reg.v
//Bit 30,     reg_mute_start       ,default = 0,mute start,pluse,auto clr in reg.v
//Bit 29:28,  reserved
//Bit 27:16,  reg_mute_block_num   ,default = 0,mute block number
//Bit 15:8,   reg_mute_ch_Bit      ,default = 0,mute Bit at channel statue which bit
//Bit 7:3,    reserved
//Bit 2,      reg_mute_data_sel    ,default = 0,mute data sel: 0 data 1 reg_mute_data_value
//Bit 1:0,    reg_mute_mode        ,default = 0,0:always mute 1:mute block number and dis mute 2:mute block number and hold bus
#define P_EARCTX_ERR_CORRT_CTRL3                   (volatile uint32_t *)0xfe33342c
//Bit 31:30,  reserved
//Bit 29,     reg_bch_en           ,default = 0,bch generate enable
//Bit 28:24,  reg_bch_msb          ,default = 0,bch data msb position in audio data
//Bit 23:0,   reg_mute_data_value  ,default = 0,mute value,only for audio data part
#define P_EARCTX_ERR_CORRT_CTRL4                   (volatile uint32_t *)0xfe333430
//Bit 31,    reg_ubit_fifo_lr_swap        ,default = 0,//user Bit lr swap
//Bit 30,    reg_ubit_fifo_lr_same        ,default = 0,//l/r channel use same Bit user bit
//Bit 29:25, reg_data_msb                 ,default = 0,audio data msb postion in input data
//Bit 24,    reg_data_rsv                 ,default = 0,audio data msb/lsb
//Bit 23,    reg_ubit_value               ,default = 0,user Bit value
//Bit 22,    reg_vbit_value               ,default = 0,valid Bit value
//Bit 21,    reg_data_sel                 ,default = 0,//data sel: 0 data 1 reg_mute_data_value
//Bit 20:19, reg_ubit_sel                 ,default = 0,//userBit sel: 0 data 1 reg_value 2 fifo data
//Bit 18,    reg_vbit_sel                 ,default = 0,//validBit sel: 0 data 1 reg_value
//Bit 17,    reg_chst_sel                 ,default = 0,//channel status sel: 0 data 1 reg_value
//Bit 16,    reg_ubit_fifo_less_irq_en    ,default = 0,fifo_less_thd irq enable
//Bit 15:8,  reg_ubit_fifo_start_thd      ,default = 0,start transmit iu after fifo level greater than this value
//Bit 7:0,   reg_ubit_fifo_less_thd       ,default = 0,generate irq,when fifo level less than this value
#define P_EARCTX_ERR_CORRT_STAT0                   (volatile uint32_t *)0xfe333434
//Bit 31:0,  ro_err_corrt_stat0          ,default = 0,
#define P_EARCTX_SPDIFOUT_CHSTS0                   (volatile uint32_t *)0xfe333438
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[31:0]
#define P_EARCTX_SPDIFOUT_CHSTS1                   (volatile uint32_t *)0xfe33343c
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[63:32]
#define P_EARCTX_SPDIFOUT_CHSTS2                   (volatile uint32_t *)0xfe333440
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[95:64]
#define P_EARCTX_SPDIFOUT_CHSTS3                   (volatile uint32_t *)0xfe333444
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[127:96]
#define P_EARCTX_SPDIFOUT_CHSTS4                   (volatile uint32_t *)0xfe333448
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[159:128]
#define P_EARCTX_SPDIFOUT_CHSTS5                   (volatile uint32_t *)0xfe33344c
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[191:160]
#define P_EARCTX_SPDIFOUT_CHSTS6                   (volatile uint32_t *)0xfe333450
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[31:0]
#define P_EARCTX_SPDIFOUT_CHSTS7                   (volatile uint32_t *)0xfe333454
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[63:32]
#define P_EARCTX_SPDIFOUT_CHSTS8                   (volatile uint32_t *)0xfe333458
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[95:64]
#define P_EARCTX_SPDIFOUT_CHSTS9                   (volatile uint32_t *)0xfe33345c
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[127:96]
#define P_EARCTX_SPDIFOUT_CHSTSA                   (volatile uint32_t *)0xfe333460
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[159:128]
#define P_EARCTX_SPDIFOUT_CHSTSB                   (volatile uint32_t *)0xfe333464
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[191:160]
#define P_EARCTX_FE_CTRL0                          (volatile uint32_t *)0xfe333468
//Bit 31,    reg_mute_hold_clr      ,default = 0,clear mute hold statues,pluse, auto clr
//Bit 30,    reg_work_enable        ,default = 0,wore enable
//Bit 29,    reg_dmac_invt          ,default = 0,fe out invent
//Bit 28,    reg_hold_time_en       ,default = 0,hold min time enable
//Bit 27,    reg_hold_soft_clr_en   ,default = 0,0 auto clear hold at next valid 1 clear hold with reg_mute_hold_clr
//Bit 26:24, reg_hold_time_tick_sel ,default = 0,hold min time tick select
//Bit 23:0,  reg_hold_min_time      ,default = 0,hold min time
#define P_EARCTX_FE_STAT0                          (volatile uint32_t *)0xfe33346c
//Bit 31:0,  ro_fe_stat0          ,default = 0,
#define P_EARCTX_SPDIFOUT_STAT                     (volatile uint32_t *)0xfe333470
//Bit 31:0,  ro_spdifout_stat     ,default = 0,
#define P_EARCTX_SPDIFOUT_CTRL2                    (volatile uint32_t *)0xfe333474
//Bit 31:28,  reserved
//Bit 27:16,  reg_clr_by_init      ,default = 0,reg_clr_by_init
//Bit 15:0 ,  reg_mask             ,default = 0,reg_mask
#define P_EARCTX_SPDIFOUT_GAIN2                    (volatile uint32_t *)0xfe333478
//Bit 31:0,  spdifout_gain2        ,default = 0,spdifout gain2
#define P_EARCTX_SPDIFOUT_GAIN3                    (volatile uint32_t *)0xfe33347c
//Bit 31:0,  spdifout_gain3        ,default = 0,spdifout gain3
#define P_EARCTX_SPDIFOUT_GAIN4                    (volatile uint32_t *)0xfe333480
//Bit 31:0,  spdifout_gain4        ,default = 0,spdifout gain4
#define P_EARCTX_SPDIFOUT_GAIN5                    (volatile uint32_t *)0xfe333484
//Bit 31:0,  spdifout_gain5        ,default = 0,spdifout gain5
//
//
// Closing file:  earctx_dmac.h
//
//========================================================================
//  AUDIO EARCTX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff603600
// -----------------------------------------------
//
// Reading file:  earctx_top.h
//
#define P_EARCTX_TOP_CTRL0                         (volatile uint32_t *)0xff603600
//Bit   31:18,   reserved
//Bit   17:16,   reg_earctx_debug_mux     unsigned, default = 0, debug mux
//Bit   15,      reg_slow_sync_scan_reg   unsigned, default = 0, reg_slow_sync_scan_reg
//Bit   14:12,   reserved
//Bit   11,      reg_hdmi_hpd_invt        unsigned, default = 0, hdmi_hpd invent
//Bit   10,      reg_hdmi_hpd_value       unsigned, default = 0, hdmi_hpd mux = 3,register value
//Bit   9:8,     reg_hdmi_hpd_mux         unsigned, default = 0, hdmi_hpd mux
//Bit   7,       reg_earctx_hd_hpd_invt   unsigned, default = 0, earctx_hd_hdp invent
//Bit   6,       reg_earctx_hd_hpd_value  unsigned, default = 0, earctx_hd_hdp mux = 3,register value
//Bit   5:4,     reg_earctx_hd_hdp_mux    unsigned, default = 0, earctx_hd_hdp mux
//Bit   3:2,     reserved
//Bit   1,       reg_earctx_force_mode_en unsigned, default = 0, force mode enale
//Bit   0,       reg_earctx_force_mode    unsigned, default = 0, force mode value
#define P_EARCTX_DMAC_INT_MASK                     (volatile uint32_t *)0xff603604
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define P_EARCTX_DMAC_INT_PENDING                  (volatile uint32_t *)0xff603608
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define P_EARCTX_CMDC_INT_MASK                     (volatile uint32_t *)0xff60360c
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define P_EARCTX_CMDC_INT_PENDING                  (volatile uint32_t *)0xff603610
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define P_EARCTX_ANA_CTRL0                         (volatile uint32_t *)0xff603614
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define P_EARCTX_ANA_CTRL1                         (volatile uint32_t *)0xff603618
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define P_EARCTX_ANA_CTRL2                         (volatile uint32_t *)0xff60361c
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define P_EARCTX_ANA_STAT0                         (volatile uint32_t *)0xff603620
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  earctx_top.h
//
//========================================================================
//  AUDIO EARCRX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333800
// -----------------------------------------------
//
// Reading file:  earc_rx_cmdc.h
//
#define P_EARC_RX_CMDC_TOP_CTRL0                   (volatile uint32_t *)0xfe333800
//Bit   31   ,     idle2_int                 unsigned, default = 0, 1: enable
//Bit   30   ,     idle1_int     	         unsigned, default = 0, 1: enable
//Bit   29   ,     disc2_int     	         unsigned, default = 0, 1: enable
//Bit   28   ,     disc1_int     	         unsigned, default = 0, 1: enable
//Bit   27   ,     earc_int      	         unsigned, default = 0, 1: enable
//Bit   26   ,     hb_status_int 	         unsigned, default = 0, 1: enable
//Bit   25   ,     losthb_int    	         unsigned, default = 0, 1: enable
//Bit   24   ,     timeout_int   	         unsigned, default = 0, 1: enable
//Bit   23   ,     status_ch_int 	         unsigned, default = 0, 1: enable
//Bit   22   ,     int_rec_invalid_id        unsigned, default = 0, 1: enable
//Bit   21   ,     int_rec_invalid_offset    unsigned, default = 0, 1: enable
//Bit   20   ,     int_rec_unexp             unsigned, default = 0, 1: enable
//Bit   19   ,     int_rec_ecc_err           unsigned, default = 0, 1: enable
//Bit   18   ,     int_rec_parity_err        unsigned, default = 0, 1: enable
//Bit   17   ,     int_recv_packet           unsigned, default = 0, 1: enable
//Bit   16   ,     int_rec_time_out          unsigned, default = 0, 1: enable
//Bit   15   ,     cmdc_debug0               unsigned, default = 0, 1: enable
//Bit   14   ,     cmdc_debug1               unsigned, default = 0, 1: enable
//Bit   13   ,     cmdc_debug2               unsigned, default = 0, 1: enable
//Bit   12:7 ,     reserved
//Bit    6   ,     mute_select               unsigned, default = 0, 1: use bit5, 0: earc off
//Bit    5   ,     mute_contrl               unsigned, default = 0, value of mannual mute control
//Bit    4:0 ,     reserved
#define P_EARC_RX_CMDC_TOP_CTRL1                   (volatile uint32_t *)0xfe333804
//Bit      31:13,  reserved
//Bit      12:8,   reg_scan_reg             unsigned, RW, default = 0,
//Bit      7:5,    reserved
//Bit      4:0,    reg_top_soft_rst         unsigned, RW, default = 0,
#define P_EARC_RX_CMDC_TOP_CTRL2                   (volatile uint32_t *)0xfe333808
//Bit      31,         reset_idle2_int                unsigned, default =0
//Bit      30,         reset_idle1_int                unsigned, default =0
//Bit      29,         reset_disc2_int                unsigned, default =0
//Bit      28,         reset_disc1_int                unsigned, default =0
//Bit      27,         reset_earc_int                 unsigned, default =0
//Bit      26,         reset_hb_status_int            unsigned, default =0
//Bit      25,         reset_losthb_int               unsigned, default =0
//Bit      24,         reset_timeout_int              unsigned, default =0
//Bit      23,         reset_status_ch_int            unsigned, default =0
//Bit      22,         reset_int_rec_invalid_id       unsigned, default =0
//Bit      21,         reset_int_rec_invalid_offset   unsigned, default =0
//Bit      20,         reset_int_rec_unexp            unsigned, default =0
//Bit      19,         reset_int_rec_ecc_err          unsigned, default =0
//Bit      18,         reset_int_rec_parity_err       unsigned, default =0
//Bit      17,         reset_int_recv_packet          unsigned, default =0
//Bit      16,         reset_int_rec_time_out         unsigned, default =0
//Bit      15:0,       reserved
#define P_EARC_RX_CMDC_TIMER_CTRL0                 (volatile uint32_t *)0xfe33380c
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_TIMER_CTRL1                 (volatile uint32_t *)0xfe333810
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_TIMER_CTRL2                 (volatile uint32_t *)0xfe333814
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_TIMER_CTRL3                 (volatile uint32_t *)0xfe333818
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_VSM_CTRL0                   (volatile uint32_t *)0xfe33381c
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state 		        unsigned, default = 0,  XX
//Bit      27,      arc_initiated 	        unsigned, default = 0,  XX
//Bit      26,      arc_terminated 	        unsigned, default = 0,  XX
//Bit      25,      arc_enable 		        unsigned, default = 0,  XX
//Bit      24,      man_hpd 		        unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel 		        unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state              unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en 	        unsigned, default = 0,  XX
//Bit    13:0,      reserved
#define P_EARC_RX_CMDC_VSM_CTRL1                   (volatile uint32_t *)0xfe333820
//Bit    31:12,      max_count_th          unsigned, default = 0,  idle done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  idle done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  idle done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  idle done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  idle done timing
#define P_EARC_RX_CMDC_VSM_CTRL2                   (volatile uint32_t *)0xfe333824
//Bit    31:12,      max_count_th          unsigned, default = 0,  comma off done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  comma off done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  comma off done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  comma off done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  comma off done timing
#define P_EARC_RX_CMDC_VSM_CTRL3                   (volatile uint32_t *)0xfe333828
//Bit    31:12,      max_count_th          unsigned, default = 0,  earc_time out timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  earc_time out timing
//Bit      6:4,      time_sel              unsigned, default = 0,  earc_time out timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  earc_time out timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  earc_time out timing
#define P_EARC_RX_CMDC_VSM_CTRL4                   (volatile uint32_t *)0xfe33382c
//Bit    31:12,      max_count_th          unsigned, default = 0,  heartbeat lost timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  heartbeat lost timing
//Bit      6:4,      time_sel              unsigned, default = 0,  heartbeat lost timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  heartbeat lost timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  heartbeat lost timing
#define P_EARC_RX_CMDC_VSM_CTRL5                   (volatile uint32_t *)0xfe333830
//Bit    31:16,      reserved
//Bit     15:8,      status_soft           unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define P_EARC_RX_CMDC_VSM_CTRL6                   (volatile uint32_t *)0xfe333834
//Bit    31:17,      reserved
//Bit        16,     cntl_hpd_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      15:4,     cntl_hpd_valid_width  unsigned, default = 0,  in earc heartbeat det timing
//Bit      3:0,      cntl_hpd_glitch_width unsigned, default = 0,  in earc heartbeat det timing
#define P_EARC_RX_CMDC_VSM_CTRL7                   (volatile uint32_t *)0xfe333838
//Bit      31:0,     vsm_ctrl7             unsigned,  default = 0,
#define P_EARC_RX_CMDC_VSM_CTRL8                   (volatile uint32_t *)0xfe33383c
//Bit      31:0,     vsm_ctrl8             unsigned,  default = 0,
#define P_EARC_RX_CMDC_VSM_CTRL9                   (volatile uint32_t *)0xfe333840
//Bit      31:0,     vsm_ctrl9             unsigned,  default = 0,
#define P_EARC_RX_CMDC_SENDER_CTRL0                (volatile uint32_t *)0xfe333844
//Bit      31:2,     reserved
//Bit      1,        hb_chg_conf_auto          unsigned,  default = 0,
//Bit      0,        hb_chg_auto               unsigned,  default = 1,
#define P_EARC_RX_CMDC_PACKET_CTRL0                (volatile uint32_t *)0xfe333848
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst_man                unsigned, default = 0,  packet control
//Bit     28:24,      ready_th                    unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_th                 unsigned, default = 0,  packet control
//Bit       7:5,      reserved
//Bit         4,      sw_state_update             unsigned, default = 0,  packet control
//Bit       3:0,      sw_state                    unsigned, default = 0,  packet control
#define P_EARC_RX_CMDC_PACKET_CTRL1                (volatile uint32_t *)0xfe33384c
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_reg_st                  unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_th                     unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_th                      unsigned, default = 0,
//Bit       7:0,      post_flag                   unsigned, default = 0,
#define P_EARC_RX_CMDC_PACKET_CTRL2                (volatile uint32_t *)0xfe333850
//Bit      31:0,      pre_flag                    unsigned, default = 0,  X
#define P_EARC_RX_CMDC_PACKET_CTRL3                (volatile uint32_t *)0xfe333854
//Bit      31,       cmdc_en                      unsigned, default = 0,  XX
//Bit      30,       cmdc_parity_mask             unsigned, default = 0,  XX
//Bit      29,       imeout_en                    unsigned, default = 0,  XX
//Bit      28,       ecc_check_en                 unsigned, default = 0,  XX
//Bit      27,       rev_debug_en                 unsigned, default = 0,  XX
//Bit     26:16,     reserved
//Bit      15:0,     timeout_th                   unsigned, default = 0,  X
#define P_EARC_RX_CMDC_PACKET_CTRL4                (volatile uint32_t *)0xfe333858
//Bit      31,       ack_ignore                   unsigned, default = 0,  XX
//Bit      30,       cmdc_tail_check_mask         unsigned, default = 0,  XX
//Bit     29:20,     reserved
//Bit      19:0,     cmdc_packet_head             unsigned, default = 0,  XX
#define P_EARC_RX_CMDC_PACKET_CTRL5                (volatile uint32_t *)0xfe33385c
//Bit     31:24,     rev_debug_mask               unsigned, default = 0,  XX
//Bit     23:20,     reserved
//Bit      19:0,     cmdc_packet_head_mask        unsigned, default = 0,  XX
#define P_EARC_RX_CMDC_PACKET_CTRL6                (volatile uint32_t *)0xfe333860
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:9,     reserved
//Bit         8,     rec_packet_d                 unsigned, default = 0,  XX
//Bit         7,     rec_parity_err_cnt		      unsigned, default = 0,  XX
//Bit         6,     rec_ecc_err_cnt		      unsigned, default = 0,  XX
//Bit         5,     rec_unexp_cnt			      unsigned, default = 0,  XX
//Bit         4,     rec_invalid_offset_cnt	      unsigned, default = 0,  XX
//Bit         3,     rec_invalid_id_cnt		      unsigned, default = 0,  XX
//Bit         2,     rec_timeout_cnt		      unsigned, default = 0,  XX
//Bit         1,     rec_w_cnt				      unsigned, default = 0,  XX
//Bit         0,     rec_r_cnt				      unsigned, default = 0,  X
#define P_EARC_RX_CMDC_BIPHASE_CTRL0               (volatile uint32_t *)0xfe333864
//Bit     31:24,     reg_tns                       unsigned, default = 7, xx
//Bit     23:16,     delay_th                      unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define P_EARC_RX_CMDC_BIPHASE_CTRL1               (volatile uint32_t *)0xfe333868
//Bit     31:16,     reserved
//Bit        15,     ack_val_en                      unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     width                        unsigned, default = 0,  send
#define P_EARC_RX_CMDC_BIPHASE_CTRL2               (volatile uint32_t *)0xfe33386c
//Bit      31,        ack_val_en                  unsigned, default = 0,  send
//Bit      30:20,     reserved
//Bit       19:16,    ack_rate                   unsigned, default = 0,  comma send
//Bit       15:0,     width                         unsigned, default = 0,  comma sen
#define P_EARC_RX_CMDC_BIPHASE_CTRL3               (volatile uint32_t *)0xfe333870
//Bit      31:0,     biphase_ctrl3                 unsigned, default = 0,
#define P_EARC_RX_CMDC_DEVICE_ID_CTRL              (volatile uint32_t *)0xfe333874
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_w_r_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_w_r_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:16,     reserved
//Bit      15:8,     apb_w_r_id                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apb_w_r_start_addr            unsigned, default = 0, apb bus wr/read
#define P_EARC_RX_CMDC_DEVICE_WDATA                (volatile uint32_t *)0xfe333878
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/rea
#define P_EARC_RX_CMDC_DEVICE_RDATA                (volatile uint32_t *)0xfe33387c
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/rea
#define P_EARC_RX_ANA_CTRL0                        (volatile uint32_t *)0xfe333880
//Bit      31:0,     ana_ctrl0                     unsigned, default = 0,
#define P_EARC_RX_ANA_CTRL1                        (volatile uint32_t *)0xfe333884
//Bit      31:0,     ana_ctrl1                     unsigned, default = 0,
#define P_EARC_RX_ANA_CTRL2                        (volatile uint32_t *)0xfe333888
//Bit      31:0,     ana_ctrl2                     unsigned, default = 0,
#define P_EARC_RX_ANA_CTRL3                        (volatile uint32_t *)0xfe33388c
//Bit      31:0,     ana_ctrl3                     unsigned, default = 0,
#define P_EARC_RX_ANA_CTRL4                        (volatile uint32_t *)0xfe333890
//Bit      31:0,     ana_ctrl4                     unsigned, default = 0,
#define P_EARC_RX_ANA_CTRL5                        (volatile uint32_t *)0xfe333894
//Bit      31:0,     ana_ctrl5                     unsigned, default = 0,
#define P_EARC_RX_ANA_STAT0                        (volatile uint32_t *)0xfe333898
//Bit      31:0,     ro_ANA_status0              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS0                     (volatile uint32_t *)0xfe33389c
//Bit      31:0,     ro_cmdc_status0              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS1                     (volatile uint32_t *)0xfe3338a0
//Bit      31:0,     ro_cmdc_status1              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS2                     (volatile uint32_t *)0xfe3338a4
//Bit      31:0,     ro_cmdc_status2              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS3                     (volatile uint32_t *)0xfe3338a8
//Bit      31:0,     ro_cmdc_status3              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS4                     (volatile uint32_t *)0xfe3338ac
//Bit      31:0,     ro_cmdc_status4              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS5                     (volatile uint32_t *)0xfe3338b0
//Bit      31:0,     ro_cmdc_status5              unsigned, RO, default = 0,
#define P_EARC_RX_CMDC_STATUS6                     (volatile uint32_t *)0xfe3338b4
//Bit      31,         ro_idle2_int                unsigned, RO, default =0
//Bit      30,         ro_idle1_int                unsigned, RO, default =0
//Bit      29,         ro_disc2_int                unsigned, RO, default =0
//Bit      28,         ro_disc1_int                unsigned, RO, default =0
//Bit      27,         ro_earc_int                 unsigned, RO, default =0
//Bit      26,         ro_hb_status_int            unsigned, RO, default =0
//Bit      25,         ro_losthb_int               unsigned, RO, default =0
//Bit      24,         ro_timeout_int              unsigned, RO, default =0
//Bit      23,         ro_status_ch_int            unsigned, RO, default =0
//Bit      22,         ro_int_rec_invalid_id       unsigned, RO, default =0
//Bit      21,         ro_int_rec_invalid_offset   unsigned, RO, default =0
//Bit      20,         ro_int_rec_unexp            unsigned, RO, default =0
//Bit      19,         ro_int_rec_ecc_err          unsigned, RO, default =0
//Bit      18,         ro_int_rec_parity_err       unsigned, RO, default =0
//Bit      17,         ro_int_recv_packet          unsigned, RO, default =0
//Bit      16,         ro_int_rec_time_out         unsigned, RO, default =0
//Bit      15:0,       reserved
//
// Closing file:  earc_rx_cmdc.h
//
//========================================================================
//  AUDIO EARCRX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333c00
// -----------------------------------------------
//
// Reading file:  earcrx_dmac.h
//
#define P_EARCRX_DMAC_TOP_CTRL0                    (volatile uint32_t *)0xfe333c00
//Bit   31,     reg_top_work_en               unsigned, default = 0, top work enable
//Bit   30,     reg_top_soft_rst              unsigned, default = 0, top soft reset
//Bit   29:23,  reserved
//Bit   22:20,  reg_dmac_debug_sel            unsigned, default = 0, dmac debug select
//Bit   19:18,  reserved
//Bit   17,     reg_dmac_valid_sel            unsigned, default = 0, dmac sync without clk
//Bit   16,     reg_dmac_without_clk          unsigned, default = 0, dmac sync without clk
//Bit   15,     reg_sf_sync_scan_reg          unsigned, default = 0, rst_n soft reset scan reg
//Bit   14,     reserved
//Bit   13,     reg_slow_sync_scan_reg        unsigned, default = 0, rst_n sync clk_slow scan reg
//Bit   12,     reg_a_sync_scan_reg           unsigned, default = 0, rst_n sync clk_analog scan reg
//Bit   11,     reg_slow_auto_gate            unsigned, default = 0, clk_slow auto gate
//Bit   10,     reg_a_auto_gate               unsigned, default = 0, clk_analog auto gate
//Bit   9:0,    reserved
#define P_EARCRX_DMAC_SYNC_CTRL0                   (volatile uint32_t *)0xfe333c04
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac sync module work enable
//Bit   30,     reg_rst_afifo_out_n           unsigned, default = 0, afifo out reset
//Bit   29,     reg_rst_afifo_in_n            unsigned, default = 0, afifo in reset
//Bit   28:17,  reserved
//Bit   16,     reg_ana_buf_data_sel_en       unsigned, default = 0, data from analog delay enable
//Bit   15,     reserved
//Bit   14:12,  reg_ana_buf_data_sel          unsigned, default = 0, delay cycles
//Bit   11,     reserved
//Bit   10:8,   reg_ana_clr_cnt               unsigned, default = 0, valid last how many 0 will clear
//Bit   7,      reserved
//Bit   6:4,    reg_ana_set_cnt               unsigned, default = 0, valid last how may 1 will set
//Bit   3:1,    reserved
//Bit   0,      reg_dmacin_phase              unsigned, default = 0, dmac data invert
#define P_EARCRX_DMAC_SYNC_STAT0                   (volatile uint32_t *)0xfe333c08
//Bit   31:0,   reg_dmac_sync_stat0           unsigned, default = 0
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL0              (volatile uint32_t *)0xfe333c0c
//Bit   31,     reg_work_enable               unsigned, default = 0, spdif in sample enable
//Bit   30,     reg_spdifin_phase             unsigned, default = 0, spdif in invert
//Bit   29,     reg_debug_en                  unsigned, default = 0, debug single enable
//Bit   28,     reg_width_sel                 unsigned, default = 0, 0 detect by max_width 1 detect by min_width
//Bit   27:23,  reserved
//Bit   22:20,  reg_sample_mode               unsigned, default = 0, value
//Bit   19:0,   reg_base_timer                unsigned, default = 0, base timer to detect sample mode change
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL1              (volatile uint32_t *)0xfe333c10
//Bit   31,     reg_force_sample_mode         unsigned, default = 0, 0 auto detect sample mode 1 force a fixed sample mode with reg_sample_mode
//Bit   30,     reserved
//Bit   29:20,  reg_sample_mode0_timer_th     unsigned, default = 0, mode0 threathold time
//Bit   19:10,  reg_sample_mode1_timer_th     unsigned, default = 0, mode1 threathold time
//Bit   9:0,    reg_sample_mode2_timer_th     unsigned, default = 0, mode2 threathold time
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL2              (volatile uint32_t *)0xfe333c14
//Bit   31:30,  reserved
//Bit   29:20,  reg_sample_mode3_timer_th     unsigned, default = 0, mode3 threathold time
//Bit   19:10,  reg_sample_mode4_timer_th     unsigned, default = 0, mode4 threathold time
//Bit   9:0,    reg_sample_mode5_timer_th     unsigned, default = 0, mode5 threathold time
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL3              (volatile uint32_t *)0xfe333c18
//Bit   31:24,  reg_sample_mode0_timer        unsigned, default = 0, mode0 sample time
//Bit   23:16,  reg_sample_mode1_timer        unsigned, default = 0, mode1 sample time
//Bit   15:8,   reg_sample_mode2_timer        unsigned, default = 0, mode2 sample time
//Bit   7:0,    reg_sample_mode3_timer        unsigned, default = 0, mode3 sample time
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL4              (volatile uint32_t *)0xfe333c1c
//Bit   31:24,  reg_sample_mode4_timer        unsigned, default = 0, mode4 sample time
//Bit   23:16,  reg_sample_mode5_timer        unsigned, default = 0, mode5 sample time
//Bit   15:8,   reg_sample_mode6_timer        unsigned, default = 0, mode6 sample time
//Bit   7:0,    reserved
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL5              (volatile uint32_t *)0xfe333c20
//Bit   31,     reg_sq_filt_en                unsigned, default = 0, dmac_sqout filter enable
//Bit   30,     reg_spdif_sqout_phase         unsigned, default = 0, dmac_sqout invert
//Bit   29:27,  reg_filter_tick_sel           unsigned, default = 0, dmac_sqout filter tick select
//Bit   26:24,  reg_filter_sel                unsigned, default = 0, dmac_sqout filter select
//Bit   23:20,  reserved
//Bit   19:0,   reg_sq_filt_timer             unsigned, default = 0, dmac_sqout filter tick
#define P_EARCRX_SPDIFIN_SAMPLE_STAT0              (volatile uint32_t *)0xfe333c24
//Bit   31:0,   reg_spdifin_sample_stat0      unsigned, default = 0
#define P_EARCRX_SPDIFIN_SAMPLE_STAT1              (volatile uint32_t *)0xfe333c28
//Bit   31:0,   reg_spdifin_sample_stat1      unsigned, default = 0
#define P_EARCRX_SPDIFIN_MUTE_VAL                  (volatile uint32_t *)0xfe333c2c
//Bit   31:0,   reg_spdifin_mute_val          unsigned, default = 0, spdif in mute value
#define P_EARCRX_SPDIFIN_CTRL0                     (volatile uint32_t *)0xfe333c30
//Bit   31,     reg_work_enable               unsigned, default = 0, spdifin wore enable
//Bit   30,     reg_chnum_sel                 unsigned, default = 0, 0 ch_num = 0~383  1 ch_num = 0~1
//Bit   29:28,  reserved
//Bit   27,     reg_debug_en                  unsigned, default = 0, debug enable
//Bit   26,     reg_chnum_en                  unsigned, default = 0, star add ch_cnt to ch_num
//Bit   25,     reg_findpapb_en               unsigned, default = 0, papb check enalbe
//Bit   24,     reg_nonpcm2pcm_en             unsigned, default = 0, nonpcm2pcm_th enable
//Bit   23:12,  reg_nonpcm2pcm_th             unsigned, default = 0, if long time didn't detect PaPb again,will generate irq
//Bit   11:8,   reg_ch_status_sel             unsigned, default = 0, for stat1/stat2
//Bit   7,      reg_mute_l                    unsigned, default = 0, mute channel l
//Bit   6,      reg_mute_r                    unsigned, default = 0, mute channel r
//Bit   5:4,    reserved
//Bit   3,      reg_check_valid               unsigned, default = 0, valid check enable
//Bit   2,      reg_check_parity              unsigned, default = 0, parity check enable
//Bit   1,      reg_invert_data               unsigned, default = 0, spdif data invert
//Bit   0,      reserved
#define P_EARCRX_SPDIFIN_CTRL1                     (volatile uint32_t *)0xfe333c34
//Bit   31:24,  reserved
//Bit   31:24,  reg_clr_internal_sts          unsigned, default = 0, internal irq status clear
//Bit   23:12,  reg_mute_block_check_thd      unsigned, default = 0, mute block check time thd
//Bit   11:9,   reg_mute_block_check_tick_sel unsigned, default = 0, mute block check tick sel
//Bit   8,      reg_papb_ext_sync             unsigned, default = 0, ext 0 sync check for papb
//Bit   7:0,    reg_papb_ext_mask             unsigned, default = 0, sync 0 mask
#define P_EARCRX_SPDIFIN_CTRL2                     (volatile uint32_t *)0xfe333c38
//Bit   31:24,  reg_mute_bit                   unsigned, default = 0, mute bit in channel st
//Bit   23:19,  reg_mute_block_num             unsigned, default = 0, mute min block number to declare
//Bit   18,     reg_mute_lr_ch_sel             unsigned, default = 0, mute bit in channel st L or R
//Bit   17,     reg_mute_block_check_en        unsigned, default = 0, mute block number check enable
//Bit   16,     reg_earc_cps_chst_clr_en       unsigned, default = 0, auto clear compress mode when channel status not compress
//Bit   15,     reg_earc_cps_nonpcm2pcm_clr_en unsigned, default = 0, auto clear compress mode when nonpcm2pcm
//Bit   14,     reg_earc_auto                  unsigned, default = 0, auto change earc/arc
//Bit   13,     reg_earcin_papb_lr             unsigned, default = 0, user l or r channel status to check papb
//Bit   12,     reg_earcin_check_papb          unsigned, default = 0, 0:data valid after 1 block;1: in 1st block if exit papb ,data valid after papb
//Bit   11,     reg_earcin_start_papb          unsigned, default = 0, start write toddr 1:from papb check,0 from preamble Z,valid when reg_earcin_check_papb set
//Bit   10,     reg_formatchange_auto_rst      unsigned, default = 0, auto reset will detect format change
//Bit   9,      reg_earcin_cpsb_pcpd_sel      unsigned, default = 0, compress B pcpd select : 1:next 4th subframe data 0:next sub frame data
//Bit   8:4,    reg_earc_papb_msb             unsigned, default = 0, papb msb position in data
//Bit   3,      reg_earcin_spdif_force        unsigned, default = 0, when in arc mode,spdif on force enable
//Bit   2,      reg_earcin_spdif_force_set    unsigned, default = 0, force value
//Bit   1,      reg_earcin_mode_force         unsigned, default = 0, earc mode force enable
//Bit   0,      reg_earcin_mode_force_set     unsigned, default = 0, force value
#define P_EARCRX_SPDIFIN_CTRL3                     (volatile uint32_t *)0xfe333c3c
//Bit   31:16,  reg_earc_pa_value             unsigned, default = 0, earc mode pa value
//Bit   15:0,   reg_earc_pb_value             unsigned, default = 0, earc mode pb value
#define P_EARCRX_SPDIFIN_STAT0                     (volatile uint32_t *)0xfe333c40
//Bit   31:0,   reg_spdifin_stat0             unsigned, default = 0
#define P_EARCRX_SPDIFIN_STAT1                     (volatile uint32_t *)0xfe333c44
//Bit   31:0,   reg_spdifin_stat1             unsigned, default = 0
#define P_EARCRX_SPDIFIN_STAT2                     (volatile uint32_t *)0xfe333c48
//Bit   31:0,   reg_spdifin_stat2             unsigned, default = 0
#define P_EARCRX_DMAC_UBIT_CTRL0                   (volatile uint32_t *)0xfe333c4c
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac user bit decode enable
//Bit   30:24,  reg_iu_sync                   unsigned, default = 0, iu sync value
//Bit   23:16,  reg_fifo_thd                  unsigned, default = 0, generate irq when fifo level pass some threshold
//Bit   15,     reg_max_dist_en               unsigned, default = 0, max distance between IUs to set lost
//Bit   14,     reg_iu_sync_en                unsigned, default = 0, iu sync code enable 0 : all iu to fifo 1 only sync iu packet to fifo
//Bit   13:12,  reg_user_lr                   unsigned, default = 0, 00 off 01 use l channel userbit 10 use r channel userbit 11 user lr channel userbit
//Bit   11:8,   reg_max_dist                  unsigned, default = 0, max distance between IUs value
//Bit   7,      reg_fifo_thd_en               unsigned, default = 0, fifo_thd irq enable
//Bit   6,      reg_fifo_lost_init_en         unsigned, default = 0, when lost,initial fifo
//Bit   5,      reg_fifo_init                 unsigned, default = 0, fifo initial
//Bit   4:0,    reg_data_bit                  unsigned, default = 0, user bit position in data
#define P_EARCRX_IU_RDATA                          (volatile uint32_t *)0xfe333c50
//Bit   31:8,   reserved
//Bit   7:0,    i_iu_rdata                    unsigned, default = 0, iu data,read only
#define P_EARCRX_DMAC_UBIT_STAT0                   (volatile uint32_t *)0xfe333c54
//Bit   31:0,   reg_dmac_ubit_stat0           unsigned, default = 0
#define P_EARCRX_ERR_CORRECT_CTRL0                 (volatile uint32_t *)0xfe333c58
//Bit   31,     reg_work_enable               unsigned, default = 0, err correct work enable
//Bit   30,     reserved
//Bit   29,     reg_rst_afifo_out_n           unsigned, default = 0, reset afifo out side
//Bit   28,     reg_rst_afifo_in_n            unsigned, default = 0, reset afifo in side
//Bit   27,     reg_lr_check                  unsigned, default = 0, enable lr_check
//Bit   26:7,   reserved
//Bit   6,      reg_bchout_data_ml            unsigned, default = 0, bch output 16bit data msb is 27 or 19
//Bit   5,      reg_bchout_data_rsv           unsigned, default = 0, bch output data revers
//Bit   4,      reg_bchin_ecc_ml              unsigned, default = 0, bch input ecc msb/lsb
//Bit   3,      reg_bchin_ecc_rsv             unsigned, default = 0, bch input ecc revers
//Bit   2,      reg_bchin_data_rsv            unsigned, default = 0, bch input data revers
//Bit   1,      reg_force_set                 unsigned, default = 0, 0 off 1 compress audio mode
//Bit   0,      reg_force_en                  unsigned, default = 0, force work mode enable
#define P_EARCRX_ERR_CORRECT_STAT0                 (volatile uint32_t *)0xfe333c5c
//Bit   31:0,   reg_err_correct_stat0         unsigned, default = 0
#define P_EARCRX_ANA_RST_CTRL0                     (volatile uint32_t *)0xfe333c60
//Bit   31,     reg_work_enable               unsigned, default = 0, analog reset check work enable
//Bit   30,     reg_ana_rst_sf_en             unsigned, default = 0, analog reset from register enable
//Bit   29,     reg_ana_rst_sf                unsigned, default = 0, soft reset value
//Bit   28,     reserved
//Bit   27:23,  reg_new_format_pos_num        unsigned, default = 0, when new format data in, hold reset after N posedge
//Bit   22:20,  reg_dmacrx_div2_thd_tick_sel  unsigned, default = 0, earcrx_div2 hold threshold tick select
//Bit   19:0,   reg_earcrx_div2_thd           unsigned, default = 0, earcrx_div2 hold threshold
#define P_EARCRX_ANA_RST_CTRL1                     (volatile uint32_t *)0xfe333c64
//Bit   31,     reg_dmacrx_data_filt_en       unsigned, default = 0, filter enable
//Bit   30:28,  reg_dmacrx_data_filter_sel    unsigned, default = 0, filter select
//Bit   27:25,  reg_dmacrx_data_tick_sel      unsigned, default = 0, filter tick sel
//Bit   24:16,  reg_dmacrx_data_time          unsigned, default = 0, filter tick time
//Bit   15,     reg_dmacrx_sqout_filt_en      unsigned, default = 0, filter enable
//Bit   14:12,  reg_dmacrx_sqout_filter_sel   unsigned, default = 0, filter select
//Bit   11:9,   reg_dmacrx_sqout_tick_sel     unsigned, default = 0, filter tick sel
//Bit   8:0,    reg_dmacrx_sqout_time         unsigned, default = 0, filter tick time
#define P_EARCRX_SPDIFIN_CTRL4                     (volatile uint32_t *)0xfe333c80
//Bit   31,     reserved
//Bit   30,     reg_add_ch_r                        unsigned, default = 0, reg_add_ch_r
//Bit   29,     reg_bc_val0_en                      unsigned, default = 0, reg_bc_val0_en
//Bit   28:20,  reg_stable_mask                     unsigned, default = 0, reg_stable_mask
//Bit   19:16,  reg_stable_zcnt                     unsigned, default = 0, reg_stable_zcnt
//Bit   15:0 ,  reserved
#define P_EARCRX_SPDIFIN_CTRL5                     (volatile uint32_t *)0xfe333c84
//Bit   31,     reg_st_timeout_sts_clr              unsigned, default = 0, reg_st_timeout_sts_clr
//Bit   30:28,  reserved
//Bit   27:16,  reg_st_timeout_check_thd            unsigned, default = 0, reg_st_timeout_check_thd
//Bit   15,     reserved
//Bit   14:12,  reg_st_timeout_check_tick_sel       unsigned, default = 0, reg_st_timeout_check_tick_sel
//Bit   11,     reg_st_timeout_check_en             unsigned, default = 0, reg_st_timeout_check_en
//Bit   10:9,   reserved
//Bit   8:0,    reg_stable_int_mask                 unsigned, default = 0, reg_stable_int_mask
#define P_EARCRX_SPDIFIN_CTRL6                     (volatile uint32_t *)0xfe333c88
//Bit   31:17,  reserved
//Bit   16,     reg_check_time_en                   unsigned, default = 0, reg_check_time_en
//Bit   15:0,   reg_check_time_thd                  unsigned, default = 0, reg_check_time_thd
#define P_EARCRX_DMAC_SYNC_CTRL1                   (volatile uint32_t *)0xfe333c8c
//Bit   31:19,  reserved
//Bit   18,     reg_auto_neg_int_en                 unsigned, default = 0, reg_auto_neg_int_en
//Bit   17,     reg_auto_stable_clr                 unsigned, default = 0, reg_auto_stable_clr
//Bit   16,     reg_auto_stable_en                  unsigned, default = 0, reg_auto_stable_en
//Bit   15:0,   reg_auto_stable_thd                 unsigned, default = 0, reg_auto_stable_thd
#define P_EARCRX_SPDIFIN_SAMPLE_CTRL6              (volatile uint32_t *)0xfe333c90
//Bit   31:18,  reserved
//Bit   17,     reg_hold_tri_sample                 unsigned, default = 0, reg_hold_tri_sample
//Bit   16,     reg_sample_mode_filter_en           unsigned, default = 0, reg_sample_mode_filter_en
//Bit   15:8,   reg_stable_cyc_min                  unsigned, default = 0, reg_stable_cyc_min
//Bit   7:0,    reg_stable_cyc_max                  unsigned, default = 0, reg_stable_cyc_max
#define P_EARCRX_DMAC_SYNC_CTRL2                   (volatile uint32_t *)0xfe333c94
//Bit   31,     reg_unstable_t0_err_clr             unsigned, default = 0, reg_unstable_t0_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t0_check_en            unsigned, default = 0, reg_unstable_t0_check_en
//Bit   18:16,  reg_unstable_t0_tick_sel            unsigned, default = 0, reg_unstable_t0_tick_sel
//Bit   15:0,   reg_unstable_t0_thd                 unsigned, default = 0, reg_unstable_t0_thd
#define P_EARCRX_DMAC_SYNC_CTRL3                   (volatile uint32_t *)0xfe333c98
//Bit   31,     reg_unstable_t1_err_clr             unsigned, default = 0, reg_unstable_t1_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t1_check_en            unsigned, default = 0, reg_unstable_t1_check_en
//Bit   18:16,  reg_unstable_t1_tick_sel            unsigned, default = 0, reg_unstable_t1_tick_sel
//Bit   15:0,   reg_unstable_t1_thd                 unsigned, default = 0, reg_unstable_t1_thd
#define P_EARCRX_DMAC_SYNC_CTRL4                   (volatile uint32_t *)0xfe333c9c
//Bit   31,     reg_unstable_t2_err_clr             unsigned, default = 0, reg_unstable_t2_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t2_check_en            unsigned, default = 0, reg_unstable_t2_check_en
//Bit   18:16,  reg_unstable_t2_tick_sel            unsigned, default = 0, reg_unstable_t2_tick_sel
//Bit   15:0,   reg_unstable_t2_thd                 unsigned, default = 0, reg_unstable_t2_thd
#define P_EARCRX_DMAC_SYNC_STAT1                   (volatile uint32_t *)0xfe333ca0
//Bit   31:0,   reg_dmac_sync_stat1           unsigned, default = 0
#define P_EARCRX_DMAC_SYNC_STAT2                   (volatile uint32_t *)0xfe333ca4
//Bit   31:0,   reg_dmac_sync_stat2           unsigned, default = 0
#define P_EARCRX_DMAC_SYNC_STAT3                   (volatile uint32_t *)0xfe333ca8
//Bit   31:0,   reg_dmac_sync_stat3           unsigned, default = 0
//
// Closing file:  earcrx_dmac.h
//
//========================================================================
//  AUDIO EARCRX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333e00
// -----------------------------------------------
//
// Reading file:  earcrx_top.h
//
#define P_EARCRX_TOP_CTRL0                         (volatile uint32_t *)0xfe333e00
//Bit   31:10,  reserved
//Bit   9:8,    reg_top_debug_sel             unsigned, default = 0, top debug select
//Bit   7,      reg_spdif_rx_en_force         unsigned, default = 0, force spdif_rx_en to reg_spdif_rx_en_force_value
//Bit   6,      reg_spdif_rx_en_force_value   unsigned, default = 0, value
//Bit   5,      reg_spdif_rx_sqen_force       unsigned, default = 0, force spdif_rx_sqen to reg_spdif_rx_sqe
//Bit   4,      reg_spdif_rx_sqen_force_value unsigned, default = 0, value
//Bit   3,      reg_dmacrx_en_force           unsigned, default = 0, force dmacrx_en to reg_dmacrx_en_force_value
//Bit   2,      reg_dmacrx_en_force_value     unsigned, default = 0, value
//Bit   1,      reg_dmacrx_sqen_force         unsigned, default = 0, force dmacrx_sqen to reg_dmacrx_sqen_force_value
//Bit   0,      reg_dmacrx_sqen_force_value   unsigned, default = 0, value
#define P_EARCRX_DMAC_INT_MASK                     (volatile uint32_t *)0xfe333e04
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define P_EARCRX_DMAC_INT_PENDING                  (volatile uint32_t *)0xfe333e08
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define P_EARCRX_CMDC_INT_MASK                     (volatile uint32_t *)0xfe333e0c
//Bit   31:16,  reserved
//Bit   15:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define P_EARCRX_CMDC_INT_PENDING                  (volatile uint32_t *)0xfe333e10
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define P_EARCRX_ANA_CTRL0                         (volatile uint32_t *)0xfe333e14
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_ANA_CTRL1                         (volatile uint32_t *)0xfe333e18
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_ANA_STAT0                         (volatile uint32_t *)0xfe333e1c
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_PLL_CTRL0                         (volatile uint32_t *)0xfe333e20
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_PLL_CTRL1                         (volatile uint32_t *)0xfe333e24
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_PLL_CTRL2                         (volatile uint32_t *)0xfe333e28
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_PLL_CTRL3                         (volatile uint32_t *)0xfe333e2c
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define P_EARCRX_PLL_STAT0                         (volatile uint32_t *)0xfe333e30
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  earcrx_top.h
//
//========================================================================
//  AUDIO RESAMPLEB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334000
// -----------------------------------------------
//
// Reading file:  RESAMPLEB.h
//
#define P_AUDIO_RSAMPB_CTRL0                       (volatile uint32_t *)0xfe334000
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define P_AUDIO_RSAMPB_CTRL1                       (volatile uint32_t *)0xfe334004
//Bit   31:27      reserved          //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:4        reserved          //unsigned  , default =2;
//Bit   3:0        reg_inp_mux       //unsigned  , default =0;
#define P_AUDIO_RSAMPB_CTRL2                       (volatile uint32_t *)0xfe334008
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define P_AUDIO_RSAMPB_PHSINIT                     (volatile uint32_t *)0xfe33400c
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define P_AUDIO_RSAMPB_PHSSTEP                     (volatile uint32_t *)0xfe334010
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define P_AUDIO_RSAMPB_SHIFT                       (volatile uint32_t *)0xfe334014
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define P_AUDIO_RSAMPB_ADJ_CTRL0                   (volatile uint32_t *)0xfe334018
//Bit   31:3        reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define P_AUDIO_RSAMPB_ADJ_CTRL1                   (volatile uint32_t *)0xfe33401c
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define P_AUDIO_RSAMPB_ADJ_SFT                     (volatile uint32_t *)0xfe334020
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define P_AUDIO_RSAMPB_ADJ_IDET_LEN                (volatile uint32_t *)0xfe334024
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define P_AUDIO_RSAMPB_ADJ_FORCE                   (volatile uint32_t *)0xfe334028
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define P_AUDIO_RSAMPB_ADJ_KI_FORCE                (volatile uint32_t *)0xfe33402c
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define P_AUDIO_RSAMPB_WATCHDOG_THRD               (volatile uint32_t *)0xfe334030
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define P_AUDIO_RSAMPB_RO_STATUS                   (volatile uint32_t *)0xfe334040
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define P_AUDIO_RSAMPB_RO_ADJ_FREQ                 (volatile uint32_t *)0xfe334044
//Bit   31:0       ro_rsamp_adj_freq
#define P_AUDIO_RSAMPB_RO_ADJ_DIFF_BAK             (volatile uint32_t *)0xfe334048
//Bit   31:0       ro_det_diff_bak
#define P_AUDIO_RSAMPB_RO_ADJ_DIFF_DLT             (volatile uint32_t *)0xfe33404c
//Bit   31:0       ro_det_diff_dlt
#define P_AUDIO_RSAMPB_RO_ADJ_PHS_ERR              (volatile uint32_t *)0xfe334050
//Bit   31:0       ro_det_phase_err
#define P_AUDIO_RSAMPB_RO_ADJ_KI_OUT               (volatile uint32_t *)0xfe334054
//Bit   31:0       ro_rsamp_ki_out
#define P_AUDIO_RSAMPB_RO_IN_CNT                   (volatile uint32_t *)0xfe334058
//Bit   31:0       ro_rsamp_in_cnt
#define P_AUDIO_RSAMPB_RO_OUT_CNT                  (volatile uint32_t *)0xfe33405c
//Bit   31:0       ro_rsamp_out_cnt
#define P_AUDIO_RSAMPB_RO_ADJ_PHS_ERR_VAR          (volatile uint32_t *)0xfe334060
//Bit   31:0       ro_det_phase_err_var
#define P_AUDIO_RSAMPB_POST_COEF0                  (volatile uint32_t *)0xfe334080
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define P_AUDIO_RSAMPB_POST_COEF1                  (volatile uint32_t *)0xfe334084
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define P_AUDIO_RSAMPB_POST_COEF2                  (volatile uint32_t *)0xfe334088
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define P_AUDIO_RSAMPB_POST_COEF3                  (volatile uint32_t *)0xfe33408c
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define P_AUDIO_RSAMPB_POST_COEF4                  (volatile uint32_t *)0xfe334090
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define P_AUDIO_RSAMPB_AA_COEF_ADDR                (volatile uint32_t *)0xfe3340c0
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define P_AUDIO_RSAMPB_AA_COEF_DATA                (volatile uint32_t *)0xfe3340c4
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define P_AUDIO_RSAMPB_SINC_COEF_ADDR              (volatile uint32_t *)0xfe334100
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define P_AUDIO_RSAMPB_SINC_COEF_DATA              (volatile uint32_t *)0xfe334104
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  RESAMPLEB.h
//
//
// Closing file:  REG_LIST_AUDIO_RTL.h
//
//
// Reading file:  REG_LIST_DSP_RTL.h
//
// synopsys translate_off
// synopsys translate_on
//========================================================================
//  DSPA - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe340000
// -----------------------------------------------
#define P_DSP_CFG0                                 (volatile uint32_t *)0xfe340000
#define P_DSP_CFG1                                 (volatile uint32_t *)0xfe340004
#define P_DSP_CFG2                                 (volatile uint32_t *)0xfe340008
#define P_DSP_IMPWIRE                              (volatile uint32_t *)0xfe34000c
#define P_DSP_RESET_VEC                            (volatile uint32_t *)0xfe340010
#define P_DSP_SEC_CFG0                             (volatile uint32_t *)0xfe340018
#define P_DSP_SEC_CFG1                             (volatile uint32_t *)0xfe34001c
#define P_DSP_IRQ_CTRL0                            (volatile uint32_t *)0xfe340040
#define P_DSP_IRQ_CTRL1                            (volatile uint32_t *)0xfe340044
#define P_DSP_IRQ_CTRL2                            (volatile uint32_t *)0xfe340048
#define P_DSP_IRQ_CTRL3                            (volatile uint32_t *)0xfe34004c
#define P_DSP_IRQ_CTRL4                            (volatile uint32_t *)0xfe340050
#define P_DSP_IRQ_CTRL5                            (volatile uint32_t *)0xfe340054
#define P_DSP_IRQ_CTRL6                            (volatile uint32_t *)0xfe340058
#define P_DSP_IRQ_CTRL7                            (volatile uint32_t *)0xfe34005c
#define P_DSP_IRQ_CTRL8                            (volatile uint32_t *)0xfe340060
#define P_DSP_IRQ_STS                              (volatile uint32_t *)0xfe34007c
#define P_DSP_REMAP0                               (volatile uint32_t *)0xfe340080
#define P_DSP_REMAP1                               (volatile uint32_t *)0xfe340084
#define P_DSP_REMAP2                               (volatile uint32_t *)0xfe340088
#define P_DSP_STS0                                 (volatile uint32_t *)0xfe340100
#define P_DSP_STS1                                 (volatile uint32_t *)0xfe340104
#define P_DSP_STS2                                 (volatile uint32_t *)0xfe340108
#define P_DSP_STS3                                 (volatile uint32_t *)0xfe34010c
#define P_DSP_STS4                                 (volatile uint32_t *)0xfe340110
#define P_DSP_STS5                                 (volatile uint32_t *)0xfe340114
#define P_DSP_QIF_CTRL                             (volatile uint32_t *)0xfe340200
#define P_DSP_QIF_STS                              (volatile uint32_t *)0xfe340204
#define P_DSP_WRFIFO_TOCPUA                        (volatile uint32_t *)0xfe340208
#define P_DSP_WRFIFO_TOCPUB                        (volatile uint32_t *)0xfe34020c
#define P_DSP_WRFIFO_TODSP                         (volatile uint32_t *)0xfe340210
#define P_DSP_RDFIFO_FRCPUA                        (volatile uint32_t *)0xfe340220
#define P_DSP_RDFIFO_FRCPUB                        (volatile uint32_t *)0xfe340224
#define P_DSP_RDFIFO_FRDSP                         (volatile uint32_t *)0xfe340228
//========================================================================
//  DSPB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe350000
// -----------------------------------------------
#define P_DSPB_CFG0                                (volatile uint32_t *)0xfe350000
#define P_DSPB_CFG1                                (volatile uint32_t *)0xfe350004
#define P_DSPB_CFG2                                (volatile uint32_t *)0xfe350008
#define P_DSPB_IMPWIRE                             (volatile uint32_t *)0xfe35000c
#define P_DSPB_RESET_VEC                           (volatile uint32_t *)0xfe350010
#define P_DSPB_SEC_CFG0                            (volatile uint32_t *)0xfe350018
#define P_DSPB_SEC_CFG1                            (volatile uint32_t *)0xfe35001c
#define P_DSPB_IRQ_CTRL0                           (volatile uint32_t *)0xfe350040
#define P_DSPB_IRQ_CTRL1                           (volatile uint32_t *)0xfe350044
#define P_DSPB_IRQ_CTRL2                           (volatile uint32_t *)0xfe350048
#define P_DSPB_IRQ_CTRL3                           (volatile uint32_t *)0xfe35004c
#define P_DSPB_IRQ_CTRL4                           (volatile uint32_t *)0xfe350050
#define P_DSPB_IRQ_CTRL5                           (volatile uint32_t *)0xfe350054
#define P_DSPB_IRQ_CTRL6                           (volatile uint32_t *)0xfe350058
#define P_DSPB_IRQ_CTRL7                           (volatile uint32_t *)0xfe35005c
#define P_DSPB_IRQ_CTRL8                           (volatile uint32_t *)0xfe350060
#define P_DSPB_IRQ_STS                             (volatile uint32_t *)0xfe35007c
#define P_DSPB_REMAP0                              (volatile uint32_t *)0xfe350080
#define P_DSPB_REMAP1                              (volatile uint32_t *)0xfe350084
#define P_DSPB_REMAP2                              (volatile uint32_t *)0xfe350088
#define P_DSPB_STS0                                (volatile uint32_t *)0xfe350100
#define P_DSPB_STS1                                (volatile uint32_t *)0xfe350104
#define P_DSPB_STS2                                (volatile uint32_t *)0xfe350108
#define P_DSPB_STS3                                (volatile uint32_t *)0xfe35010c
#define P_DSPB_STS4                                (volatile uint32_t *)0xfe350110
#define P_DSPB_STS5                                (volatile uint32_t *)0xfe350114
#define P_DSPB_QIF_CTRL                            (volatile uint32_t *)0xfe350200
#define P_DSPB_QIF_STS                             (volatile uint32_t *)0xfe350204
#define P_DSPB_WRFIFO_TOCPUA                       (volatile uint32_t *)0xfe350208
#define P_DSPB_WRFIFO_TOCPUB                       (volatile uint32_t *)0xfe35020c
#define P_DSPB_WRFIFO_TODSP                        (volatile uint32_t *)0xfe350210
#define P_DSPB_RDFIFO_FRCPUA                       (volatile uint32_t *)0xfe350220
#define P_DSPB_RDFIFO_FRCPUB                       (volatile uint32_t *)0xfe350224
#define P_DSPB_RDFIFO_FRDSP                        (volatile uint32_t *)0xfe350228
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  REG_LIST_DSP_RTL.h
//
//
// Reading file:  REG_LIST_SECURITY_RTL.h
//
//
//***************************************************************************
// Title:      REG_LIST_SECURITY_RTL.h
//
// Author:     shan.luan
//
// Created:    23:09:44 28/02/2020
//
// Description:
//
// Note:
//
// History:
//
//***************************************************************************
//========================================================================
//  TS_DEMUX_REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe444000
// -----------------------------------------------
#define P_RCH_READY_CHANNEL_0                      (volatile uint32_t *)0xfe444000
#define P_RCH_READY_CHANNEL_1                      (volatile uint32_t *)0xfe444020
#define P_RCH_READY_CHANNEL_2                      (volatile uint32_t *)0xfe444040
#define P_RCH_READY_CHANNEL_3                      (volatile uint32_t *)0xfe444060
#define P_RCH_READY_CHANNEL_4                      (volatile uint32_t *)0xfe444080
#define P_RCH_READY_CHANNEL_5                      (volatile uint32_t *)0xfe4440a0
#define P_RCH_READY_CHANNEL_6                      (volatile uint32_t *)0xfe4440c0
#define P_RCH_READY_CHANNEL_7                      (volatile uint32_t *)0xfe4440e0
#define P_RCH_READY_CHANNEL_8                      (volatile uint32_t *)0xfe444100
#define P_RCH_READY_CHANNEL_9                      (volatile uint32_t *)0xfe444120
#define P_RCH_READY_CHANNEL_10                     (volatile uint32_t *)0xfe444140
#define P_RCH_READY_CHANNEL_11                     (volatile uint32_t *)0xfe444160
#define P_RCH_READY_CHANNEL_12                     (volatile uint32_t *)0xfe444180
#define P_RCH_READY_CHANNEL_13                     (volatile uint32_t *)0xfe4441a0
#define P_RCH_READY_CHANNEL_14                     (volatile uint32_t *)0xfe4441c0
#define P_RCH_READY_CHANNEL_15                     (volatile uint32_t *)0xfe4441e0
#define P_RCH_READY_CHANNEL_16                     (volatile uint32_t *)0xfe444200
#define P_RCH_READY_CHANNEL_17                     (volatile uint32_t *)0xfe444220
#define P_RCH_READY_CHANNEL_18                     (volatile uint32_t *)0xfe444240
#define P_RCH_READY_CHANNEL_19                     (volatile uint32_t *)0xfe444260
#define P_RCH_READY_CHANNEL_20                     (volatile uint32_t *)0xfe444280
#define P_RCH_READY_CHANNEL_21                     (volatile uint32_t *)0xfe4442a0
#define P_RCH_READY_CHANNEL_22                     (volatile uint32_t *)0xfe4442c0
#define P_RCH_READY_CHANNEL_23                     (volatile uint32_t *)0xfe4442e0
#define P_RCH_READY_CHANNEL_24                     (volatile uint32_t *)0xfe444300
#define P_RCH_READY_CHANNEL_25                     (volatile uint32_t *)0xfe444320
#define P_RCH_READY_CHANNEL_26                     (volatile uint32_t *)0xfe444340
#define P_RCH_READY_CHANNEL_27                     (volatile uint32_t *)0xfe444360
#define P_RCH_READY_CHANNEL_28                     (volatile uint32_t *)0xfe444380
#define P_RCH_READY_CHANNEL_29                     (volatile uint32_t *)0xfe4443a0
#define P_RCH_READY_CHANNEL_30                     (volatile uint32_t *)0xfe4443c0
#define P_RCH_READY_CHANNEL_31                     (volatile uint32_t *)0xfe4443e0
#define P_RCH_STATUS_CHANNEL_0                     (volatile uint32_t *)0xfe444004
#define P_RCH_STATUS_CHANNEL_1                     (volatile uint32_t *)0xfe444024
#define P_RCH_STATUS_CHANNEL_2                     (volatile uint32_t *)0xfe444044
#define P_RCH_STATUS_CHANNEL_3                     (volatile uint32_t *)0xfe444064
#define P_RCH_STATUS_CHANNEL_4                     (volatile uint32_t *)0xfe444084
#define P_RCH_STATUS_CHANNEL_5                     (volatile uint32_t *)0xfe4440a4
#define P_RCH_STATUS_CHANNEL_6                     (volatile uint32_t *)0xfe4440c4
#define P_RCH_STATUS_CHANNEL_7                     (volatile uint32_t *)0xfe4440e4
#define P_RCH_STATUS_CHANNEL_8                     (volatile uint32_t *)0xfe444104
#define P_RCH_STATUS_CHANNEL_9                     (volatile uint32_t *)0xfe444124
#define P_RCH_STATUS_CHANNEL_10                    (volatile uint32_t *)0xfe444144
#define P_RCH_STATUS_CHANNEL_11                    (volatile uint32_t *)0xfe444164
#define P_RCH_STATUS_CHANNEL_12                    (volatile uint32_t *)0xfe444184
#define P_RCH_STATUS_CHANNEL_13                    (volatile uint32_t *)0xfe4441a4
#define P_RCH_STATUS_CHANNEL_14                    (volatile uint32_t *)0xfe4441c4
#define P_RCH_STATUS_CHANNEL_15                    (volatile uint32_t *)0xfe4441e4
#define P_RCH_STATUS_CHANNEL_16                    (volatile uint32_t *)0xfe444204
#define P_RCH_STATUS_CHANNEL_17                    (volatile uint32_t *)0xfe444224
#define P_RCH_STATUS_CHANNEL_18                    (volatile uint32_t *)0xfe444244
#define P_RCH_STATUS_CHANNEL_19                    (volatile uint32_t *)0xfe444264
#define P_RCH_STATUS_CHANNEL_20                    (volatile uint32_t *)0xfe444284
#define P_RCH_STATUS_CHANNEL_21                    (volatile uint32_t *)0xfe4442a4
#define P_RCH_STATUS_CHANNEL_22                    (volatile uint32_t *)0xfe4442c4
#define P_RCH_STATUS_CHANNEL_23                    (volatile uint32_t *)0xfe4442e4
#define P_RCH_STATUS_CHANNEL_24                    (volatile uint32_t *)0xfe444304
#define P_RCH_STATUS_CHANNEL_25                    (volatile uint32_t *)0xfe444324
#define P_RCH_STATUS_CHANNEL_26                    (volatile uint32_t *)0xfe444344
#define P_RCH_STATUS_CHANNEL_27                    (volatile uint32_t *)0xfe444364
#define P_RCH_STATUS_CHANNEL_28                    (volatile uint32_t *)0xfe444384
#define P_RCH_STATUS_CHANNEL_29                    (volatile uint32_t *)0xfe4443a4
#define P_RCH_STATUS_CHANNEL_30                    (volatile uint32_t *)0xfe4443c4
#define P_RCH_STATUS_CHANNEL_31                    (volatile uint32_t *)0xfe4443e4
#define P_RCH_CFG_CHANNEL_0                        (volatile uint32_t *)0xfe444008
#define P_RCH_CFG_CHANNEL_1                        (volatile uint32_t *)0xfe444028
#define P_RCH_CFG_CHANNEL_2                        (volatile uint32_t *)0xfe444048
#define P_RCH_CFG_CHANNEL_3                        (volatile uint32_t *)0xfe444068
#define P_RCH_CFG_CHANNEL_4                        (volatile uint32_t *)0xfe444088
#define P_RCH_CFG_CHANNEL_5                        (volatile uint32_t *)0xfe4440a8
#define P_RCH_CFG_CHANNEL_6                        (volatile uint32_t *)0xfe4440c8
#define P_RCH_CFG_CHANNEL_7                        (volatile uint32_t *)0xfe4440e8
#define P_RCH_CFG_CHANNEL_8                        (volatile uint32_t *)0xfe444108
#define P_RCH_CFG_CHANNEL_9                        (volatile uint32_t *)0xfe444128
#define P_RCH_CFG_CHANNEL_10                       (volatile uint32_t *)0xfe444148
#define P_RCH_CFG_CHANNEL_11                       (volatile uint32_t *)0xfe444168
#define P_RCH_CFG_CHANNEL_12                       (volatile uint32_t *)0xfe444188
#define P_RCH_CFG_CHANNEL_13                       (volatile uint32_t *)0xfe4441a8
#define P_RCH_CFG_CHANNEL_14                       (volatile uint32_t *)0xfe4441c8
#define P_RCH_CFG_CHANNEL_15                       (volatile uint32_t *)0xfe4441e8
#define P_RCH_CFG_CHANNEL_16                       (volatile uint32_t *)0xfe444208
#define P_RCH_CFG_CHANNEL_17                       (volatile uint32_t *)0xfe444228
#define P_RCH_CFG_CHANNEL_18                       (volatile uint32_t *)0xfe444248
#define P_RCH_CFG_CHANNEL_19                       (volatile uint32_t *)0xfe444268
#define P_RCH_CFG_CHANNEL_20                       (volatile uint32_t *)0xfe444288
#define P_RCH_CFG_CHANNEL_21                       (volatile uint32_t *)0xfe4442a8
#define P_RCH_CFG_CHANNEL_22                       (volatile uint32_t *)0xfe4442c8
#define P_RCH_CFG_CHANNEL_23                       (volatile uint32_t *)0xfe4442e8
#define P_RCH_CFG_CHANNEL_24                       (volatile uint32_t *)0xfe444308
#define P_RCH_CFG_CHANNEL_25                       (volatile uint32_t *)0xfe444328
#define P_RCH_CFG_CHANNEL_26                       (volatile uint32_t *)0xfe444348
#define P_RCH_CFG_CHANNEL_27                       (volatile uint32_t *)0xfe444368
#define P_RCH_CFG_CHANNEL_28                       (volatile uint32_t *)0xfe444388
#define P_RCH_CFG_CHANNEL_29                       (volatile uint32_t *)0xfe4443a8
#define P_RCH_CFG_CHANNEL_30                       (volatile uint32_t *)0xfe4443c8
#define P_RCH_CFG_CHANNEL_31                       (volatile uint32_t *)0xfe4443e8
#define P_RCH_ADDR_CHANNEL_0                       (volatile uint32_t *)0xfe44400c
#define P_RCH_ADDR_CHANNEL_1                       (volatile uint32_t *)0xfe44402c
#define P_RCH_ADDR_CHANNEL_2                       (volatile uint32_t *)0xfe44404c
#define P_RCH_ADDR_CHANNEL_3                       (volatile uint32_t *)0xfe44406c
#define P_RCH_ADDR_CHANNEL_4                       (volatile uint32_t *)0xfe44408c
#define P_RCH_ADDR_CHANNEL_5                       (volatile uint32_t *)0xfe4440ac
#define P_RCH_ADDR_CHANNEL_6                       (volatile uint32_t *)0xfe4440cc
#define P_RCH_ADDR_CHANNEL_7                       (volatile uint32_t *)0xfe4440ec
#define P_RCH_ADDR_CHANNEL_8                       (volatile uint32_t *)0xfe44410c
#define P_RCH_ADDR_CHANNEL_9                       (volatile uint32_t *)0xfe44412c
#define P_RCH_ADDR_CHANNEL_10                      (volatile uint32_t *)0xfe44414c
#define P_RCH_ADDR_CHANNEL_11                      (volatile uint32_t *)0xfe44416c
#define P_RCH_ADDR_CHANNEL_12                      (volatile uint32_t *)0xfe44418c
#define P_RCH_ADDR_CHANNEL_13                      (volatile uint32_t *)0xfe4441ac
#define P_RCH_ADDR_CHANNEL_14                      (volatile uint32_t *)0xfe4441cc
#define P_RCH_ADDR_CHANNEL_15                      (volatile uint32_t *)0xfe4441ec
#define P_RCH_ADDR_CHANNEL_16                      (volatile uint32_t *)0xfe44420c
#define P_RCH_ADDR_CHANNEL_17                      (volatile uint32_t *)0xfe44422c
#define P_RCH_ADDR_CHANNEL_18                      (volatile uint32_t *)0xfe44424c
#define P_RCH_ADDR_CHANNEL_19                      (volatile uint32_t *)0xfe44426c
#define P_RCH_ADDR_CHANNEL_20                      (volatile uint32_t *)0xfe44428c
#define P_RCH_ADDR_CHANNEL_21                      (volatile uint32_t *)0xfe4442ac
#define P_RCH_ADDR_CHANNEL_22                      (volatile uint32_t *)0xfe4442cc
#define P_RCH_ADDR_CHANNEL_23                      (volatile uint32_t *)0xfe4442ec
#define P_RCH_ADDR_CHANNEL_24                      (volatile uint32_t *)0xfe44430c
#define P_RCH_ADDR_CHANNEL_25                      (volatile uint32_t *)0xfe44432c
#define P_RCH_ADDR_CHANNEL_26                      (volatile uint32_t *)0xfe44434c
#define P_RCH_ADDR_CHANNEL_27                      (volatile uint32_t *)0xfe44436c
#define P_RCH_ADDR_CHANNEL_28                      (volatile uint32_t *)0xfe44438c
#define P_RCH_ADDR_CHANNEL_29                      (volatile uint32_t *)0xfe4443ac
#define P_RCH_ADDR_CHANNEL_30                      (volatile uint32_t *)0xfe4443cc
#define P_RCH_ADDR_CHANNEL_31                      (volatile uint32_t *)0xfe4443ec
#define P_RCH_LEN_CHANNEL_0                        (volatile uint32_t *)0xfe444010
#define P_RCH_LEN_CHANNEL_1                        (volatile uint32_t *)0xfe444030
#define P_RCH_LEN_CHANNEL_2                        (volatile uint32_t *)0xfe444050
#define P_RCH_LEN_CHANNEL_3                        (volatile uint32_t *)0xfe444070
#define P_RCH_LEN_CHANNEL_4                        (volatile uint32_t *)0xfe444090
#define P_RCH_LEN_CHANNEL_5                        (volatile uint32_t *)0xfe4440b0
#define P_RCH_LEN_CHANNEL_6                        (volatile uint32_t *)0xfe4440d0
#define P_RCH_LEN_CHANNEL_7                        (volatile uint32_t *)0xfe4440f0
#define P_RCH_LEN_CHANNEL_8                        (volatile uint32_t *)0xfe444110
#define P_RCH_LEN_CHANNEL_9                        (volatile uint32_t *)0xfe444130
#define P_RCH_LEN_CHANNEL_10                       (volatile uint32_t *)0xfe444150
#define P_RCH_LEN_CHANNEL_11                       (volatile uint32_t *)0xfe444170
#define P_RCH_LEN_CHANNEL_12                       (volatile uint32_t *)0xfe444190
#define P_RCH_LEN_CHANNEL_13                       (volatile uint32_t *)0xfe4441b0
#define P_RCH_LEN_CHANNEL_14                       (volatile uint32_t *)0xfe4441d0
#define P_RCH_LEN_CHANNEL_15                       (volatile uint32_t *)0xfe4441f0
#define P_RCH_LEN_CHANNEL_16                       (volatile uint32_t *)0xfe444210
#define P_RCH_LEN_CHANNEL_17                       (volatile uint32_t *)0xfe444230
#define P_RCH_LEN_CHANNEL_18                       (volatile uint32_t *)0xfe444250
#define P_RCH_LEN_CHANNEL_19                       (volatile uint32_t *)0xfe444270
#define P_RCH_LEN_CHANNEL_20                       (volatile uint32_t *)0xfe444290
#define P_RCH_LEN_CHANNEL_21                       (volatile uint32_t *)0xfe4442b0
#define P_RCH_LEN_CHANNEL_22                       (volatile uint32_t *)0xfe4442d0
#define P_RCH_LEN_CHANNEL_23                       (volatile uint32_t *)0xfe4442f0
#define P_RCH_LEN_CHANNEL_24                       (volatile uint32_t *)0xfe444310
#define P_RCH_LEN_CHANNEL_25                       (volatile uint32_t *)0xfe444330
#define P_RCH_LEN_CHANNEL_26                       (volatile uint32_t *)0xfe444350
#define P_RCH_LEN_CHANNEL_27                       (volatile uint32_t *)0xfe444370
#define P_RCH_LEN_CHANNEL_28                       (volatile uint32_t *)0xfe444390
#define P_RCH_LEN_CHANNEL_29                       (volatile uint32_t *)0xfe4443b0
#define P_RCH_LEN_CHANNEL_30                       (volatile uint32_t *)0xfe4443d0
#define P_RCH_LEN_CHANNEL_31                       (volatile uint32_t *)0xfe4443f0
#define P_RCH_RD_LEN_CHANNEL_0                     (volatile uint32_t *)0xfe444014
#define P_RCH_RD_LEN_CHANNEL_1                     (volatile uint32_t *)0xfe444034
#define P_RCH_RD_LEN_CHANNEL_2                     (volatile uint32_t *)0xfe444054
#define P_RCH_RD_LEN_CHANNEL_3                     (volatile uint32_t *)0xfe444074
#define P_RCH_RD_LEN_CHANNEL_4                     (volatile uint32_t *)0xfe444094
#define P_RCH_RD_LEN_CHANNEL_5                     (volatile uint32_t *)0xfe4440b4
#define P_RCH_RD_LEN_CHANNEL_6                     (volatile uint32_t *)0xfe4440d4
#define P_RCH_RD_LEN_CHANNEL_7                     (volatile uint32_t *)0xfe4440f4
#define P_RCH_RD_LEN_CHANNEL_8                     (volatile uint32_t *)0xfe444114
#define P_RCH_RD_LEN_CHANNEL_9                     (volatile uint32_t *)0xfe444134
#define P_RCH_RD_LEN_CHANNEL_10                    (volatile uint32_t *)0xfe444154
#define P_RCH_RD_LEN_CHANNEL_11                    (volatile uint32_t *)0xfe444174
#define P_RCH_RD_LEN_CHANNEL_12                    (volatile uint32_t *)0xfe444194
#define P_RCH_RD_LEN_CHANNEL_13                    (volatile uint32_t *)0xfe4441b4
#define P_RCH_RD_LEN_CHANNEL_14                    (volatile uint32_t *)0xfe4441d4
#define P_RCH_RD_LEN_CHANNEL_15                    (volatile uint32_t *)0xfe4441f4
#define P_RCH_RD_LEN_CHANNEL_16                    (volatile uint32_t *)0xfe444214
#define P_RCH_RD_LEN_CHANNEL_17                    (volatile uint32_t *)0xfe444234
#define P_RCH_RD_LEN_CHANNEL_18                    (volatile uint32_t *)0xfe444254
#define P_RCH_RD_LEN_CHANNEL_19                    (volatile uint32_t *)0xfe444274
#define P_RCH_RD_LEN_CHANNEL_20                    (volatile uint32_t *)0xfe444294
#define P_RCH_RD_LEN_CHANNEL_21                    (volatile uint32_t *)0xfe4442b4
#define P_RCH_RD_LEN_CHANNEL_22                    (volatile uint32_t *)0xfe4442d4
#define P_RCH_RD_LEN_CHANNEL_23                    (volatile uint32_t *)0xfe4442f4
#define P_RCH_RD_LEN_CHANNEL_24                    (volatile uint32_t *)0xfe444314
#define P_RCH_RD_LEN_CHANNEL_25                    (volatile uint32_t *)0xfe444334
#define P_RCH_RD_LEN_CHANNEL_26                    (volatile uint32_t *)0xfe444354
#define P_RCH_RD_LEN_CHANNEL_27                    (volatile uint32_t *)0xfe444374
#define P_RCH_RD_LEN_CHANNEL_28                    (volatile uint32_t *)0xfe444394
#define P_RCH_RD_LEN_CHANNEL_29                    (volatile uint32_t *)0xfe4443b4
#define P_RCH_RD_LEN_CHANNEL_30                    (volatile uint32_t *)0xfe4443d4
#define P_RCH_RD_LEN_CHANNEL_31                    (volatile uint32_t *)0xfe4443f4
#define P_RCH_PTR_CHANNEL_0                        (volatile uint32_t *)0xfe444018
#define P_RCH_PTR_CHANNEL_1                        (volatile uint32_t *)0xfe444038
#define P_RCH_PTR_CHANNEL_2                        (volatile uint32_t *)0xfe444058
#define P_RCH_PTR_CHANNEL_3                        (volatile uint32_t *)0xfe444078
#define P_RCH_PTR_CHANNEL_4                        (volatile uint32_t *)0xfe444098
#define P_RCH_PTR_CHANNEL_5                        (volatile uint32_t *)0xfe4440b8
#define P_RCH_PTR_CHANNEL_6                        (volatile uint32_t *)0xfe4440d8
#define P_RCH_PTR_CHANNEL_7                        (volatile uint32_t *)0xfe4440f8
#define P_RCH_PTR_CHANNEL_8                        (volatile uint32_t *)0xfe444118
#define P_RCH_PTR_CHANNEL_9                        (volatile uint32_t *)0xfe444138
#define P_RCH_PTR_CHANNEL_10                       (volatile uint32_t *)0xfe444158
#define P_RCH_PTR_CHANNEL_11                       (volatile uint32_t *)0xfe444178
#define P_RCH_PTR_CHANNEL_12                       (volatile uint32_t *)0xfe444198
#define P_RCH_PTR_CHANNEL_13                       (volatile uint32_t *)0xfe4441b8
#define P_RCH_PTR_CHANNEL_14                       (volatile uint32_t *)0xfe4441d8
#define P_RCH_PTR_CHANNEL_15                       (volatile uint32_t *)0xfe4441f8
#define P_RCH_PTR_CHANNEL_16                       (volatile uint32_t *)0xfe444218
#define P_RCH_PTR_CHANNEL_17                       (volatile uint32_t *)0xfe444238
#define P_RCH_PTR_CHANNEL_18                       (volatile uint32_t *)0xfe444258
#define P_RCH_PTR_CHANNEL_19                       (volatile uint32_t *)0xfe444278
#define P_RCH_PTR_CHANNEL_20                       (volatile uint32_t *)0xfe444298
#define P_RCH_PTR_CHANNEL_21                       (volatile uint32_t *)0xfe4442b8
#define P_RCH_PTR_CHANNEL_22                       (volatile uint32_t *)0xfe4442d8
#define P_RCH_PTR_CHANNEL_23                       (volatile uint32_t *)0xfe4442f8
#define P_RCH_PTR_CHANNEL_24                       (volatile uint32_t *)0xfe444318
#define P_RCH_PTR_CHANNEL_25                       (volatile uint32_t *)0xfe444338
#define P_RCH_PTR_CHANNEL_26                       (volatile uint32_t *)0xfe444358
#define P_RCH_PTR_CHANNEL_27                       (volatile uint32_t *)0xfe444378
#define P_RCH_PTR_CHANNEL_28                       (volatile uint32_t *)0xfe444398
#define P_RCH_PTR_CHANNEL_29                       (volatile uint32_t *)0xfe4443b8
#define P_RCH_PTR_CHANNEL_30                       (volatile uint32_t *)0xfe4443d8
#define P_RCH_PTR_CHANNEL_31                       (volatile uint32_t *)0xfe4443f8
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_0            (volatile uint32_t *)0xfe44401c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_1            (volatile uint32_t *)0xfe44403c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_2            (volatile uint32_t *)0xfe44405c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_3            (volatile uint32_t *)0xfe44407c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_4            (volatile uint32_t *)0xfe44409c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_5            (volatile uint32_t *)0xfe4440bc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_6            (volatile uint32_t *)0xfe4440dc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_7            (volatile uint32_t *)0xfe4440fc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_8            (volatile uint32_t *)0xfe44411c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_9            (volatile uint32_t *)0xfe44413c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_10           (volatile uint32_t *)0xfe44415c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_11           (volatile uint32_t *)0xfe44417c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_12           (volatile uint32_t *)0xfe44419c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_13           (volatile uint32_t *)0xfe4441bc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_14           (volatile uint32_t *)0xfe4441dc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_15           (volatile uint32_t *)0xfe4441fc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_16           (volatile uint32_t *)0xfe44421c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_17           (volatile uint32_t *)0xfe44423c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_18           (volatile uint32_t *)0xfe44425c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_19           (volatile uint32_t *)0xfe44427c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_20           (volatile uint32_t *)0xfe44429c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_21           (volatile uint32_t *)0xfe4442bc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_22           (volatile uint32_t *)0xfe4442dc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_23           (volatile uint32_t *)0xfe4442fc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_24           (volatile uint32_t *)0xfe44431c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_25           (volatile uint32_t *)0xfe44433c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_26           (volatile uint32_t *)0xfe44435c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_27           (volatile uint32_t *)0xfe44437c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_28           (volatile uint32_t *)0xfe44439c
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_29           (volatile uint32_t *)0xfe4443bc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_30           (volatile uint32_t *)0xfe4443dc
#define P_RCH_PKT_SYNC_STATUS_CHANNEL_31           (volatile uint32_t *)0xfe4443fc
#define P_WCH_READY_CHANNEL_0                      (volatile uint32_t *)0xfe445000
#define P_WCH_READY_CHANNEL_1                      (volatile uint32_t *)0xfe445020
#define P_WCH_READY_CHANNEL_2                      (volatile uint32_t *)0xfe445040
#define P_WCH_READY_CHANNEL_3                      (volatile uint32_t *)0xfe445060
#define P_WCH_READY_CHANNEL_4                      (volatile uint32_t *)0xfe445080
#define P_WCH_READY_CHANNEL_5                      (volatile uint32_t *)0xfe4450a0
#define P_WCH_READY_CHANNEL_6                      (volatile uint32_t *)0xfe4450c0
#define P_WCH_READY_CHANNEL_7                      (volatile uint32_t *)0xfe4450e0
#define P_WCH_READY_CHANNEL_8                      (volatile uint32_t *)0xfe445100
#define P_WCH_READY_CHANNEL_9                      (volatile uint32_t *)0xfe445120
#define P_WCH_READY_CHANNEL_10                     (volatile uint32_t *)0xfe445140
#define P_WCH_READY_CHANNEL_11                     (volatile uint32_t *)0xfe445160
#define P_WCH_READY_CHANNEL_12                     (volatile uint32_t *)0xfe445180
#define P_WCH_READY_CHANNEL_13                     (volatile uint32_t *)0xfe4451a0
#define P_WCH_READY_CHANNEL_14                     (volatile uint32_t *)0xfe4451c0
#define P_WCH_READY_CHANNEL_15                     (volatile uint32_t *)0xfe4451e0
#define P_WCH_READY_CHANNEL_16                     (volatile uint32_t *)0xfe445200
#define P_WCH_READY_CHANNEL_17                     (volatile uint32_t *)0xfe445220
#define P_WCH_READY_CHANNEL_18                     (volatile uint32_t *)0xfe445240
#define P_WCH_READY_CHANNEL_19                     (volatile uint32_t *)0xfe445260
#define P_WCH_READY_CHANNEL_20                     (volatile uint32_t *)0xfe445280
#define P_WCH_READY_CHANNEL_21                     (volatile uint32_t *)0xfe4452a0
#define P_WCH_READY_CHANNEL_22                     (volatile uint32_t *)0xfe4452c0
#define P_WCH_READY_CHANNEL_23                     (volatile uint32_t *)0xfe4452e0
#define P_WCH_READY_CHANNEL_24                     (volatile uint32_t *)0xfe445300
#define P_WCH_READY_CHANNEL_25                     (volatile uint32_t *)0xfe445320
#define P_WCH_READY_CHANNEL_26                     (volatile uint32_t *)0xfe445340
#define P_WCH_READY_CHANNEL_27                     (volatile uint32_t *)0xfe445360
#define P_WCH_READY_CHANNEL_28                     (volatile uint32_t *)0xfe445380
#define P_WCH_READY_CHANNEL_29                     (volatile uint32_t *)0xfe4453a0
#define P_WCH_READY_CHANNEL_30                     (volatile uint32_t *)0xfe4453c0
#define P_WCH_READY_CHANNEL_31                     (volatile uint32_t *)0xfe4453e0
#define P_WCH_READY_CHANNEL_32                     (volatile uint32_t *)0xfe445400
#define P_WCH_READY_CHANNEL_33                     (volatile uint32_t *)0xfe445420
#define P_WCH_READY_CHANNEL_34                     (volatile uint32_t *)0xfe445440
#define P_WCH_READY_CHANNEL_35                     (volatile uint32_t *)0xfe445460
#define P_WCH_READY_CHANNEL_36                     (volatile uint32_t *)0xfe445480
#define P_WCH_READY_CHANNEL_37                     (volatile uint32_t *)0xfe4454a0
#define P_WCH_READY_CHANNEL_38                     (volatile uint32_t *)0xfe4454c0
#define P_WCH_READY_CHANNEL_39                     (volatile uint32_t *)0xfe4454e0
#define P_WCH_READY_CHANNEL_40                     (volatile uint32_t *)0xfe445500
#define P_WCH_READY_CHANNEL_41                     (volatile uint32_t *)0xfe445520
#define P_WCH_READY_CHANNEL_42                     (volatile uint32_t *)0xfe445540
#define P_WCH_READY_CHANNEL_43                     (volatile uint32_t *)0xfe445560
#define P_WCH_READY_CHANNEL_44                     (volatile uint32_t *)0xfe445580
#define P_WCH_READY_CHANNEL_45                     (volatile uint32_t *)0xfe4455a0
#define P_WCH_READY_CHANNEL_46                     (volatile uint32_t *)0xfe4455c0
#define P_WCH_READY_CHANNEL_47                     (volatile uint32_t *)0xfe4455e0
#define P_WCH_READY_CHANNEL_48                     (volatile uint32_t *)0xfe445600
#define P_WCH_READY_CHANNEL_49                     (volatile uint32_t *)0xfe445620
#define P_WCH_READY_CHANNEL_50                     (volatile uint32_t *)0xfe445640
#define P_WCH_READY_CHANNEL_51                     (volatile uint32_t *)0xfe445660
#define P_WCH_READY_CHANNEL_52                     (volatile uint32_t *)0xfe445680
#define P_WCH_READY_CHANNEL_53                     (volatile uint32_t *)0xfe4456a0
#define P_WCH_READY_CHANNEL_54                     (volatile uint32_t *)0xfe4456c0
#define P_WCH_READY_CHANNEL_55                     (volatile uint32_t *)0xfe4456e0
#define P_WCH_READY_CHANNEL_56                     (volatile uint32_t *)0xfe445700
#define P_WCH_READY_CHANNEL_57                     (volatile uint32_t *)0xfe445720
#define P_WCH_READY_CHANNEL_58                     (volatile uint32_t *)0xfe445740
#define P_WCH_READY_CHANNEL_59                     (volatile uint32_t *)0xfe445760
#define P_WCH_READY_CHANNEL_60                     (volatile uint32_t *)0xfe445780
#define P_WCH_READY_CHANNEL_61                     (volatile uint32_t *)0xfe4457a0
#define P_WCH_READY_CHANNEL_62                     (volatile uint32_t *)0xfe4457c0
#define P_WCH_READY_CHANNEL_63                     (volatile uint32_t *)0xfe4457e0
#define P_WCH_READY_CHANNEL_64                     (volatile uint32_t *)0xfe445800
#define P_WCH_READY_CHANNEL_65                     (volatile uint32_t *)0xfe445820
#define P_WCH_READY_CHANNEL_66                     (volatile uint32_t *)0xfe445840
#define P_WCH_READY_CHANNEL_67                     (volatile uint32_t *)0xfe445860
#define P_WCH_READY_CHANNEL_68                     (volatile uint32_t *)0xfe445880
#define P_WCH_READY_CHANNEL_69                     (volatile uint32_t *)0xfe4458a0
#define P_WCH_READY_CHANNEL_70                     (volatile uint32_t *)0xfe4458c0
#define P_WCH_READY_CHANNEL_71                     (volatile uint32_t *)0xfe4458e0
#define P_WCH_READY_CHANNEL_72                     (volatile uint32_t *)0xfe445900
#define P_WCH_READY_CHANNEL_73                     (volatile uint32_t *)0xfe445920
#define P_WCH_READY_CHANNEL_74                     (volatile uint32_t *)0xfe445940
#define P_WCH_READY_CHANNEL_75                     (volatile uint32_t *)0xfe445960
#define P_WCH_READY_CHANNEL_76                     (volatile uint32_t *)0xfe445980
#define P_WCH_READY_CHANNEL_77                     (volatile uint32_t *)0xfe4459a0
#define P_WCH_READY_CHANNEL_78                     (volatile uint32_t *)0xfe4459c0
#define P_WCH_READY_CHANNEL_79                     (volatile uint32_t *)0xfe4459e0
#define P_WCH_READY_CHANNEL_80                     (volatile uint32_t *)0xfe445a00
#define P_WCH_READY_CHANNEL_81                     (volatile uint32_t *)0xfe445a20
#define P_WCH_READY_CHANNEL_82                     (volatile uint32_t *)0xfe445a40
#define P_WCH_READY_CHANNEL_83                     (volatile uint32_t *)0xfe445a60
#define P_WCH_READY_CHANNEL_84                     (volatile uint32_t *)0xfe445a80
#define P_WCH_READY_CHANNEL_85                     (volatile uint32_t *)0xfe445aa0
#define P_WCH_READY_CHANNEL_86                     (volatile uint32_t *)0xfe445ac0
#define P_WCH_READY_CHANNEL_87                     (volatile uint32_t *)0xfe445ae0
#define P_WCH_READY_CHANNEL_88                     (volatile uint32_t *)0xfe445b00
#define P_WCH_READY_CHANNEL_89                     (volatile uint32_t *)0xfe445b20
#define P_WCH_READY_CHANNEL_90                     (volatile uint32_t *)0xfe445b40
#define P_WCH_READY_CHANNEL_91                     (volatile uint32_t *)0xfe445b60
#define P_WCH_READY_CHANNEL_92                     (volatile uint32_t *)0xfe445b80
#define P_WCH_READY_CHANNEL_93                     (volatile uint32_t *)0xfe445ba0
#define P_WCH_READY_CHANNEL_94                     (volatile uint32_t *)0xfe445bc0
#define P_WCH_READY_CHANNEL_95                     (volatile uint32_t *)0xfe445be0
#define P_WCH_READY_CHANNEL_96                     (volatile uint32_t *)0xfe445c00
#define P_WCH_READY_CHANNEL_97                     (volatile uint32_t *)0xfe445c20
#define P_WCH_READY_CHANNEL_98                     (volatile uint32_t *)0xfe445c40
#define P_WCH_READY_CHANNEL_99                     (volatile uint32_t *)0xfe445c60
#define P_WCH_READY_CHANNEL_100                    (volatile uint32_t *)0xfe445c80
#define P_WCH_READY_CHANNEL_101                    (volatile uint32_t *)0xfe445ca0
#define P_WCH_READY_CHANNEL_102                    (volatile uint32_t *)0xfe445cc0
#define P_WCH_READY_CHANNEL_103                    (volatile uint32_t *)0xfe445ce0
#define P_WCH_READY_CHANNEL_104                    (volatile uint32_t *)0xfe445d00
#define P_WCH_READY_CHANNEL_105                    (volatile uint32_t *)0xfe445d20
#define P_WCH_READY_CHANNEL_106                    (volatile uint32_t *)0xfe445d40
#define P_WCH_READY_CHANNEL_107                    (volatile uint32_t *)0xfe445d60
#define P_WCH_READY_CHANNEL_108                    (volatile uint32_t *)0xfe445d80
#define P_WCH_READY_CHANNEL_109                    (volatile uint32_t *)0xfe445da0
#define P_WCH_READY_CHANNEL_110                    (volatile uint32_t *)0xfe445dc0
#define P_WCH_READY_CHANNEL_111                    (volatile uint32_t *)0xfe445de0
#define P_WCH_READY_CHANNEL_112                    (volatile uint32_t *)0xfe445e00
#define P_WCH_READY_CHANNEL_113                    (volatile uint32_t *)0xfe445e20
#define P_WCH_READY_CHANNEL_114                    (volatile uint32_t *)0xfe445e40
#define P_WCH_READY_CHANNEL_115                    (volatile uint32_t *)0xfe445e60
#define P_WCH_READY_CHANNEL_116                    (volatile uint32_t *)0xfe445e80
#define P_WCH_READY_CHANNEL_117                    (volatile uint32_t *)0xfe445ea0
#define P_WCH_READY_CHANNEL_118                    (volatile uint32_t *)0xfe445ec0
#define P_WCH_READY_CHANNEL_119                    (volatile uint32_t *)0xfe445ee0
#define P_WCH_READY_CHANNEL_120                    (volatile uint32_t *)0xfe445f00
#define P_WCH_READY_CHANNEL_121                    (volatile uint32_t *)0xfe445f20
#define P_WCH_READY_CHANNEL_122                    (volatile uint32_t *)0xfe445f40
#define P_WCH_READY_CHANNEL_123                    (volatile uint32_t *)0xfe445f60
#define P_WCH_READY_CHANNEL_124                    (volatile uint32_t *)0xfe445f80
#define P_WCH_READY_CHANNEL_125                    (volatile uint32_t *)0xfe445fa0
#define P_WCH_READY_CHANNEL_126                    (volatile uint32_t *)0xfe445fc0
#define P_WCH_READY_CHANNEL_127                    (volatile uint32_t *)0xfe445fe0
#define P_WCH_DEBUG_CHANNEL_0                      (volatile uint32_t *)0xfe445004
#define P_WCH_DEBUG_CHANNEL_1                      (volatile uint32_t *)0xfe445024
#define P_WCH_DEBUG_CHANNEL_2                      (volatile uint32_t *)0xfe445044
#define P_WCH_DEBUG_CHANNEL_3                      (volatile uint32_t *)0xfe445064
#define P_WCH_DEBUG_CHANNEL_4                      (volatile uint32_t *)0xfe445084
#define P_WCH_DEBUG_CHANNEL_5                      (volatile uint32_t *)0xfe4450a4
#define P_WCH_DEBUG_CHANNEL_6                      (volatile uint32_t *)0xfe4450c4
#define P_WCH_DEBUG_CHANNEL_7                      (volatile uint32_t *)0xfe4450e4
#define P_WCH_DEBUG_CHANNEL_8                      (volatile uint32_t *)0xfe445104
#define P_WCH_DEBUG_CHANNEL_9                      (volatile uint32_t *)0xfe445124
#define P_WCH_DEBUG_CHANNEL_10                     (volatile uint32_t *)0xfe445144
#define P_WCH_DEBUG_CHANNEL_11                     (volatile uint32_t *)0xfe445164
#define P_WCH_DEBUG_CHANNEL_12                     (volatile uint32_t *)0xfe445184
#define P_WCH_DEBUG_CHANNEL_13                     (volatile uint32_t *)0xfe4451a4
#define P_WCH_DEBUG_CHANNEL_14                     (volatile uint32_t *)0xfe4451c4
#define P_WCH_DEBUG_CHANNEL_15                     (volatile uint32_t *)0xfe4451e4
#define P_WCH_DEBUG_CHANNEL_16                     (volatile uint32_t *)0xfe445204
#define P_WCH_DEBUG_CHANNEL_17                     (volatile uint32_t *)0xfe445224
#define P_WCH_DEBUG_CHANNEL_18                     (volatile uint32_t *)0xfe445244
#define P_WCH_DEBUG_CHANNEL_19                     (volatile uint32_t *)0xfe445264
#define P_WCH_DEBUG_CHANNEL_20                     (volatile uint32_t *)0xfe445284
#define P_WCH_DEBUG_CHANNEL_21                     (volatile uint32_t *)0xfe4452a4
#define P_WCH_DEBUG_CHANNEL_22                     (volatile uint32_t *)0xfe4452c4
#define P_WCH_DEBUG_CHANNEL_23                     (volatile uint32_t *)0xfe4452e4
#define P_WCH_DEBUG_CHANNEL_24                     (volatile uint32_t *)0xfe445304
#define P_WCH_DEBUG_CHANNEL_25                     (volatile uint32_t *)0xfe445324
#define P_WCH_DEBUG_CHANNEL_26                     (volatile uint32_t *)0xfe445344
#define P_WCH_DEBUG_CHANNEL_27                     (volatile uint32_t *)0xfe445364
#define P_WCH_DEBUG_CHANNEL_28                     (volatile uint32_t *)0xfe445384
#define P_WCH_DEBUG_CHANNEL_29                     (volatile uint32_t *)0xfe4453a4
#define P_WCH_DEBUG_CHANNEL_30                     (volatile uint32_t *)0xfe4453c4
#define P_WCH_DEBUG_CHANNEL_31                     (volatile uint32_t *)0xfe4453e4
#define P_WCH_DEBUG_CHANNEL_32                     (volatile uint32_t *)0xfe445404
#define P_WCH_DEBUG_CHANNEL_33                     (volatile uint32_t *)0xfe445424
#define P_WCH_DEBUG_CHANNEL_34                     (volatile uint32_t *)0xfe445444
#define P_WCH_DEBUG_CHANNEL_35                     (volatile uint32_t *)0xfe445464
#define P_WCH_DEBUG_CHANNEL_36                     (volatile uint32_t *)0xfe445484
#define P_WCH_DEBUG_CHANNEL_37                     (volatile uint32_t *)0xfe4454a4
#define P_WCH_DEBUG_CHANNEL_38                     (volatile uint32_t *)0xfe4454c4
#define P_WCH_DEBUG_CHANNEL_39                     (volatile uint32_t *)0xfe4454e4
#define P_WCH_DEBUG_CHANNEL_40                     (volatile uint32_t *)0xfe445504
#define P_WCH_DEBUG_CHANNEL_41                     (volatile uint32_t *)0xfe445524
#define P_WCH_DEBUG_CHANNEL_42                     (volatile uint32_t *)0xfe445544
#define P_WCH_DEBUG_CHANNEL_43                     (volatile uint32_t *)0xfe445564
#define P_WCH_DEBUG_CHANNEL_44                     (volatile uint32_t *)0xfe445584
#define P_WCH_DEBUG_CHANNEL_45                     (volatile uint32_t *)0xfe4455a4
#define P_WCH_DEBUG_CHANNEL_46                     (volatile uint32_t *)0xfe4455c4
#define P_WCH_DEBUG_CHANNEL_47                     (volatile uint32_t *)0xfe4455e4
#define P_WCH_DEBUG_CHANNEL_48                     (volatile uint32_t *)0xfe445604
#define P_WCH_DEBUG_CHANNEL_49                     (volatile uint32_t *)0xfe445624
#define P_WCH_DEBUG_CHANNEL_50                     (volatile uint32_t *)0xfe445644
#define P_WCH_DEBUG_CHANNEL_51                     (volatile uint32_t *)0xfe445664
#define P_WCH_DEBUG_CHANNEL_52                     (volatile uint32_t *)0xfe445684
#define P_WCH_DEBUG_CHANNEL_53                     (volatile uint32_t *)0xfe4456a4
#define P_WCH_DEBUG_CHANNEL_54                     (volatile uint32_t *)0xfe4456c4
#define P_WCH_DEBUG_CHANNEL_55                     (volatile uint32_t *)0xfe4456e4
#define P_WCH_DEBUG_CHANNEL_56                     (volatile uint32_t *)0xfe445704
#define P_WCH_DEBUG_CHANNEL_57                     (volatile uint32_t *)0xfe445724
#define P_WCH_DEBUG_CHANNEL_58                     (volatile uint32_t *)0xfe445744
#define P_WCH_DEBUG_CHANNEL_59                     (volatile uint32_t *)0xfe445764
#define P_WCH_DEBUG_CHANNEL_60                     (volatile uint32_t *)0xfe445784
#define P_WCH_DEBUG_CHANNEL_61                     (volatile uint32_t *)0xfe4457a4
#define P_WCH_DEBUG_CHANNEL_62                     (volatile uint32_t *)0xfe4457c4
#define P_WCH_DEBUG_CHANNEL_63                     (volatile uint32_t *)0xfe4457e4
#define P_WCH_DEBUG_CHANNEL_64                     (volatile uint32_t *)0xfe445804
#define P_WCH_DEBUG_CHANNEL_65                     (volatile uint32_t *)0xfe445824
#define P_WCH_DEBUG_CHANNEL_66                     (volatile uint32_t *)0xfe445844
#define P_WCH_DEBUG_CHANNEL_67                     (volatile uint32_t *)0xfe445864
#define P_WCH_DEBUG_CHANNEL_68                     (volatile uint32_t *)0xfe445884
#define P_WCH_DEBUG_CHANNEL_69                     (volatile uint32_t *)0xfe4458a4
#define P_WCH_DEBUG_CHANNEL_70                     (volatile uint32_t *)0xfe4458c4
#define P_WCH_DEBUG_CHANNEL_71                     (volatile uint32_t *)0xfe4458e4
#define P_WCH_DEBUG_CHANNEL_72                     (volatile uint32_t *)0xfe445904
#define P_WCH_DEBUG_CHANNEL_73                     (volatile uint32_t *)0xfe445924
#define P_WCH_DEBUG_CHANNEL_74                     (volatile uint32_t *)0xfe445944
#define P_WCH_DEBUG_CHANNEL_75                     (volatile uint32_t *)0xfe445964
#define P_WCH_DEBUG_CHANNEL_76                     (volatile uint32_t *)0xfe445984
#define P_WCH_DEBUG_CHANNEL_77                     (volatile uint32_t *)0xfe4459a4
#define P_WCH_DEBUG_CHANNEL_78                     (volatile uint32_t *)0xfe4459c4
#define P_WCH_DEBUG_CHANNEL_79                     (volatile uint32_t *)0xfe4459e4
#define P_WCH_DEBUG_CHANNEL_80                     (volatile uint32_t *)0xfe445a04
#define P_WCH_DEBUG_CHANNEL_81                     (volatile uint32_t *)0xfe445a24
#define P_WCH_DEBUG_CHANNEL_82                     (volatile uint32_t *)0xfe445a44
#define P_WCH_DEBUG_CHANNEL_83                     (volatile uint32_t *)0xfe445a64
#define P_WCH_DEBUG_CHANNEL_84                     (volatile uint32_t *)0xfe445a84
#define P_WCH_DEBUG_CHANNEL_85                     (volatile uint32_t *)0xfe445aa4
#define P_WCH_DEBUG_CHANNEL_86                     (volatile uint32_t *)0xfe445ac4
#define P_WCH_DEBUG_CHANNEL_87                     (volatile uint32_t *)0xfe445ae4
#define P_WCH_DEBUG_CHANNEL_88                     (volatile uint32_t *)0xfe445b04
#define P_WCH_DEBUG_CHANNEL_89                     (volatile uint32_t *)0xfe445b24
#define P_WCH_DEBUG_CHANNEL_90                     (volatile uint32_t *)0xfe445b44
#define P_WCH_DEBUG_CHANNEL_91                     (volatile uint32_t *)0xfe445b64
#define P_WCH_DEBUG_CHANNEL_92                     (volatile uint32_t *)0xfe445b84
#define P_WCH_DEBUG_CHANNEL_93                     (volatile uint32_t *)0xfe445ba4
#define P_WCH_DEBUG_CHANNEL_94                     (volatile uint32_t *)0xfe445bc4
#define P_WCH_DEBUG_CHANNEL_95                     (volatile uint32_t *)0xfe445be4
#define P_WCH_DEBUG_CHANNEL_96                     (volatile uint32_t *)0xfe445c04
#define P_WCH_DEBUG_CHANNEL_97                     (volatile uint32_t *)0xfe445c24
#define P_WCH_DEBUG_CHANNEL_98                     (volatile uint32_t *)0xfe445c44
#define P_WCH_DEBUG_CHANNEL_99                     (volatile uint32_t *)0xfe445c64
#define P_WCH_DEBUG_CHANNEL_100                    (volatile uint32_t *)0xfe445c84
#define P_WCH_DEBUG_CHANNEL_101                    (volatile uint32_t *)0xfe445ca4
#define P_WCH_DEBUG_CHANNEL_102                    (volatile uint32_t *)0xfe445cc4
#define P_WCH_DEBUG_CHANNEL_103                    (volatile uint32_t *)0xfe445ce4
#define P_WCH_DEBUG_CHANNEL_104                    (volatile uint32_t *)0xfe445d04
#define P_WCH_DEBUG_CHANNEL_105                    (volatile uint32_t *)0xfe445d24
#define P_WCH_DEBUG_CHANNEL_106                    (volatile uint32_t *)0xfe445d44
#define P_WCH_DEBUG_CHANNEL_107                    (volatile uint32_t *)0xfe445d64
#define P_WCH_DEBUG_CHANNEL_108                    (volatile uint32_t *)0xfe445d84
#define P_WCH_DEBUG_CHANNEL_109                    (volatile uint32_t *)0xfe445da4
#define P_WCH_DEBUG_CHANNEL_110                    (volatile uint32_t *)0xfe445dc4
#define P_WCH_DEBUG_CHANNEL_111                    (volatile uint32_t *)0xfe445de4
#define P_WCH_DEBUG_CHANNEL_112                    (volatile uint32_t *)0xfe445e04
#define P_WCH_DEBUG_CHANNEL_113                    (volatile uint32_t *)0xfe445e24
#define P_WCH_DEBUG_CHANNEL_114                    (volatile uint32_t *)0xfe445e44
#define P_WCH_DEBUG_CHANNEL_115                    (volatile uint32_t *)0xfe445e64
#define P_WCH_DEBUG_CHANNEL_116                    (volatile uint32_t *)0xfe445e84
#define P_WCH_DEBUG_CHANNEL_117                    (volatile uint32_t *)0xfe445ea4
#define P_WCH_DEBUG_CHANNEL_118                    (volatile uint32_t *)0xfe445ec4
#define P_WCH_DEBUG_CHANNEL_119                    (volatile uint32_t *)0xfe445ee4
#define P_WCH_DEBUG_CHANNEL_120                    (volatile uint32_t *)0xfe445f04
#define P_WCH_DEBUG_CHANNEL_121                    (volatile uint32_t *)0xfe445f24
#define P_WCH_DEBUG_CHANNEL_122                    (volatile uint32_t *)0xfe445f44
#define P_WCH_DEBUG_CHANNEL_123                    (volatile uint32_t *)0xfe445f64
#define P_WCH_DEBUG_CHANNEL_124                    (volatile uint32_t *)0xfe445f84
#define P_WCH_DEBUG_CHANNEL_125                    (volatile uint32_t *)0xfe445fa4
#define P_WCH_DEBUG_CHANNEL_126                    (volatile uint32_t *)0xfe445fc4
#define P_WCH_DEBUG_CHANNEL_127                    (volatile uint32_t *)0xfe445fe4
#define P_WCH_CFG_CHANNEL_0                        (volatile uint32_t *)0xfe445008
#define P_WCH_CFG_CHANNEL_1                        (volatile uint32_t *)0xfe445028
#define P_WCH_CFG_CHANNEL_2                        (volatile uint32_t *)0xfe445048
#define P_WCH_CFG_CHANNEL_3                        (volatile uint32_t *)0xfe445068
#define P_WCH_CFG_CHANNEL_4                        (volatile uint32_t *)0xfe445088
#define P_WCH_CFG_CHANNEL_5                        (volatile uint32_t *)0xfe4450a8
#define P_WCH_CFG_CHANNEL_6                        (volatile uint32_t *)0xfe4450c8
#define P_WCH_CFG_CHANNEL_7                        (volatile uint32_t *)0xfe4450e8
#define P_WCH_CFG_CHANNEL_8                        (volatile uint32_t *)0xfe445108
#define P_WCH_CFG_CHANNEL_9                        (volatile uint32_t *)0xfe445128
#define P_WCH_CFG_CHANNEL_10                       (volatile uint32_t *)0xfe445148
#define P_WCH_CFG_CHANNEL_11                       (volatile uint32_t *)0xfe445168
#define P_WCH_CFG_CHANNEL_12                       (volatile uint32_t *)0xfe445188
#define P_WCH_CFG_CHANNEL_13                       (volatile uint32_t *)0xfe4451a8
#define P_WCH_CFG_CHANNEL_14                       (volatile uint32_t *)0xfe4451c8
#define P_WCH_CFG_CHANNEL_15                       (volatile uint32_t *)0xfe4451e8
#define P_WCH_CFG_CHANNEL_16                       (volatile uint32_t *)0xfe445208
#define P_WCH_CFG_CHANNEL_17                       (volatile uint32_t *)0xfe445228
#define P_WCH_CFG_CHANNEL_18                       (volatile uint32_t *)0xfe445248
#define P_WCH_CFG_CHANNEL_19                       (volatile uint32_t *)0xfe445268
#define P_WCH_CFG_CHANNEL_20                       (volatile uint32_t *)0xfe445288
#define P_WCH_CFG_CHANNEL_21                       (volatile uint32_t *)0xfe4452a8
#define P_WCH_CFG_CHANNEL_22                       (volatile uint32_t *)0xfe4452c8
#define P_WCH_CFG_CHANNEL_23                       (volatile uint32_t *)0xfe4452e8
#define P_WCH_CFG_CHANNEL_24                       (volatile uint32_t *)0xfe445308
#define P_WCH_CFG_CHANNEL_25                       (volatile uint32_t *)0xfe445328
#define P_WCH_CFG_CHANNEL_26                       (volatile uint32_t *)0xfe445348
#define P_WCH_CFG_CHANNEL_27                       (volatile uint32_t *)0xfe445368
#define P_WCH_CFG_CHANNEL_28                       (volatile uint32_t *)0xfe445388
#define P_WCH_CFG_CHANNEL_29                       (volatile uint32_t *)0xfe4453a8
#define P_WCH_CFG_CHANNEL_30                       (volatile uint32_t *)0xfe4453c8
#define P_WCH_CFG_CHANNEL_31                       (volatile uint32_t *)0xfe4453e8
#define P_WCH_CFG_CHANNEL_32                       (volatile uint32_t *)0xfe445408
#define P_WCH_CFG_CHANNEL_33                       (volatile uint32_t *)0xfe445428
#define P_WCH_CFG_CHANNEL_34                       (volatile uint32_t *)0xfe445448
#define P_WCH_CFG_CHANNEL_35                       (volatile uint32_t *)0xfe445468
#define P_WCH_CFG_CHANNEL_36                       (volatile uint32_t *)0xfe445488
#define P_WCH_CFG_CHANNEL_37                       (volatile uint32_t *)0xfe4454a8
#define P_WCH_CFG_CHANNEL_38                       (volatile uint32_t *)0xfe4454c8
#define P_WCH_CFG_CHANNEL_39                       (volatile uint32_t *)0xfe4454e8
#define P_WCH_CFG_CHANNEL_40                       (volatile uint32_t *)0xfe445508
#define P_WCH_CFG_CHANNEL_41                       (volatile uint32_t *)0xfe445528
#define P_WCH_CFG_CHANNEL_42                       (volatile uint32_t *)0xfe445548
#define P_WCH_CFG_CHANNEL_43                       (volatile uint32_t *)0xfe445568
#define P_WCH_CFG_CHANNEL_44                       (volatile uint32_t *)0xfe445588
#define P_WCH_CFG_CHANNEL_45                       (volatile uint32_t *)0xfe4455a8
#define P_WCH_CFG_CHANNEL_46                       (volatile uint32_t *)0xfe4455c8
#define P_WCH_CFG_CHANNEL_47                       (volatile uint32_t *)0xfe4455e8
#define P_WCH_CFG_CHANNEL_48                       (volatile uint32_t *)0xfe445608
#define P_WCH_CFG_CHANNEL_49                       (volatile uint32_t *)0xfe445628
#define P_WCH_CFG_CHANNEL_50                       (volatile uint32_t *)0xfe445648
#define P_WCH_CFG_CHANNEL_51                       (volatile uint32_t *)0xfe445668
#define P_WCH_CFG_CHANNEL_52                       (volatile uint32_t *)0xfe445688
#define P_WCH_CFG_CHANNEL_53                       (volatile uint32_t *)0xfe4456a8
#define P_WCH_CFG_CHANNEL_54                       (volatile uint32_t *)0xfe4456c8
#define P_WCH_CFG_CHANNEL_55                       (volatile uint32_t *)0xfe4456e8
#define P_WCH_CFG_CHANNEL_56                       (volatile uint32_t *)0xfe445708
#define P_WCH_CFG_CHANNEL_57                       (volatile uint32_t *)0xfe445728
#define P_WCH_CFG_CHANNEL_58                       (volatile uint32_t *)0xfe445748
#define P_WCH_CFG_CHANNEL_59                       (volatile uint32_t *)0xfe445768
#define P_WCH_CFG_CHANNEL_60                       (volatile uint32_t *)0xfe445788
#define P_WCH_CFG_CHANNEL_61                       (volatile uint32_t *)0xfe4457a8
#define P_WCH_CFG_CHANNEL_62                       (volatile uint32_t *)0xfe4457c8
#define P_WCH_CFG_CHANNEL_63                       (volatile uint32_t *)0xfe4457e8
#define P_WCH_CFG_CHANNEL_64                       (volatile uint32_t *)0xfe445808
#define P_WCH_CFG_CHANNEL_65                       (volatile uint32_t *)0xfe445828
#define P_WCH_CFG_CHANNEL_66                       (volatile uint32_t *)0xfe445848
#define P_WCH_CFG_CHANNEL_67                       (volatile uint32_t *)0xfe445868
#define P_WCH_CFG_CHANNEL_68                       (volatile uint32_t *)0xfe445888
#define P_WCH_CFG_CHANNEL_69                       (volatile uint32_t *)0xfe4458a8
#define P_WCH_CFG_CHANNEL_70                       (volatile uint32_t *)0xfe4458c8
#define P_WCH_CFG_CHANNEL_71                       (volatile uint32_t *)0xfe4458e8
#define P_WCH_CFG_CHANNEL_72                       (volatile uint32_t *)0xfe445908
#define P_WCH_CFG_CHANNEL_73                       (volatile uint32_t *)0xfe445928
#define P_WCH_CFG_CHANNEL_74                       (volatile uint32_t *)0xfe445948
#define P_WCH_CFG_CHANNEL_75                       (volatile uint32_t *)0xfe445968
#define P_WCH_CFG_CHANNEL_76                       (volatile uint32_t *)0xfe445988
#define P_WCH_CFG_CHANNEL_77                       (volatile uint32_t *)0xfe4459a8
#define P_WCH_CFG_CHANNEL_78                       (volatile uint32_t *)0xfe4459c8
#define P_WCH_CFG_CHANNEL_79                       (volatile uint32_t *)0xfe4459e8
#define P_WCH_CFG_CHANNEL_80                       (volatile uint32_t *)0xfe445a08
#define P_WCH_CFG_CHANNEL_81                       (volatile uint32_t *)0xfe445a28
#define P_WCH_CFG_CHANNEL_82                       (volatile uint32_t *)0xfe445a48
#define P_WCH_CFG_CHANNEL_83                       (volatile uint32_t *)0xfe445a68
#define P_WCH_CFG_CHANNEL_84                       (volatile uint32_t *)0xfe445a88
#define P_WCH_CFG_CHANNEL_85                       (volatile uint32_t *)0xfe445aa8
#define P_WCH_CFG_CHANNEL_86                       (volatile uint32_t *)0xfe445ac8
#define P_WCH_CFG_CHANNEL_87                       (volatile uint32_t *)0xfe445ae8
#define P_WCH_CFG_CHANNEL_88                       (volatile uint32_t *)0xfe445b08
#define P_WCH_CFG_CHANNEL_89                       (volatile uint32_t *)0xfe445b28
#define P_WCH_CFG_CHANNEL_90                       (volatile uint32_t *)0xfe445b48
#define P_WCH_CFG_CHANNEL_91                       (volatile uint32_t *)0xfe445b68
#define P_WCH_CFG_CHANNEL_92                       (volatile uint32_t *)0xfe445b88
#define P_WCH_CFG_CHANNEL_93                       (volatile uint32_t *)0xfe445ba8
#define P_WCH_CFG_CHANNEL_94                       (volatile uint32_t *)0xfe445bc8
#define P_WCH_CFG_CHANNEL_95                       (volatile uint32_t *)0xfe445be8
#define P_WCH_CFG_CHANNEL_96                       (volatile uint32_t *)0xfe445c08
#define P_WCH_CFG_CHANNEL_97                       (volatile uint32_t *)0xfe445c28
#define P_WCH_CFG_CHANNEL_98                       (volatile uint32_t *)0xfe445c48
#define P_WCH_CFG_CHANNEL_99                       (volatile uint32_t *)0xfe445c68
#define P_WCH_CFG_CHANNEL_100                      (volatile uint32_t *)0xfe445c88
#define P_WCH_CFG_CHANNEL_101                      (volatile uint32_t *)0xfe445ca8
#define P_WCH_CFG_CHANNEL_102                      (volatile uint32_t *)0xfe445cc8
#define P_WCH_CFG_CHANNEL_103                      (volatile uint32_t *)0xfe445ce8
#define P_WCH_CFG_CHANNEL_104                      (volatile uint32_t *)0xfe445d08
#define P_WCH_CFG_CHANNEL_105                      (volatile uint32_t *)0xfe445d28
#define P_WCH_CFG_CHANNEL_106                      (volatile uint32_t *)0xfe445d48
#define P_WCH_CFG_CHANNEL_107                      (volatile uint32_t *)0xfe445d68
#define P_WCH_CFG_CHANNEL_108                      (volatile uint32_t *)0xfe445d88
#define P_WCH_CFG_CHANNEL_109                      (volatile uint32_t *)0xfe445da8
#define P_WCH_CFG_CHANNEL_110                      (volatile uint32_t *)0xfe445dc8
#define P_WCH_CFG_CHANNEL_111                      (volatile uint32_t *)0xfe445de8
#define P_WCH_CFG_CHANNEL_112                      (volatile uint32_t *)0xfe445e08
#define P_WCH_CFG_CHANNEL_113                      (volatile uint32_t *)0xfe445e28
#define P_WCH_CFG_CHANNEL_114                      (volatile uint32_t *)0xfe445e48
#define P_WCH_CFG_CHANNEL_115                      (volatile uint32_t *)0xfe445e68
#define P_WCH_CFG_CHANNEL_116                      (volatile uint32_t *)0xfe445e88
#define P_WCH_CFG_CHANNEL_117                      (volatile uint32_t *)0xfe445ea8
#define P_WCH_CFG_CHANNEL_118                      (volatile uint32_t *)0xfe445ec8
#define P_WCH_CFG_CHANNEL_119                      (volatile uint32_t *)0xfe445ee8
#define P_WCH_CFG_CHANNEL_120                      (volatile uint32_t *)0xfe445f08
#define P_WCH_CFG_CHANNEL_121                      (volatile uint32_t *)0xfe445f28
#define P_WCH_CFG_CHANNEL_122                      (volatile uint32_t *)0xfe445f48
#define P_WCH_CFG_CHANNEL_123                      (volatile uint32_t *)0xfe445f68
#define P_WCH_CFG_CHANNEL_124                      (volatile uint32_t *)0xfe445f88
#define P_WCH_CFG_CHANNEL_125                      (volatile uint32_t *)0xfe445fa8
#define P_WCH_CFG_CHANNEL_126                      (volatile uint32_t *)0xfe445fc8
#define P_WCH_CFG_CHANNEL_127                      (volatile uint32_t *)0xfe445fe8
#define P_WCH_ADDR_CHANNEL_0                       (volatile uint32_t *)0xfe44500c
#define P_WCH_ADDR_CHANNEL_1                       (volatile uint32_t *)0xfe44502c
#define P_WCH_ADDR_CHANNEL_2                       (volatile uint32_t *)0xfe44504c
#define P_WCH_ADDR_CHANNEL_3                       (volatile uint32_t *)0xfe44506c
#define P_WCH_ADDR_CHANNEL_4                       (volatile uint32_t *)0xfe44508c
#define P_WCH_ADDR_CHANNEL_5                       (volatile uint32_t *)0xfe4450ac
#define P_WCH_ADDR_CHANNEL_6                       (volatile uint32_t *)0xfe4450cc
#define P_WCH_ADDR_CHANNEL_7                       (volatile uint32_t *)0xfe4450ec
#define P_WCH_ADDR_CHANNEL_8                       (volatile uint32_t *)0xfe44510c
#define P_WCH_ADDR_CHANNEL_9                       (volatile uint32_t *)0xfe44512c
#define P_WCH_ADDR_CHANNEL_10                      (volatile uint32_t *)0xfe44514c
#define P_WCH_ADDR_CHANNEL_11                      (volatile uint32_t *)0xfe44516c
#define P_WCH_ADDR_CHANNEL_12                      (volatile uint32_t *)0xfe44518c
#define P_WCH_ADDR_CHANNEL_13                      (volatile uint32_t *)0xfe4451ac
#define P_WCH_ADDR_CHANNEL_14                      (volatile uint32_t *)0xfe4451cc
#define P_WCH_ADDR_CHANNEL_15                      (volatile uint32_t *)0xfe4451ec
#define P_WCH_ADDR_CHANNEL_16                      (volatile uint32_t *)0xfe44520c
#define P_WCH_ADDR_CHANNEL_17                      (volatile uint32_t *)0xfe44522c
#define P_WCH_ADDR_CHANNEL_18                      (volatile uint32_t *)0xfe44524c
#define P_WCH_ADDR_CHANNEL_19                      (volatile uint32_t *)0xfe44526c
#define P_WCH_ADDR_CHANNEL_20                      (volatile uint32_t *)0xfe44528c
#define P_WCH_ADDR_CHANNEL_21                      (volatile uint32_t *)0xfe4452ac
#define P_WCH_ADDR_CHANNEL_22                      (volatile uint32_t *)0xfe4452cc
#define P_WCH_ADDR_CHANNEL_23                      (volatile uint32_t *)0xfe4452ec
#define P_WCH_ADDR_CHANNEL_24                      (volatile uint32_t *)0xfe44530c
#define P_WCH_ADDR_CHANNEL_25                      (volatile uint32_t *)0xfe44532c
#define P_WCH_ADDR_CHANNEL_26                      (volatile uint32_t *)0xfe44534c
#define P_WCH_ADDR_CHANNEL_27                      (volatile uint32_t *)0xfe44536c
#define P_WCH_ADDR_CHANNEL_28                      (volatile uint32_t *)0xfe44538c
#define P_WCH_ADDR_CHANNEL_29                      (volatile uint32_t *)0xfe4453ac
#define P_WCH_ADDR_CHANNEL_30                      (volatile uint32_t *)0xfe4453cc
#define P_WCH_ADDR_CHANNEL_31                      (volatile uint32_t *)0xfe4453ec
#define P_WCH_ADDR_CHANNEL_32                      (volatile uint32_t *)0xfe44540c
#define P_WCH_ADDR_CHANNEL_33                      (volatile uint32_t *)0xfe44542c
#define P_WCH_ADDR_CHANNEL_34                      (volatile uint32_t *)0xfe44544c
#define P_WCH_ADDR_CHANNEL_35                      (volatile uint32_t *)0xfe44546c
#define P_WCH_ADDR_CHANNEL_36                      (volatile uint32_t *)0xfe44548c
#define P_WCH_ADDR_CHANNEL_37                      (volatile uint32_t *)0xfe4454ac
#define P_WCH_ADDR_CHANNEL_38                      (volatile uint32_t *)0xfe4454cc
#define P_WCH_ADDR_CHANNEL_39                      (volatile uint32_t *)0xfe4454ec
#define P_WCH_ADDR_CHANNEL_40                      (volatile uint32_t *)0xfe44550c
#define P_WCH_ADDR_CHANNEL_41                      (volatile uint32_t *)0xfe44552c
#define P_WCH_ADDR_CHANNEL_42                      (volatile uint32_t *)0xfe44554c
#define P_WCH_ADDR_CHANNEL_43                      (volatile uint32_t *)0xfe44556c
#define P_WCH_ADDR_CHANNEL_44                      (volatile uint32_t *)0xfe44558c
#define P_WCH_ADDR_CHANNEL_45                      (volatile uint32_t *)0xfe4455ac
#define P_WCH_ADDR_CHANNEL_46                      (volatile uint32_t *)0xfe4455cc
#define P_WCH_ADDR_CHANNEL_47                      (volatile uint32_t *)0xfe4455ec
#define P_WCH_ADDR_CHANNEL_48                      (volatile uint32_t *)0xfe44560c
#define P_WCH_ADDR_CHANNEL_49                      (volatile uint32_t *)0xfe44562c
#define P_WCH_ADDR_CHANNEL_50                      (volatile uint32_t *)0xfe44564c
#define P_WCH_ADDR_CHANNEL_51                      (volatile uint32_t *)0xfe44566c
#define P_WCH_ADDR_CHANNEL_52                      (volatile uint32_t *)0xfe44568c
#define P_WCH_ADDR_CHANNEL_53                      (volatile uint32_t *)0xfe4456ac
#define P_WCH_ADDR_CHANNEL_54                      (volatile uint32_t *)0xfe4456cc
#define P_WCH_ADDR_CHANNEL_55                      (volatile uint32_t *)0xfe4456ec
#define P_WCH_ADDR_CHANNEL_56                      (volatile uint32_t *)0xfe44570c
#define P_WCH_ADDR_CHANNEL_57                      (volatile uint32_t *)0xfe44572c
#define P_WCH_ADDR_CHANNEL_58                      (volatile uint32_t *)0xfe44574c
#define P_WCH_ADDR_CHANNEL_59                      (volatile uint32_t *)0xfe44576c
#define P_WCH_ADDR_CHANNEL_60                      (volatile uint32_t *)0xfe44578c
#define P_WCH_ADDR_CHANNEL_61                      (volatile uint32_t *)0xfe4457ac
#define P_WCH_ADDR_CHANNEL_62                      (volatile uint32_t *)0xfe4457cc
#define P_WCH_ADDR_CHANNEL_63                      (volatile uint32_t *)0xfe4457ec
#define P_WCH_ADDR_CHANNEL_64                      (volatile uint32_t *)0xfe44580c
#define P_WCH_ADDR_CHANNEL_65                      (volatile uint32_t *)0xfe44582c
#define P_WCH_ADDR_CHANNEL_66                      (volatile uint32_t *)0xfe44584c
#define P_WCH_ADDR_CHANNEL_67                      (volatile uint32_t *)0xfe44586c
#define P_WCH_ADDR_CHANNEL_68                      (volatile uint32_t *)0xfe44588c
#define P_WCH_ADDR_CHANNEL_69                      (volatile uint32_t *)0xfe4458ac
#define P_WCH_ADDR_CHANNEL_70                      (volatile uint32_t *)0xfe4458cc
#define P_WCH_ADDR_CHANNEL_71                      (volatile uint32_t *)0xfe4458ec
#define P_WCH_ADDR_CHANNEL_72                      (volatile uint32_t *)0xfe44590c
#define P_WCH_ADDR_CHANNEL_73                      (volatile uint32_t *)0xfe44592c
#define P_WCH_ADDR_CHANNEL_74                      (volatile uint32_t *)0xfe44594c
#define P_WCH_ADDR_CHANNEL_75                      (volatile uint32_t *)0xfe44596c
#define P_WCH_ADDR_CHANNEL_76                      (volatile uint32_t *)0xfe44598c
#define P_WCH_ADDR_CHANNEL_77                      (volatile uint32_t *)0xfe4459ac
#define P_WCH_ADDR_CHANNEL_78                      (volatile uint32_t *)0xfe4459cc
#define P_WCH_ADDR_CHANNEL_79                      (volatile uint32_t *)0xfe4459ec
#define P_WCH_ADDR_CHANNEL_80                      (volatile uint32_t *)0xfe445a0c
#define P_WCH_ADDR_CHANNEL_81                      (volatile uint32_t *)0xfe445a2c
#define P_WCH_ADDR_CHANNEL_82                      (volatile uint32_t *)0xfe445a4c
#define P_WCH_ADDR_CHANNEL_83                      (volatile uint32_t *)0xfe445a6c
#define P_WCH_ADDR_CHANNEL_84                      (volatile uint32_t *)0xfe445a8c
#define P_WCH_ADDR_CHANNEL_85                      (volatile uint32_t *)0xfe445aac
#define P_WCH_ADDR_CHANNEL_86                      (volatile uint32_t *)0xfe445acc
#define P_WCH_ADDR_CHANNEL_87                      (volatile uint32_t *)0xfe445aec
#define P_WCH_ADDR_CHANNEL_88                      (volatile uint32_t *)0xfe445b0c
#define P_WCH_ADDR_CHANNEL_89                      (volatile uint32_t *)0xfe445b2c
#define P_WCH_ADDR_CHANNEL_90                      (volatile uint32_t *)0xfe445b4c
#define P_WCH_ADDR_CHANNEL_91                      (volatile uint32_t *)0xfe445b6c
#define P_WCH_ADDR_CHANNEL_92                      (volatile uint32_t *)0xfe445b8c
#define P_WCH_ADDR_CHANNEL_93                      (volatile uint32_t *)0xfe445bac
#define P_WCH_ADDR_CHANNEL_94                      (volatile uint32_t *)0xfe445bcc
#define P_WCH_ADDR_CHANNEL_95                      (volatile uint32_t *)0xfe445bec
#define P_WCH_ADDR_CHANNEL_96                      (volatile uint32_t *)0xfe445c0c
#define P_WCH_ADDR_CHANNEL_97                      (volatile uint32_t *)0xfe445c2c
#define P_WCH_ADDR_CHANNEL_98                      (volatile uint32_t *)0xfe445c4c
#define P_WCH_ADDR_CHANNEL_99                      (volatile uint32_t *)0xfe445c6c
#define P_WCH_ADDR_CHANNEL_100                     (volatile uint32_t *)0xfe445c8c
#define P_WCH_ADDR_CHANNEL_101                     (volatile uint32_t *)0xfe445cac
#define P_WCH_ADDR_CHANNEL_102                     (volatile uint32_t *)0xfe445ccc
#define P_WCH_ADDR_CHANNEL_103                     (volatile uint32_t *)0xfe445cec
#define P_WCH_ADDR_CHANNEL_104                     (volatile uint32_t *)0xfe445d0c
#define P_WCH_ADDR_CHANNEL_105                     (volatile uint32_t *)0xfe445d2c
#define P_WCH_ADDR_CHANNEL_106                     (volatile uint32_t *)0xfe445d4c
#define P_WCH_ADDR_CHANNEL_107                     (volatile uint32_t *)0xfe445d6c
#define P_WCH_ADDR_CHANNEL_108                     (volatile uint32_t *)0xfe445d8c
#define P_WCH_ADDR_CHANNEL_109                     (volatile uint32_t *)0xfe445dac
#define P_WCH_ADDR_CHANNEL_110                     (volatile uint32_t *)0xfe445dcc
#define P_WCH_ADDR_CHANNEL_111                     (volatile uint32_t *)0xfe445dec
#define P_WCH_ADDR_CHANNEL_112                     (volatile uint32_t *)0xfe445e0c
#define P_WCH_ADDR_CHANNEL_113                     (volatile uint32_t *)0xfe445e2c
#define P_WCH_ADDR_CHANNEL_114                     (volatile uint32_t *)0xfe445e4c
#define P_WCH_ADDR_CHANNEL_115                     (volatile uint32_t *)0xfe445e6c
#define P_WCH_ADDR_CHANNEL_116                     (volatile uint32_t *)0xfe445e8c
#define P_WCH_ADDR_CHANNEL_117                     (volatile uint32_t *)0xfe445eac
#define P_WCH_ADDR_CHANNEL_118                     (volatile uint32_t *)0xfe445ecc
#define P_WCH_ADDR_CHANNEL_119                     (volatile uint32_t *)0xfe445eec
#define P_WCH_ADDR_CHANNEL_120                     (volatile uint32_t *)0xfe445f0c
#define P_WCH_ADDR_CHANNEL_121                     (volatile uint32_t *)0xfe445f2c
#define P_WCH_ADDR_CHANNEL_122                     (volatile uint32_t *)0xfe445f4c
#define P_WCH_ADDR_CHANNEL_123                     (volatile uint32_t *)0xfe445f6c
#define P_WCH_ADDR_CHANNEL_124                     (volatile uint32_t *)0xfe445f8c
#define P_WCH_ADDR_CHANNEL_125                     (volatile uint32_t *)0xfe445fac
#define P_WCH_ADDR_CHANNEL_126                     (volatile uint32_t *)0xfe445fcc
#define P_WCH_ADDR_CHANNEL_127                     (volatile uint32_t *)0xfe445fec
#define P_WCH_LEN_CHANNEL_0                        (volatile uint32_t *)0xfe445010
#define P_WCH_LEN_CHANNEL_1                        (volatile uint32_t *)0xfe445030
#define P_WCH_LEN_CHANNEL_2                        (volatile uint32_t *)0xfe445050
#define P_WCH_LEN_CHANNEL_3                        (volatile uint32_t *)0xfe445070
#define P_WCH_LEN_CHANNEL_4                        (volatile uint32_t *)0xfe445090
#define P_WCH_LEN_CHANNEL_5                        (volatile uint32_t *)0xfe4450b0
#define P_WCH_LEN_CHANNEL_6                        (volatile uint32_t *)0xfe4450d0
#define P_WCH_LEN_CHANNEL_7                        (volatile uint32_t *)0xfe4450f0
#define P_WCH_LEN_CHANNEL_8                        (volatile uint32_t *)0xfe445110
#define P_WCH_LEN_CHANNEL_9                        (volatile uint32_t *)0xfe445130
#define P_WCH_LEN_CHANNEL_10                       (volatile uint32_t *)0xfe445150
#define P_WCH_LEN_CHANNEL_11                       (volatile uint32_t *)0xfe445170
#define P_WCH_LEN_CHANNEL_12                       (volatile uint32_t *)0xfe445190
#define P_WCH_LEN_CHANNEL_13                       (volatile uint32_t *)0xfe4451b0
#define P_WCH_LEN_CHANNEL_14                       (volatile uint32_t *)0xfe4451d0
#define P_WCH_LEN_CHANNEL_15                       (volatile uint32_t *)0xfe4451f0
#define P_WCH_LEN_CHANNEL_16                       (volatile uint32_t *)0xfe445210
#define P_WCH_LEN_CHANNEL_17                       (volatile uint32_t *)0xfe445230
#define P_WCH_LEN_CHANNEL_18                       (volatile uint32_t *)0xfe445250
#define P_WCH_LEN_CHANNEL_19                       (volatile uint32_t *)0xfe445270
#define P_WCH_LEN_CHANNEL_20                       (volatile uint32_t *)0xfe445290
#define P_WCH_LEN_CHANNEL_21                       (volatile uint32_t *)0xfe4452b0
#define P_WCH_LEN_CHANNEL_22                       (volatile uint32_t *)0xfe4452d0
#define P_WCH_LEN_CHANNEL_23                       (volatile uint32_t *)0xfe4452f0
#define P_WCH_LEN_CHANNEL_24                       (volatile uint32_t *)0xfe445310
#define P_WCH_LEN_CHANNEL_25                       (volatile uint32_t *)0xfe445330
#define P_WCH_LEN_CHANNEL_26                       (volatile uint32_t *)0xfe445350
#define P_WCH_LEN_CHANNEL_27                       (volatile uint32_t *)0xfe445370
#define P_WCH_LEN_CHANNEL_28                       (volatile uint32_t *)0xfe445390
#define P_WCH_LEN_CHANNEL_29                       (volatile uint32_t *)0xfe4453b0
#define P_WCH_LEN_CHANNEL_30                       (volatile uint32_t *)0xfe4453d0
#define P_WCH_LEN_CHANNEL_31                       (volatile uint32_t *)0xfe4453f0
#define P_WCH_LEN_CHANNEL_32                       (volatile uint32_t *)0xfe445410
#define P_WCH_LEN_CHANNEL_33                       (volatile uint32_t *)0xfe445430
#define P_WCH_LEN_CHANNEL_34                       (volatile uint32_t *)0xfe445450
#define P_WCH_LEN_CHANNEL_35                       (volatile uint32_t *)0xfe445470
#define P_WCH_LEN_CHANNEL_36                       (volatile uint32_t *)0xfe445490
#define P_WCH_LEN_CHANNEL_37                       (volatile uint32_t *)0xfe4454b0
#define P_WCH_LEN_CHANNEL_38                       (volatile uint32_t *)0xfe4454d0
#define P_WCH_LEN_CHANNEL_39                       (volatile uint32_t *)0xfe4454f0
#define P_WCH_LEN_CHANNEL_40                       (volatile uint32_t *)0xfe445510
#define P_WCH_LEN_CHANNEL_41                       (volatile uint32_t *)0xfe445530
#define P_WCH_LEN_CHANNEL_42                       (volatile uint32_t *)0xfe445550
#define P_WCH_LEN_CHANNEL_43                       (volatile uint32_t *)0xfe445570
#define P_WCH_LEN_CHANNEL_44                       (volatile uint32_t *)0xfe445590
#define P_WCH_LEN_CHANNEL_45                       (volatile uint32_t *)0xfe4455b0
#define P_WCH_LEN_CHANNEL_46                       (volatile uint32_t *)0xfe4455d0
#define P_WCH_LEN_CHANNEL_47                       (volatile uint32_t *)0xfe4455f0
#define P_WCH_LEN_CHANNEL_48                       (volatile uint32_t *)0xfe445610
#define P_WCH_LEN_CHANNEL_49                       (volatile uint32_t *)0xfe445630
#define P_WCH_LEN_CHANNEL_50                       (volatile uint32_t *)0xfe445650
#define P_WCH_LEN_CHANNEL_51                       (volatile uint32_t *)0xfe445670
#define P_WCH_LEN_CHANNEL_52                       (volatile uint32_t *)0xfe445690
#define P_WCH_LEN_CHANNEL_53                       (volatile uint32_t *)0xfe4456b0
#define P_WCH_LEN_CHANNEL_54                       (volatile uint32_t *)0xfe4456d0
#define P_WCH_LEN_CHANNEL_55                       (volatile uint32_t *)0xfe4456f0
#define P_WCH_LEN_CHANNEL_56                       (volatile uint32_t *)0xfe445710
#define P_WCH_LEN_CHANNEL_57                       (volatile uint32_t *)0xfe445730
#define P_WCH_LEN_CHANNEL_58                       (volatile uint32_t *)0xfe445750
#define P_WCH_LEN_CHANNEL_59                       (volatile uint32_t *)0xfe445770
#define P_WCH_LEN_CHANNEL_60                       (volatile uint32_t *)0xfe445790
#define P_WCH_LEN_CHANNEL_61                       (volatile uint32_t *)0xfe4457b0
#define P_WCH_LEN_CHANNEL_62                       (volatile uint32_t *)0xfe4457d0
#define P_WCH_LEN_CHANNEL_63                       (volatile uint32_t *)0xfe4457f0
#define P_WCH_LEN_CHANNEL_64                       (volatile uint32_t *)0xfe445810
#define P_WCH_LEN_CHANNEL_65                       (volatile uint32_t *)0xfe445830
#define P_WCH_LEN_CHANNEL_66                       (volatile uint32_t *)0xfe445850
#define P_WCH_LEN_CHANNEL_67                       (volatile uint32_t *)0xfe445870
#define P_WCH_LEN_CHANNEL_68                       (volatile uint32_t *)0xfe445890
#define P_WCH_LEN_CHANNEL_69                       (volatile uint32_t *)0xfe4458b0
#define P_WCH_LEN_CHANNEL_70                       (volatile uint32_t *)0xfe4458d0
#define P_WCH_LEN_CHANNEL_71                       (volatile uint32_t *)0xfe4458f0
#define P_WCH_LEN_CHANNEL_72                       (volatile uint32_t *)0xfe445910
#define P_WCH_LEN_CHANNEL_73                       (volatile uint32_t *)0xfe445930
#define P_WCH_LEN_CHANNEL_74                       (volatile uint32_t *)0xfe445950
#define P_WCH_LEN_CHANNEL_75                       (volatile uint32_t *)0xfe445970
#define P_WCH_LEN_CHANNEL_76                       (volatile uint32_t *)0xfe445990
#define P_WCH_LEN_CHANNEL_77                       (volatile uint32_t *)0xfe4459b0
#define P_WCH_LEN_CHANNEL_78                       (volatile uint32_t *)0xfe4459d0
#define P_WCH_LEN_CHANNEL_79                       (volatile uint32_t *)0xfe4459f0
#define P_WCH_LEN_CHANNEL_80                       (volatile uint32_t *)0xfe445a10
#define P_WCH_LEN_CHANNEL_81                       (volatile uint32_t *)0xfe445a30
#define P_WCH_LEN_CHANNEL_82                       (volatile uint32_t *)0xfe445a50
#define P_WCH_LEN_CHANNEL_83                       (volatile uint32_t *)0xfe445a70
#define P_WCH_LEN_CHANNEL_84                       (volatile uint32_t *)0xfe445a90
#define P_WCH_LEN_CHANNEL_85                       (volatile uint32_t *)0xfe445ab0
#define P_WCH_LEN_CHANNEL_86                       (volatile uint32_t *)0xfe445ad0
#define P_WCH_LEN_CHANNEL_87                       (volatile uint32_t *)0xfe445af0
#define P_WCH_LEN_CHANNEL_88                       (volatile uint32_t *)0xfe445b10
#define P_WCH_LEN_CHANNEL_89                       (volatile uint32_t *)0xfe445b30
#define P_WCH_LEN_CHANNEL_90                       (volatile uint32_t *)0xfe445b50
#define P_WCH_LEN_CHANNEL_91                       (volatile uint32_t *)0xfe445b70
#define P_WCH_LEN_CHANNEL_92                       (volatile uint32_t *)0xfe445b90
#define P_WCH_LEN_CHANNEL_93                       (volatile uint32_t *)0xfe445bb0
#define P_WCH_LEN_CHANNEL_94                       (volatile uint32_t *)0xfe445bd0
#define P_WCH_LEN_CHANNEL_95                       (volatile uint32_t *)0xfe445bf0
#define P_WCH_LEN_CHANNEL_96                       (volatile uint32_t *)0xfe445c10
#define P_WCH_LEN_CHANNEL_97                       (volatile uint32_t *)0xfe445c30
#define P_WCH_LEN_CHANNEL_98                       (volatile uint32_t *)0xfe445c50
#define P_WCH_LEN_CHANNEL_99                       (volatile uint32_t *)0xfe445c70
#define P_WCH_LEN_CHANNEL_100                      (volatile uint32_t *)0xfe445c90
#define P_WCH_LEN_CHANNEL_101                      (volatile uint32_t *)0xfe445cb0
#define P_WCH_LEN_CHANNEL_102                      (volatile uint32_t *)0xfe445cd0
#define P_WCH_LEN_CHANNEL_103                      (volatile uint32_t *)0xfe445cf0
#define P_WCH_LEN_CHANNEL_104                      (volatile uint32_t *)0xfe445d10
#define P_WCH_LEN_CHANNEL_105                      (volatile uint32_t *)0xfe445d30
#define P_WCH_LEN_CHANNEL_106                      (volatile uint32_t *)0xfe445d50
#define P_WCH_LEN_CHANNEL_107                      (volatile uint32_t *)0xfe445d70
#define P_WCH_LEN_CHANNEL_108                      (volatile uint32_t *)0xfe445d90
#define P_WCH_LEN_CHANNEL_109                      (volatile uint32_t *)0xfe445db0
#define P_WCH_LEN_CHANNEL_110                      (volatile uint32_t *)0xfe445dd0
#define P_WCH_LEN_CHANNEL_111                      (volatile uint32_t *)0xfe445df0
#define P_WCH_LEN_CHANNEL_112                      (volatile uint32_t *)0xfe445e10
#define P_WCH_LEN_CHANNEL_113                      (volatile uint32_t *)0xfe445e30
#define P_WCH_LEN_CHANNEL_114                      (volatile uint32_t *)0xfe445e50
#define P_WCH_LEN_CHANNEL_115                      (volatile uint32_t *)0xfe445e70
#define P_WCH_LEN_CHANNEL_116                      (volatile uint32_t *)0xfe445e90
#define P_WCH_LEN_CHANNEL_117                      (volatile uint32_t *)0xfe445eb0
#define P_WCH_LEN_CHANNEL_118                      (volatile uint32_t *)0xfe445ed0
#define P_WCH_LEN_CHANNEL_119                      (volatile uint32_t *)0xfe445ef0
#define P_WCH_LEN_CHANNEL_120                      (volatile uint32_t *)0xfe445f10
#define P_WCH_LEN_CHANNEL_121                      (volatile uint32_t *)0xfe445f30
#define P_WCH_LEN_CHANNEL_122                      (volatile uint32_t *)0xfe445f50
#define P_WCH_LEN_CHANNEL_123                      (volatile uint32_t *)0xfe445f70
#define P_WCH_LEN_CHANNEL_124                      (volatile uint32_t *)0xfe445f90
#define P_WCH_LEN_CHANNEL_125                      (volatile uint32_t *)0xfe445fb0
#define P_WCH_LEN_CHANNEL_126                      (volatile uint32_t *)0xfe445fd0
#define P_WCH_LEN_CHANNEL_127                      (volatile uint32_t *)0xfe445ff0
#define P_WCH_WR_LEN_CHANNEL_0                     (volatile uint32_t *)0xfe445014
#define P_WCH_WR_LEN_CHANNEL_1                     (volatile uint32_t *)0xfe445034
#define P_WCH_WR_LEN_CHANNEL_2                     (volatile uint32_t *)0xfe445054
#define P_WCH_WR_LEN_CHANNEL_3                     (volatile uint32_t *)0xfe445074
#define P_WCH_WR_LEN_CHANNEL_4                     (volatile uint32_t *)0xfe445094
#define P_WCH_WR_LEN_CHANNEL_5                     (volatile uint32_t *)0xfe4450b4
#define P_WCH_WR_LEN_CHANNEL_6                     (volatile uint32_t *)0xfe4450d4
#define P_WCH_WR_LEN_CHANNEL_7                     (volatile uint32_t *)0xfe4450f4
#define P_WCH_WR_LEN_CHANNEL_8                     (volatile uint32_t *)0xfe445114
#define P_WCH_WR_LEN_CHANNEL_9                     (volatile uint32_t *)0xfe445134
#define P_WCH_WR_LEN_CHANNEL_10                    (volatile uint32_t *)0xfe445154
#define P_WCH_WR_LEN_CHANNEL_11                    (volatile uint32_t *)0xfe445174
#define P_WCH_WR_LEN_CHANNEL_12                    (volatile uint32_t *)0xfe445194
#define P_WCH_WR_LEN_CHANNEL_13                    (volatile uint32_t *)0xfe4451b4
#define P_WCH_WR_LEN_CHANNEL_14                    (volatile uint32_t *)0xfe4451d4
#define P_WCH_WR_LEN_CHANNEL_15                    (volatile uint32_t *)0xfe4451f4
#define P_WCH_WR_LEN_CHANNEL_16                    (volatile uint32_t *)0xfe445214
#define P_WCH_WR_LEN_CHANNEL_17                    (volatile uint32_t *)0xfe445234
#define P_WCH_WR_LEN_CHANNEL_18                    (volatile uint32_t *)0xfe445254
#define P_WCH_WR_LEN_CHANNEL_19                    (volatile uint32_t *)0xfe445274
#define P_WCH_WR_LEN_CHANNEL_20                    (volatile uint32_t *)0xfe445294
#define P_WCH_WR_LEN_CHANNEL_21                    (volatile uint32_t *)0xfe4452b4
#define P_WCH_WR_LEN_CHANNEL_22                    (volatile uint32_t *)0xfe4452d4
#define P_WCH_WR_LEN_CHANNEL_23                    (volatile uint32_t *)0xfe4452f4
#define P_WCH_WR_LEN_CHANNEL_24                    (volatile uint32_t *)0xfe445314
#define P_WCH_WR_LEN_CHANNEL_25                    (volatile uint32_t *)0xfe445334
#define P_WCH_WR_LEN_CHANNEL_26                    (volatile uint32_t *)0xfe445354
#define P_WCH_WR_LEN_CHANNEL_27                    (volatile uint32_t *)0xfe445374
#define P_WCH_WR_LEN_CHANNEL_28                    (volatile uint32_t *)0xfe445394
#define P_WCH_WR_LEN_CHANNEL_29                    (volatile uint32_t *)0xfe4453b4
#define P_WCH_WR_LEN_CHANNEL_30                    (volatile uint32_t *)0xfe4453d4
#define P_WCH_WR_LEN_CHANNEL_31                    (volatile uint32_t *)0xfe4453f4
#define P_WCH_WR_LEN_CHANNEL_32                    (volatile uint32_t *)0xfe445414
#define P_WCH_WR_LEN_CHANNEL_33                    (volatile uint32_t *)0xfe445434
#define P_WCH_WR_LEN_CHANNEL_34                    (volatile uint32_t *)0xfe445454
#define P_WCH_WR_LEN_CHANNEL_35                    (volatile uint32_t *)0xfe445474
#define P_WCH_WR_LEN_CHANNEL_36                    (volatile uint32_t *)0xfe445494
#define P_WCH_WR_LEN_CHANNEL_37                    (volatile uint32_t *)0xfe4454b4
#define P_WCH_WR_LEN_CHANNEL_38                    (volatile uint32_t *)0xfe4454d4
#define P_WCH_WR_LEN_CHANNEL_39                    (volatile uint32_t *)0xfe4454f4
#define P_WCH_WR_LEN_CHANNEL_40                    (volatile uint32_t *)0xfe445514
#define P_WCH_WR_LEN_CHANNEL_41                    (volatile uint32_t *)0xfe445534
#define P_WCH_WR_LEN_CHANNEL_42                    (volatile uint32_t *)0xfe445554
#define P_WCH_WR_LEN_CHANNEL_43                    (volatile uint32_t *)0xfe445574
#define P_WCH_WR_LEN_CHANNEL_44                    (volatile uint32_t *)0xfe445594
#define P_WCH_WR_LEN_CHANNEL_45                    (volatile uint32_t *)0xfe4455b4
#define P_WCH_WR_LEN_CHANNEL_46                    (volatile uint32_t *)0xfe4455d4
#define P_WCH_WR_LEN_CHANNEL_47                    (volatile uint32_t *)0xfe4455f4
#define P_WCH_WR_LEN_CHANNEL_48                    (volatile uint32_t *)0xfe445614
#define P_WCH_WR_LEN_CHANNEL_49                    (volatile uint32_t *)0xfe445634
#define P_WCH_WR_LEN_CHANNEL_50                    (volatile uint32_t *)0xfe445654
#define P_WCH_WR_LEN_CHANNEL_51                    (volatile uint32_t *)0xfe445674
#define P_WCH_WR_LEN_CHANNEL_52                    (volatile uint32_t *)0xfe445694
#define P_WCH_WR_LEN_CHANNEL_53                    (volatile uint32_t *)0xfe4456b4
#define P_WCH_WR_LEN_CHANNEL_54                    (volatile uint32_t *)0xfe4456d4
#define P_WCH_WR_LEN_CHANNEL_55                    (volatile uint32_t *)0xfe4456f4
#define P_WCH_WR_LEN_CHANNEL_56                    (volatile uint32_t *)0xfe445714
#define P_WCH_WR_LEN_CHANNEL_57                    (volatile uint32_t *)0xfe445734
#define P_WCH_WR_LEN_CHANNEL_58                    (volatile uint32_t *)0xfe445754
#define P_WCH_WR_LEN_CHANNEL_59                    (volatile uint32_t *)0xfe445774
#define P_WCH_WR_LEN_CHANNEL_60                    (volatile uint32_t *)0xfe445794
#define P_WCH_WR_LEN_CHANNEL_61                    (volatile uint32_t *)0xfe4457b4
#define P_WCH_WR_LEN_CHANNEL_62                    (volatile uint32_t *)0xfe4457d4
#define P_WCH_WR_LEN_CHANNEL_63                    (volatile uint32_t *)0xfe4457f4
#define P_WCH_WR_LEN_CHANNEL_64                    (volatile uint32_t *)0xfe445814
#define P_WCH_WR_LEN_CHANNEL_65                    (volatile uint32_t *)0xfe445834
#define P_WCH_WR_LEN_CHANNEL_66                    (volatile uint32_t *)0xfe445854
#define P_WCH_WR_LEN_CHANNEL_67                    (volatile uint32_t *)0xfe445874
#define P_WCH_WR_LEN_CHANNEL_68                    (volatile uint32_t *)0xfe445894
#define P_WCH_WR_LEN_CHANNEL_69                    (volatile uint32_t *)0xfe4458b4
#define P_WCH_WR_LEN_CHANNEL_70                    (volatile uint32_t *)0xfe4458d4
#define P_WCH_WR_LEN_CHANNEL_71                    (volatile uint32_t *)0xfe4458f4
#define P_WCH_WR_LEN_CHANNEL_72                    (volatile uint32_t *)0xfe445914
#define P_WCH_WR_LEN_CHANNEL_73                    (volatile uint32_t *)0xfe445934
#define P_WCH_WR_LEN_CHANNEL_74                    (volatile uint32_t *)0xfe445954
#define P_WCH_WR_LEN_CHANNEL_75                    (volatile uint32_t *)0xfe445974
#define P_WCH_WR_LEN_CHANNEL_76                    (volatile uint32_t *)0xfe445994
#define P_WCH_WR_LEN_CHANNEL_77                    (volatile uint32_t *)0xfe4459b4
#define P_WCH_WR_LEN_CHANNEL_78                    (volatile uint32_t *)0xfe4459d4
#define P_WCH_WR_LEN_CHANNEL_79                    (volatile uint32_t *)0xfe4459f4
#define P_WCH_WR_LEN_CHANNEL_80                    (volatile uint32_t *)0xfe445a14
#define P_WCH_WR_LEN_CHANNEL_81                    (volatile uint32_t *)0xfe445a34
#define P_WCH_WR_LEN_CHANNEL_82                    (volatile uint32_t *)0xfe445a54
#define P_WCH_WR_LEN_CHANNEL_83                    (volatile uint32_t *)0xfe445a74
#define P_WCH_WR_LEN_CHANNEL_84                    (volatile uint32_t *)0xfe445a94
#define P_WCH_WR_LEN_CHANNEL_85                    (volatile uint32_t *)0xfe445ab4
#define P_WCH_WR_LEN_CHANNEL_86                    (volatile uint32_t *)0xfe445ad4
#define P_WCH_WR_LEN_CHANNEL_87                    (volatile uint32_t *)0xfe445af4
#define P_WCH_WR_LEN_CHANNEL_88                    (volatile uint32_t *)0xfe445b14
#define P_WCH_WR_LEN_CHANNEL_89                    (volatile uint32_t *)0xfe445b34
#define P_WCH_WR_LEN_CHANNEL_90                    (volatile uint32_t *)0xfe445b54
#define P_WCH_WR_LEN_CHANNEL_91                    (volatile uint32_t *)0xfe445b74
#define P_WCH_WR_LEN_CHANNEL_92                    (volatile uint32_t *)0xfe445b94
#define P_WCH_WR_LEN_CHANNEL_93                    (volatile uint32_t *)0xfe445bb4
#define P_WCH_WR_LEN_CHANNEL_94                    (volatile uint32_t *)0xfe445bd4
#define P_WCH_WR_LEN_CHANNEL_95                    (volatile uint32_t *)0xfe445bf4
#define P_WCH_WR_LEN_CHANNEL_96                    (volatile uint32_t *)0xfe445c14
#define P_WCH_WR_LEN_CHANNEL_97                    (volatile uint32_t *)0xfe445c34
#define P_WCH_WR_LEN_CHANNEL_98                    (volatile uint32_t *)0xfe445c54
#define P_WCH_WR_LEN_CHANNEL_99                    (volatile uint32_t *)0xfe445c74
#define P_WCH_WR_LEN_CHANNEL_100                   (volatile uint32_t *)0xfe445c94
#define P_WCH_WR_LEN_CHANNEL_101                   (volatile uint32_t *)0xfe445cb4
#define P_WCH_WR_LEN_CHANNEL_102                   (volatile uint32_t *)0xfe445cd4
#define P_WCH_WR_LEN_CHANNEL_103                   (volatile uint32_t *)0xfe445cf4
#define P_WCH_WR_LEN_CHANNEL_104                   (volatile uint32_t *)0xfe445d14
#define P_WCH_WR_LEN_CHANNEL_105                   (volatile uint32_t *)0xfe445d34
#define P_WCH_WR_LEN_CHANNEL_106                   (volatile uint32_t *)0xfe445d54
#define P_WCH_WR_LEN_CHANNEL_107                   (volatile uint32_t *)0xfe445d74
#define P_WCH_WR_LEN_CHANNEL_108                   (volatile uint32_t *)0xfe445d94
#define P_WCH_WR_LEN_CHANNEL_109                   (volatile uint32_t *)0xfe445db4
#define P_WCH_WR_LEN_CHANNEL_110                   (volatile uint32_t *)0xfe445dd4
#define P_WCH_WR_LEN_CHANNEL_111                   (volatile uint32_t *)0xfe445df4
#define P_WCH_WR_LEN_CHANNEL_112                   (volatile uint32_t *)0xfe445e14
#define P_WCH_WR_LEN_CHANNEL_113                   (volatile uint32_t *)0xfe445e34
#define P_WCH_WR_LEN_CHANNEL_114                   (volatile uint32_t *)0xfe445e54
#define P_WCH_WR_LEN_CHANNEL_115                   (volatile uint32_t *)0xfe445e74
#define P_WCH_WR_LEN_CHANNEL_116                   (volatile uint32_t *)0xfe445e94
#define P_WCH_WR_LEN_CHANNEL_117                   (volatile uint32_t *)0xfe445eb4
#define P_WCH_WR_LEN_CHANNEL_118                   (volatile uint32_t *)0xfe445ed4
#define P_WCH_WR_LEN_CHANNEL_119                   (volatile uint32_t *)0xfe445ef4
#define P_WCH_WR_LEN_CHANNEL_120                   (volatile uint32_t *)0xfe445f14
#define P_WCH_WR_LEN_CHANNEL_121                   (volatile uint32_t *)0xfe445f34
#define P_WCH_WR_LEN_CHANNEL_122                   (volatile uint32_t *)0xfe445f54
#define P_WCH_WR_LEN_CHANNEL_123                   (volatile uint32_t *)0xfe445f74
#define P_WCH_WR_LEN_CHANNEL_124                   (volatile uint32_t *)0xfe445f94
#define P_WCH_WR_LEN_CHANNEL_125                   (volatile uint32_t *)0xfe445fb4
#define P_WCH_WR_LEN_CHANNEL_126                   (volatile uint32_t *)0xfe445fd4
#define P_WCH_WR_LEN_CHANNEL_127                   (volatile uint32_t *)0xfe445ff4
#define P_WCH_PTR_CHANNEL_0                        (volatile uint32_t *)0xfe445018
#define P_WCH_PTR_CHANNEL_1                        (volatile uint32_t *)0xfe445038
#define P_WCH_PTR_CHANNEL_2                        (volatile uint32_t *)0xfe445058
#define P_WCH_PTR_CHANNEL_3                        (volatile uint32_t *)0xfe445078
#define P_WCH_PTR_CHANNEL_4                        (volatile uint32_t *)0xfe445098
#define P_WCH_PTR_CHANNEL_5                        (volatile uint32_t *)0xfe4450b8
#define P_WCH_PTR_CHANNEL_6                        (volatile uint32_t *)0xfe4450d8
#define P_WCH_PTR_CHANNEL_7                        (volatile uint32_t *)0xfe4450f8
#define P_WCH_PTR_CHANNEL_8                        (volatile uint32_t *)0xfe445118
#define P_WCH_PTR_CHANNEL_9                        (volatile uint32_t *)0xfe445138
#define P_WCH_PTR_CHANNEL_10                       (volatile uint32_t *)0xfe445158
#define P_WCH_PTR_CHANNEL_11                       (volatile uint32_t *)0xfe445178
#define P_WCH_PTR_CHANNEL_12                       (volatile uint32_t *)0xfe445198
#define P_WCH_PTR_CHANNEL_13                       (volatile uint32_t *)0xfe4451b8
#define P_WCH_PTR_CHANNEL_14                       (volatile uint32_t *)0xfe4451d8
#define P_WCH_PTR_CHANNEL_15                       (volatile uint32_t *)0xfe4451f8
#define P_WCH_PTR_CHANNEL_16                       (volatile uint32_t *)0xfe445218
#define P_WCH_PTR_CHANNEL_17                       (volatile uint32_t *)0xfe445238
#define P_WCH_PTR_CHANNEL_18                       (volatile uint32_t *)0xfe445258
#define P_WCH_PTR_CHANNEL_19                       (volatile uint32_t *)0xfe445278
#define P_WCH_PTR_CHANNEL_20                       (volatile uint32_t *)0xfe445298
#define P_WCH_PTR_CHANNEL_21                       (volatile uint32_t *)0xfe4452b8
#define P_WCH_PTR_CHANNEL_22                       (volatile uint32_t *)0xfe4452d8
#define P_WCH_PTR_CHANNEL_23                       (volatile uint32_t *)0xfe4452f8
#define P_WCH_PTR_CHANNEL_24                       (volatile uint32_t *)0xfe445318
#define P_WCH_PTR_CHANNEL_25                       (volatile uint32_t *)0xfe445338
#define P_WCH_PTR_CHANNEL_26                       (volatile uint32_t *)0xfe445358
#define P_WCH_PTR_CHANNEL_27                       (volatile uint32_t *)0xfe445378
#define P_WCH_PTR_CHANNEL_28                       (volatile uint32_t *)0xfe445398
#define P_WCH_PTR_CHANNEL_29                       (volatile uint32_t *)0xfe4453b8
#define P_WCH_PTR_CHANNEL_30                       (volatile uint32_t *)0xfe4453d8
#define P_WCH_PTR_CHANNEL_31                       (volatile uint32_t *)0xfe4453f8
#define P_WCH_PTR_CHANNEL_32                       (volatile uint32_t *)0xfe445418
#define P_WCH_PTR_CHANNEL_33                       (volatile uint32_t *)0xfe445438
#define P_WCH_PTR_CHANNEL_34                       (volatile uint32_t *)0xfe445458
#define P_WCH_PTR_CHANNEL_35                       (volatile uint32_t *)0xfe445478
#define P_WCH_PTR_CHANNEL_36                       (volatile uint32_t *)0xfe445498
#define P_WCH_PTR_CHANNEL_37                       (volatile uint32_t *)0xfe4454b8
#define P_WCH_PTR_CHANNEL_38                       (volatile uint32_t *)0xfe4454d8
#define P_WCH_PTR_CHANNEL_39                       (volatile uint32_t *)0xfe4454f8
#define P_WCH_PTR_CHANNEL_40                       (volatile uint32_t *)0xfe445518
#define P_WCH_PTR_CHANNEL_41                       (volatile uint32_t *)0xfe445538
#define P_WCH_PTR_CHANNEL_42                       (volatile uint32_t *)0xfe445558
#define P_WCH_PTR_CHANNEL_43                       (volatile uint32_t *)0xfe445578
#define P_WCH_PTR_CHANNEL_44                       (volatile uint32_t *)0xfe445598
#define P_WCH_PTR_CHANNEL_45                       (volatile uint32_t *)0xfe4455b8
#define P_WCH_PTR_CHANNEL_46                       (volatile uint32_t *)0xfe4455d8
#define P_WCH_PTR_CHANNEL_47                       (volatile uint32_t *)0xfe4455f8
#define P_WCH_PTR_CHANNEL_48                       (volatile uint32_t *)0xfe445618
#define P_WCH_PTR_CHANNEL_49                       (volatile uint32_t *)0xfe445638
#define P_WCH_PTR_CHANNEL_50                       (volatile uint32_t *)0xfe445658
#define P_WCH_PTR_CHANNEL_51                       (volatile uint32_t *)0xfe445678
#define P_WCH_PTR_CHANNEL_52                       (volatile uint32_t *)0xfe445698
#define P_WCH_PTR_CHANNEL_53                       (volatile uint32_t *)0xfe4456b8
#define P_WCH_PTR_CHANNEL_54                       (volatile uint32_t *)0xfe4456d8
#define P_WCH_PTR_CHANNEL_55                       (volatile uint32_t *)0xfe4456f8
#define P_WCH_PTR_CHANNEL_56                       (volatile uint32_t *)0xfe445718
#define P_WCH_PTR_CHANNEL_57                       (volatile uint32_t *)0xfe445738
#define P_WCH_PTR_CHANNEL_58                       (volatile uint32_t *)0xfe445758
#define P_WCH_PTR_CHANNEL_59                       (volatile uint32_t *)0xfe445778
#define P_WCH_PTR_CHANNEL_60                       (volatile uint32_t *)0xfe445798
#define P_WCH_PTR_CHANNEL_61                       (volatile uint32_t *)0xfe4457b8
#define P_WCH_PTR_CHANNEL_62                       (volatile uint32_t *)0xfe4457d8
#define P_WCH_PTR_CHANNEL_63                       (volatile uint32_t *)0xfe4457f8
#define P_WCH_PTR_CHANNEL_64                       (volatile uint32_t *)0xfe445818
#define P_WCH_PTR_CHANNEL_65                       (volatile uint32_t *)0xfe445838
#define P_WCH_PTR_CHANNEL_66                       (volatile uint32_t *)0xfe445858
#define P_WCH_PTR_CHANNEL_67                       (volatile uint32_t *)0xfe445878
#define P_WCH_PTR_CHANNEL_68                       (volatile uint32_t *)0xfe445898
#define P_WCH_PTR_CHANNEL_69                       (volatile uint32_t *)0xfe4458b8
#define P_WCH_PTR_CHANNEL_70                       (volatile uint32_t *)0xfe4458d8
#define P_WCH_PTR_CHANNEL_71                       (volatile uint32_t *)0xfe4458f8
#define P_WCH_PTR_CHANNEL_72                       (volatile uint32_t *)0xfe445918
#define P_WCH_PTR_CHANNEL_73                       (volatile uint32_t *)0xfe445938
#define P_WCH_PTR_CHANNEL_74                       (volatile uint32_t *)0xfe445958
#define P_WCH_PTR_CHANNEL_75                       (volatile uint32_t *)0xfe445978
#define P_WCH_PTR_CHANNEL_76                       (volatile uint32_t *)0xfe445998
#define P_WCH_PTR_CHANNEL_77                       (volatile uint32_t *)0xfe4459b8
#define P_WCH_PTR_CHANNEL_78                       (volatile uint32_t *)0xfe4459d8
#define P_WCH_PTR_CHANNEL_79                       (volatile uint32_t *)0xfe4459f8
#define P_WCH_PTR_CHANNEL_80                       (volatile uint32_t *)0xfe445a18
#define P_WCH_PTR_CHANNEL_81                       (volatile uint32_t *)0xfe445a38
#define P_WCH_PTR_CHANNEL_82                       (volatile uint32_t *)0xfe445a58
#define P_WCH_PTR_CHANNEL_83                       (volatile uint32_t *)0xfe445a78
#define P_WCH_PTR_CHANNEL_84                       (volatile uint32_t *)0xfe445a98
#define P_WCH_PTR_CHANNEL_85                       (volatile uint32_t *)0xfe445ab8
#define P_WCH_PTR_CHANNEL_86                       (volatile uint32_t *)0xfe445ad8
#define P_WCH_PTR_CHANNEL_87                       (volatile uint32_t *)0xfe445af8
#define P_WCH_PTR_CHANNEL_88                       (volatile uint32_t *)0xfe445b18
#define P_WCH_PTR_CHANNEL_89                       (volatile uint32_t *)0xfe445b38
#define P_WCH_PTR_CHANNEL_90                       (volatile uint32_t *)0xfe445b58
#define P_WCH_PTR_CHANNEL_91                       (volatile uint32_t *)0xfe445b78
#define P_WCH_PTR_CHANNEL_92                       (volatile uint32_t *)0xfe445b98
#define P_WCH_PTR_CHANNEL_93                       (volatile uint32_t *)0xfe445bb8
#define P_WCH_PTR_CHANNEL_94                       (volatile uint32_t *)0xfe445bd8
#define P_WCH_PTR_CHANNEL_95                       (volatile uint32_t *)0xfe445bf8
#define P_WCH_PTR_CHANNEL_96                       (volatile uint32_t *)0xfe445c18
#define P_WCH_PTR_CHANNEL_97                       (volatile uint32_t *)0xfe445c38
#define P_WCH_PTR_CHANNEL_98                       (volatile uint32_t *)0xfe445c58
#define P_WCH_PTR_CHANNEL_99                       (volatile uint32_t *)0xfe445c78
#define P_WCH_PTR_CHANNEL_100                      (volatile uint32_t *)0xfe445c98
#define P_WCH_PTR_CHANNEL_101                      (volatile uint32_t *)0xfe445cb8
#define P_WCH_PTR_CHANNEL_102                      (volatile uint32_t *)0xfe445cd8
#define P_WCH_PTR_CHANNEL_103                      (volatile uint32_t *)0xfe445cf8
#define P_WCH_PTR_CHANNEL_104                      (volatile uint32_t *)0xfe445d18
#define P_WCH_PTR_CHANNEL_105                      (volatile uint32_t *)0xfe445d38
#define P_WCH_PTR_CHANNEL_106                      (volatile uint32_t *)0xfe445d58
#define P_WCH_PTR_CHANNEL_107                      (volatile uint32_t *)0xfe445d78
#define P_WCH_PTR_CHANNEL_108                      (volatile uint32_t *)0xfe445d98
#define P_WCH_PTR_CHANNEL_109                      (volatile uint32_t *)0xfe445db8
#define P_WCH_PTR_CHANNEL_110                      (volatile uint32_t *)0xfe445dd8
#define P_WCH_PTR_CHANNEL_111                      (volatile uint32_t *)0xfe445df8
#define P_WCH_PTR_CHANNEL_112                      (volatile uint32_t *)0xfe445e18
#define P_WCH_PTR_CHANNEL_113                      (volatile uint32_t *)0xfe445e38
#define P_WCH_PTR_CHANNEL_114                      (volatile uint32_t *)0xfe445e58
#define P_WCH_PTR_CHANNEL_115                      (volatile uint32_t *)0xfe445e78
#define P_WCH_PTR_CHANNEL_116                      (volatile uint32_t *)0xfe445e98
#define P_WCH_PTR_CHANNEL_117                      (volatile uint32_t *)0xfe445eb8
#define P_WCH_PTR_CHANNEL_118                      (volatile uint32_t *)0xfe445ed8
#define P_WCH_PTR_CHANNEL_119                      (volatile uint32_t *)0xfe445ef8
#define P_WCH_PTR_CHANNEL_120                      (volatile uint32_t *)0xfe445f18
#define P_WCH_PTR_CHANNEL_121                      (volatile uint32_t *)0xfe445f38
#define P_WCH_PTR_CHANNEL_122                      (volatile uint32_t *)0xfe445f58
#define P_WCH_PTR_CHANNEL_123                      (volatile uint32_t *)0xfe445f78
#define P_WCH_PTR_CHANNEL_124                      (volatile uint32_t *)0xfe445f98
#define P_WCH_PTR_CHANNEL_125                      (volatile uint32_t *)0xfe445fb8
#define P_WCH_PTR_CHANNEL_126                      (volatile uint32_t *)0xfe445fd8
#define P_WCH_PTR_CHANNEL_127                      (volatile uint32_t *)0xfe445ff8
#define P_WCMD_CNT_CHANNEL_0                       (volatile uint32_t *)0xfe44501c
#define P_WCMD_CNT_CHANNEL_1                       (volatile uint32_t *)0xfe44503c
#define P_WCMD_CNT_CHANNEL_2                       (volatile uint32_t *)0xfe44505c
#define P_WCMD_CNT_CHANNEL_3                       (volatile uint32_t *)0xfe44507c
#define P_WCMD_CNT_CHANNEL_4                       (volatile uint32_t *)0xfe44509c
#define P_WCMD_CNT_CHANNEL_5                       (volatile uint32_t *)0xfe4450bc
#define P_WCMD_CNT_CHANNEL_6                       (volatile uint32_t *)0xfe4450dc
#define P_WCMD_CNT_CHANNEL_7                       (volatile uint32_t *)0xfe4450fc
#define P_WCMD_CNT_CHANNEL_8                       (volatile uint32_t *)0xfe44511c
#define P_WCMD_CNT_CHANNEL_9                       (volatile uint32_t *)0xfe44513c
#define P_WCMD_CNT_CHANNEL_10                      (volatile uint32_t *)0xfe44515c
#define P_WCMD_CNT_CHANNEL_11                      (volatile uint32_t *)0xfe44517c
#define P_WCMD_CNT_CHANNEL_12                      (volatile uint32_t *)0xfe44519c
#define P_WCMD_CNT_CHANNEL_13                      (volatile uint32_t *)0xfe4451bc
#define P_WCMD_CNT_CHANNEL_14                      (volatile uint32_t *)0xfe4451dc
#define P_WCMD_CNT_CHANNEL_15                      (volatile uint32_t *)0xfe4451fc
#define P_WCMD_CNT_CHANNEL_16                      (volatile uint32_t *)0xfe44521c
#define P_WCMD_CNT_CHANNEL_17                      (volatile uint32_t *)0xfe44523c
#define P_WCMD_CNT_CHANNEL_18                      (volatile uint32_t *)0xfe44525c
#define P_WCMD_CNT_CHANNEL_19                      (volatile uint32_t *)0xfe44527c
#define P_WCMD_CNT_CHANNEL_20                      (volatile uint32_t *)0xfe44529c
#define P_WCMD_CNT_CHANNEL_21                      (volatile uint32_t *)0xfe4452bc
#define P_WCMD_CNT_CHANNEL_22                      (volatile uint32_t *)0xfe4452dc
#define P_WCMD_CNT_CHANNEL_23                      (volatile uint32_t *)0xfe4452fc
#define P_WCMD_CNT_CHANNEL_24                      (volatile uint32_t *)0xfe44531c
#define P_WCMD_CNT_CHANNEL_25                      (volatile uint32_t *)0xfe44533c
#define P_WCMD_CNT_CHANNEL_26                      (volatile uint32_t *)0xfe44535c
#define P_WCMD_CNT_CHANNEL_27                      (volatile uint32_t *)0xfe44537c
#define P_WCMD_CNT_CHANNEL_28                      (volatile uint32_t *)0xfe44539c
#define P_WCMD_CNT_CHANNEL_29                      (volatile uint32_t *)0xfe4453bc
#define P_WCMD_CNT_CHANNEL_30                      (volatile uint32_t *)0xfe4453dc
#define P_WCMD_CNT_CHANNEL_31                      (volatile uint32_t *)0xfe4453fc
#define P_WCMD_CNT_CHANNEL_32                      (volatile uint32_t *)0xfe44541c
#define P_WCMD_CNT_CHANNEL_33                      (volatile uint32_t *)0xfe44543c
#define P_WCMD_CNT_CHANNEL_34                      (volatile uint32_t *)0xfe44545c
#define P_WCMD_CNT_CHANNEL_35                      (volatile uint32_t *)0xfe44547c
#define P_WCMD_CNT_CHANNEL_36                      (volatile uint32_t *)0xfe44549c
#define P_WCMD_CNT_CHANNEL_37                      (volatile uint32_t *)0xfe4454bc
#define P_WCMD_CNT_CHANNEL_38                      (volatile uint32_t *)0xfe4454dc
#define P_WCMD_CNT_CHANNEL_39                      (volatile uint32_t *)0xfe4454fc
#define P_WCMD_CNT_CHANNEL_40                      (volatile uint32_t *)0xfe44551c
#define P_WCMD_CNT_CHANNEL_41                      (volatile uint32_t *)0xfe44553c
#define P_WCMD_CNT_CHANNEL_42                      (volatile uint32_t *)0xfe44555c
#define P_WCMD_CNT_CHANNEL_43                      (volatile uint32_t *)0xfe44557c
#define P_WCMD_CNT_CHANNEL_44                      (volatile uint32_t *)0xfe44559c
#define P_WCMD_CNT_CHANNEL_45                      (volatile uint32_t *)0xfe4455bc
#define P_WCMD_CNT_CHANNEL_46                      (volatile uint32_t *)0xfe4455dc
#define P_WCMD_CNT_CHANNEL_47                      (volatile uint32_t *)0xfe4455fc
#define P_WCMD_CNT_CHANNEL_48                      (volatile uint32_t *)0xfe44561c
#define P_WCMD_CNT_CHANNEL_49                      (volatile uint32_t *)0xfe44563c
#define P_WCMD_CNT_CHANNEL_50                      (volatile uint32_t *)0xfe44565c
#define P_WCMD_CNT_CHANNEL_51                      (volatile uint32_t *)0xfe44567c
#define P_WCMD_CNT_CHANNEL_52                      (volatile uint32_t *)0xfe44569c
#define P_WCMD_CNT_CHANNEL_53                      (volatile uint32_t *)0xfe4456bc
#define P_WCMD_CNT_CHANNEL_54                      (volatile uint32_t *)0xfe4456dc
#define P_WCMD_CNT_CHANNEL_55                      (volatile uint32_t *)0xfe4456fc
#define P_WCMD_CNT_CHANNEL_56                      (volatile uint32_t *)0xfe44571c
#define P_WCMD_CNT_CHANNEL_57                      (volatile uint32_t *)0xfe44573c
#define P_WCMD_CNT_CHANNEL_58                      (volatile uint32_t *)0xfe44575c
#define P_WCMD_CNT_CHANNEL_59                      (volatile uint32_t *)0xfe44577c
#define P_WCMD_CNT_CHANNEL_60                      (volatile uint32_t *)0xfe44579c
#define P_WCMD_CNT_CHANNEL_61                      (volatile uint32_t *)0xfe4457bc
#define P_WCMD_CNT_CHANNEL_62                      (volatile uint32_t *)0xfe4457dc
#define P_WCMD_CNT_CHANNEL_63                      (volatile uint32_t *)0xfe4457fc
#define P_WCMD_CNT_CHANNEL_64                      (volatile uint32_t *)0xfe44581c
#define P_WCMD_CNT_CHANNEL_65                      (volatile uint32_t *)0xfe44583c
#define P_WCMD_CNT_CHANNEL_66                      (volatile uint32_t *)0xfe44585c
#define P_WCMD_CNT_CHANNEL_67                      (volatile uint32_t *)0xfe44587c
#define P_WCMD_CNT_CHANNEL_68                      (volatile uint32_t *)0xfe44589c
#define P_WCMD_CNT_CHANNEL_69                      (volatile uint32_t *)0xfe4458bc
#define P_WCMD_CNT_CHANNEL_70                      (volatile uint32_t *)0xfe4458dc
#define P_WCMD_CNT_CHANNEL_71                      (volatile uint32_t *)0xfe4458fc
#define P_WCMD_CNT_CHANNEL_72                      (volatile uint32_t *)0xfe44591c
#define P_WCMD_CNT_CHANNEL_73                      (volatile uint32_t *)0xfe44593c
#define P_WCMD_CNT_CHANNEL_74                      (volatile uint32_t *)0xfe44595c
#define P_WCMD_CNT_CHANNEL_75                      (volatile uint32_t *)0xfe44597c
#define P_WCMD_CNT_CHANNEL_76                      (volatile uint32_t *)0xfe44599c
#define P_WCMD_CNT_CHANNEL_77                      (volatile uint32_t *)0xfe4459bc
#define P_WCMD_CNT_CHANNEL_78                      (volatile uint32_t *)0xfe4459dc
#define P_WCMD_CNT_CHANNEL_79                      (volatile uint32_t *)0xfe4459fc
#define P_WCMD_CNT_CHANNEL_80                      (volatile uint32_t *)0xfe445a1c
#define P_WCMD_CNT_CHANNEL_81                      (volatile uint32_t *)0xfe445a3c
#define P_WCMD_CNT_CHANNEL_82                      (volatile uint32_t *)0xfe445a5c
#define P_WCMD_CNT_CHANNEL_83                      (volatile uint32_t *)0xfe445a7c
#define P_WCMD_CNT_CHANNEL_84                      (volatile uint32_t *)0xfe445a9c
#define P_WCMD_CNT_CHANNEL_85                      (volatile uint32_t *)0xfe445abc
#define P_WCMD_CNT_CHANNEL_86                      (volatile uint32_t *)0xfe445adc
#define P_WCMD_CNT_CHANNEL_87                      (volatile uint32_t *)0xfe445afc
#define P_WCMD_CNT_CHANNEL_88                      (volatile uint32_t *)0xfe445b1c
#define P_WCMD_CNT_CHANNEL_89                      (volatile uint32_t *)0xfe445b3c
#define P_WCMD_CNT_CHANNEL_90                      (volatile uint32_t *)0xfe445b5c
#define P_WCMD_CNT_CHANNEL_91                      (volatile uint32_t *)0xfe445b7c
#define P_WCMD_CNT_CHANNEL_92                      (volatile uint32_t *)0xfe445b9c
#define P_WCMD_CNT_CHANNEL_93                      (volatile uint32_t *)0xfe445bbc
#define P_WCMD_CNT_CHANNEL_94                      (volatile uint32_t *)0xfe445bdc
#define P_WCMD_CNT_CHANNEL_95                      (volatile uint32_t *)0xfe445bfc
#define P_WCMD_CNT_CHANNEL_96                      (volatile uint32_t *)0xfe445c1c
#define P_WCMD_CNT_CHANNEL_97                      (volatile uint32_t *)0xfe445c3c
#define P_WCMD_CNT_CHANNEL_98                      (volatile uint32_t *)0xfe445c5c
#define P_WCMD_CNT_CHANNEL_99                      (volatile uint32_t *)0xfe445c7c
#define P_WCMD_CNT_CHANNEL_100                     (volatile uint32_t *)0xfe445c9c
#define P_WCMD_CNT_CHANNEL_101                     (volatile uint32_t *)0xfe445cbc
#define P_WCMD_CNT_CHANNEL_102                     (volatile uint32_t *)0xfe445cdc
#define P_WCMD_CNT_CHANNEL_103                     (volatile uint32_t *)0xfe445cfc
#define P_WCMD_CNT_CHANNEL_104                     (volatile uint32_t *)0xfe445d1c
#define P_WCMD_CNT_CHANNEL_105                     (volatile uint32_t *)0xfe445d3c
#define P_WCMD_CNT_CHANNEL_106                     (volatile uint32_t *)0xfe445d5c
#define P_WCMD_CNT_CHANNEL_107                     (volatile uint32_t *)0xfe445d7c
#define P_WCMD_CNT_CHANNEL_108                     (volatile uint32_t *)0xfe445d9c
#define P_WCMD_CNT_CHANNEL_109                     (volatile uint32_t *)0xfe445dbc
#define P_WCMD_CNT_CHANNEL_110                     (volatile uint32_t *)0xfe445ddc
#define P_WCMD_CNT_CHANNEL_111                     (volatile uint32_t *)0xfe445dfc
#define P_WCMD_CNT_CHANNEL_112                     (volatile uint32_t *)0xfe445e1c
#define P_WCMD_CNT_CHANNEL_113                     (volatile uint32_t *)0xfe445e3c
#define P_WCMD_CNT_CHANNEL_114                     (volatile uint32_t *)0xfe445e5c
#define P_WCMD_CNT_CHANNEL_115                     (volatile uint32_t *)0xfe445e7c
#define P_WCMD_CNT_CHANNEL_116                     (volatile uint32_t *)0xfe445e9c
#define P_WCMD_CNT_CHANNEL_117                     (volatile uint32_t *)0xfe445ebc
#define P_WCMD_CNT_CHANNEL_118                     (volatile uint32_t *)0xfe445edc
#define P_WCMD_CNT_CHANNEL_119                     (volatile uint32_t *)0xfe445efc
#define P_WCMD_CNT_CHANNEL_120                     (volatile uint32_t *)0xfe445f1c
#define P_WCMD_CNT_CHANNEL_121                     (volatile uint32_t *)0xfe445f3c
#define P_WCMD_CNT_CHANNEL_122                     (volatile uint32_t *)0xfe445f5c
#define P_WCMD_CNT_CHANNEL_123                     (volatile uint32_t *)0xfe445f7c
#define P_WCMD_CNT_CHANNEL_124                     (volatile uint32_t *)0xfe445f9c
#define P_WCMD_CNT_CHANNEL_125                     (volatile uint32_t *)0xfe445fbc
#define P_WCMD_CNT_CHANNEL_126                     (volatile uint32_t *)0xfe445fdc
#define P_WCMD_CNT_CHANNEL_127                     (volatile uint32_t *)0xfe445ffc
#define P_DMX_RDMA_INT_MASK                        (volatile uint32_t *)0xfe446000
#define P_DMX_WDMA_INT_MASK_0                      (volatile uint32_t *)0xfe446004
#define P_DMX_WDMA_INT_MASK_1                      (volatile uint32_t *)0xfe446008
#define P_DMX_WDMA_INT_MASK_2                      (volatile uint32_t *)0xfe44600c
#define P_DMX_WDMA_INT_MASK_3                      (volatile uint32_t *)0xfe446010
#define P_DMX_CLEAN_W_BATCH_0                      (volatile uint32_t *)0xfe446014
#define P_DMX_CLEAN_W_BATCH_1                      (volatile uint32_t *)0xfe446018
#define P_DMX_CLEAN_W_BATCH_2                      (volatile uint32_t *)0xfe44601c
#define P_DMX_CLEAN_W_BATCH_3                      (volatile uint32_t *)0xfe446020
#define P_DMX_CLEAN_RDMA                           (volatile uint32_t *)0xfe446024
#define P_DMX_CLEAN_WDMA_0                         (volatile uint32_t *)0xfe446028
#define P_DMX_CLEAN_WDMA_1                         (volatile uint32_t *)0xfe44602c
#define P_DMX_CLEAN_WDMA_2                         (volatile uint32_t *)0xfe446030
#define P_DMX_CLEAN_WDMA_3                         (volatile uint32_t *)0xfe446034
#define P_DMX_RDMA_ACTIVE                          (volatile uint32_t *)0xfe446038
#define P_DMX_WDMA_ACTIVE_0                        (volatile uint32_t *)0xfe44603c
#define P_DMX_WDMA_ACTIVE_1                        (volatile uint32_t *)0xfe446040
#define P_DMX_WDMA_ACTIVE_2                        (volatile uint32_t *)0xfe446044
#define P_DMX_WDMA_ACTIVE_3                        (volatile uint32_t *)0xfe446048
#define P_DMX_DMA_RDONE                            (volatile uint32_t *)0xfe44604c
#define P_DMX_DMA_WDONE_0                          (volatile uint32_t *)0xfe446050
#define P_DMX_DMA_WDONE_1                          (volatile uint32_t *)0xfe446054
#define P_DMX_DMA_WDONE_2                          (volatile uint32_t *)0xfe446058
#define P_DMX_DMA_WDONE_3                          (volatile uint32_t *)0xfe44605c
#define P_DMX_RDES_ERR                             (volatile uint32_t *)0xfe446060
#define P_DMX_RDES_LEN_ERR                         (volatile uint32_t *)0xfe446064
#define P_DMX_WDES_ERR_0                           (volatile uint32_t *)0xfe446068
#define P_DMX_WDES_ERR_1                           (volatile uint32_t *)0xfe44606c
#define P_DMX_WDES_ERR_2                           (volatile uint32_t *)0xfe446070
#define P_DMX_WDES_ERR_3                           (volatile uint32_t *)0xfe446074
#define P_DMX_DMA_BATCH_END_0                      (volatile uint32_t *)0xfe446078
#define P_DMX_DMA_BATCH_END_1                      (volatile uint32_t *)0xfe44607c
#define P_DMX_DMA_BATCH_END_2                      (volatile uint32_t *)0xfe446080
#define P_DMX_DMA_BATCH_END_3                      (volatile uint32_t *)0xfe446084
#define P_DMX_WDES_EOC_DONE_0                      (volatile uint32_t *)0xfe446088
#define P_DMX_WDES_EOC_DONE_1                      (volatile uint32_t *)0xfe44608c
#define P_DMX_WDES_EOC_DONE_2                      (volatile uint32_t *)0xfe446090
#define P_DMX_WDES_EOC_DONE_3                      (volatile uint32_t *)0xfe446094
#define P_DMX_WCH_RESP_ERR0                        (volatile uint32_t *)0xfe446098
#define P_DMX_WCH_RESP_ERR1                        (volatile uint32_t *)0xfe44609c
#define P_DMX_WCH_RESP_ERR2                        (volatile uint32_t *)0xfe4460a0
#define P_DMX_WCH_RESP_ERR3                        (volatile uint32_t *)0xfe4460a4
#define P_DMX_UPDT_PKT_SYNC                        (volatile uint32_t *)0xfe4460c0
#define P_DMX_RCHN_CFG                             (volatile uint32_t *)0xfe4460c4
#define P_DMX_WCHN_CFG                             (volatile uint32_t *)0xfe4460c8
#define P_DMX_MEM_PD_CRTL                          (volatile uint32_t *)0xfe4460cc
#define P_DMX_DMA_BUS_CFG                          (volatile uint32_t *)0xfe4460d0
#define P_DMX_DMA_GMW_CFG                          (volatile uint32_t *)0xfe4460d4
#define P_DMX_DMA_GMR_CFG                          (volatile uint32_t *)0xfe4460d8
//========================================================================
//  TS OUTPUT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442c00
// -----------------------------------------------
#define P_TS_OUTPUT_PID_RDY                        (volatile uint32_t *)0xfe442c00
#define P_TS_OUTPUT_TEE_LOCK                       (volatile uint32_t *)0xfe442c04
#define P_TS_OUTPUT_PID_CFG                        (volatile uint32_t *)0xfe442c08
#define P_TS_OUTPUT_PID_DAT                        (volatile uint32_t *)0xfe442c0c
#define P_TS_OUTPUT_OUT_CFG                        (volatile uint32_t *)0xfe442c10
#define P_TS_OUTPUT_PCR_TAB_ENTRY_0                (volatile uint32_t *)0xfe442c40
#define P_TS_OUTPUT_PCR_TAB_ENTRY_1                (volatile uint32_t *)0xfe442c44
#define P_TS_OUTPUT_PCR_TAB_ENTRY_2                (volatile uint32_t *)0xfe442c48
#define P_TS_OUTPUT_PCR_TAB_ENTRY_3                (volatile uint32_t *)0xfe442c4c
#define P_TS_OUTPUT_PCR_TAB_ENTRY_4                (volatile uint32_t *)0xfe442c50
#define P_TS_OUTPUT_PCR_TAB_ENTRY_5                (volatile uint32_t *)0xfe442c54
#define P_TS_OUTPUT_PCR_TAB_ENTRY_6                (volatile uint32_t *)0xfe442c58
#define P_TS_OUTPUT_PCR_TAB_ENTRY_7                (volatile uint32_t *)0xfe442c5c
#define P_TS_OUTPUT_PCR_TAB_ENTRY_8                (volatile uint32_t *)0xfe442c60
#define P_TS_OUTPUT_PCR_TAB_ENTRY_9                (volatile uint32_t *)0xfe442c64
#define P_TS_OUTPUT_PCR_TAB_ENTRY_10               (volatile uint32_t *)0xfe442c68
#define P_TS_OUTPUT_PCR_TAB_ENTRY_11               (volatile uint32_t *)0xfe442c6c
#define P_TS_OUTPUT_PCR_TAB_ENTRY_12               (volatile uint32_t *)0xfe442c70
#define P_TS_OUTPUT_PCR_TAB_ENTRY_13               (volatile uint32_t *)0xfe442c74
#define P_TS_OUTPUT_PCR_TAB_ENTRY_14               (volatile uint32_t *)0xfe442c78
#define P_TS_OUTPUT_PCR_TAB_ENTRY_15               (volatile uint32_t *)0xfe442c7c
#define P_TS_OUTPUT_SID_TAB_0_1                    (volatile uint32_t *)0xfe442c80
#define P_TS_OUTPUT_SID_TAB_2_3                    (volatile uint32_t *)0xfe442c84
#define P_TS_OUTPUT_SID_TAB_4_5                    (volatile uint32_t *)0xfe442c88
#define P_TS_OUTPUT_SID_TAB_6_7                    (volatile uint32_t *)0xfe442c8c
#define P_TS_OUTPUT_SID_TAB_8_9                    (volatile uint32_t *)0xfe442c90
#define P_TS_OUTPUT_SID_TAB_10_11                  (volatile uint32_t *)0xfe442c94
#define P_TS_OUTPUT_SID_TAB_12_13                  (volatile uint32_t *)0xfe442c98
#define P_TS_OUTPUT_SID_TAB_14_15                  (volatile uint32_t *)0xfe442c9c
#define P_TS_OUTPUT_SID_TAB_16_17                  (volatile uint32_t *)0xfe442ca0
#define P_TS_OUTPUT_SID_TAB_18_19                  (volatile uint32_t *)0xfe442ca4
#define P_TS_OUTPUT_SID_TAB_20_21                  (volatile uint32_t *)0xfe442ca8
#define P_TS_OUTPUT_SID_TAB_22_23                  (volatile uint32_t *)0xfe442cac
#define P_TS_OUTPUT_SID_TAB_24_25                  (volatile uint32_t *)0xfe442cb0
#define P_TS_OUTPUT_SID_TAB_26_27                  (volatile uint32_t *)0xfe442cb4
#define P_TS_OUTPUT_SID_TAB_28_29                  (volatile uint32_t *)0xfe442cb8
#define P_TS_OUTPUT_SID_TAB_30_31                  (volatile uint32_t *)0xfe442cbc
#define P_TS_OUTPUT_SID_TAB_32_33                  (volatile uint32_t *)0xfe442cc0
#define P_TS_OUTPUT_SID_TAB_34_35                  (volatile uint32_t *)0xfe442cc4
#define P_TS_OUTPUT_SID_TAB_36_37                  (volatile uint32_t *)0xfe442cc8
#define P_TS_OUTPUT_SID_TAB_38_39                  (volatile uint32_t *)0xfe442ccc
#define P_TS_OUTPUT_SID_TAB_40_41                  (volatile uint32_t *)0xfe442cd0
#define P_TS_OUTPUT_SID_TAB_42_43                  (volatile uint32_t *)0xfe442cd4
#define P_TS_OUTPUT_SID_TAB_44_45                  (volatile uint32_t *)0xfe442cd8
#define P_TS_OUTPUT_SID_TAB_46_47                  (volatile uint32_t *)0xfe442cdc
#define P_TS_OUTPUT_SID_TAB_48_49                  (volatile uint32_t *)0xfe442ce0
#define P_TS_OUTPUT_SID_TAB_50_51                  (volatile uint32_t *)0xfe442ce4
#define P_TS_OUTPUT_SID_TAB_52_53                  (volatile uint32_t *)0xfe442ce8
#define P_TS_OUTPUT_SID_TAB_54_55                  (volatile uint32_t *)0xfe442cec
#define P_TS_OUTPUT_SID_TAB_56_57                  (volatile uint32_t *)0xfe442cf0
#define P_TS_OUTPUT_SID_TAB_58_59                  (volatile uint32_t *)0xfe442cf4
#define P_TS_OUTPUT_SID_TAB_60_61                  (volatile uint32_t *)0xfe442cf8
#define P_TS_OUTPUT_SID_TAB_62_63                  (volatile uint32_t *)0xfe442cfc
#define P_TS_OUTPUT_ES_TAB_0                       (volatile uint32_t *)0xfe442d00
#define P_TS_OUTPUT_ES_TAB_1                       (volatile uint32_t *)0xfe442d04
#define P_TS_OUTPUT_ES_TAB_2                       (volatile uint32_t *)0xfe442d08
#define P_TS_OUTPUT_ES_TAB_3                       (volatile uint32_t *)0xfe442d0c
#define P_TS_OUTPUT_ES_TAB_4                       (volatile uint32_t *)0xfe442d10
#define P_TS_OUTPUT_ES_TAB_5                       (volatile uint32_t *)0xfe442d14
#define P_TS_OUTPUT_ES_TAB_6                       (volatile uint32_t *)0xfe442d18
#define P_TS_OUTPUT_ES_TAB_7                       (volatile uint32_t *)0xfe442d1c
#define P_TS_OUTPUT_ES_TAB_8                       (volatile uint32_t *)0xfe442d20
#define P_TS_OUTPUT_ES_TAB_9                       (volatile uint32_t *)0xfe442d24
#define P_TS_OUTPUT_ES_TAB_10                      (volatile uint32_t *)0xfe442d28
#define P_TS_OUTPUT_ES_TAB_11                      (volatile uint32_t *)0xfe442d2c
#define P_TS_OUTPUT_ES_TAB_12                      (volatile uint32_t *)0xfe442d30
#define P_TS_OUTPUT_ES_TAB_13                      (volatile uint32_t *)0xfe442d34
#define P_TS_OUTPUT_ES_TAB_14                      (volatile uint32_t *)0xfe442d38
#define P_TS_OUTPUT_ES_TAB_15                      (volatile uint32_t *)0xfe442d3c
#define P_TS_OUTPUT_ES_TAB_16                      (volatile uint32_t *)0xfe442d40
#define P_TS_OUTPUT_ES_TAB_17                      (volatile uint32_t *)0xfe442d44
#define P_TS_OUTPUT_ES_TAB_18                      (volatile uint32_t *)0xfe442d48
#define P_TS_OUTPUT_ES_TAB_19                      (volatile uint32_t *)0xfe442d4c
#define P_TS_OUTPUT_ES_TAB_20                      (volatile uint32_t *)0xfe442d50
#define P_TS_OUTPUT_ES_TAB_21                      (volatile uint32_t *)0xfe442d54
#define P_TS_OUTPUT_ES_TAB_22                      (volatile uint32_t *)0xfe442d58
#define P_TS_OUTPUT_ES_TAB_23                      (volatile uint32_t *)0xfe442d5c
#define P_TS_OUTPUT_ES_TAB_24                      (volatile uint32_t *)0xfe442d60
#define P_TS_OUTPUT_ES_TAB_25                      (volatile uint32_t *)0xfe442d64
#define P_TS_OUTPUT_ES_TAB_26                      (volatile uint32_t *)0xfe442d68
#define P_TS_OUTPUT_ES_TAB_27                      (volatile uint32_t *)0xfe442d6c
#define P_TS_OUTPUT_ES_TAB_28                      (volatile uint32_t *)0xfe442d70
#define P_TS_OUTPUT_ES_TAB_29                      (volatile uint32_t *)0xfe442d74
#define P_TS_OUTPUT_ES_TAB_30                      (volatile uint32_t *)0xfe442d78
#define P_TS_OUTPUT_ES_TAB_31                      (volatile uint32_t *)0xfe442d7c
#define P_TS_OUTPUT_ES_TAB_32                      (volatile uint32_t *)0xfe442d80
#define P_TS_OUTPUT_ES_TAB_33                      (volatile uint32_t *)0xfe442d84
#define P_TS_OUTPUT_ES_TAB_34                      (volatile uint32_t *)0xfe442d88
#define P_TS_OUTPUT_ES_TAB_35                      (volatile uint32_t *)0xfe442d8c
#define P_TS_OUTPUT_ES_TAB_36                      (volatile uint32_t *)0xfe442d90
#define P_TS_OUTPUT_ES_TAB_37                      (volatile uint32_t *)0xfe442d94
#define P_TS_OUTPUT_ES_TAB_38                      (volatile uint32_t *)0xfe442d98
#define P_TS_OUTPUT_ES_TAB_39                      (volatile uint32_t *)0xfe442d9c
#define P_TS_OUTPUT_ES_TAB_40                      (volatile uint32_t *)0xfe442da0
#define P_TS_OUTPUT_ES_TAB_41                      (volatile uint32_t *)0xfe442da4
#define P_TS_OUTPUT_ES_TAB_42                      (volatile uint32_t *)0xfe442da8
#define P_TS_OUTPUT_ES_TAB_43                      (volatile uint32_t *)0xfe442dac
#define P_TS_OUTPUT_ES_TAB_44                      (volatile uint32_t *)0xfe442db0
#define P_TS_OUTPUT_ES_TAB_45                      (volatile uint32_t *)0xfe442db4
#define P_TS_OUTPUT_ES_TAB_46                      (volatile uint32_t *)0xfe442db8
#define P_TS_OUTPUT_ES_TAB_47                      (volatile uint32_t *)0xfe442dbc
#define P_TS_OUTPUT_ES_TAB_48                      (volatile uint32_t *)0xfe442dc0
#define P_TS_OUTPUT_ES_TAB_49                      (volatile uint32_t *)0xfe442dc4
#define P_TS_OUTPUT_ES_TAB_50                      (volatile uint32_t *)0xfe442dc8
#define P_TS_OUTPUT_ES_TAB_51                      (volatile uint32_t *)0xfe442dcc
#define P_TS_OUTPUT_ES_TAB_52                      (volatile uint32_t *)0xfe442dd0
#define P_TS_OUTPUT_ES_TAB_53                      (volatile uint32_t *)0xfe442dd4
#define P_TS_OUTPUT_ES_TAB_54                      (volatile uint32_t *)0xfe442dd8
#define P_TS_OUTPUT_ES_TAB_55                      (volatile uint32_t *)0xfe442ddc
#define P_TS_OUTPUT_ES_TAB_56                      (volatile uint32_t *)0xfe442de0
#define P_TS_OUTPUT_ES_TAB_57                      (volatile uint32_t *)0xfe442de4
#define P_TS_OUTPUT_ES_TAB_58                      (volatile uint32_t *)0xfe442de8
#define P_TS_OUTPUT_ES_TAB_59                      (volatile uint32_t *)0xfe442dec
#define P_TS_OUTPUT_ES_TAB_60                      (volatile uint32_t *)0xfe442df0
#define P_TS_OUTPUT_ES_TAB_61                      (volatile uint32_t *)0xfe442df4
#define P_TS_OUTPUT_ES_TAB_62                      (volatile uint32_t *)0xfe442df8
#define P_TS_OUTPUT_ES_TAB_63                      (volatile uint32_t *)0xfe442dfc
#define P_TS_OUTPUT_PCR_REG_LSB_0                  (volatile uint32_t *)0xfe442e00
#define P_TS_OUTPUT_PCR_REG_MSB_0                  (volatile uint32_t *)0xfe442e04
#define P_TS_OUTPUT_PCR_REG_LSB_1                  (volatile uint32_t *)0xfe442e08
#define P_TS_OUTPUT_PCR_REG_MSB_1                  (volatile uint32_t *)0xfe442e0c
#define P_TS_OUTPUT_PCR_REG_LSB_2                  (volatile uint32_t *)0xfe442e10
#define P_TS_OUTPUT_PCR_REG_MSB_2                  (volatile uint32_t *)0xfe442e14
#define P_TS_OUTPUT_PCR_REG_LSB_3                  (volatile uint32_t *)0xfe442e18
#define P_TS_OUTPUT_PCR_REG_MSB_3                  (volatile uint32_t *)0xfe442e1c
#define P_TS_OUTPUT_PCR_REG_LSB_4                  (volatile uint32_t *)0xfe442e20
#define P_TS_OUTPUT_PCR_REG_MSB_4                  (volatile uint32_t *)0xfe442e24
#define P_TS_OUTPUT_PCR_REG_LSB_5                  (volatile uint32_t *)0xfe442e28
#define P_TS_OUTPUT_PCR_REG_MSB_5                  (volatile uint32_t *)0xfe442e2c
#define P_TS_OUTPUT_PCR_REG_LSB_6                  (volatile uint32_t *)0xfe442e30
#define P_TS_OUTPUT_PCR_REG_MSB_6                  (volatile uint32_t *)0xfe442e34
#define P_TS_OUTPUT_PCR_REG_LSB_7                  (volatile uint32_t *)0xfe442e38
#define P_TS_OUTPUT_PCR_REG_MSB_7                  (volatile uint32_t *)0xfe442e3c
#define P_TS_OUTPUT_PCR_REG_LSB_8                  (volatile uint32_t *)0xfe442e40
#define P_TS_OUTPUT_PCR_REG_MSB_8                  (volatile uint32_t *)0xfe442e44
#define P_TS_OUTPUT_PCR_REG_LSB_9                  (volatile uint32_t *)0xfe442e48
#define P_TS_OUTPUT_PCR_REG_MSB_9                  (volatile uint32_t *)0xfe442e4c
#define P_TS_OUTPUT_PCR_REG_LSB_10                 (volatile uint32_t *)0xfe442e50
#define P_TS_OUTPUT_PCR_REG_MSB_10                 (volatile uint32_t *)0xfe442e54
#define P_TS_OUTPUT_PCR_REG_LSB_11                 (volatile uint32_t *)0xfe442e58
#define P_TS_OUTPUT_PCR_REG_MSB_11                 (volatile uint32_t *)0xfe442e5c
#define P_TS_OUTPUT_PCR_REG_LSB_12                 (volatile uint32_t *)0xfe442e60
#define P_TS_OUTPUT_PCR_REG_MSB_12                 (volatile uint32_t *)0xfe442e64
#define P_TS_OUTPUT_PCR_REG_LSB_13                 (volatile uint32_t *)0xfe442e68
#define P_TS_OUTPUT_PCR_REG_MSB_13                 (volatile uint32_t *)0xfe442e6c
#define P_TS_OUTPUT_PCR_REG_LSB_14                 (volatile uint32_t *)0xfe442e70
#define P_TS_OUTPUT_PCR_REG_MSB_14                 (volatile uint32_t *)0xfe442e74
#define P_TS_OUTPUT_PCR_REG_LSB_15                 (volatile uint32_t *)0xfe442e78
#define P_TS_OUTPUT_PCR_REG_MSB_15                 (volatile uint32_t *)0xfe442e7c
//========================================================================
//  TSD DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442000
// -----------------------------------------------
#define P_TSD_PID_RDY                              (volatile uint32_t *)0xfe442000
#define P_TSD_TEE_LOCK                             (volatile uint32_t *)0xfe442004
#define P_TSD_PID_STS                              (volatile uint32_t *)0xfe44200c
#define P_TSD_PID_TABLE_LSB_0                      (volatile uint32_t *)0xfe442010
#define P_TSD_PID_TABLE_MSB_0                      (volatile uint32_t *)0xfe442014
#define P_TSD_PID_TABLE_LSB_1                      (volatile uint32_t *)0xfe442018
#define P_TSD_PID_TABLE_MSB_1                      (volatile uint32_t *)0xfe44201c
#define P_TSD_PID_TABLE_LSB_2                      (volatile uint32_t *)0xfe442020
#define P_TSD_PID_TABLE_MSB_2                      (volatile uint32_t *)0xfe442024
#define P_TSD_PID_TABLE_LSB_3                      (volatile uint32_t *)0xfe442028
#define P_TSD_PID_TABLE_MSB_3                      (volatile uint32_t *)0xfe44202c
#define P_TSD_PID_TABLE_LSB_4                      (volatile uint32_t *)0xfe442030
#define P_TSD_PID_TABLE_MSB_4                      (volatile uint32_t *)0xfe442034
#define P_TSD_PID_TABLE_LSB_5                      (volatile uint32_t *)0xfe442038
#define P_TSD_PID_TABLE_MSB_5                      (volatile uint32_t *)0xfe44203c
#define P_TSD_PID_TABLE_LSB_6                      (volatile uint32_t *)0xfe442040
#define P_TSD_PID_TABLE_MSB_6                      (volatile uint32_t *)0xfe442044
#define P_TSD_PID_TABLE_LSB_7                      (volatile uint32_t *)0xfe442048
#define P_TSD_PID_TABLE_MSB_7                      (volatile uint32_t *)0xfe44204c
#define P_TSD_PID_TABLE_LSB_8                      (volatile uint32_t *)0xfe442050
#define P_TSD_PID_TABLE_MSB_8                      (volatile uint32_t *)0xfe442054
#define P_TSD_PID_TABLE_LSB_9                      (volatile uint32_t *)0xfe442058
#define P_TSD_PID_TABLE_MSB_9                      (volatile uint32_t *)0xfe44205c
#define P_TSD_PID_TABLE_LSB_10                     (volatile uint32_t *)0xfe442060
#define P_TSD_PID_TABLE_MSB_10                     (volatile uint32_t *)0xfe442064
#define P_TSD_PID_TABLE_LSB_11                     (volatile uint32_t *)0xfe442068
#define P_TSD_PID_TABLE_MSB_11                     (volatile uint32_t *)0xfe44206c
#define P_TSD_PID_TABLE_LSB_12                     (volatile uint32_t *)0xfe442070
#define P_TSD_PID_TABLE_MSB_12                     (volatile uint32_t *)0xfe442074
#define P_TSD_PID_TABLE_LSB_13                     (volatile uint32_t *)0xfe442078
#define P_TSD_PID_TABLE_MSB_13                     (volatile uint32_t *)0xfe44207c
#define P_TSD_PID_TABLE_LSB_14                     (volatile uint32_t *)0xfe442080
#define P_TSD_PID_TABLE_MSB_14                     (volatile uint32_t *)0xfe442084
#define P_TSD_PID_TABLE_LSB_15                     (volatile uint32_t *)0xfe442088
#define P_TSD_PID_TABLE_MSB_15                     (volatile uint32_t *)0xfe44208c
#define P_TSD_PID_TABLE_LSB_16                     (volatile uint32_t *)0xfe442090
#define P_TSD_PID_TABLE_MSB_16                     (volatile uint32_t *)0xfe442094
#define P_TSD_PID_TABLE_LSB_17                     (volatile uint32_t *)0xfe442098
#define P_TSD_PID_TABLE_MSB_17                     (volatile uint32_t *)0xfe44209c
#define P_TSD_PID_TABLE_LSB_18                     (volatile uint32_t *)0xfe4420a0
#define P_TSD_PID_TABLE_MSB_18                     (volatile uint32_t *)0xfe4420a4
#define P_TSD_PID_TABLE_LSB_19                     (volatile uint32_t *)0xfe4420a8
#define P_TSD_PID_TABLE_MSB_19                     (volatile uint32_t *)0xfe4420ac
#define P_TSD_PID_TABLE_LSB_20                     (volatile uint32_t *)0xfe4420b0
#define P_TSD_PID_TABLE_MSB_20                     (volatile uint32_t *)0xfe4420b4
#define P_TSD_PID_TABLE_LSB_21                     (volatile uint32_t *)0xfe4420b8
#define P_TSD_PID_TABLE_MSB_21                     (volatile uint32_t *)0xfe4420bc
#define P_TSD_PID_TABLE_LSB_22                     (volatile uint32_t *)0xfe4420c0
#define P_TSD_PID_TABLE_MSB_22                     (volatile uint32_t *)0xfe4420c4
#define P_TSD_PID_TABLE_LSB_23                     (volatile uint32_t *)0xfe4420c8
#define P_TSD_PID_TABLE_MSB_23                     (volatile uint32_t *)0xfe4420cc
#define P_TSD_PID_TABLE_LSB_24                     (volatile uint32_t *)0xfe4420d0
#define P_TSD_PID_TABLE_MSB_24                     (volatile uint32_t *)0xfe4420d4
#define P_TSD_PID_TABLE_LSB_25                     (volatile uint32_t *)0xfe4420d8
#define P_TSD_PID_TABLE_MSB_25                     (volatile uint32_t *)0xfe4420dc
#define P_TSD_PID_TABLE_LSB_26                     (volatile uint32_t *)0xfe4420e0
#define P_TSD_PID_TABLE_MSB_26                     (volatile uint32_t *)0xfe4420e4
#define P_TSD_PID_TABLE_LSB_27                     (volatile uint32_t *)0xfe4420e8
#define P_TSD_PID_TABLE_MSB_27                     (volatile uint32_t *)0xfe4420ec
#define P_TSD_PID_TABLE_LSB_28                     (volatile uint32_t *)0xfe4420f0
#define P_TSD_PID_TABLE_MSB_28                     (volatile uint32_t *)0xfe4420f4
#define P_TSD_PID_TABLE_LSB_29                     (volatile uint32_t *)0xfe4420f8
#define P_TSD_PID_TABLE_MSB_29                     (volatile uint32_t *)0xfe4420fc
#define P_TSD_PID_TABLE_LSB_30                     (volatile uint32_t *)0xfe442100
#define P_TSD_PID_TABLE_MSB_30                     (volatile uint32_t *)0xfe442104
#define P_TSD_PID_TABLE_LSB_31                     (volatile uint32_t *)0xfe442108
#define P_TSD_PID_TABLE_MSB_31                     (volatile uint32_t *)0xfe44210c
#define P_TSD_PID_TABLE_LSB_32                     (volatile uint32_t *)0xfe442110
#define P_TSD_PID_TABLE_MSB_32                     (volatile uint32_t *)0xfe442114
#define P_TSD_PID_TABLE_LSB_33                     (volatile uint32_t *)0xfe442118
#define P_TSD_PID_TABLE_MSB_33                     (volatile uint32_t *)0xfe44211c
#define P_TSD_PID_TABLE_LSB_34                     (volatile uint32_t *)0xfe442120
#define P_TSD_PID_TABLE_MSB_34                     (volatile uint32_t *)0xfe442124
#define P_TSD_PID_TABLE_LSB_35                     (volatile uint32_t *)0xfe442128
#define P_TSD_PID_TABLE_MSB_35                     (volatile uint32_t *)0xfe44212c
#define P_TSD_PID_TABLE_LSB_36                     (volatile uint32_t *)0xfe442130
#define P_TSD_PID_TABLE_MSB_36                     (volatile uint32_t *)0xfe442134
#define P_TSD_PID_TABLE_LSB_37                     (volatile uint32_t *)0xfe442138
#define P_TSD_PID_TABLE_MSB_37                     (volatile uint32_t *)0xfe44213c
#define P_TSD_PID_TABLE_LSB_38                     (volatile uint32_t *)0xfe442140
#define P_TSD_PID_TABLE_MSB_38                     (volatile uint32_t *)0xfe442144
#define P_TSD_PID_TABLE_LSB_39                     (volatile uint32_t *)0xfe442148
#define P_TSD_PID_TABLE_MSB_39                     (volatile uint32_t *)0xfe44214c
#define P_TSD_PID_TABLE_LSB_40                     (volatile uint32_t *)0xfe442150
#define P_TSD_PID_TABLE_MSB_40                     (volatile uint32_t *)0xfe442154
#define P_TSD_PID_TABLE_LSB_41                     (volatile uint32_t *)0xfe442158
#define P_TSD_PID_TABLE_MSB_41                     (volatile uint32_t *)0xfe44215c
#define P_TSD_PID_TABLE_LSB_42                     (volatile uint32_t *)0xfe442160
#define P_TSD_PID_TABLE_MSB_42                     (volatile uint32_t *)0xfe442164
#define P_TSD_PID_TABLE_LSB_43                     (volatile uint32_t *)0xfe442168
#define P_TSD_PID_TABLE_MSB_43                     (volatile uint32_t *)0xfe44216c
#define P_TSD_PID_TABLE_LSB_44                     (volatile uint32_t *)0xfe442170
#define P_TSD_PID_TABLE_MSB_44                     (volatile uint32_t *)0xfe442174
#define P_TSD_PID_TABLE_LSB_45                     (volatile uint32_t *)0xfe442178
#define P_TSD_PID_TABLE_MSB_45                     (volatile uint32_t *)0xfe44217c
#define P_TSD_PID_TABLE_LSB_46                     (volatile uint32_t *)0xfe442180
#define P_TSD_PID_TABLE_MSB_46                     (volatile uint32_t *)0xfe442184
#define P_TSD_PID_TABLE_LSB_47                     (volatile uint32_t *)0xfe442188
#define P_TSD_PID_TABLE_MSB_47                     (volatile uint32_t *)0xfe44218c
#define P_TSD_PID_TABLE_LSB_48                     (volatile uint32_t *)0xfe442190
#define P_TSD_PID_TABLE_MSB_48                     (volatile uint32_t *)0xfe442194
#define P_TSD_PID_TABLE_LSB_49                     (volatile uint32_t *)0xfe442198
#define P_TSD_PID_TABLE_MSB_49                     (volatile uint32_t *)0xfe44219c
#define P_TSD_PID_TABLE_LSB_50                     (volatile uint32_t *)0xfe4421a0
#define P_TSD_PID_TABLE_MSB_50                     (volatile uint32_t *)0xfe4421a4
#define P_TSD_PID_TABLE_LSB_51                     (volatile uint32_t *)0xfe4421a8
#define P_TSD_PID_TABLE_MSB_51                     (volatile uint32_t *)0xfe4421ac
#define P_TSD_PID_TABLE_LSB_52                     (volatile uint32_t *)0xfe4421b0
#define P_TSD_PID_TABLE_MSB_52                     (volatile uint32_t *)0xfe4421b4
#define P_TSD_PID_TABLE_LSB_53                     (volatile uint32_t *)0xfe4421b8
#define P_TSD_PID_TABLE_MSB_53                     (volatile uint32_t *)0xfe4421bc
#define P_TSD_PID_TABLE_LSB_54                     (volatile uint32_t *)0xfe4421c0
#define P_TSD_PID_TABLE_MSB_54                     (volatile uint32_t *)0xfe4421c4
#define P_TSD_PID_TABLE_LSB_55                     (volatile uint32_t *)0xfe4421c8
#define P_TSD_PID_TABLE_MSB_55                     (volatile uint32_t *)0xfe4421cc
#define P_TSD_PID_TABLE_LSB_56                     (volatile uint32_t *)0xfe4421d0
#define P_TSD_PID_TABLE_MSB_56                     (volatile uint32_t *)0xfe4421d4
#define P_TSD_PID_TABLE_LSB_57                     (volatile uint32_t *)0xfe4421d8
#define P_TSD_PID_TABLE_MSB_57                     (volatile uint32_t *)0xfe4421dc
#define P_TSD_PID_TABLE_LSB_58                     (volatile uint32_t *)0xfe4421e0
#define P_TSD_PID_TABLE_MSB_58                     (volatile uint32_t *)0xfe4421e4
#define P_TSD_PID_TABLE_LSB_59                     (volatile uint32_t *)0xfe4421e8
#define P_TSD_PID_TABLE_MSB_59                     (volatile uint32_t *)0xfe4421ec
#define P_TSD_PID_TABLE_LSB_60                     (volatile uint32_t *)0xfe4421f0
#define P_TSD_PID_TABLE_MSB_60                     (volatile uint32_t *)0xfe4421f4
#define P_TSD_PID_TABLE_LSB_61                     (volatile uint32_t *)0xfe4421f8
#define P_TSD_PID_TABLE_MSB_61                     (volatile uint32_t *)0xfe4421fc
#define P_TSD_PID_TABLE_LSB_62                     (volatile uint32_t *)0xfe442200
#define P_TSD_PID_TABLE_MSB_62                     (volatile uint32_t *)0xfe442204
#define P_TSD_PID_TABLE_LSB_63                     (volatile uint32_t *)0xfe442208
#define P_TSD_PID_TABLE_MSB_63                     (volatile uint32_t *)0xfe44220c
//========================================================================
// SECURE TOP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440300
// -----------------------------------------------
#define P_SEC_TOP_CFG_LOCKABLE                     (volatile uint32_t *)0xfe440300
#define P_SEC_TOP_CFG_LOCK                         (volatile uint32_t *)0xfe440304
#define P_SEC_TOP_CFG_WTO                          (volatile uint32_t *)0xfe440308
#define P_SEC_TOP_N2_GENOUT                        (volatile uint32_t *)0xfe44030c
#define P_SEC_TOP_CFG_REG                          (volatile uint32_t *)0xfe440310
#define P_SEC_TOP_NSK_CTRL                         (volatile uint32_t *)0xfe440314
#define P_SEC_TOP_AKL_STS                          (volatile uint32_t *)0xfe440318
#define P_SEC_TOP_ND_STATUS                        (volatile uint32_t *)0xfe44031c
#define P_SEC_TOP_CFG_DEMUX                        (volatile uint32_t *)0xfe440320
#define P_SEC_TOP_CFG_DIF                          (volatile uint32_t *)0xfe440330
#define P_SEC_TOP_NSK_HASH0                        (volatile uint32_t *)0xfe440340
#define P_SEC_TOP_NSK_HASH1                        (volatile uint32_t *)0xfe440344
#define P_SEC_TOP_NSK_HASH2                        (volatile uint32_t *)0xfe440348
#define P_SEC_TOP_NSK_HASH3                        (volatile uint32_t *)0xfe44034c
#define P_SEC_TOP_PATH0_CTRL                       (volatile uint32_t *)0xfe4403a0
#define P_SEC_TOP_PATH1_CTRL                       (volatile uint32_t *)0xfe4403a4
#define P_SEC_TOP_PATH2_CTRL                       (volatile uint32_t *)0xfe4403a8
#define P_SEC_TOP_PATH3_CTRL                       (volatile uint32_t *)0xfe4403ac
#define P_SEC_TOP_DEMOD_PKT_CFG0                   (volatile uint32_t *)0xfe4403b0
#define P_SEC_TOP_DEMOD_PKT_CFG1                   (volatile uint32_t *)0xfe4403b4
#define P_SEC_TOP_DEMOD_PKT_CFG2                   (volatile uint32_t *)0xfe4403b8
#define P_SEC_TOP_DEMOD_PKT_CFG3                   (volatile uint32_t *)0xfe4403bc
#define P_SEC_TOP_DEMOD_FIFO_CFG0                  (volatile uint32_t *)0xfe4403c0
#define P_SEC_TOP_DEMOD_FIFO_CFG1                  (volatile uint32_t *)0xfe4403c4
#define P_SEC_TOP_TS_O_PATH_CTRL                   (volatile uint32_t *)0xfe4403c8
#define P_SEC_TOP_CLEAN_DEMOD_INT                  (volatile uint32_t *)0xfe4403cc
#define P_SEC_TOP_DEMOD_INT_MASK                   (volatile uint32_t *)0xfe4403d0
#define P_SEC_TOP_DEMOD_INT_STATUS                 (volatile uint32_t *)0xfe4403d4
#define P_SEC_TOP_TS_CHN0_ERR_STATUS               (volatile uint32_t *)0xfe4403d8
#define P_SEC_TOP_TS_CHN1_ERR_STATUS               (volatile uint32_t *)0xfe4403dc
#define P_SEC_TOP_TS_CHN2_ERR_STATUS               (volatile uint32_t *)0xfe4403e0
#define P_SEC_TOP_TS_CHN3_ERR_STATUS               (volatile uint32_t *)0xfe4403e4
//========================================================================
// TSE DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442800
// -----------------------------------------------
#define P_TSE_PID_RDY                              (volatile uint32_t *)0xfe442800
#define P_TSE_TEE_LOCK                             (volatile uint32_t *)0xfe442804
#define P_TSE_PID_STS                              (volatile uint32_t *)0xfe44280c
#define P_TSE_PID_TABLE_LSB_0                      (volatile uint32_t *)0xfe442810
#define P_TSE_PID_TABLE_MSB_0                      (volatile uint32_t *)0xfe442814
#define P_TSE_PID_TABLE_LSB_1                      (volatile uint32_t *)0xfe442818
#define P_TSE_PID_TABLE_MSB_1                      (volatile uint32_t *)0xfe44281c
#define P_TSE_PID_TABLE_LSB_2                      (volatile uint32_t *)0xfe442820
#define P_TSE_PID_TABLE_MSB_2                      (volatile uint32_t *)0xfe442824
#define P_TSE_PID_TABLE_LSB_3                      (volatile uint32_t *)0xfe442828
#define P_TSE_PID_TABLE_MSB_3                      (volatile uint32_t *)0xfe44282c
#define P_TSE_PID_TABLE_LSB_4                      (volatile uint32_t *)0xfe442830
#define P_TSE_PID_TABLE_MSB_4                      (volatile uint32_t *)0xfe442834
#define P_TSE_PID_TABLE_LSB_5                      (volatile uint32_t *)0xfe442838
#define P_TSE_PID_TABLE_MSB_5                      (volatile uint32_t *)0xfe44283c
#define P_TSE_PID_TABLE_LSB_6                      (volatile uint32_t *)0xfe442840
#define P_TSE_PID_TABLE_MSB_6                      (volatile uint32_t *)0xfe442844
#define P_TSE_PID_TABLE_LSB_7                      (volatile uint32_t *)0xfe442848
#define P_TSE_PID_TABLE_MSB_7                      (volatile uint32_t *)0xfe44284c
#define P_TSE_PID_TABLE_LSB_8                      (volatile uint32_t *)0xfe442850
#define P_TSE_PID_TABLE_MSB_8                      (volatile uint32_t *)0xfe442854
#define P_TSE_PID_TABLE_LSB_9                      (volatile uint32_t *)0xfe442858
#define P_TSE_PID_TABLE_MSB_9                      (volatile uint32_t *)0xfe44285c
#define P_TSE_PID_TABLE_LSB_10                     (volatile uint32_t *)0xfe442860
#define P_TSE_PID_TABLE_MSB_10                     (volatile uint32_t *)0xfe442864
#define P_TSE_PID_TABLE_LSB_11                     (volatile uint32_t *)0xfe442868
#define P_TSE_PID_TABLE_MSB_11                     (volatile uint32_t *)0xfe44286c
#define P_TSE_PID_TABLE_LSB_12                     (volatile uint32_t *)0xfe442870
#define P_TSE_PID_TABLE_MSB_12                     (volatile uint32_t *)0xfe442874
#define P_TSE_PID_TABLE_LSB_13                     (volatile uint32_t *)0xfe442878
#define P_TSE_PID_TABLE_MSB_13                     (volatile uint32_t *)0xfe44287c
#define P_TSE_PID_TABLE_LSB_14                     (volatile uint32_t *)0xfe442880
#define P_TSE_PID_TABLE_MSB_14                     (volatile uint32_t *)0xfe442884
#define P_TSE_PID_TABLE_LSB_15                     (volatile uint32_t *)0xfe442888
#define P_TSE_PID_TABLE_MSB_15                     (volatile uint32_t *)0xfe44288c
#define P_TSE_PID_TABLE_LSB_16                     (volatile uint32_t *)0xfe442890
#define P_TSE_PID_TABLE_MSB_16                     (volatile uint32_t *)0xfe442894
#define P_TSE_PID_TABLE_LSB_17                     (volatile uint32_t *)0xfe442898
#define P_TSE_PID_TABLE_MSB_17                     (volatile uint32_t *)0xfe44289c
#define P_TSE_PID_TABLE_LSB_18                     (volatile uint32_t *)0xfe4428a0
#define P_TSE_PID_TABLE_MSB_18                     (volatile uint32_t *)0xfe4428a4
#define P_TSE_PID_TABLE_LSB_19                     (volatile uint32_t *)0xfe4428a8
#define P_TSE_PID_TABLE_MSB_19                     (volatile uint32_t *)0xfe4428ac
#define P_TSE_PID_TABLE_LSB_20                     (volatile uint32_t *)0xfe4428b0
#define P_TSE_PID_TABLE_MSB_20                     (volatile uint32_t *)0xfe4428b4
#define P_TSE_PID_TABLE_LSB_21                     (volatile uint32_t *)0xfe4428b8
#define P_TSE_PID_TABLE_MSB_21                     (volatile uint32_t *)0xfe4428bc
#define P_TSE_PID_TABLE_LSB_22                     (volatile uint32_t *)0xfe4428c0
#define P_TSE_PID_TABLE_MSB_22                     (volatile uint32_t *)0xfe4428c4
#define P_TSE_PID_TABLE_LSB_23                     (volatile uint32_t *)0xfe4428c8
#define P_TSE_PID_TABLE_MSB_23                     (volatile uint32_t *)0xfe4428cc
#define P_TSE_PID_TABLE_LSB_24                     (volatile uint32_t *)0xfe4428d0
#define P_TSE_PID_TABLE_MSB_24                     (volatile uint32_t *)0xfe4428d4
#define P_TSE_PID_TABLE_LSB_25                     (volatile uint32_t *)0xfe4428d8
#define P_TSE_PID_TABLE_MSB_25                     (volatile uint32_t *)0xfe4428dc
#define P_TSE_PID_TABLE_LSB_26                     (volatile uint32_t *)0xfe4428e0
#define P_TSE_PID_TABLE_MSB_26                     (volatile uint32_t *)0xfe4428e4
#define P_TSE_PID_TABLE_LSB_27                     (volatile uint32_t *)0xfe4428e8
#define P_TSE_PID_TABLE_MSB_27                     (volatile uint32_t *)0xfe4428ec
#define P_TSE_PID_TABLE_LSB_28                     (volatile uint32_t *)0xfe4428f0
#define P_TSE_PID_TABLE_MSB_28                     (volatile uint32_t *)0xfe4428f4
#define P_TSE_PID_TABLE_LSB_29                     (volatile uint32_t *)0xfe4428f8
#define P_TSE_PID_TABLE_MSB_29                     (volatile uint32_t *)0xfe4428fc
#define P_TSE_PID_TABLE_LSB_30                     (volatile uint32_t *)0xfe442900
#define P_TSE_PID_TABLE_MSB_30                     (volatile uint32_t *)0xfe442904
#define P_TSE_PID_TABLE_LSB_31                     (volatile uint32_t *)0xfe442908
#define P_TSE_PID_TABLE_MSB_31                     (volatile uint32_t *)0xfe44290c
#define P_TSE_PID_TABLE_LSB_32                     (volatile uint32_t *)0xfe442910
#define P_TSE_PID_TABLE_MSB_32                     (volatile uint32_t *)0xfe442914
#define P_TSE_PID_TABLE_LSB_33                     (volatile uint32_t *)0xfe442918
#define P_TSE_PID_TABLE_MSB_33                     (volatile uint32_t *)0xfe44291c
#define P_TSE_PID_TABLE_LSB_34                     (volatile uint32_t *)0xfe442920
#define P_TSE_PID_TABLE_MSB_34                     (volatile uint32_t *)0xfe442924
#define P_TSE_PID_TABLE_LSB_35                     (volatile uint32_t *)0xfe442928
#define P_TSE_PID_TABLE_MSB_35                     (volatile uint32_t *)0xfe44292c
#define P_TSE_PID_TABLE_LSB_36                     (volatile uint32_t *)0xfe442930
#define P_TSE_PID_TABLE_MSB_36                     (volatile uint32_t *)0xfe442934
#define P_TSE_PID_TABLE_LSB_37                     (volatile uint32_t *)0xfe442938
#define P_TSE_PID_TABLE_MSB_37                     (volatile uint32_t *)0xfe44293c
#define P_TSE_PID_TABLE_LSB_38                     (volatile uint32_t *)0xfe442940
#define P_TSE_PID_TABLE_MSB_38                     (volatile uint32_t *)0xfe442944
#define P_TSE_PID_TABLE_LSB_39                     (volatile uint32_t *)0xfe442948
#define P_TSE_PID_TABLE_MSB_39                     (volatile uint32_t *)0xfe44294c
#define P_TSE_PID_TABLE_LSB_40                     (volatile uint32_t *)0xfe442950
#define P_TSE_PID_TABLE_MSB_40                     (volatile uint32_t *)0xfe442954
#define P_TSE_PID_TABLE_LSB_41                     (volatile uint32_t *)0xfe442958
#define P_TSE_PID_TABLE_MSB_41                     (volatile uint32_t *)0xfe44295c
#define P_TSE_PID_TABLE_LSB_42                     (volatile uint32_t *)0xfe442960
#define P_TSE_PID_TABLE_MSB_42                     (volatile uint32_t *)0xfe442964
#define P_TSE_PID_TABLE_LSB_43                     (volatile uint32_t *)0xfe442968
#define P_TSE_PID_TABLE_MSB_43                     (volatile uint32_t *)0xfe44296c
#define P_TSE_PID_TABLE_LSB_44                     (volatile uint32_t *)0xfe442970
#define P_TSE_PID_TABLE_MSB_44                     (volatile uint32_t *)0xfe442974
#define P_TSE_PID_TABLE_LSB_45                     (volatile uint32_t *)0xfe442978
#define P_TSE_PID_TABLE_MSB_45                     (volatile uint32_t *)0xfe44297c
#define P_TSE_PID_TABLE_LSB_46                     (volatile uint32_t *)0xfe442980
#define P_TSE_PID_TABLE_MSB_46                     (volatile uint32_t *)0xfe442984
#define P_TSE_PID_TABLE_LSB_47                     (volatile uint32_t *)0xfe442988
#define P_TSE_PID_TABLE_MSB_47                     (volatile uint32_t *)0xfe44298c
#define P_TSE_PID_TABLE_LSB_48                     (volatile uint32_t *)0xfe442990
#define P_TSE_PID_TABLE_MSB_48                     (volatile uint32_t *)0xfe442994
#define P_TSE_PID_TABLE_LSB_49                     (volatile uint32_t *)0xfe442998
#define P_TSE_PID_TABLE_MSB_49                     (volatile uint32_t *)0xfe44299c
#define P_TSE_PID_TABLE_LSB_50                     (volatile uint32_t *)0xfe4429a0
#define P_TSE_PID_TABLE_MSB_50                     (volatile uint32_t *)0xfe4429a4
#define P_TSE_PID_TABLE_LSB_51                     (volatile uint32_t *)0xfe4429a8
#define P_TSE_PID_TABLE_MSB_51                     (volatile uint32_t *)0xfe4429ac
#define P_TSE_PID_TABLE_LSB_52                     (volatile uint32_t *)0xfe4429b0
#define P_TSE_PID_TABLE_MSB_52                     (volatile uint32_t *)0xfe4429b4
#define P_TSE_PID_TABLE_LSB_53                     (volatile uint32_t *)0xfe4429b8
#define P_TSE_PID_TABLE_MSB_53                     (volatile uint32_t *)0xfe4429bc
#define P_TSE_PID_TABLE_LSB_54                     (volatile uint32_t *)0xfe4429c0
#define P_TSE_PID_TABLE_MSB_54                     (volatile uint32_t *)0xfe4429c4
#define P_TSE_PID_TABLE_LSB_55                     (volatile uint32_t *)0xfe4429c8
#define P_TSE_PID_TABLE_MSB_55                     (volatile uint32_t *)0xfe4429cc
#define P_TSE_PID_TABLE_LSB_56                     (volatile uint32_t *)0xfe4429d0
#define P_TSE_PID_TABLE_MSB_56                     (volatile uint32_t *)0xfe4429d4
#define P_TSE_PID_TABLE_LSB_57                     (volatile uint32_t *)0xfe4429d8
#define P_TSE_PID_TABLE_MSB_57                     (volatile uint32_t *)0xfe4429dc
#define P_TSE_PID_TABLE_LSB_58                     (volatile uint32_t *)0xfe4429e0
#define P_TSE_PID_TABLE_MSB_58                     (volatile uint32_t *)0xfe4429e4
#define P_TSE_PID_TABLE_LSB_59                     (volatile uint32_t *)0xfe4429e8
#define P_TSE_PID_TABLE_MSB_59                     (volatile uint32_t *)0xfe4429ec
#define P_TSE_PID_TABLE_LSB_60                     (volatile uint32_t *)0xfe4429f0
#define P_TSE_PID_TABLE_MSB_60                     (volatile uint32_t *)0xfe4429f4
#define P_TSE_PID_TABLE_LSB_61                     (volatile uint32_t *)0xfe4429f8
#define P_TSE_PID_TABLE_MSB_61                     (volatile uint32_t *)0xfe4429fc
#define P_TSE_PID_TABLE_LSB_62                     (volatile uint32_t *)0xfe442a00
#define P_TSE_PID_TABLE_MSB_62                     (volatile uint32_t *)0xfe442a04
#define P_TSE_PID_TABLE_LSB_63                     (volatile uint32_t *)0xfe442a08
#define P_TSE_PID_TABLE_MSB_63                     (volatile uint32_t *)0xfe442a0c
//========================================================================
// TSN DESC REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442400
// -----------------------------------------------
#define P_TSN_PID_RDY                              (volatile uint32_t *)0xfe442400
#define P_TSN_TEE_LOCK                             (volatile uint32_t *)0xfe442404
#define P_TSN_S17_CFG                              (volatile uint32_t *)0xfe442408
#define P_TSN_PID_STS                              (volatile uint32_t *)0xfe44240c
#define P_TSN_PID_TABLE_0                          (volatile uint32_t *)0xfe442410
#define P_TSN_PID_TABLE_1                          (volatile uint32_t *)0xfe442414
#define P_TSN_PID_TABLE_2                          (volatile uint32_t *)0xfe442418
#define P_TSN_PID_TABLE_3                          (volatile uint32_t *)0xfe44241c
#define P_TSN_PID_TABLE_4                          (volatile uint32_t *)0xfe442420
#define P_TSN_PID_TABLE_5                          (volatile uint32_t *)0xfe442424
#define P_TSN_PID_TABLE_6                          (volatile uint32_t *)0xfe442428
#define P_TSN_PID_TABLE_7                          (volatile uint32_t *)0xfe44242c
#define P_TSN_PID_TABLE_8                          (volatile uint32_t *)0xfe442430
#define P_TSN_PID_TABLE_9                          (volatile uint32_t *)0xfe442434
#define P_TSN_PID_TABLE_10                         (volatile uint32_t *)0xfe442438
#define P_TSN_PID_TABLE_11                         (volatile uint32_t *)0xfe44243c
#define P_TSN_PID_TABLE_12                         (volatile uint32_t *)0xfe442440
#define P_TSN_PID_TABLE_13                         (volatile uint32_t *)0xfe442444
#define P_TSN_PID_TABLE_14                         (volatile uint32_t *)0xfe442448
#define P_TSN_PID_TABLE_15                         (volatile uint32_t *)0xfe44244c
#define P_TSN_PID_TABLE_16                         (volatile uint32_t *)0xfe442450
#define P_TSN_PID_TABLE_17                         (volatile uint32_t *)0xfe442454
#define P_TSN_PID_TABLE_18                         (volatile uint32_t *)0xfe442458
#define P_TSN_PID_TABLE_19                         (volatile uint32_t *)0xfe44245c
#define P_TSN_PID_TABLE_20                         (volatile uint32_t *)0xfe442460
#define P_TSN_PID_TABLE_21                         (volatile uint32_t *)0xfe442464
#define P_TSN_PID_TABLE_22                         (volatile uint32_t *)0xfe442468
#define P_TSN_PID_TABLE_23                         (volatile uint32_t *)0xfe44246c
#define P_TSN_PID_TABLE_24                         (volatile uint32_t *)0xfe442470
#define P_TSN_PID_TABLE_25                         (volatile uint32_t *)0xfe442474
#define P_TSN_PID_TABLE_26                         (volatile uint32_t *)0xfe442478
#define P_TSN_PID_TABLE_27                         (volatile uint32_t *)0xfe44247c
#define P_TSN_PID_TABLE_28                         (volatile uint32_t *)0xfe442480
#define P_TSN_PID_TABLE_29                         (volatile uint32_t *)0xfe442484
#define P_TSN_PID_TABLE_30                         (volatile uint32_t *)0xfe442488
#define P_TSN_PID_TABLE_31                         (volatile uint32_t *)0xfe44248c
#define P_TSN_PID_TABLE_32                         (volatile uint32_t *)0xfe442490
#define P_TSN_PID_TABLE_33                         (volatile uint32_t *)0xfe442494
#define P_TSN_PID_TABLE_34                         (volatile uint32_t *)0xfe442498
#define P_TSN_PID_TABLE_35                         (volatile uint32_t *)0xfe44249c
#define P_TSN_PID_TABLE_36                         (volatile uint32_t *)0xfe4424a0
#define P_TSN_PID_TABLE_37                         (volatile uint32_t *)0xfe4424a4
#define P_TSN_PID_TABLE_38                         (volatile uint32_t *)0xfe4424a8
#define P_TSN_PID_TABLE_39                         (volatile uint32_t *)0xfe4424ac
#define P_TSN_PID_TABLE_40                         (volatile uint32_t *)0xfe4424b0
#define P_TSN_PID_TABLE_41                         (volatile uint32_t *)0xfe4424b4
#define P_TSN_PID_TABLE_42                         (volatile uint32_t *)0xfe4424b8
#define P_TSN_PID_TABLE_43                         (volatile uint32_t *)0xfe4424bc
#define P_TSN_PID_TABLE_44                         (volatile uint32_t *)0xfe4424c0
#define P_TSN_PID_TABLE_45                         (volatile uint32_t *)0xfe4424c4
#define P_TSN_PID_TABLE_46                         (volatile uint32_t *)0xfe4424c8
#define P_TSN_PID_TABLE_47                         (volatile uint32_t *)0xfe4424cc
#define P_TSN_PID_TABLE_48                         (volatile uint32_t *)0xfe4424d0
#define P_TSN_PID_TABLE_49                         (volatile uint32_t *)0xfe4424d4
#define P_TSN_PID_TABLE_50                         (volatile uint32_t *)0xfe4424d8
#define P_TSN_PID_TABLE_51                         (volatile uint32_t *)0xfe4424dc
#define P_TSN_PID_TABLE_52                         (volatile uint32_t *)0xfe4424e0
#define P_TSN_PID_TABLE_53                         (volatile uint32_t *)0xfe4424e4
#define P_TSN_PID_TABLE_54                         (volatile uint32_t *)0xfe4424e8
#define P_TSN_PID_TABLE_55                         (volatile uint32_t *)0xfe4424ec
#define P_TSN_PID_TABLE_56                         (volatile uint32_t *)0xfe4424f0
#define P_TSN_PID_TABLE_57                         (volatile uint32_t *)0xfe4424f4
#define P_TSN_PID_TABLE_58                         (volatile uint32_t *)0xfe4424f8
#define P_TSN_PID_TABLE_59                         (volatile uint32_t *)0xfe4424fc
#define P_TSN_PID_TABLE_60                         (volatile uint32_t *)0xfe442500
#define P_TSN_PID_TABLE_61                         (volatile uint32_t *)0xfe442504
#define P_TSN_PID_TABLE_62                         (volatile uint32_t *)0xfe442508
#define P_TSN_PID_TABLE_63                         (volatile uint32_t *)0xfe44250c
#define P_TSN_PID_TABLE_64                         (volatile uint32_t *)0xfe442510
#define P_TSN_PID_TABLE_65                         (volatile uint32_t *)0xfe442514
#define P_TSN_PID_TABLE_66                         (volatile uint32_t *)0xfe442518
#define P_TSN_PID_TABLE_67                         (volatile uint32_t *)0xfe44251c
#define P_TSN_PID_TABLE_68                         (volatile uint32_t *)0xfe442520
#define P_TSN_PID_TABLE_69                         (volatile uint32_t *)0xfe442524
#define P_TSN_PID_TABLE_70                         (volatile uint32_t *)0xfe442528
#define P_TSN_PID_TABLE_71                         (volatile uint32_t *)0xfe44252c
#define P_TSN_PID_TABLE_72                         (volatile uint32_t *)0xfe442530
#define P_TSN_PID_TABLE_73                         (volatile uint32_t *)0xfe442534
#define P_TSN_PID_TABLE_74                         (volatile uint32_t *)0xfe442538
#define P_TSN_PID_TABLE_75                         (volatile uint32_t *)0xfe44253c
#define P_TSN_PID_TABLE_76                         (volatile uint32_t *)0xfe442540
#define P_TSN_PID_TABLE_77                         (volatile uint32_t *)0xfe442544
#define P_TSN_PID_TABLE_78                         (volatile uint32_t *)0xfe442548
#define P_TSN_PID_TABLE_79                         (volatile uint32_t *)0xfe44254c
#define P_TSN_PID_TABLE_80                         (volatile uint32_t *)0xfe442550
#define P_TSN_PID_TABLE_81                         (volatile uint32_t *)0xfe442554
#define P_TSN_PID_TABLE_82                         (volatile uint32_t *)0xfe442558
#define P_TSN_PID_TABLE_83                         (volatile uint32_t *)0xfe44255c
#define P_TSN_PID_TABLE_84                         (volatile uint32_t *)0xfe442560
#define P_TSN_PID_TABLE_85                         (volatile uint32_t *)0xfe442564
#define P_TSN_PID_TABLE_86                         (volatile uint32_t *)0xfe442568
#define P_TSN_PID_TABLE_87                         (volatile uint32_t *)0xfe44256c
#define P_TSN_PID_TABLE_88                         (volatile uint32_t *)0xfe442570
#define P_TSN_PID_TABLE_89                         (volatile uint32_t *)0xfe442574
#define P_TSN_PID_TABLE_90                         (volatile uint32_t *)0xfe442578
#define P_TSN_PID_TABLE_91                         (volatile uint32_t *)0xfe44257c
#define P_TSN_PID_TABLE_92                         (volatile uint32_t *)0xfe442580
#define P_TSN_PID_TABLE_93                         (volatile uint32_t *)0xfe442584
#define P_TSN_PID_TABLE_94                         (volatile uint32_t *)0xfe442588
#define P_TSN_PID_TABLE_95                         (volatile uint32_t *)0xfe44258c
#define P_TSN_PID_TABLE_96                         (volatile uint32_t *)0xfe442590
#define P_TSN_PID_TABLE_97                         (volatile uint32_t *)0xfe442594
#define P_TSN_PID_TABLE_98                         (volatile uint32_t *)0xfe442598
#define P_TSN_PID_TABLE_99                         (volatile uint32_t *)0xfe44259c
#define P_TSN_PID_TABLE_100                        (volatile uint32_t *)0xfe4425a0
#define P_TSN_PID_TABLE_101                        (volatile uint32_t *)0xfe4425a4
#define P_TSN_PID_TABLE_102                        (volatile uint32_t *)0xfe4425a8
#define P_TSN_PID_TABLE_103                        (volatile uint32_t *)0xfe4425ac
#define P_TSN_PID_TABLE_104                        (volatile uint32_t *)0xfe4425b0
#define P_TSN_PID_TABLE_105                        (volatile uint32_t *)0xfe4425b4
#define P_TSN_PID_TABLE_106                        (volatile uint32_t *)0xfe4425b8
#define P_TSN_PID_TABLE_107                        (volatile uint32_t *)0xfe4425bc
#define P_TSN_PID_TABLE_108                        (volatile uint32_t *)0xfe4425c0
#define P_TSN_PID_TABLE_109                        (volatile uint32_t *)0xfe4425c4
#define P_TSN_PID_TABLE_110                        (volatile uint32_t *)0xfe4425c8
#define P_TSN_PID_TABLE_111                        (volatile uint32_t *)0xfe4425cc
#define P_TSN_PID_TABLE_112                        (volatile uint32_t *)0xfe4425d0
#define P_TSN_PID_TABLE_113                        (volatile uint32_t *)0xfe4425d4
#define P_TSN_PID_TABLE_114                        (volatile uint32_t *)0xfe4425d8
#define P_TSN_PID_TABLE_115                        (volatile uint32_t *)0xfe4425dc
#define P_TSN_PID_TABLE_116                        (volatile uint32_t *)0xfe4425e0
#define P_TSN_PID_TABLE_117                        (volatile uint32_t *)0xfe4425e4
#define P_TSN_PID_TABLE_118                        (volatile uint32_t *)0xfe4425e8
#define P_TSN_PID_TABLE_119                        (volatile uint32_t *)0xfe4425ec
#define P_TSN_PID_TABLE_120                        (volatile uint32_t *)0xfe4425f0
#define P_TSN_PID_TABLE_121                        (volatile uint32_t *)0xfe4425f4
#define P_TSN_PID_TABLE_122                        (volatile uint32_t *)0xfe4425f8
#define P_TSN_PID_TABLE_123                        (volatile uint32_t *)0xfe4425fc
#define P_TSN_PID_TABLE_124                        (volatile uint32_t *)0xfe442600
#define P_TSN_PID_TABLE_125                        (volatile uint32_t *)0xfe442604
#define P_TSN_PID_TABLE_126                        (volatile uint32_t *)0xfe442608
#define P_TSN_PID_TABLE_127                        (volatile uint32_t *)0xfe44260c
//========================================================================
// RNG REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440700
// -----------------------------------------------
#define P_RNG_TEE_READY                            (volatile uint32_t *)0xfe440700
#define P_RNG_TEE_LOCK                             (volatile uint32_t *)0xfe440704
#define P_RNG_TEE_CFG                              (volatile uint32_t *)0xfe440708
#define P_RNG_TEE_NIST_OUT                         (volatile uint32_t *)0xfe44070c
#define P_RNG_TEE_OUT0                             (volatile uint32_t *)0xfe440710
#define P_RNG_TEE_OUT1                             (volatile uint32_t *)0xfe440714
#define P_RNG_TEE_OUT2                             (volatile uint32_t *)0xfe440718
#define P_RNG_TEE_OUT3                             (volatile uint32_t *)0xfe44071c
#define P_RNG_CFG_RING                             (volatile uint32_t *)0xfe440740
#define P_RNG_CFG_RESEED                           (volatile uint32_t *)0xfe440744
#define P_RNG_CFG_HEALTH                           (volatile uint32_t *)0xfe440748
#define P_RNG_CFG_MISC                             (volatile uint32_t *)0xfe44074c
#define P_RNG_REE_READY                            (volatile uint32_t *)0xfe440780
#define P_RNG_REE_DEBUG                            (volatile uint32_t *)0xfe440784
#define P_RNG_REE_CFG                              (volatile uint32_t *)0xfe440788
#define P_RNG_REE_OUT0                             (volatile uint32_t *)0xfe440790
#define P_RNG_REE_OUT1                             (volatile uint32_t *)0xfe440794
#define P_RNG_REE_OUT2                             (volatile uint32_t *)0xfe440798
#define P_RNG_REE_OUT3                             (volatile uint32_t *)0xfe44079c
//========================================================================
// OTP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440000
// -----------------------------------------------
#define P_OTP_TEE_RDY                              (volatile uint32_t *)0xfe440000
#define P_OTP_TEE_DEBUG                            (volatile uint32_t *)0xfe440004
#define P_OTP_TEE_CFG                              (volatile uint32_t *)0xfe440008
#define P_OTP_TEE_WR_DAT                           (volatile uint32_t *)0xfe440010
#define P_OTP_TEE_RD_DAT                           (volatile uint32_t *)0xfe440020
#define P_OTP_LIC_A                                (volatile uint32_t *)0xfe440040
#define P_OTP_AML_ID_L                             (volatile uint32_t *)0xfe440080
#define P_OTP_AML_ID_H                             (volatile uint32_t *)0xfe440084
#define P_OTP_ACGK_ID_L                            (volatile uint32_t *)0xfe440088
#define P_OTP_ACGK_ID_H                            (volatile uint32_t *)0xfe44008c
#define P_OTP_DVGK_ID_L                            (volatile uint32_t *)0xfe440090
#define P_OTP_DVGK_ID_H                            (volatile uint32_t *)0xfe440094
#define P_OTP_DVUK_ID_L                            (volatile uint32_t *)0xfe440098
#define P_OTP_DVUK_ID_H                            (volatile uint32_t *)0xfe44009c
#define P_OTP_DGPK_ID_L                            (volatile uint32_t *)0xfe4400a0
#define P_OTP_DGPK_ID_H                            (volatile uint32_t *)0xfe4400a4
#define P_OTP_SECPU_ID_L                           (volatile uint32_t *)0xfe4400a8
#define P_OTP_SECPU_ID_H                           (volatile uint32_t *)0xfe4400ac
#define P_OTP_ETSI012_ID_L                         (volatile uint32_t *)0xfe4400b0
#define P_OTP_ETSI012_ID_H                         (volatile uint32_t *)0xfe4400b4
#define P_OTP_ETSI3_ID_L                           (volatile uint32_t *)0xfe4400b8
#define P_OTP_ETSI3_ID_H                           (volatile uint32_t *)0xfe4400bc
#define P_OTP_MSR_ID_L                             (volatile uint32_t *)0xfe4400c0
#define P_OTP_MSR_ID_H                             (volatile uint32_t *)0xfe4400c4
#define P_OTP_VO_ID_L                              (volatile uint32_t *)0xfe4400c8
#define P_OTP_VO_ID_H                              (volatile uint32_t *)0xfe4400cc
#define P_OTP_NUID_ID_L                            (volatile uint32_t *)0xfe4400d0
#define P_OTP_NUID_ID_H                            (volatile uint32_t *)0xfe4400d4
#define P_OTP_CONAX_ID_L                           (volatile uint32_t *)0xfe4400d8
#define P_OTP_CONAX_ID_H                           (volatile uint32_t *)0xfe4400dc
#define P_OTP_NSK_ID_L                             (volatile uint32_t *)0xfe4400e0
#define P_OTP_NSK_ID_H                             (volatile uint32_t *)0xfe4400e4
#define P_OTP_REE_RDY                              (volatile uint32_t *)0xfe440100
#define P_OTP_REE_DEBUG                            (volatile uint32_t *)0xfe440104
#define P_OTP_REE_CFG                              (volatile uint32_t *)0xfe440108
#define P_OTP_MRK_CHKNUM                           (volatile uint32_t *)0xfe44010c
#define P_OTP_REE_RD_DAT                           (volatile uint32_t *)0xfe440120
//========================================================================
// KL REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440200
// -----------------------------------------------
#define P_MKL_TEE_RDY                              (volatile uint32_t *)0xfe440200
#define P_MKL_TEE_DEBUG                            (volatile uint32_t *)0xfe440204
#define P_MKL_TEE_CFG                              (volatile uint32_t *)0xfe440208
#define P_MKL_TEE_CMD                              (volatile uint32_t *)0xfe44020c
#define P_MKL_TEE_EK                               (volatile uint32_t *)0xfe440210
#define P_MKL_TEE_CR_0                             (volatile uint32_t *)0xfe440270
#define P_MKL_TEE_CR_1                             (volatile uint32_t *)0xfe440274
#define P_MKL_TEE_CR_2                             (volatile uint32_t *)0xfe440278
#define P_MKL_TEE_CR_3                             (volatile uint32_t *)0xfe44027c
#define P_MKL_REE_RDY                              (volatile uint32_t *)0xfe440280
#define P_MKL_REE_DEBUG                            (volatile uint32_t *)0xfe440284
#define P_MKL_REE_CFG                              (volatile uint32_t *)0xfe440288
#define P_MKL_REE_CMD                              (volatile uint32_t *)0xfe44028c
#define P_MKL_REE_EK                               (volatile uint32_t *)0xfe440290
//========================================================================
// DMA REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440400
// -----------------------------------------------
#define P_DMA_CORE_DSC_0                           (volatile uint32_t *)0xfe440400
#define P_DMA_CORE_DSC_1                           (volatile uint32_t *)0xfe440404
#define P_DMA_CORE_DSC_2                           (volatile uint32_t *)0xfe440408
#define P_DMA_CORE_DSC_3                           (volatile uint32_t *)0xfe44040c
#define P_DMA_CORE_DSC_4                           (volatile uint32_t *)0xfe440410
#define P_DMA_CORE_DSC_5                           (volatile uint32_t *)0xfe440414
#define P_DMA_CORE_IRQ_STS_0                       (volatile uint32_t *)0xfe440420
#define P_DMA_CORE_IRQ_STS_1                       (volatile uint32_t *)0xfe440424
#define P_DMA_CORE_IRQ_STS_2                       (volatile uint32_t *)0xfe440428
#define P_DMA_CORE_IRQ_STS_3                       (volatile uint32_t *)0xfe44042c
#define P_DMA_CORE_IRQ_STS_4                       (volatile uint32_t *)0xfe440430
#define P_DMA_CORE_IRQ_STS_5                       (volatile uint32_t *)0xfe440434
#define P_DMA_CORE_CFG_REG                         (volatile uint32_t *)0xfe440440
#define P_DMA_CORE_CFG_SEC_LSB                     (volatile uint32_t *)0xfe440444
#define P_DMA_CORE_CFG_SEC_MSB                     (volatile uint32_t *)0xfe440448
//========================================================================
// KT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440500
// -----------------------------------------------
#define P_KT_TEE_RDY                               (volatile uint32_t *)0xfe440500
#define P_KT_TEE_RDY2                              (volatile uint32_t *)0xfe440504
#define P_KT_TEE_CFG                               (volatile uint32_t *)0xfe440508
#define P_KT_TEE_STS                               (volatile uint32_t *)0xfe44050c
#define P_KT_TEE_KEY0                              (volatile uint32_t *)0xfe440510
#define P_KT_TEE_KEY1                              (volatile uint32_t *)0xfe440514
#define P_KT_TEE_KEY2                              (volatile uint32_t *)0xfe440518
#define P_KT_TEE_KEY3                              (volatile uint32_t *)0xfe44051c
#define P_KT_REE_RDY                               (volatile uint32_t *)0xfe440580
#define P_KT_REE_RDY2                              (volatile uint32_t *)0xfe440584
#define P_KT_REE_CFG                               (volatile uint32_t *)0xfe440588
#define P_KT_REE_STS                               (volatile uint32_t *)0xfe44058c
#define P_KT_REE_KEY0                              (volatile uint32_t *)0xfe440590
#define P_KT_REE_KEY1                              (volatile uint32_t *)0xfe440594
#define P_KT_REE_KEY2                              (volatile uint32_t *)0xfe440598
#define P_KT_REE_KEY3                              (volatile uint32_t *)0xfe44059c
//========================================================================
// CERT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440600
// -----------------------------------------------
//========================================================================
// SP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe441000
// -----------------------------------------------
//ree domain
#define P_REE_SCPU2REE_CSR_ADDR                    (volatile uint32_t *)0xfe441c00
#define P_REE_SCPU2REE_DATA_ST_ADDR                (volatile uint32_t *)0xfe441e00
#define P_REE_SCPU2REE_DATA_ED_ADDR                (volatile uint32_t *)0xfe441e7c
#define P_REE_REE2SCPU_CSR_ADDR                    (volatile uint32_t *)0xfe441800
#define P_REE_REE2SCPU_DATA_ST_ADDR                (volatile uint32_t *)0xfe441a00
#define P_REE_REE2SCPU_DATA_ED_ADDR                (volatile uint32_t *)0xfe441a7c
//tee domain
#define P_TEE_SCPU2TEE_CSR_ADDR                    (volatile uint32_t *)0xfe441400
#define P_TEE_SCPU2TEE_DATA_ST_ADDR                (volatile uint32_t *)0xfe441600
#define P_TEE_SCPU2TEE_DATA_ED_ADDR                (volatile uint32_t *)0xfe44167c
#define P_TEE_TEE2SCPU_CSR_ADDR                    (volatile uint32_t *)0xfe441000
#define P_TEE_TEE2SCPU_DATA_ST_ADDR                (volatile uint32_t *)0xfe441200
#define P_TEE_TEE2SCPU_DATA_ED_ADDR                (volatile uint32_t *)0xfe44127c
//========================================================================
// NSK REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe450000
// -----------------------------------------------
//
// Closing file:  REG_LIST_SECURITY_RTL.h
//
//
// Reading file:  REG_LIST_DEMUX_RTL.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe034000
// -----------------------------------------------
// There are two instantiations under one CBUS slave.  Each CBUS slave can support
// 256 registers.  Each demux is allocated 128 registers so set the offset in
// the middle
// Copy this define but don't add a base address
#define SECOND_DEMUX_OFFSET_0  0x50
#define THIRD_DEMUX_OFFSET_0   0xa0
//========================================================================
//  STB TOP Registers				    (8'hf0 - 8'hf7)
//========================================================================
// Bit 5:4 -- fec_sel_demux_2
// Bit 3:2 -- fec_sel_demux_1
// Bit 1:0 -- fec_sel_demux_0
#define P_TS_TOP_CONFIG1                           (volatile uint32_t *)0xfe03413c
// Bit 31:24 -- file_m2ts_skip_bytes_hiu1
// Bit 23:22 -- reserved
// Bit 21 -- ts_hiu_enable_hiu1
// Bit 20:16 -- fec_clk_div_hiu1
// Bit 15:8 -- TS_package_length_sub_1_hiu1 (default : 187)
// Bit 7:0 -- fec_sync_byte_hiu1 (default : 0x47)
#define P_TS_HIU1_CONFIG                           (volatile uint32_t *)0xfe034138
//bit[1:0]--   stb_recorder2_sel
#define P_STB_RECORDER2_CNTL                       (volatile uint32_t *)0xfe0343b8
// bit [11]--   s2p2_disable
// bit [10:7]-- s2p2_clk_div
// bit [6:0]--  fec_serial_control_2
#define P_STB_S2P2_CONFIG                          (volatile uint32_t *)0xfe0343bc
// bit 30:28 -- ciplus_o_sel
// bit 27:26 -- ciplus_i_sel
// bit 25 -- use FAIL fro TS2
// bit 24 -- use FAIL fro TS1
// bit 23 -- use FAIL fro TS0
// bit 22 -- invert fec_error for S2P1
// bit 21 -- invert fec_data for S2P1
// bit 20 -- invert fec_sync for S2P1
// bit 19 -- invert fec_valid for S2P1
// bit 18 -- invert fec_clk for S2P1
// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
// Bit 15 -- enable_des_pl_clk
// Bit 14 -- ts_out_select[3]
// Bit 13 --  use FAIL for TS3
// Bit 12:10 -- ts_out_select[2:0], 0-TS0, 1-TS1, 2-TS2, 3-TS3, 4-S2P2, 5-S2P1, 6-S2P0, 7-File, 8-File1
// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
// bit 7 -- enable_des_pl
// bit 6 -- invert fec_error for S2P0
// bit 5 -- invert fec_data for S2P0
// bit 4 -- invert fec_sync for S2P0
// bit 3 -- invert fec_valid for S2P0
// bit 2 -- invert fec_clk for S2P0
// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
#define P_STB_TOP_CONFIG                           (volatile uint32_t *)0xfe0343c0
// 31:28 - s2p1_clk_div
// 27:24 - s2p0_clk_div
// 23    - s2p1_disable
// 22    - s2p0_disable
// 21    - Reserved
// 20 -- TS_OUT_error_INVERT
// 19 -- TS_OUT_data_INVERT
// 18 -- TS_OUT_sync_INVERT
// 17 -- TS_OUT_valid_INVERT
// 16 -- TS_OUT_clk_INVERT
// 15:8 -- TS_package_length_sub_1 (default : 187)
//  7:0 -- fec_sync_byte (default : 0x47)
#define P_TS_TOP_CONFIG                            (volatile uint32_t *)0xfe0343c4
// Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3
// Bit 23:16 -- file_m2ts_skip_bytes
// Bit 15:8 -- des_out_dly
// Bit 7:6 -- transport_scrambling_control_odd // should be 3
// Bit 5 -- ts_hiu_enable
// Bit 4:0 -- fec_clk_div
#define P_TS_FILE_CONFIG                           (volatile uint32_t *)0xfe0343c8
// Bit 19:14 -- des_2 ts pl state   -- Read Only
// Bit 13:8 -- des ts pl state   -- Read Only
// Bit 3:0 PID index to 8 PID to get key-set
// auto increase after TS_PL_PID_DATA read/write
#define P_TS_PL_PID_INDEX                          (volatile uint32_t *)0xfe0343cc
// Bit 13 -- PID match disable
// Bit 12:0 -- PID
#define P_TS_PL_PID_DATA                           (volatile uint32_t *)0xfe0343d0
#define P_COMM_DESC_KEY0                           (volatile uint32_t *)0xfe0343d4
#define P_COMM_DESC_KEY1                           (volatile uint32_t *)0xfe0343d8
#define P_COMM_DESC_KEY_RW                         (volatile uint32_t *)0xfe0343dc
// CI+ Register defines
// Bits[31:0] of the key
#define P_CIPLUS_KEY0                              (volatile uint32_t *)0xfe0343e0
// Bits[63:32] of the key
#define P_CIPLUS_KEY1                              (volatile uint32_t *)0xfe0343e4
// Bits[95:64] of the key
#define P_CIPLUS_KEY2                              (volatile uint32_t *)0xfe0343e8
// Bits[127:96] of the key
#define P_CIPLUS_KEY3                              (volatile uint32_t *)0xfe0343ec
// bit[5] write AES IV B value
// bit[4] write AES IV A value
// bit[3] write AES B key
// bit[2] write AES A key
// bit[1] write DES B key
// bit[0] write DES A key
#define P_CIPLUS_KEY_WR                            (volatile uint32_t *)0xfe0343f0
// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
// [3]      General enable for the ciplus module
// [2]      AES CBC disable (default should be 0 to enable AES CBC)
// [1]      AES Enable
// [0]      DES Enable
#define P_CIPLUS_CONFIG                            (volatile uint32_t *)0xfe0343f4
// bit[31:28] AES IV endian
// bit[27:24] AES message out endian
// bit[23:20] AES message in endian
// bit[19:16] AES key endian
// bit[15:11]  unused
// bit[10:8]  DES message out endian
// bit[6:4]   DES message in endian
// bit[2:0]   DES key endian
#define P_CIPLUS_ENDIAN                            (volatile uint32_t *)0xfe0343f8
// bit 15:8 - des_out_dly_2
// bit   7 - reserved
// Bit   6-- enable_des_pl_clk_2
// bit   5 - enable_des_pl_2
// bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2
// bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
#define P_COMM_DESC_2_CTL                          (volatile uint32_t *)0xfe0343fc
//
// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
//        Instead, since the demux has multiple instances (and many registers) use a separate
//        script to create a separate stb_define.h for C-code.
//========================================================================
//  STB Registers				    (8'h00 - 8'h4f)
//
//========================================================================
// STB registers are 8'h0x
// Bit 15:0 -- version number : 0x0002  (v0.01)
// Bit 16 -- fec_select[3]
// Bit 15 -- fec_core_select 1 - select descramble output
// Bit 14:12 -  fec_select[2:0] 0-TS0, 1-TS1, 2-TS2, 3-TS3, 4-S2P2, 5-S2P1, 6-S2P0, 7-File, 8-File1
// Bit 11 -- FEC_CLK
// Bit 10 -- SOP
// Bit 9 -- D_VALID
// Bit 8 -- D_FAIL
// Bit 7:0 -- D_DATA 7:0
// bit 31 -- enable_free_clk_fec_data_valid
// bit 30 -- enable_free_clk_stb_reg
// bit 29 -- always_use_pes_package_length
// bit 28 -- disable_pre_incomplete_section_fix
// bit 27 -- pointer_field_multiple_pre_en
// bit 26 -- ignore_pre_incomplete_section
// bit 25 -- video2_enable
// bit 24:22 -- video2_type
// bit 21 -- do_not_trust_pes_package_length
// bit 20 (bit 4) -- Bypass use recoder path
// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
// bit 18 (bit 2) -- Disable Splicing
// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
// Bit 15 - do not trust section length
// Bit 14 - om cmd push even zero
// Bit 13 - set_buff_ready_even_not_busy
// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
// Bit 11 - discard_av_package -- for ts_recorder use only
// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
// Bit 9 - ts_recorder_enable
// Bit 8 - (table_id == 0xff) means section_end
// Bit 7 - do not send incomplete section
// Bit 6 - do not discard duplicate package
// Bit 5 - search SOP when transport_error_indicator
// Bit 4 - stb demux enable
// Bit 3 - do not reset state machine on SOP
// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
// Bit 1 - do not use SOP input ( check FEC sync byte instead )
// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
// bit 15:8 demux package length - 1 ( default : 187 )
// bit 7:0 default is 0x47
// bit 31:16 -- filter memory write data hi[31:16]
// bit 15:0 -- filter memory write data low [15:0]
// bit 31:24 -- advanced setting hi
// bit 23:16 -- advanced setting low
// bit 15 -- filter memory write data request
// bit 7:0 -- filter memory write addr
// bit 13:8 demux state  -- read only
// bit 7:4 -- maxnum section filter compare address
// bit 3:0 -- maxnum PID filter compare address
// bit 15 - transport_error_indicator
// bit 14 - payload_unit_start_indicator
// bit 13 - transport_priority
// bit 12:0 - PID
// bit 7:6 transport_scrambling_control
// bit 5:4 adaptation_field_control
// bit 3:0 continuity_counter
// bit 15:12 -- om_cmd_count (read only)
// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
// bit   5:3 -- type_stb_om_w_rd (read only)
// bit     2 -- unit_start_stb_om_w_rd (read only)
// bit     1 -- om_cmd_overflow (read only)
// bit     0 -- om_cmd_pending (read)
// bit     0 -- om_cmd_read_finished (write)
// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
// bit 11:0 -- offset for section data
// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
// bit 7:4 -- section buffer size for group 1
// bit 11:8 -- section buffer size for group 2
// bit 15:12 -- section buffer size for group 3
// section buffer busy status for buff 31:0 ( Read Only )
// section buffer write status for buff 31:0 -- Read
// clear buffer status ( buff READY and BUSY ) -- write
// bit 4:0 -- SEC_BUFFER_INDEX   RW
// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
// bit 14 -- output_section_buffer_valid
// bit 15 -- section_reset_busy (Read Only)
// bit 9:5 -- BYPASS PID number
// bit 4:0 -- PCR PID number
// bit 15:0 -- stream_id filter bit enable
// bit 7:0 -- stream_id filter target
// bit 12 -- PCR_EN
// bit 11:0 -- PCR90K_DIV
// bit 31:0 -- PCR[31:0] R/W
// bit 31:0 -- VPTS[31:0] R/W
// bit 31:0 -- VDTS[31:0] R/W
// bit 31:0 -- APTS[31:0] R/W
// bit 31:0 -- SPTS[31:0] R/W
// read -- status, write 1 clear status
// bit 15 -- SUB_PTS[32]
// bit 14 -- AUDIO_PTS[32]
// bit 13 -- VIDEO_DTS[32]
// bit 12 -- VIDEO_PTS[32]
// bit 3 -- sub_pts_ready
// bit 2 -- audio_pts_ready
// bit 1 -- video_dts_ready
// bit 0 -- video_pts_ready
// bit 3:0 --
//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]
//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
//  2 -- pes_package_bytes_left[15:0]
//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
//
// read only
// bit[31] -- no_match_record_en
// bit[30:16] - reserved
// default : 0x807f
// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)
// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
// 15:0  WRITE 1 CLEAR to clear interrupt source
//12 -- INPUT_TIME_OUT
//11 -- PCR_ready
//10 -- audio_splicing_point
// 9 -- video_splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN
// Bit 5:3 - demux om write endian control for bypass
// Bit 2:0 - demux om write endian control for section
// When Bit 31 - 1 write will indicate all type use separate endian (Write Only)
// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
// Bit 17:15 - demux om write endian control for SUB_PACKET
// Bit 14:12 - demux om write endian control for AUDIO_PACKET
// Bit 11:9  - demux om write endian control for VIDEO_PACKET
//
// When Bit 31 - 0 write will indicate all type else use Bit 8:6
// Bit 8:6 - demux om write endian control for else
// Bit 10:9 -- sel DPTS_wr_ptr: 00 from parserA ; 01 from parserB
// Bit 8:7 -- use hi_bsf interface: 01 sel hiu0; 10 sel hiu1
// Bit 6:2 - Reserved
// Bit 1 - enable_halt_ts_hiu_fix
// Bit 0 - enable_halt_ts_hiu
// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
// bit 10 -- mask bit for SUB_AHB_DMA_EN
// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
// bit 8 -- mask bit for SECTION_AHB_DMA_EN
// bit 7 -- mask bit for recoder stream
// bit 6:0 -- mask bit for each type
// bit 31:0 -- vb_wr_ptr for video PDTS
// bit 31:0 -- ab_wr_ptr for audio PDTS
// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
// bit 19:0 -- SB_START (sb_start << 12 == byte address);
// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)
// bit 31:0 -- sb_wr_ptr for sub PES
// bit 31:16 -- ob_wr_ptr for other PES
// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
// bit 19:0 -- OB_START (ob_start << 12 == byte address);
// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)
// bit 31:0 -- ob_wr_ptr for sub PES
// 15:0  DEMUX interrupt MASK
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN
// 31:16 VIDEO PID filter data
//15 -- splicing VIDEO PID change enable
//14:10 -- VIDEO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only)
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 31:16 AUDIO PID filter data
//15 -- splicing AUDIO PID change enable
//14:10 -- AUDIO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only)
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 23:16 M2TS_SKIP_BYTES
// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
// 7:0  PACKAGE BYTE COUNT (Read Only)
// 15:0 2 bytes strong sync add to PES
// bit 15 -- stb_om_ren
// bit 14:11 -- reserved
// bit  10:0 -- OM_DATA_RD_ADDR
// bit 15:0 -- OM_DATA_RD
// AUTO STOP SETTING for 32 channels
// 4-nbits per channel
// when write
// bit 3 -- set section active
// bit 2:0 -- auto stop after count (0 means never stop)
// when read
// bit 3 -- current active status (1 - active, 0 - stopped )
// bit 2:0 -- count down to auto stop
// section 31:24
// section 23:16
// section 15:8
// section 7:0
// bit 31:0 reset channel status - each bit reset each channel
// read -- 32 channel status
// bit 4 -- video_stamp_use_dts
// bit 3 -- audio_stamp_sync_1_en
// bit 2 -- audio_stamp_insert_en
// bit 1 -- video_stamp_sync_1_en
// bit 0 -- video_stamp_insert_en
// Write : Bit[4:0] secter filter number for reset
// Read  : select according to output_section_buffer_valid :
//         per bit per section buffer valid status
//         or section_buffer_ignore
// bit[31:0] - channel_reset_timeout_disable
// bit[31] - no_match_reset_timeout_disable
// bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count
// bit[31:0] - channel_packet_count_disable
// bit[31] - no_match_packet_count_disable
// bit[30:0] input_packet_count
// bit[31:0] channel_record_enable
// bit[31:0] channel_process_enable
// bit[31:24] small_sec_size ((n+1) * 256 Bytes)
// bit[23:16] small_sec_rd_ptr
// bit[15:8]  small_sec_wr_ptr
// bit[7:2]   reserved
// bit[1] small_sec_wr_ptr_wr_enable
// bit[0] small_section_enable
// bit[31:0] small_sec_start_addr
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  REG_LIST_DEMUX_RTL.h
//
//=======================================================================
// DEMOD
//=======================================================================
//`include "demod_reg.h"
//`include "demod_dvbt2_reg.h"
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./REG_LIST_RTL.h
//
//
// Reading file:  ./vcbus_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
//===========================================================================
//
// Reading file:  rdma_regs.h
//
//===========================================================================
// RDMA registers 0x00 - 0xff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  RDMA_VCBUS_BASE = 0x11
// -----------------------------------------------
// Bit 31: 0 RW AHB start address for manual start DMA
#define P_RDMA_AHB_START_ADDR_MAN                  (volatile uint32_t *)0xff004400
// Bit 31: 0 RW AHB end address for manual start DMA
#define P_RDMA_AHB_END_ADDR_MAN                    (volatile uint32_t *)0xff004404
// Bit 31: 0 RW AHB start address for auto start source 1
#define P_RDMA_AHB_START_ADDR_1                    (volatile uint32_t *)0xff004408
// Bit 31: 0 RW AHB end address for auto start source 1
#define P_RDMA_AHB_END_ADDR_1                      (volatile uint32_t *)0xff00440c
// Bit 31: 0 RW AHB start address for auto start source 2
#define P_RDMA_AHB_START_ADDR_2                    (volatile uint32_t *)0xff004410
// Bit 31: 0 RW AHB end address for auto start source 2
#define P_RDMA_AHB_END_ADDR_2                      (volatile uint32_t *)0xff004414
// Bit 31: 0 RW AHB start address for auto start source 3
#define P_RDMA_AHB_START_ADDR_3                    (volatile uint32_t *)0xff004418
// Bit 31: 0 RW AHB end address for auto start source 3
#define P_RDMA_AHB_END_ADDR_3                      (volatile uint32_t *)0xff00441c
// Bit 31: 0 RW AHB start address for auto start source 4
#define P_RDMA_AHB_START_ADDR_4                    (volatile uint32_t *)0xff004420
// Bit 31: 0 RW AHB end address for auto start source 4
#define P_RDMA_AHB_END_ADDR_4                      (volatile uint32_t *)0xff004424
// Bit 31: 0 RW AHB start address for auto start source 5
#define P_RDMA_AHB_START_ADDR_5                    (volatile uint32_t *)0xff004428
// Bit 31: 0 RW AHB end address for auto start source 5
#define P_RDMA_AHB_END_ADDR_5                      (volatile uint32_t *)0xff00442c
// Bit 31: 0 RW AHB start address for auto start source 6
#define P_RDMA_AHB_START_ADDR_6                    (volatile uint32_t *)0xff004430
// Bit 31: 0 RW AHB end address for auto start source 6
#define P_RDMA_AHB_END_ADDR_6                      (volatile uint32_t *)0xff004434
// Bit 31: 0 RW AHB start address for auto start source 7
#define P_RDMA_AHB_START_ADDR_7                    (volatile uint32_t *)0xff004438
// Bit 31: 0 RW AHB end address for auto start source 7
#define P_RDMA_AHB_END_ADDR_7                      (volatile uint32_t *)0xff00443c
// Auto start DMA control:
// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
// Bit     4 R  Rsrv.
// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
// Bit     0 R  Rsrv.
#define P_RDMA_ACCESS_AUTO                         (volatile uint32_t *)0xff004440
#define P_RDMA_ACCESS_AUTO2                        (volatile uint32_t *)0xff004444
// Manual start DMA control:
// Bit 31: 3 R  Rsrv.
// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
#define P_RDMA_ACCESS_MAN                          (volatile uint32_t *)0xff00444c
// RDMA general control:
// Bit 31:25 R  Rsrv.
// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
// Bit 23:19 R  Rsrv.
// Bit 18:13 R  Rsrv.
// Bit 12: 7 R  Rsrv.
// Bit     6 RW ctrl_ddr_urgent.
// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
//                                      1=ABH write request burst size 24;
//                                      2=ABH write request burst size 32;
//                                      3=ABH write request burst size 48.
// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
//                                      1=ABH read request burst size 24;
//                                      2=ABH read request burst size 32;
//                                      3=ABH read request burst size 48.
// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logic except register.
// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
#define P_RDMA_CTRL                                (volatile uint32_t *)0xff004450
// Read only.
// Bit 31:29 R  Rsrv.
// Bit    28 R  rdma_done_int.
// Bit 27:25 R  Rsrv.
// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
#define P_RDMA_STATUS                              (volatile uint32_t *)0xff004454
#define P_RDMA_STATUS2                             (volatile uint32_t *)0xff004458
#define P_RDMA_STATUS3                             (volatile uint32_t *)0xff00445c
#define P_RDMA_ACCESS_AUTO4                        (volatile uint32_t *)0xff004460
#define P_RDMA_SRAM_CNTL                           (volatile uint32_t *)0xff004480
#define P_RDMA_SRAM_REGADDR                        (volatile uint32_t *)0xff004484
#define P_RDMA_SRAM_REGDATA                        (volatile uint32_t *)0xff004488
#define P_RDMA_AUTO_SRC1_SEL                       (volatile uint32_t *)0xff00448c
#define P_RDMA_AUTO_SRC2_SEL                       (volatile uint32_t *)0xff004490
#define P_RDMA_AUTO_SRC3_SEL                       (volatile uint32_t *)0xff004494
#define P_RDMA_AUTO_SRC4_SEL                       (volatile uint32_t *)0xff004498
#define P_RDMA_AUTO_SRC5_SEL                       (volatile uint32_t *)0xff00449c
#define P_RDMA_AUTO_SRC6_SEL                       (volatile uint32_t *)0xff0044a0
#define P_RDMA_AUTO_SRC7_SEL                       (volatile uint32_t *)0xff0044a4
//
// Closing file:  rdma_regs.h
//
//
// Reading file:  vpu_vdin0_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VDIN0_VCBUS_BASE = 0x12
// -----------------------------------------------
//
// Reading file:  vpu_vdin_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
#define P_VDIN_SCALE_COEF_IDX                      (volatile uint32_t *)0xff004800
#define P_VDIN_SCALE_COEF                          (volatile uint32_t *)0xff004804
//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
//bit 30,   mpeg_field info which can be written by software
//Bit 29,   force go_field, pulse signal
//Bit 28,   force go_line, pulse signal
//Bit 27,   enable mpeg_go_field input signal
//Bit 26:20, hold lines
//Bit 19,   delay go_field function enable
//Bit 18:12, delay go_field line number
//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 5,   input window selection function enable
//Bit 4, enable VDIN common data input, otherwise there will be no video data input
//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digital video input, 7: loopback from Viu1, 8: MIPI.
#define P_VDIN_COM_CTRL0                           (volatile uint32_t *)0xff004808
//Bit 28:16 active_max_pix_cnt, readonly
//Bit 12:0  active_max_pix_cnt_shadow, readonly
#define P_VDIN_ACTIVE_MAX_PIX_CNT_STATUS           (volatile uint32_t *)0xff00480c
//Bit 28:16 go_line_cnt, readonly
//Bit 12:0  active_line_cnt, readonly
#define P_VDIN_LCNT_STATUS                         (volatile uint32_t *)0xff004810
//Readonly
//Bit [14:3] lfifo_buf_cnt
//Bit 2, vdin_direct_done status
//Bit 1, vdin_nr_done status
//Bit 0, field
#define P_VDIN_COM_STATUS0                         (volatile uint32_t *)0xff004814
//Readonly
//Bit 31, vdi4 fifo overflow
//Bit 29:24, vdi3_asfifo_cnt
//Bit 23, vdi3 fifo overflow
//Bit 21:16, vdi3_asfifo_cnt
//Bit 15, vdi2 fifo overflow
//Bit 13:8, vdi2_asfifo_cnt
//Bit 7, vdi1 fifo overflow
//Bit 5:0, vdi1_asfifo_cnt
#define P_VDIN_COM_STATUS1                         (volatile uint32_t *)0xff004818
//Bit 28:16 go_line_cnt_shadow, readonly
//Bit 12:0  active_line_cnt_shadow, readonly
#define P_VDIN_LCNT_SHADOW_STATUS                  (volatile uint32_t *)0xff00481c
//each 8bit asfifo_ctrl is following:
//Bit 7, DE  enable
//Bit 6, go field enable
//Bit 5, go line enable
//Bit 4, if true, negative active input vsync
//Bit 3, if true, negative active input hsync
//Bit 2, vsync soft reset fifo enable
//Bit 1, overflow status clear
//Bit 0 asfifo soft reset, level signal
//Bit 7:0 vdi1 asfifo_ctrl
//Bit 23:16 vdi2 asfifo_ctrl
#define P_VDIN_ASFIFO_CTRL0                        (volatile uint32_t *)0xff004820
//Bit 7:0 vdi3 asfifo_ctrl
//Bit 23:16 vdi4 asfifo_ctrl
#define P_VDIN_ASFIFO_CTRL1                        (volatile uint32_t *)0xff004824
//Bit 28:16 input width minus 1, after the window function
//Bit 12:0  output width minus 1
#define P_VDIN_WIDTHM1I_WIDTHM1O                   (volatile uint32_t *)0xff004828
//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
//Bit 7, prehsc_en
//Bit 6, hsc_en,
//Bit 5, hsc_short_lineo_en, short line output enable
//Bit 4, hsc_nearest_en
//Bit 3, hsc_phase0_always_en
//Bit 2:0, hsc_bank_length
#define P_VDIN_SC_MISC_CTRL                        (volatile uint32_t *)0xff00482c
//Bit 28:24, integer portion
//Bit 23:0, fraction portion
#define P_VDIN_HSC_PHASE_STEP                      (volatile uint32_t *)0xff004830
//Bit 30:29    hscale rpt_p0_num
//Bit 28:24    hscale ini_rcv_num
//Bit 23:0     hscale ini_phase
#define P_VDIN_HSC_INI_CTRL                        (volatile uint32_t *)0xff004834
//Read only
//Bit 23, vdi7 fifo overflow
//Bit 21:16, vdi7_asfifo_cnt
//Bit 15, vdi6 fifo overflow
//Bit 13:8, vdi6_asfifo_cnt
//Bit 7, vdi5 fifo overflow
//Bit 5:0, vdi5_asfifo_cnt
#define P_VDIN_COM_STATUS2                         (volatile uint32_t *)0xff004838
//Bit 25:16 asfifo decimate control
//Bit 25, if true, decimation counter sync with first valid DE in the field,
//otherwise the decimation counter is not sync with external signal
//Bit 24, decimation de enable
//Bit 23:20, decimation phase, which counter value use to decimate,
//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 ....
//Bit 7:0 vdi5 asfifo_ctrl
#define P_VDIN_ASFIFO_CTRL2                        (volatile uint32_t *)0xff00483c
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define P_VDIN_MATRIX_CTRL                         (volatile uint32_t *)0xff004840
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VDIN_MATRIX_COEF00_01                    (volatile uint32_t *)0xff004844
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VDIN_MATRIX_COEF02_10                    (volatile uint32_t *)0xff004848
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VDIN_MATRIX_COEF11_12                    (volatile uint32_t *)0xff00484c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VDIN_MATRIX_COEF20_21                    (volatile uint32_t *)0xff004850
//BIt 18:16 conv_rs
//Bit 12:0  coef22
#define P_VDIN_MATRIX_COEF22                       (volatile uint32_t *)0xff004854
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VDIN_MATRIX_OFFSET0_1                    (volatile uint32_t *)0xff004858
//Bit 10:0  offset2
#define P_VDIN_MATRIX_OFFSET2                      (volatile uint32_t *)0xff00485c
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VDIN_MATRIX_PRE_OFFSET0_1                (volatile uint32_t *)0xff004860
//Bit 10:0  pre_offset2
#define P_VDIN_MATRIX_PRE_OFFSET2                  (volatile uint32_t *)0xff004864
//12:0 lfifo_buf_size
#define P_VDIN_LFIFO_CTRL                          (volatile uint32_t *)0xff004868
#define P_VDIN_COM_GCLK_CTRL                       (volatile uint32_t *)0xff00486c
//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
#define P_VDIN_INTF_WIDTHM1                        (volatile uint32_t *)0xff004870
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define P_VDIN_LFIFO_URG_CTRL                      (volatile uint32_t *)0xff004878
//Bit 8, 1: discard data before line fifo, 0: normal mode
//Bit 7:0 Write chroma canvas address
#define P_VDIN_WR_CTRL2                            (volatile uint32_t *)0xff00487c
//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
//                                                            1: Output every odd pixels' CbCr;
//                                                            2: Output an average value per even&odd pair of pixels;
//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
//Bit 28 clear write response counter in the vdin write memory interface
//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 23 vdin frame reset enable, if true, it will provide frame reset during go_field(vsync) to the modules after that
//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
//Bit 21 vdin direct write done status clear bit
//Bit 20 vdin NR write done status clear bit
//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
//                                                       1: Output every odd lines' CbCr;
//                                                       2: Reserved;
//                                                       3: Output all CbCr.
//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using
//Bit 10 1: disable ctrl_reg write pulse which will reset internal counter. when bit 11 is 1, this bit should be 1.
//Bit 9 vdin write request urgent
//Bit 8 vdin write request enable
//Bit 7:0 Write luma canvas address
#define P_VDIN_WR_CTRL                             (volatile uint32_t *)0xff004880
//Bit 29, if true, horizontal reverse
//Bit 28:16 start
//Bit 12:0  end
#define P_VDIN_WR_H_START_END                      (volatile uint32_t *)0xff004884
//Bit 29, if true, vertical reverse
//Bit 28:16 start
//Bit 15:13 field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//Bit 12:0  end
#define P_VDIN_WR_V_START_END                      (volatile uint32_t *)0xff004888
//Bit 24:20, integer portion
//Bit 19:0, fraction portion
#define P_VDIN_VSC_PHASE_STEP                      (volatile uint32_t *)0xff00488c
//Bit 23, vsc_en, vertical scaler enable
//Bit 22  if true, repeat last line while scaling, otherwise use the dummy data to extend the input picture
//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
//Bit 20:16 ini skip_line_num
//Bit 15:0 vscaler ini_phase
#define P_VDIN_VSC_INI_CTRL                        (volatile uint32_t *)0xff004890
//Bit 28:16, vshrink input height minus 1
//Bit 12:0, scaler input height minus 1
#define P_VDIN_SCIN_HEIGHTM1                       (volatile uint32_t *)0xff004894
//Bit 23:16, dummy component 0
//Bit 15:8, dummy component 1
//Bit 7:0, dummy component 2
#define P_VDIN_DUMMY_DATA                          (volatile uint32_t *)0xff004898
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VDIN_MATRIX_PROBE_COLOR                  (volatile uint32_t *)0xff0048a0
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VDIN_MATRIX_HL_COLOR                     (volatile uint32_t *)0xff0048a4
//28:16 probe x, postion
//12:0  probe y, position
#define P_VDIN_MATRIX_PROBE_POS                    (volatile uint32_t *)0xff0048a8
#define P_VDIN_CHROMA_ADDR_PORT                    (volatile uint32_t *)0xff0048ac
#define P_VDIN_CHROMA_DATA_PORT                    (volatile uint32_t *)0xff0048b0
//
#define P_VDIN_CM_BRI_CON_CTRL                     (volatile uint32_t *)0xff0048b4
//Bit 17  clk_cyc_cnt_clr, if true, clear this register
//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt
//Bit 15:0   line width using vpu clk
#define P_VDIN_GO_LINE_CTRL                        (volatile uint32_t *)0xff0048bc
//Bit 31:24 hist_pix_white_th, larger than this th is counted as white pixel
//Bit 23:16 hist_pix_black_th, less than this th is counted as black pixel
//Bit 11    hist_34bin_only,   34 bin only mode, including white/black
//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 8     ldim_stts_en
//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define P_VDIN_HIST_CTRL                           (volatile uint32_t *)0xff0048c0
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define P_VDIN_HIST_H_START_END                    (volatile uint32_t *)0xff0048c4
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define P_VDIN_HIST_V_START_END                    (volatile uint32_t *)0xff0048c8
//Bit 15:8  hist_max    maximum value
//Bit 7:0   hist_min    minimum value
//read only
#define P_VDIN_HIST_MAX_MIN                        (volatile uint32_t *)0xff0048cc
//Bit 31:0  hist_spl_rd
//counts for the total luma value
//read only
#define P_VDIN_HIST_SPL_VAL                        (volatile uint32_t *)0xff0048d0
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define P_VDIN_HIST_SPL_PIX_CNT                    (volatile uint32_t *)0xff0048d4
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value
//read only
#define P_VDIN_HIST_CHROMA_SUM                     (volatile uint32_t *)0xff0048d8
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
//VDIN_DNLP_HIST00[31:16] counts for the second bin
//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define P_VDIN_DNLP_HIST00                         (volatile uint32_t *)0xff0048dc
#define P_VDIN_DNLP_HIST01                         (volatile uint32_t *)0xff0048e0
#define P_VDIN_DNLP_HIST02                         (volatile uint32_t *)0xff0048e4
#define P_VDIN_DNLP_HIST03                         (volatile uint32_t *)0xff0048e8
#define P_VDIN_DNLP_HIST04                         (volatile uint32_t *)0xff0048ec
#define P_VDIN_DNLP_HIST05                         (volatile uint32_t *)0xff0048f0
#define P_VDIN_DNLP_HIST06                         (volatile uint32_t *)0xff0048f4
#define P_VDIN_DNLP_HIST07                         (volatile uint32_t *)0xff0048f8
#define P_VDIN_DNLP_HIST08                         (volatile uint32_t *)0xff0048fc
#define P_VDIN_DNLP_HIST09                         (volatile uint32_t *)0xff004900
#define P_VDIN_DNLP_HIST10                         (volatile uint32_t *)0xff004904
#define P_VDIN_DNLP_HIST11                         (volatile uint32_t *)0xff004908
#define P_VDIN_DNLP_HIST12                         (volatile uint32_t *)0xff00490c
#define P_VDIN_DNLP_HIST13                         (volatile uint32_t *)0xff004910
#define P_VDIN_DNLP_HIST14                         (volatile uint32_t *)0xff004914
#define P_VDIN_DNLP_HIST15                         (volatile uint32_t *)0xff004918
#define P_VDIN_DNLP_HIST16                         (volatile uint32_t *)0xff00491c
#define P_VDIN_DNLP_HIST17                         (volatile uint32_t *)0xff004920
#define P_VDIN_DNLP_HIST18                         (volatile uint32_t *)0xff004924
#define P_VDIN_DNLP_HIST19                         (volatile uint32_t *)0xff004928
#define P_VDIN_DNLP_HIST20                         (volatile uint32_t *)0xff00492c
#define P_VDIN_DNLP_HIST21                         (volatile uint32_t *)0xff004930
#define P_VDIN_DNLP_HIST22                         (volatile uint32_t *)0xff004934
#define P_VDIN_DNLP_HIST23                         (volatile uint32_t *)0xff004938
#define P_VDIN_DNLP_HIST24                         (volatile uint32_t *)0xff00493c
#define P_VDIN_DNLP_HIST25                         (volatile uint32_t *)0xff004940
#define P_VDIN_DNLP_HIST26                         (volatile uint32_t *)0xff004944
#define P_VDIN_DNLP_HIST27                         (volatile uint32_t *)0xff004948
#define P_VDIN_DNLP_HIST28                         (volatile uint32_t *)0xff00494c
#define P_VDIN_DNLP_HIST29                         (volatile uint32_t *)0xff004950
#define P_VDIN_DNLP_HIST30                         (volatile uint32_t *)0xff004954
#define P_VDIN_DNLP_HIST31                         (volatile uint32_t *)0xff004958
//Bit 31, local dimming statistic enable
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION
//Bit 6:0, region read index
//`define VDIN_LDIM_STTS_HIST_REGION_IDX       8'h57
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
//`define VDIN_LDIM_STTS_HIST_SET_REGION       8'h58
//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
//`define VDIN_LDIM_STTS_HIST_READ_REGION      8'h59
//Bit 18, reset bit, high active
//Bit 17, if true, widen hs/vs pulse
//Bit 16  vsync total counter always accumulating enable
//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
//Bit 11:4, vsync_span, define how many vsync span need to measure
//Bit 2:0  meas_hs_index, index to select which HS counter/range
#define P_VDIN_MEAS_CTRL0                          (volatile uint32_t *)0xff004968
//Read only
//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
//15:0      high bit portion of vsync total counter
#define P_VDIN_MEAS_VS_COUNT_HI                    (volatile uint32_t *)0xff00496c
//Read only
//31:0, low bit portion of vsync total counter
#define P_VDIN_MEAS_VS_COUNT_LO                    (volatile uint32_t *)0xff004970
//according to the meas_hs_index in register VDIN_MEAS_CTRL0
//meas_hs_index == 0, first hs range
//meas_hs_index == 1, second hs range
//meas_hs_index == 2, third hs range
//meas_hs_index == 3, fourth hs range
//bit 28:16 count_start
//bit 12:0 count_end
#define P_VDIN_MEAS_HS_RANGE                       (volatile uint32_t *)0xff004974
//Read only
//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
//meas_hs_index == 0, first range hs counter,
//meas_hs_index == 1, second range hs counter
//meas_hs_index == 2, third range hs counter
//meas_hs_index == 3, fourth range hs counter
//23:0
#define P_VDIN_MEAS_HS_COUNT                       (volatile uint32_t *)0xff004978
//Bit 8      white_enable
//Bit 7:0    blkbar_white_level
#define P_VDIN_BLKBAR_CTRL1                        (volatile uint32_t *)0xff00497c
// Bit 31:24 blkbar_black_level    threshold to judge a black point
// Bit 23:21 Reserved
// Bit 20:8  blkbar_hwidth         left and right region width
// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
// Bit 3     blkbar_det_en
// Bit 2:1   blkbar_din_sel
// bit blkbar_det_top_en
#define P_VDIN_BLKBAR_CTRL0                        (volatile uint32_t *)0xff004980
// Bit 31:29 Reserved
// Bit 28:16 blkbar_hstart.        Left region start
// Bit 15:13 Reserved
// Bit 12:0  blkbar_hend.          Right region end
#define P_VDIN_BLKBAR_H_START_END                  (volatile uint32_t *)0xff004984
// Bit 31:29 Reserved
// Bit 28:16 blkbar_vstart
// Bit 15:13 Reserved
// Bit 12:0  blkbar_vend
#define P_VDIN_BLKBAR_V_START_END                  (volatile uint32_t *)0xff004988
// Bit 31:20 Reserved
// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black
#define P_VDIN_BLKBAR_CNT_THRESHOLD                (volatile uint32_t *)0xff00498c
// Bit 31:29 Reserved
// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
// Bit 15:13 Reserved
// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
#define P_VDIN_BLKBAR_ROW_TH1_TH2                  (volatile uint32_t *)0xff004990
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
#define P_VDIN_BLKBAR_IND_LEFT_START_END           (volatile uint32_t *)0xff004994
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
#define P_VDIN_BLKBAR_IND_RIGHT_START_END          (volatile uint32_t *)0xff004998
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
#define P_VDIN_BLKBAR_IND_LEFT1_CNT                (volatile uint32_t *)0xff00499c
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
#define P_VDIN_BLKBAR_IND_LEFT2_CNT                (volatile uint32_t *)0xff0049a0
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT1_CNT               (volatile uint32_t *)0xff0049a4
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT2_CNT               (volatile uint32_t *)0xff0049a8
//Readonly
// Bit 31:30 Reserved
// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
// Bit 28:16 blkbar_top_pos.            Top black bar position
// Bit 15:13 Reserved.
// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
#define P_VDIN_BLKBAR_STATUS0                      (volatile uint32_t *)0xff0049ac
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_left_pos.       Left black bar position
// Bit 15:13 Reserved
// Bit 12:0  blkbar_right_pos.      Right black bar position
#define P_VDIN_BLKBAR_STATUS1                      (volatile uint32_t *)0xff0049b0
//Bit 28:16 input window H start
//Bit 12:0  input window H end
#define P_VDIN_WIN_H_START_END                     (volatile uint32_t *)0xff0049b4
//Bit 28:16 input window H start
//Bit 12:0  input window V start
#define P_VDIN_WIN_V_START_END                     (volatile uint32_t *)0xff0049b8
//Bit 23:16 vdi8 asfifo_ctrl
//Bit 15:8 vdi7 asfifo_ctrl
//Bit 7:0 vdi6 asfifo_ctrl
#define P_VDIN_ASFIFO_CTRL3                        (volatile uint32_t *)0xff0049bc
//Bit 3:2 vshrk_clk2_ctrl
//Bit 1:0 vshrk_clk1_ctrl
#define P_VDIN_COM_GCLK_CTRL2                      (volatile uint32_t *)0xff0049c0
//Bit 27 vshrk_en
//Bit 26:25 vshrk_mode
//Bit 24 vshrk_lpf_mode
//Bit 23:0 vshrk_dummy
#define P_VDIN_VSHRK_CTRL                          (volatile uint32_t *)0xff0049c4
#define P_VDIN_DNLP_HIST32                         (volatile uint32_t *)0xff0049c8
//Read only
//Bit 7, vdi9 fifo overflow
//Bit 5:0, vdi9_asfifo_cnt
#define P_VDIN_COM_STATUS3                         (volatile uint32_t *)0xff0049cc
#define P_VDIN_SYNC_MASK                           (volatile uint32_t *)0xff0049d0
//Bit 7:0,  hsync_mask_num
//Bit 15:8, vsync_mask_num
//Bit 16,   hsync_mask_enable
//Bit 17,   vsync_mask_num
//dolby vdin
#define P_VDIN_DOLBY_DSC_CTRL0                     (volatile uint32_t *)0xff0049d4
#define P_VDIN_DOLBY_DSC_CTRL1                     (volatile uint32_t *)0xff0049d8
#define P_VDIN_DOLBY_DSC_CTRL2                     (volatile uint32_t *)0xff0049dc
#define P_VDIN_DOLBY_DSC_CTRL3                     (volatile uint32_t *)0xff0049e0
#define P_VDIN_DOLBY_AXI_CTRL0                     (volatile uint32_t *)0xff0049e4
#define P_VDIN_DOLBY_AXI_CTRL1                     (volatile uint32_t *)0xff0049e8
#define P_VDIN_DOLBY_AXI_CTRL2                     (volatile uint32_t *)0xff0049ec
#define P_VDIN_DOLBY_AXI_CTRL3                     (volatile uint32_t *)0xff0049f0
#define P_VDIN_DOLBY_DSC_STATUS0                   (volatile uint32_t *)0xff0049f4
#define P_VDIN_DOLBY_DSC_STATUS1                   (volatile uint32_t *)0xff0049f8
#define P_VDIN_DOLBY_DSC_STATUS2                   (volatile uint32_t *)0xff0049fc
#define P_VDIN_DOLBY_DSC_STATUS3                   (volatile uint32_t *)0xff004874
//hdr2 0x80 - -0xc0
#define P_VDIN_HDR2_CTRL                           (volatile uint32_t *)0xff004a00
#define P_VDIN_HDR2_CLK_GATE                       (volatile uint32_t *)0xff004a04
#define P_VDIN_HDR2_MATRIXI_COEF00_01              (volatile uint32_t *)0xff004a08
#define P_VDIN_HDR2_MATRIXI_COEF02_10              (volatile uint32_t *)0xff004a0c
#define P_VDIN_HDR2_MATRIXI_COEF11_12              (volatile uint32_t *)0xff004a10
#define P_VDIN_HDR2_MATRIXI_COEF20_21              (volatile uint32_t *)0xff004a14
#define P_VDIN_HDR2_MATRIXI_COEF22                 (volatile uint32_t *)0xff004a18
#define P_VDIN_HDR2_MATRIXI_COEF30_31              (volatile uint32_t *)0xff004a1c
#define P_VDIN_HDR2_MATRIXI_COEF32_40              (volatile uint32_t *)0xff004a20
#define P_VDIN_HDR2_MATRIXI_COEF41_42              (volatile uint32_t *)0xff004a24
#define P_VDIN_HDR2_MATRIXI_OFFSET0_1              (volatile uint32_t *)0xff004a28
#define P_VDIN_HDR2_MATRIXI_OFFSET2                (volatile uint32_t *)0xff004a2c
#define P_VDIN_HDR2_MATRIXI_PRE_OFFSET0_1          (volatile uint32_t *)0xff004a30
#define P_VDIN_HDR2_MATRIXI_PRE_OFFSET2            (volatile uint32_t *)0xff004a34
#define P_VDIN_HDR2_MATRIXO_COEF00_01              (volatile uint32_t *)0xff004a38
#define P_VDIN_HDR2_MATRIXO_COEF02_10              (volatile uint32_t *)0xff004a3c
#define P_VDIN_HDR2_MATRIXO_COEF11_12              (volatile uint32_t *)0xff004a40
#define P_VDIN_HDR2_MATRIXO_COEF20_21              (volatile uint32_t *)0xff004a44
#define P_VDIN_HDR2_MATRIXO_COEF22                 (volatile uint32_t *)0xff004a48
#define P_VDIN_HDR2_MATRIXO_COEF30_31              (volatile uint32_t *)0xff004a4c
#define P_VDIN_HDR2_MATRIXO_COEF32_40              (volatile uint32_t *)0xff004a50
#define P_VDIN_HDR2_MATRIXO_COEF41_42              (volatile uint32_t *)0xff004a54
#define P_VDIN_HDR2_MATRIXO_OFFSET0_1              (volatile uint32_t *)0xff004a58
#define P_VDIN_HDR2_MATRIXO_OFFSET2                (volatile uint32_t *)0xff004a5c
#define P_VDIN_HDR2_MATRIXO_PRE_OFFSET0_1          (volatile uint32_t *)0xff004a60
#define P_VDIN_HDR2_MATRIXO_PRE_OFFSET2            (volatile uint32_t *)0xff004a64
#define P_VDIN_HDR2_MATRIXI_CLIP                   (volatile uint32_t *)0xff004a68
#define P_VDIN_HDR2_MATRIXO_CLIP                   (volatile uint32_t *)0xff004a6c
#define P_VDIN_HDR2_CGAIN_OFFT                     (volatile uint32_t *)0xff004a70
#define P_VDIN_EOTF_LUT_ADDR_PORT                  (volatile uint32_t *)0xff004a78
#define P_VDIN_EOTF_LUT_DATA_PORT                  (volatile uint32_t *)0xff004a7c
#define P_VDIN_OETF_LUT_ADDR_PORT                  (volatile uint32_t *)0xff004a80
#define P_VDIN_OETF_LUT_DATA_PORT                  (volatile uint32_t *)0xff004a84
#define P_VDIN_CGAIN_LUT_ADDR_PORT                 (volatile uint32_t *)0xff004a88
#define P_VDIN_CGAIN_LUT_DATA_PORT                 (volatile uint32_t *)0xff004a8c
#define P_VDIN_HDR2_CGAIN_COEF0                    (volatile uint32_t *)0xff004a90
#define P_VDIN_HDR2_CGAIN_COEF1                    (volatile uint32_t *)0xff004a94
#define P_VDIN_OGAIN_LUT_ADDR_PORT                 (volatile uint32_t *)0xff004a98
#define P_VDIN_OGAIN_LUT_DATA_PORT                 (volatile uint32_t *)0xff004a9c
#define P_VDIN_HDR2_ADPS_CTRL                      (volatile uint32_t *)0xff004aa0
#define P_VDIN_HDR2_ADPS_ALPHA0                    (volatile uint32_t *)0xff004aa4
#define P_VDIN_HDR2_ADPS_ALPHA1                    (volatile uint32_t *)0xff004aa8
#define P_VDIN_HDR2_ADPS_BETA0                     (volatile uint32_t *)0xff004aac
#define P_VDIN_HDR2_ADPS_BETA1                     (volatile uint32_t *)0xff004ab0
#define P_VDIN_HDR2_ADPS_BETA2                     (volatile uint32_t *)0xff004ab4
#define P_VDIN_HDR2_ADPS_COEF0                     (volatile uint32_t *)0xff004ab8
#define P_VDIN_HDR2_ADPS_COEF1                     (volatile uint32_t *)0xff004abc
#define P_VDIN_HDR2_GMUT_CTRL                      (volatile uint32_t *)0xff004ac0
#define P_VDIN_HDR2_GMUT_COEF0                     (volatile uint32_t *)0xff004ac4
#define P_VDIN_HDR2_GMUT_COEF1                     (volatile uint32_t *)0xff004ac8
#define P_VDIN_HDR2_GMUT_COEF2                     (volatile uint32_t *)0xff004acc
#define P_VDIN_HDR2_GMUT_COEF3                     (volatile uint32_t *)0xff004ad0
#define P_VDIN_HDR2_GMUT_COEF4                     (volatile uint32_t *)0xff004ad4
#define P_VDIN_HDR2_PIPE_CTRL1                     (volatile uint32_t *)0xff004ad8
#define P_VDIN_HDR2_PIPE_CTRL2                     (volatile uint32_t *)0xff004adc
#define P_VDIN_HDR2_PIPE_CTRL3                     (volatile uint32_t *)0xff004ae0
#define P_VDIN_HDR2_PROC_WIN1                      (volatile uint32_t *)0xff004ae4
#define P_VDIN_HDR2_PROC_WIN2                      (volatile uint32_t *)0xff004ae8
#define P_VDIN_HDR2_MATRIXI_EN_CTRL                (volatile uint32_t *)0xff004aec
#define P_VDIN_HDR2_MATRIXO_EN_CTRL                (volatile uint32_t *)0xff004af0
#define P_VDIN_HDR2_HIST_CTRL                      (volatile uint32_t *)0xff004af4
#define P_VDIN_HDR2_HIST_H_START_END               (volatile uint32_t *)0xff004af8
#define P_VDIN_HDR2_HIST_V_START_END               (volatile uint32_t *)0xff004afc
#define P_VDIN_HDR2_HIST_RD                        (volatile uint32_t *)0xff004a74
#define P_VDIN_WRARB_MODE                          (volatile uint32_t *)0xff004b00
#define P_VDIN_WRARB_REQEN_SLV                     (volatile uint32_t *)0xff004b04
#define P_VDIN_WRARB_WEIGH0_SLV                    (volatile uint32_t *)0xff004b08
#define P_VDIN_WRARB_WEIGH1_SLV                    (volatile uint32_t *)0xff004b0c
#define P_VDIN_RDWR_ARB_STATUS                     (volatile uint32_t *)0xff004b10
#define P_VDIN_ARB_DBG_CTRL                        (volatile uint32_t *)0xff004b14
#define P_VDIN_ARB_DBG_STAT                        (volatile uint32_t *)0xff004b18
#define P_VDIN_DBG_AXI_CMD_CNT                     (volatile uint32_t *)0xff004b1c
#define P_VDIN_DBG_AXI_DAT_CNT                     (volatile uint32_t *)0xff004b20
#define P_VDIN_CRC_CTRL                            (volatile uint32_t *)0xff004b24
#define P_VDIN_RO_CRC                              (volatile uint32_t *)0xff004b28
#define P_VDIN_LINE_INT                            (volatile uint32_t *)0xff004b2c
#define P_VDIN_WR_URGENT_CTRL                      (volatile uint32_t *)0xff00495c
#define P_VDIN_RO_WRMIF_STATUS                     (volatile uint32_t *)0xff004960
#define P_VDIN_WR_BADDR_LUMA                       (volatile uint32_t *)0xff004b30
#define P_VDIN_WR_BADDR_CHROMA                     (volatile uint32_t *)0xff004b34
#define P_VDIN_WR_STRIDE_LUMA                      (volatile uint32_t *)0xff004b38
#define P_VDIN_WR_STRIDE_CHROMA                    (volatile uint32_t *)0xff004b3c
//for vdin dolby descramble start
#define P_VDIN_DSC_CTRL                            (volatile uint32_t *)0xff004b40
//Bit   31:10     reserved
//Bit   9:4       reg_dithout_switch  ,uns, default = 36;//{2'h2,2'h1,2'h0}
//Bit   3,        reg_detunnel_en     ,uns, default = 1;
//Bit   2,        reg_detunnel_u_start,uns, default = 0;
//Bit   1,        reg_vdin_dith_en    ,uns, default = 1;
//Bit   0,        reg_descramble_en   ,uns, default = 1;
#define P_VDIN_CFMT_CTRL                           (volatile uint32_t *)0xff004b44
//Bit 31:9  reserved
//Bit 8     reg_chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 7:4   reg_chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 3     reg_chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 2:1   reg_chfmt_yc_ratio         uns, default = 1    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 0     reg_chfmt_en               uns, default = 1    ; //  horizontal formatter enable
#define P_VDIN_CFMT_W                              (volatile uint32_t *)0xff004b48
//Bit 31:29 reserved
//Bit 28:16 reg_chfmt_w                uns, default = 1920   ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  reg_cvfmt_w                uns, default = 960    ;vertical formatter width
#define P_VDIN_SCB_CTRL0                           (volatile uint32_t *)0xff004b4c
//Bit   31:12   reserved
//Bit   11      reg_444c422_gofield_en     uns, default = 1;
//Bit   10      reg_tunnel_en              uns, default = 1;
//Bit   9:4     reg_tunnel_outswitch       uns, default = 36;//{2'h2,2'h1,2'h0}
//Bit   3:2     reg_444c422_mode           uns, default = 0; //0:left 1:right 2,3:avg
//Bit   1       reg_444c422_bypass         uns, default = 0; 1:bypass
//Bit   0       reserved                   //pulse for frm_en
#define P_VDIN_SCB_CTRL1                           (volatile uint32_t *)0xff004b50
//Bit 31:29 reserved
//Bit 28:16 reg_444c422_hsize    uns, default = 1920   ;horizontal size
//Bit 15:13 reserved
//Bit 12:0  reg_444c422_vsize    uns, default = 960    ;vertical size
#define P_VDIN_DSC_HSIZE                           (volatile uint32_t *)0xff004b54
//Bit 31:29 reserved
//Bit 28:16 reg_detunnel_hsize uns, default = 1920   ;
//Bit 15:13 reserved
//Bit 12:0  reg_dither_hsize   uns, default = 1920   ;
#define P_VDIN_DSC_DETUNNEL_SEL                    (volatile uint32_t *)0xff004b58
//Bit 31:18 reserved
//Bit 17:0  reg_detunnel_sel   uns, default = 34658;  //{3'h1,3'h0,3'h3  ,3'h5,3'h4,3'h2}
#define P_VDIN_DSC_TUNNEL_SEL                      (volatile uint32_t *)0xff004b5c
//Bit 31:18 reserved
//Bit 17:0  reg_tunnel_sel   uns, default = 69868;  //= {3'h2,3'h1  ,3'h0,3'h3  ,3'h5,3'h4};
#define P_VDIN_HDR2_SIZE                           (volatile uint32_t *)0xff004b60
#define P_VDIN_VSHRK_SIZE_M1                       (volatile uint32_t *)0xff004b64
//dither
#define P_VDIN_DITH_CTRL                           (volatile uint32_t *)0xff004b80
#define P_VDIN_DITH_LUT_1                          (volatile uint32_t *)0xff004b84
#define P_VDIN_DITH_LUT_2                          (volatile uint32_t *)0xff004b88
#define P_VDIN_DITH_LUT_3                          (volatile uint32_t *)0xff004b8c
#define P_VDIN_DITH_LUT_4                          (volatile uint32_t *)0xff004b90
#define P_VDIN_DITH_LUT_5                          (volatile uint32_t *)0xff004b94
#define P_VDIN_DITH_LUT_6                          (volatile uint32_t *)0xff004b98
#define P_VDIN_DITH_LUT_7                          (volatile uint32_t *)0xff004b9c
#define P_VDIN_DITH_LUT_8                          (volatile uint32_t *)0xff004ba0
#define P_VDIN_DITH_LUT_9                          (volatile uint32_t *)0xff004ba4
#define P_VDIN_DITH_LUT_10                         (volatile uint32_t *)0xff004ba8
#define P_VDIN_DITH_LUT_11                         (volatile uint32_t *)0xff004bac
#define P_VDIN_DITH_LUT_12                         (volatile uint32_t *)0xff004bb0
//for vdin dolby descramble end
#define P_VDIN_HSK_CTRL                            (volatile uint32_t *)0xff004bbc
//Bit   31:23    reserved
//Bit   22:16    reg_hsk_size  ,uns, default = 4;
//Bit   15:13    reserved
//Bit   12:0     reg_frm_hsize ,uns, default = 1920;
#define P_VDIN_HSK_COEF_0                          (volatile uint32_t *)0xff004bc0
//Bit  31:0   reg_hsk_coef00  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_1                          (volatile uint32_t *)0xff004bc4
//Bit  31:0   reg_hsk_coef01  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_2                          (volatile uint32_t *)0xff004bc8
//Bit  31:0   reg_hsk_coef02  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_3                          (volatile uint32_t *)0xff004bcc
//Bit  31:0   reg_hsk_coef03  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define P_VDIN_HSK_COEF_4                          (volatile uint32_t *)0xff004bd0
//Bit  31:0   reg_hsk_coef04  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_5                          (volatile uint32_t *)0xff004bd4
//Bit  31:0   reg_hsk_coef05  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_6                          (volatile uint32_t *)0xff004bd8
//Bit  31:0   reg_hsk_coef06  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_7                          (volatile uint32_t *)0xff004bdc
//Bit  31:0   reg_hsk_coef07  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define P_VDIN_HSK_COEF_8                          (volatile uint32_t *)0xff004be0
//Bit  31:0   reg_hsk_coef08  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_9                          (volatile uint32_t *)0xff004be4
//Bit  31:0   reg_hsk_coef09  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_A                          (volatile uint32_t *)0xff004be8
//Bit  31:0   reg_hsk_coef10  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_B                          (volatile uint32_t *)0xff004bec
//Bit  31:0   reg_hsk_coef11  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define P_VDIN_HSK_COEF_C                          (volatile uint32_t *)0xff004bf0
//Bit  31:0   reg_hsk_coef12  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_D                          (volatile uint32_t *)0xff004bf4
//Bit  31:0   reg_hsk_coef13  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_E                          (volatile uint32_t *)0xff004bf8
//Bit  31:0   reg_hsk_coef14  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define P_VDIN_HSK_COEF_F                          (volatile uint32_t *)0xff004bfc
//Bit  31:0   reg_hsk_coef15  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_vdin_regs.h
//

//8'h72 occupied by histogram 32
//VDIN0        8'h00 - 8'h7f
#define VDIN0_SCALE_COEF_IDX                    (VDIN_SCALE_COEF_IDX               )
#define VDIN0_SCALE_COEF                        (VDIN_SCALE_COEF                   )
#define VDIN0_COM_CTRL0                         (VDIN_COM_CTRL0                    )
#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         (VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN0_LCNT_STATUS                       (VDIN_LCNT_STATUS                  )
#define VDIN0_COM_STATUS0                       (VDIN_COM_STATUS0                  )
#define VDIN0_COM_STATUS1                       (VDIN_COM_STATUS1                  )
#define VDIN0_LCNT_SHADOW_STATUS                (VDIN_LCNT_SHADOW_STATUS           )
#define VDIN0_ASFIFO_CTRL0                      (VDIN_ASFIFO_CTRL0                 )
#define VDIN0_ASFIFO_CTRL1                      (VDIN_ASFIFO_CTRL1                 )
#define VDIN0_WIDTHM1I_WIDTHM1O                 (VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN0_SC_MISC_CTRL                      (VDIN_SC_MISC_CTRL                 )
#define VDIN0_HSC_PHASE_STEP                    (VDIN_HSC_PHASE_STEP               )
#define VDIN0_HSC_INI_CTRL                      (VDIN_HSC_INI_CTRL                 )
#define VDIN0_COM_STATUS2                       (VDIN_COM_STATUS2                  )
#define VDIN0_COM_STATUS3                       (VDIN_COM_STATUS3                  )
#define VDIN0_ASFIFO_CTRL2                      (VDIN_ASFIFO_CTRL2                 )
#define VDIN0_MATRIX_CTRL                       (VDIN_MATRIX_CTRL                  )
#define VDIN0_MATRIX_COEF00_01                  (VDIN_MATRIX_COEF00_01             )
#define VDIN0_MATRIX_COEF02_10                  (VDIN_MATRIX_COEF02_10             )
#define VDIN0_MATRIX_COEF11_12                  (VDIN_MATRIX_COEF11_12             )
#define VDIN0_MATRIX_COEF20_21                  (VDIN_MATRIX_COEF20_21             )
#define VDIN0_MATRIX_COEF22                     (VDIN_MATRIX_COEF22                )
#define VDIN0_MATRIX_OFFSET0_1                  (VDIN_MATRIX_OFFSET0_1             )
#define VDIN0_MATRIX_OFFSET2                    (VDIN_MATRIX_OFFSET2               )
#define VDIN0_MATRIX_PRE_OFFSET0_1              (VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN0_MATRIX_PRE_OFFSET2                (VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN0_LFIFO_CTRL                        (VDIN_LFIFO_CTRL                   )
#define VDIN0_COM_GCLK_CTRL                     (VDIN_COM_GCLK_CTRL                )
#define VDIN0_INTF_WIDTHM1                      (VDIN_INTF_WIDTHM1                 )
#define VDIN0_WR_CTRL2                          (VDIN_WR_CTRL2                     )
#define VDIN0_WR_CTRL                           (VDIN_WR_CTRL                      )
#define VDIN0_WR_H_START_END                    (VDIN_WR_H_START_END               )
#define VDIN0_WR_V_START_END                    (VDIN_WR_V_START_END               )
#define VDIN0_VSC_PHASE_STEP                    (VDIN_VSC_PHASE_STEP               )
#define VDIN0_VSC_INI_CTRL                      (VDIN_VSC_INI_CTRL                 )
#define VDIN0_SCIN_HEIGHTM1                     (VDIN_SCIN_HEIGHTM1                )
#define VDIN0_DUMMY_DATA                        (VDIN_DUMMY_DATA                   )
#define VDIN0_MATRIX_PROBE_COLOR                (VDIN_MATRIX_PROBE_COLOR           )
#define VDIN0_MATRIX_HL_COLOR                   (VDIN_MATRIX_HL_COLOR              )
#define VDIN0_MATRIX_PROBE_POS                  (VDIN_MATRIX_PROBE_POS             )
#define VDIN0_CHROMA_ADDR_PORT                  (VDIN_CHROMA_ADDR_PORT             )
#define VDIN0_CHROMA_DATA_PORT                  (VDIN_CHROMA_DATA_PORT             )
#define VDIN0_CM_BRI_CON_CTRL                   (VDIN_CM_BRI_CON_CTRL              )
#define VDIN0_GO_LINE_CTRL                      (VDIN_GO_LINE_CTRL                 )
#define VDIN0_HIST_CTRL                         (VDIN_HIST_CTRL                    )
#define VDIN0_HIST_H_START_END                  (VDIN_HIST_H_START_END             )
#define VDIN0_HIST_V_START_END                  (VDIN_HIST_V_START_END             )
#define VDIN0_HIST_MAX_MIN                      (VDIN_HIST_MAX_MIN                 )
#define VDIN0_HIST_SPL_VAL                      (VDIN_HIST_SPL_VAL                 )
#define VDIN0_HIST_SPL_PIX_CNT                  (VDIN_HIST_SPL_PIX_CNT             )
#define VDIN0_HIST_CHROMA_SUM                   (VDIN_HIST_CHROMA_SUM              )
#define VDIN0_DNLP_HIST00                       (VDIN_DNLP_HIST00                  )
#define VDIN0_DNLP_HIST01                       (VDIN_DNLP_HIST01                  )
#define VDIN0_DNLP_HIST02                       (VDIN_DNLP_HIST02                  )
#define VDIN0_DNLP_HIST03                       (VDIN_DNLP_HIST03                  )
#define VDIN0_DNLP_HIST04                       (VDIN_DNLP_HIST04                  )
#define VDIN0_DNLP_HIST05                       (VDIN_DNLP_HIST05                  )
#define VDIN0_DNLP_HIST06                       (VDIN_DNLP_HIST06                  )
#define VDIN0_DNLP_HIST07                       (VDIN_DNLP_HIST07                  )
#define VDIN0_DNLP_HIST08                       (VDIN_DNLP_HIST08                  )
#define VDIN0_DNLP_HIST09                       (VDIN_DNLP_HIST09                  )
#define VDIN0_DNLP_HIST10                       (VDIN_DNLP_HIST10                  )
#define VDIN0_DNLP_HIST11                       (VDIN_DNLP_HIST11                  )
#define VDIN0_DNLP_HIST12                       (VDIN_DNLP_HIST12                  )
#define VDIN0_DNLP_HIST13                       (VDIN_DNLP_HIST13                  )
#define VDIN0_DNLP_HIST14                       (VDIN_DNLP_HIST14                  )
#define VDIN0_DNLP_HIST15                       (VDIN_DNLP_HIST15                  )
#define VDIN0_DNLP_HIST16                       (VDIN_DNLP_HIST16                  )
#define VDIN0_DNLP_HIST17                       (VDIN_DNLP_HIST17                  )
#define VDIN0_DNLP_HIST18                       (VDIN_DNLP_HIST18                  )
#define VDIN0_DNLP_HIST19                       (VDIN_DNLP_HIST19                  )
#define VDIN0_DNLP_HIST20                       (VDIN_DNLP_HIST20                  )
#define VDIN0_DNLP_HIST21                       (VDIN_DNLP_HIST21                  )
#define VDIN0_DNLP_HIST22                       (VDIN_DNLP_HIST22                  )
#define VDIN0_DNLP_HIST23                       (VDIN_DNLP_HIST23                  )
#define VDIN0_DNLP_HIST24                       (VDIN_DNLP_HIST24                  )
#define VDIN0_DNLP_HIST25                       (VDIN_DNLP_HIST25                  )
#define VDIN0_DNLP_HIST26                       (VDIN_DNLP_HIST26                  )
#define VDIN0_DNLP_HIST27                       (VDIN_DNLP_HIST27                  )
#define VDIN0_DNLP_HIST28                       (VDIN_DNLP_HIST28                  )
#define VDIN0_DNLP_HIST29                       (VDIN_DNLP_HIST29                  )
#define VDIN0_DNLP_HIST30                       (VDIN_DNLP_HIST30                  )
#define VDIN0_DNLP_HIST31                       (VDIN_DNLP_HIST31                  )
#define VDIN0_DNLP_HIST32                       (VDIN_DNLP_HIST32                  )
#define VDIN0_MEAS_CTRL0                        (VDIN_MEAS_CTRL0                   )
#define VDIN0_MEAS_VS_COUNT_HI                  (VDIN_MEAS_VS_COUNT_HI             )
#define VDIN0_MEAS_VS_COUNT_LO                  (VDIN_MEAS_VS_COUNT_LO             )
#define VDIN0_MEAS_HS_RANGE                     (VDIN_MEAS_HS_RANGE                )
#define VDIN0_MEAS_HS_COUNT                     (VDIN_MEAS_HS_COUNT                )
#define VDIN0_BLKBAR_CTRL1                      (VDIN_BLKBAR_CTRL1                 )
#define VDIN0_BLKBAR_CTRL0                      (VDIN_BLKBAR_CTRL0                 )
#define VDIN0_BLKBAR_H_START_END                (VDIN_BLKBAR_H_START_END           )
#define VDIN0_BLKBAR_V_START_END                (VDIN_BLKBAR_V_START_END           )
#define VDIN0_BLKBAR_CNT_THRESHOLD              (VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN0_BLKBAR_ROW_TH1_TH2                (VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN0_BLKBAR_IND_LEFT_START_END         (VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN0_BLKBAR_IND_RIGHT_START_END        (VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN0_BLKBAR_IND_LEFT1_CNT              (VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN0_BLKBAR_IND_LEFT2_CNT              (VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN0_BLKBAR_IND_RIGHT1_CNT             (VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN0_BLKBAR_IND_RIGHT2_CNT             (VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN0_BLKBAR_STATUS0                    (VDIN_BLKBAR_STATUS0               )
#define VDIN0_BLKBAR_STATUS1                    (VDIN_BLKBAR_STATUS1               )
#define VDIN0_WIN_H_START_END                   (VDIN_WIN_H_START_END              )
#define VDIN0_WIN_V_START_END                   (VDIN_WIN_V_START_END              )
#define VDIN0_ASFIFO_CTRL3                      (VDIN_ASFIFO_CTRL3                 )
#define VDIN0_LFIFO_URG_CTRL                    (VDIN_LFIFO_URG_CTRL               )
#define VDIN0_COM_GCLK_CTRL2                    (VDIN_COM_GCLK_CTRL2               )
#define VDIN0_VSHRK_CTRL                        (VDIN_VSHRK_CTRL                   )
#define VDIN0_SYNC_MASK                         (VDIN_SYNC_MASK                    )
#define VDIN0_DOLBY_DSC_CTRL0                   (VDIN_DOLBY_DSC_CTRL0  )
#define VDIN0_DOLBY_DSC_CTRL1                   (VDIN_DOLBY_DSC_CTRL1  )
#define VDIN0_DOLBY_DSC_CTRL2                   (VDIN_DOLBY_DSC_CTRL2  )
#define VDIN0_DOLBY_DSC_CTRL3                   (VDIN_DOLBY_DSC_CTRL3  )
#define VDIN0_DOLBY_AXI_CTRL0                   (VDIN_DOLBY_AXI_CTRL0  )
#define VDIN0_DOLBY_AXI_CTRL1                   (VDIN_DOLBY_AXI_CTRL1  )
#define VDIN0_DOLBY_AXI_CTRL2                   (VDIN_DOLBY_AXI_CTRL2  )
#define VDIN0_DOLBY_AXI_CTRL3                   (VDIN_DOLBY_AXI_CTRL3  )
#define VDIN0_DOLBY_DSC_STATUS0                 (VDIN_DOLBY_DSC_STATUS0)
#define VDIN0_DOLBY_DSC_STATUS1                 (VDIN_DOLBY_DSC_STATUS1)
#define VDIN0_DOLBY_DSC_STATUS2                 (VDIN_DOLBY_DSC_STATUS2)
#define VDIN0_DOLBY_DSC_STATUS3                 (VDIN_DOLBY_DSC_STATUS3)
#define VDIN0_HDR2_CTRL                           VDIN_HDR2_CTRL
#define VDIN0_HDR2_CLK_GATE                       VDIN_HDR2_CLK_GATE
#define VDIN0_HDR2_MATRIXI_COEF00_01              VDIN_HDR2_MATRIXI_COEF00_01
#define VDIN0_HDR2_MATRIXI_COEF02_10              VDIN_HDR2_MATRIXI_COEF02_10
#define VDIN0_HDR2_MATRIXI_COEF11_12              VDIN_HDR2_MATRIXI_COEF11_12
#define VDIN0_HDR2_MATRIXI_COEF20_21              VDIN_HDR2_MATRIXI_COEF20_21
#define VDIN0_HDR2_MATRIXI_COEF22                 VDIN_HDR2_MATRIXI_COEF22
#define VDIN0_HDR2_MATRIXI_COEF30_31              VDIN_HDR2_MATRIXI_COEF30_31
#define VDIN0_HDR2_MATRIXI_COEF32_40              VDIN_HDR2_MATRIXI_COEF32_40
#define VDIN0_HDR2_MATRIXI_COEF41_42              VDIN_HDR2_MATRIXI_COEF41_42
#define VDIN0_HDR2_MATRIXI_OFFSET0_1              VDIN_HDR2_MATRIXI_OFFSET0_1
#define VDIN0_HDR2_MATRIXI_OFFSET2                VDIN_HDR2_MATRIXI_OFFSET2
#define VDIN0_HDR2_MATRIXI_PRE_OFFSET0_1          VDIN_HDR2_MATRIXI_PRE_OFFSET0_1
#define VDIN0_HDR2_MATRIXI_PRE_OFFSET2            VDIN_HDR2_MATRIXI_PRE_OFFSET2
#define VDIN0_HDR2_MATRIXO_COEF00_01              VDIN_HDR2_MATRIXO_COEF00_01
#define VDIN0_HDR2_MATRIXO_COEF02_10              VDIN_HDR2_MATRIXO_COEF02_10
#define VDIN0_HDR2_MATRIXO_COEF11_12              VDIN_HDR2_MATRIXO_COEF11_12
#define VDIN0_HDR2_MATRIXO_COEF20_21              VDIN_HDR2_MATRIXO_COEF20_21
#define VDIN0_HDR2_MATRIXO_COEF22                 VDIN_HDR2_MATRIXO_COEF22
#define VDIN0_HDR2_MATRIXO_COEF30_31              VDIN_HDR2_MATRIXO_COEF30_31
#define VDIN0_HDR2_MATRIXO_COEF32_40              VDIN_HDR2_MATRIXO_COEF32_40
#define VDIN0_HDR2_MATRIXO_COEF41_42              VDIN_HDR2_MATRIXO_COEF41_42
#define VDIN0_HDR2_MATRIXO_OFFSET0_1              VDIN_HDR2_MATRIXO_OFFSET0_1
#define VDIN0_HDR2_MATRIXO_OFFSET2                VDIN_HDR2_MATRIXO_OFFSET2
#define VDIN0_HDR2_MATRIXO_PRE_OFFSET0_1          VDIN_HDR2_MATRIXO_PRE_OFFSET0_1
#define VDIN0_HDR2_MATRIXO_PRE_OFFSET2            VDIN_HDR2_MATRIXO_PRE_OFFSET2
#define VDIN0_HDR2_MATRIXI_CLIP                   VDIN_HDR2_MATRIXI_CLIP
#define VDIN0_HDR2_MATRIXO_CLIP                   VDIN_HDR2_MATRIXO_CLIP
#define VDIN0_HDR2_CGAIN_OFFT                     VDIN_HDR2_CGAIN_OFFT
#define VDIN0_EOTF_LUT_ADDR_PORT                  VDIN_EOTF_LUT_ADDR_PORT
#define VDIN0_EOTF_LUT_DATA_PORT                  VDIN_EOTF_LUT_DATA_PORT
#define VDIN0_OETF_LUT_ADDR_PORT                  VDIN_OETF_LUT_ADDR_PORT
#define VDIN0_OETF_LUT_DATA_PORT                  VDIN_OETF_LUT_DATA_PORT
#define VDIN0_OGAIN_LUT_ADDR_PORT                 VDIN_OGAIN_LUT_ADDR_PORT
#define VDIN0_OGAIN_LUT_DATA_PORT                 VDIN_OGAIN_LUT_DATA_PORT
#define VDIN0_CGAIN_LUT_ADDR_PORT                 VDIN_CGAIN_LUT_ADDR_PORT
#define VDIN0_CGAIN_LUT_DATA_PORT                 VDIN_CGAIN_LUT_DATA_PORT
#define VDIN0_HDR2_CGAIN_COEF0                    VDIN_HDR2_CGAIN_COEF0
#define VDIN0_HDR2_CGAIN_COEF1                    VDIN_HDR2_CGAIN_COEF1
#define VDIN0_HDR2_ADPS_CTRL                      VDIN_HDR2_ADPS_CTRL
#define VDIN0_HDR2_ADPS_ALPHA0                    VDIN_HDR2_ADPS_ALPHA0
#define VDIN0_HDR2_ADPS_ALPHA1                    VDIN_HDR2_ADPS_ALPHA1
#define VDIN0_HDR2_ADPS_BETA0                     VDIN_HDR2_ADPS_BETA0
#define VDIN0_HDR2_ADPS_BETA1                     VDIN_HDR2_ADPS_BETA1
#define VDIN0_HDR2_ADPS_BETA2                     VDIN_HDR2_ADPS_BETA2
#define VDIN0_HDR2_ADPS_COEF0                     VDIN_HDR2_ADPS_COEF0
#define VDIN0_HDR2_ADPS_COEF1                     VDIN_HDR2_ADPS_COEF1
#define VDIN0_HDR2_GMUT_CTRL                      VDIN_HDR2_GMUT_CTRL
#define VDIN0_HDR2_GMUT_COEF0                     VDIN_HDR2_GMUT_COEF0
#define VDIN0_HDR2_GMUT_COEF1                     VDIN_HDR2_GMUT_COEF1
#define VDIN0_HDR2_GMUT_COEF2                     VDIN_HDR2_GMUT_COEF2
#define VDIN0_HDR2_GMUT_COEF3                     VDIN_HDR2_GMUT_COEF3
#define VDIN0_HDR2_GMUT_COEF4                     VDIN_HDR2_GMUT_COEF4
#define VDIN0_HDR2_PIPE_CTRL1                     VDIN_HDR2_PIPE_CTRL1
#define VDIN0_HDR2_PIPE_CTRL2                     VDIN_HDR2_PIPE_CTRL2
#define VDIN0_HDR2_PIPE_CTRL3                     VDIN_HDR2_PIPE_CTRL3
#define VDIN0_HDR2_PROC_WIN1                      VDIN_HDR2_PROC_WIN1
#define VDIN0_HDR2_PROC_WIN2                      VDIN_HDR2_PROC_WIN2
#define VDIN0_HDR2_MATRIXI_EN_CTRL                VDIN_HDR2_MATRIXI_EN_CTRL
#define VDIN0_HDR2_MATRIXO_EN_CTRL                VDIN_HDR2_MATRIXO_EN_CTRL
#define VDIN0_HDR2_HIST_CTRL                      VDIN_HDR2_HIST_CTRL
#define VDIN0_HDR2_HIST_H_START_END               VDIN_HDR2_HIST_H_START_END
#define VDIN0_HDR2_HIST_V_START_END               VDIN_HDR2_HIST_V_START_END
#define VDIN0_HDR2_HIST_RD                        VDIN_HDR2_HIST_RD


#define VDIN0_CRC_CTRL                     (VDIN_CRC_CTRL)
#define VDIN0_RO_CRC                       (VDIN_RO_CRC  )
#define VDIN0_LINE_INT                     (VDIN_LINE_INT)
#define VDIN0_WR_URGENT_CTRL               (VDIN_WR_URGENT_CTRL)
#define VDIN0_RO_WRMIF_STATUS              (VDIN_RO_WRMIF_STATUS)

#define VDIN0_WR_BADDR_LUMA                (VDIN_WR_BADDR_LUMA   )
#define VDIN0_WR_BADDR_CHROMA              (VDIN_WR_BADDR_CHROMA )
#define VDIN0_WR_STRIDE_LUMA               (VDIN_WR_STRIDE_LUMA  )
#define VDIN0_WR_STRIDE_CHROMA             (VDIN_WR_STRIDE_CHROMA)

#define VDIN0_DSC_CTRL                      VDIN_DSC_CTRL
#define VDIN0_CFMT_CTRL                     VDIN_CFMT_CTRL
#define VDIN0_CFMT_W                        VDIN_CFMT_W
#define VDIN0_SCB_CTRL0                     VDIN_SCB_CTRL0
#define VDIN0_SCB_CTRL1                     VDIN_SCB_CTRL1
#define VDIN0_DSC_HSIZE                     VDIN_DSC_HSIZE
#define VDIN0_DSC_DETUNNEL_SEL              VDIN_DSC_DETUNNEL_SEL
#define VDIN0_DSC_TUNNEL_SEL                VDIN_DSC_TUNNEL_SEL
#define VDIN0_DITH_CTRL                     VDIN_DITH_CTRL
#define VDIN0_DITH_LUT_1                    VDIN_DITH_LUT_1
#define VDIN0_DITH_LUT_2                    VDIN_DITH_LUT_2
#define VDIN0_DITH_LUT_3                    VDIN_DITH_LUT_3
#define VDIN0_DITH_LUT_4                    VDIN_DITH_LUT_4
#define VDIN0_DITH_LUT_5                    VDIN_DITH_LUT_5
#define VDIN0_DITH_LUT_6                    VDIN_DITH_LUT_6
#define VDIN0_DITH_LUT_7                    VDIN_DITH_LUT_7
#define VDIN0_DITH_LUT_8                    VDIN_DITH_LUT_8
#define VDIN0_DITH_LUT_9                    VDIN_DITH_LUT_9
#define VDIN0_DITH_LUT_10                   VDIN_DITH_LUT_10
#define VDIN0_DITH_LUT_11                   VDIN_DITH_LUT_11
#define VDIN0_DITH_LUT_12                   VDIN_DITH_LUT_12

#define VDIN0_HSK_CTRL                      VDIN_HSK_CTRL
#define VDIN0_HSK_COEF_0                    VDIN_HSK_COEF_0
#define VDIN0_HSK_COEF_1                    VDIN_HSK_COEF_1
#define VDIN0_HSK_COEF_2                    VDIN_HSK_COEF_2
#define VDIN0_HSK_COEF_3                    VDIN_HSK_COEF_3
#define VDIN0_HSK_COEF_4                    VDIN_HSK_COEF_4
#define VDIN0_HSK_COEF_5                    VDIN_HSK_COEF_5
#define VDIN0_HSK_COEF_6                    VDIN_HSK_COEF_6
#define VDIN0_HSK_COEF_7                    VDIN_HSK_COEF_7
#define VDIN0_HSK_COEF_8                    VDIN_HSK_COEF_8
#define VDIN0_HSK_COEF_9                    VDIN_HSK_COEF_9
#define VDIN0_HSK_COEF_A                    VDIN_HSK_COEF_A
#define VDIN0_HSK_COEF_B                    VDIN_HSK_COEF_B
#define VDIN0_HSK_COEF_C                    VDIN_HSK_COEF_C
#define VDIN0_HSK_COEF_D                    VDIN_HSK_COEF_D
#define VDIN0_HSK_COEF_E                    VDIN_HSK_COEF_E
#define VDIN0_HSK_COEF_F                    VDIN_HSK_COEF_F

#define VDIN0_HDR2_SIZE                     VDIN_HDR2_SIZE
#define VDIN0_VSHRK_SIZE_M1                 VDIN_VSHRK_SIZE_M1

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_vdin0_regs.h
//
//
// Reading file:  vpu_vdin1_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VDIN1_VCBUS_BASE = 0x13
// -----------------------------------------------
#define  VDIN1_OFFSET   (0x100)
// `include "vpu_vdin_regs.h"
//8'h72 occupied by histogram 32
//VDIN1        8'h00 - 8'h7f
#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN1_COM_STATUS3                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS3                  )
#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN1_GO_LINE_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_GO_LINE_CTRL                 )
#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN1_DNLP_HIST32                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST32                  )
#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
#define VDIN1_LFIFO_URG_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_LFIFO_URG_CTRL               )
#define VDIN1_COM_GCLK_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL2               )
#define VDIN1_VSHRK_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_VSHRK_CTRL                   )
#define VDIN1_SYNC_MASK                         ((VDIN1_OFFSET << 2) + VDIN_SYNC_MASK                    )
#define VDIN1_DOLBY_DSC_CTRL0                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL0  )
#define VDIN1_DOLBY_DSC_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL1  )
#define VDIN1_DOLBY_DSC_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL2  )
#define VDIN1_DOLBY_DSC_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL3  )
#define VDIN1_DOLBY_AXI_CTRL0                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL0  )
#define VDIN1_DOLBY_AXI_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL1  )
#define VDIN1_DOLBY_AXI_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL2  )
#define VDIN1_DOLBY_AXI_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL3  )
#define VDIN1_DOLBY_DSC_STATUS0                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS0)
#define VDIN1_DOLBY_DSC_STATUS1                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS1)
#define VDIN1_DOLBY_DSC_STATUS2                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS2)
#define VDIN1_DOLBY_DSC_STATUS3                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS3)

#define VDIN1_HDR2_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HDR2_CTRL                   )
#define VDIN1_HDR2_CLK_GATE                     ((VDIN1_OFFSET << 2) + VDIN_HDR2_CLK_GATE               )
#define VDIN1_HDR2_MATRIXI_COEF00_01            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF00_01      )
#define VDIN1_HDR2_MATRIXI_COEF02_10            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF02_10      )
#define VDIN1_HDR2_MATRIXI_COEF11_12            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF11_12      )
#define VDIN1_HDR2_MATRIXI_COEF20_21            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF20_21      )
#define VDIN1_HDR2_MATRIXI_COEF22               ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF22         )
#define VDIN1_HDR2_MATRIXI_COEF30_31            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF30_31      )
#define VDIN1_HDR2_MATRIXI_COEF32_40            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF32_40      )
#define VDIN1_HDR2_MATRIXI_COEF41_42            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF41_42      )
#define VDIN1_HDR2_MATRIXI_OFFSET0_1            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_OFFSET0_1      )
#define VDIN1_HDR2_MATRIXI_OFFSET2              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_OFFSET2        )
#define VDIN1_HDR2_MATRIXI_PRE_OFFSET0_1        ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_PRE_OFFSET0_1  )
#define VDIN1_HDR2_MATRIXI_PRE_OFFSET2          ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_PRE_OFFSET2    )
#define VDIN1_HDR2_MATRIXO_COEF00_01            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF00_01      )
#define VDIN1_HDR2_MATRIXO_COEF02_10            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF02_10      )
#define VDIN1_HDR2_MATRIXO_COEF11_12            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF11_12      )
#define VDIN1_HDR2_MATRIXO_COEF20_21            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF20_21      )
#define VDIN1_HDR2_MATRIXO_COEF22               ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF22         )
#define VDIN1_HDR2_MATRIXO_COEF30_31            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF30_31      )
#define VDIN1_HDR2_MATRIXO_COEF32_40            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF32_40      )
#define VDIN1_HDR2_MATRIXO_COEF41_42            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF41_42      )
#define VDIN1_HDR2_MATRIXO_OFFSET0_1            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_OFFSET0_1      )
#define VDIN1_HDR2_MATRIXO_OFFSET2              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_OFFSET2        )
#define VDIN1_HDR2_MATRIXO_PRE_OFFSET0_1        ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_PRE_OFFSET0_1  )
#define VDIN1_HDR2_MATRIXO_PRE_OFFSET2          ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_PRE_OFFSET2    )
#define VDIN1_HDR2_MATRIXI_CLIP                 ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_CLIP           )
#define VDIN1_HDR2_MATRIXO_CLIP                 ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_CLIP           )
#define VDIN1_HDR2_CGAIN_OFFT                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_OFFT             )
#define VDIN1_EOTF_LUT_ADDR_PORT                ((VDIN1_OFFSET << 2) + VDIN_EOTF_LUT_ADDR_PORT          )
#define VDIN1_EOTF_LUT_DATA_PORT                ((VDIN1_OFFSET << 2) + VDIN_EOTF_LUT_DATA_PORT          )
#define VDIN1_OETF_LUT_ADDR_PORT                ((VDIN1_OFFSET << 2) + VDIN_OETF_LUT_ADDR_PORT          )
#define VDIN1_OETF_LUT_DATA_PORT                ((VDIN1_OFFSET << 2) + VDIN_OETF_LUT_DATA_PORT          )
#define VDIN1_OGAIN_LUT_ADDR_PORT               ((VDIN1_OFFSET << 2) + VDIN_OGAIN_LUT_ADDR_PORT         )
#define VDIN1_OGAIN_LUT_DATA_PORT               ((VDIN1_OFFSET << 2) + VDIN_OGAIN_LUT_DATA_PORT         )
#define VDIN1_CGAIN_LUT_ADDR_PORT               ((VDIN1_OFFSET << 2) + VDIN_CGAIN_LUT_ADDR_PORT         )
#define VDIN1_CGAIN_LUT_DATA_PORT               ((VDIN1_OFFSET << 2) + VDIN_CGAIN_LUT_DATA_PORT         )
#define VDIN1_HDR2_CGAIN_COEF0                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_COEF0            )
#define VDIN1_HDR2_CGAIN_COEF1                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_COEF1            )
#define VDIN1_HDR2_ADPS_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_CTRL              )
#define VDIN1_HDR2_ADPS_ALPHA0                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_ALPHA0            )
#define VDIN1_HDR2_ADPS_ALPHA1                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_ALPHA1            )
#define VDIN1_HDR2_ADPS_BETA0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA0             )
#define VDIN1_HDR2_ADPS_BETA1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA1             )
#define VDIN1_HDR2_ADPS_BETA2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA2             )
#define VDIN1_HDR2_ADPS_COEF0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_COEF0             )
#define VDIN1_HDR2_ADPS_COEF1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_COEF1             )
#define VDIN1_HDR2_GMUT_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_CTRL              )
#define VDIN1_HDR2_GMUT_COEF0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF0             )
#define VDIN1_HDR2_GMUT_COEF1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF1             )
#define VDIN1_HDR2_GMUT_COEF2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF2             )
#define VDIN1_HDR2_GMUT_COEF3                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF3             )
#define VDIN1_HDR2_GMUT_COEF4                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF4             )
#define VDIN1_HDR2_PIPE_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL1 )
#define VDIN1_HDR2_PIPE_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL2 )
#define VDIN1_HDR2_PIPE_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL3 )
#define VDIN1_HDR2_PROC_WIN1                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_PROC_WIN1  )
#define VDIN1_HDR2_PROC_WIN2                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_PROC_WIN2  )
#define VDIN1_HDR2_MATRIXI_EN_CTRL              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_EN_CTRL  )
#define VDIN1_HDR2_MATRIXO_EN_CTRL              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_EN_CTRL  )
#define VDIN1_HDR2_HIST_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_CTRL        )
#define VDIN1_HDR2_HIST_H_START_END             ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_H_START_END )
#define VDIN1_HDR2_HIST_V_START_END             ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_V_START_END )
#define VDIN1_HDR2_HIST_RD                      ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_RD          )



#define VDIN1_CRC_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_CRC_CTRL)
#define VDIN1_RO_CRC                       ((VDIN1_OFFSET << 2) + VDIN_RO_CRC  )
#define VDIN1_LINE_INT                     ((VDIN1_OFFSET << 2) + VDIN_LINE_INT)
#define VDIN1_WR_URGENT_CTRL               ((VDIN1_OFFSET << 2) + VDIN_WR_URGENT_CTRL)
#define VDIN1_RO_WRMIF_STATUS              ((VDIN1_OFFSET << 2) + VDIN_RO_WRMIF_STATUS)

#define VDIN1_WR_BADDR_LUMA                ((VDIN1_OFFSET << 2) + VDIN_WR_BADDR_LUMA   )
#define VDIN1_WR_BADDR_CHROMA              ((VDIN1_OFFSET << 2) + VDIN_WR_BADDR_CHROMA )
#define VDIN1_WR_STRIDE_LUMA               ((VDIN1_OFFSET << 2) + VDIN_WR_STRIDE_LUMA  )
#define VDIN1_WR_STRIDE_CHROMA             ((VDIN1_OFFSET << 2) + VDIN_WR_STRIDE_CHROMA)

#define VDIN1_DSC_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_DSC_CTRL    )
#define VDIN1_CFMT_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_CFMT_CTRL   )
#define VDIN1_CFMT_W                       ((VDIN1_OFFSET << 2) + VDIN_CFMT_W      )
#define VDIN1_SCB_CTRL0                    ((VDIN1_OFFSET << 2) + VDIN_SCB_CTRL0   )
#define VDIN1_SCB_CTRL1                    ((VDIN1_OFFSET << 2) + VDIN_SCB_CTRL1   )
#define VDIN1_DSC_HSIZE                    ((VDIN1_OFFSET << 2) + VDIN_DSC_HSIZE   )
#define VDIN1_DSC_DETUNNEL_SEL             ((VDIN1_OFFSET << 2) + VDIN_DSC_DETUNNEL_SEL)
#define VDIN1_DSC_TUNNEL_SEL               ((VDIN1_OFFSET << 2) + VDIN_DSC_TUNNEL_SEL)
#define VDIN1_DITH_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_DITH_CTRL   )
#define VDIN1_DITH_LUT_1                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_1  )
#define VDIN1_DITH_LUT_2                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_2  )
#define VDIN1_DITH_LUT_3                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_3  )
#define VDIN1_DITH_LUT_4                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_4  )
#define VDIN1_DITH_LUT_5                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_5  )
#define VDIN1_DITH_LUT_6                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_6  )
#define VDIN1_DITH_LUT_7                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_7  )
#define VDIN1_DITH_LUT_8                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_8  )
#define VDIN1_DITH_LUT_9                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_9  )
#define VDIN1_DITH_LUT_10                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_10 )
#define VDIN1_DITH_LUT_11                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_11 )
#define VDIN1_DITH_LUT_12                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_12 )

#define VDIN1_HSK_CTRL                     ((VDIN1_OFFSET << 2) +  VDIN_HSK_CTRL   )
#define VDIN1_HSK_COEF_0                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_0 )
#define VDIN1_HSK_COEF_1                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_1 )
#define VDIN1_HSK_COEF_2                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_2 )
#define VDIN1_HSK_COEF_3                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_3 )
#define VDIN1_HSK_COEF_4                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_4 )
#define VDIN1_HSK_COEF_5                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_5 )
#define VDIN1_HSK_COEF_6                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_6 )
#define VDIN1_HSK_COEF_7                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_7 )
#define VDIN1_HSK_COEF_8                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_8 )
#define VDIN1_HSK_COEF_9                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_9 )
#define VDIN1_HSK_COEF_A                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_A )
#define VDIN1_HSK_COEF_B                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_B )
#define VDIN1_HSK_COEF_C                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_C )
#define VDIN1_HSK_COEF_D                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_D )
#define VDIN1_HSK_COEF_E                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_E )
#define VDIN1_HSK_COEF_F                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_F )

#define VDIN1_HDR2_SIZE                    ((VDIN1_OFFSET << 2) +  VDIN_HDR2_SIZE    )
#define VDIN1_VSHRK_SIZE_M1                ((VDIN1_OFFSET << 2) +  VDIN_VSHRK_SIZE_M1)



// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_vdin1_regs.h
//
//
// Reading file:  lcd_regs.h
//
// -----------------------------------------------
// REG_BASE:  LCD_VCBUS_BASE = 0x14
// -----------------------------------------------
//========================================================================
//LCD DRV     12'h480~12'h4ef
//=======================================================================
#define P_L_GAMMA_CNTL_PORT                        (volatile uint32_t *)0xff005000
#define P_L_GAMMA_DATA_PORT                        (volatile uint32_t *)0xff005004
#define P_L_GAMMA_ADDR_PORT                        (volatile uint32_t *)0xff005008
#define P_L_GAMMA_VCOM_HSWITCH_ADDR                (volatile uint32_t *)0xff00500c
#define P_L_RGB_BASE_ADDR                          (volatile uint32_t *)0xff005014
#define P_L_RGB_COEFF_ADDR                         (volatile uint32_t *)0xff005018
#define P_L_POL_CNTL_ADDR                          (volatile uint32_t *)0xff00501c
#define P_L_DITH_CNTL_ADDR                         (volatile uint32_t *)0xff005020
#define P_L_GAMMA_PROBE_CTRL                       (volatile uint32_t *)0xff005024
//read only
#define P_L_GAMMA_PROBE_COLOR_L                    (volatile uint32_t *)0xff005028
#define P_L_GAMMA_PROBE_COLOR_H                    (volatile uint32_t *)0xff00502c
#define P_L_GAMMA_PROBE_HL_COLOR                   (volatile uint32_t *)0xff005030
#define P_L_GAMMA_PROBE_POS_X                      (volatile uint32_t *)0xff005034
#define P_L_GAMMA_PROBE_POS_Y                      (volatile uint32_t *)0xff005038
#define P_L_STH1_HS_ADDR                           (volatile uint32_t *)0xff005040
#define P_L_STH1_HE_ADDR                           (volatile uint32_t *)0xff005044
#define P_L_STH1_VS_ADDR                           (volatile uint32_t *)0xff005048
#define P_L_STH1_VE_ADDR                           (volatile uint32_t *)0xff00504c
#define P_L_STH2_HS_ADDR                           (volatile uint32_t *)0xff005050
#define P_L_STH2_HE_ADDR                           (volatile uint32_t *)0xff005054
#define P_L_STH2_VS_ADDR                           (volatile uint32_t *)0xff005058
#define P_L_STH2_VE_ADDR                           (volatile uint32_t *)0xff00505c
#define P_L_OEH_HS_ADDR                            (volatile uint32_t *)0xff005060
#define P_L_OEH_HE_ADDR                            (volatile uint32_t *)0xff005064
#define P_L_OEH_VS_ADDR                            (volatile uint32_t *)0xff005068
#define P_L_OEH_VE_ADDR                            (volatile uint32_t *)0xff00506c
#define P_L_VCOM_HSWITCH_ADDR                      (volatile uint32_t *)0xff005070
#define P_L_VCOM_VS_ADDR                           (volatile uint32_t *)0xff005074
#define P_L_VCOM_VE_ADDR                           (volatile uint32_t *)0xff005078
#define P_L_CPV1_HS_ADDR                           (volatile uint32_t *)0xff00507c
#define P_L_CPV1_HE_ADDR                           (volatile uint32_t *)0xff005080
#define P_L_CPV1_VS_ADDR                           (volatile uint32_t *)0xff005084
#define P_L_CPV1_VE_ADDR                           (volatile uint32_t *)0xff005088
#define P_L_CPV2_HS_ADDR                           (volatile uint32_t *)0xff00508c
#define P_L_CPV2_HE_ADDR                           (volatile uint32_t *)0xff005090
#define P_L_CPV2_VS_ADDR                           (volatile uint32_t *)0xff005094
#define P_L_CPV2_VE_ADDR                           (volatile uint32_t *)0xff005098
#define P_L_STV1_HS_ADDR                           (volatile uint32_t *)0xff00509c
#define P_L_STV1_HE_ADDR                           (volatile uint32_t *)0xff0050a0
#define P_L_STV1_VS_ADDR                           (volatile uint32_t *)0xff0050a4
#define P_L_STV1_VE_ADDR                           (volatile uint32_t *)0xff0050a8
#define P_L_STV2_HS_ADDR                           (volatile uint32_t *)0xff0050ac
#define P_L_STV2_HE_ADDR                           (volatile uint32_t *)0xff0050b0
#define P_L_STV2_VS_ADDR                           (volatile uint32_t *)0xff0050b4
#define P_L_STV2_VE_ADDR                           (volatile uint32_t *)0xff0050b8
#define P_L_OEV1_HS_ADDR                           (volatile uint32_t *)0xff0050bc
#define P_L_OEV1_HE_ADDR                           (volatile uint32_t *)0xff0050c0
#define P_L_OEV1_VS_ADDR                           (volatile uint32_t *)0xff0050c4
#define P_L_OEV1_VE_ADDR                           (volatile uint32_t *)0xff0050c8
#define P_L_OEV2_HS_ADDR                           (volatile uint32_t *)0xff0050cc
#define P_L_OEV2_HE_ADDR                           (volatile uint32_t *)0xff0050d0
#define P_L_OEV2_VS_ADDR                           (volatile uint32_t *)0xff0050d4
#define P_L_OEV2_VE_ADDR                           (volatile uint32_t *)0xff0050d8
#define P_L_OEV3_HS_ADDR                           (volatile uint32_t *)0xff0050dc
#define P_L_OEV3_HE_ADDR                           (volatile uint32_t *)0xff0050e0
#define P_L_OEV3_VS_ADDR                           (volatile uint32_t *)0xff0050e4
#define P_L_OEV3_VE_ADDR                           (volatile uint32_t *)0xff0050e8
#define P_L_LCD_PWR_ADDR                           (volatile uint32_t *)0xff0050ec
#define P_L_LCD_PWM0_LO_ADDR                       (volatile uint32_t *)0xff0050f0
#define P_L_LCD_PWM0_HI_ADDR                       (volatile uint32_t *)0xff0050f4
#define P_L_LCD_PWM1_LO_ADDR                       (volatile uint32_t *)0xff0050f8
#define P_L_LCD_PWM1_HI_ADDR                       (volatile uint32_t *)0xff0050fc
#define P_L_INV_CNT_ADDR                           (volatile uint32_t *)0xff005100
#define P_L_TCON_MISC_SEL_ADDR                     (volatile uint32_t *)0xff005104
#define P_L_DUAL_PORT_CNTL_ADDR                    (volatile uint32_t *)0xff005108
#define P_MLVDS_CLK_CTL1_HI                        (volatile uint32_t *)0xff00510c
#define P_MLVDS_CLK_CTL1_LO                        (volatile uint32_t *)0xff005110
//  [31:30] enable mlvds clocks
//  [24]    mlvds_clk_half_delay       24 // Bit 0
//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
#define P_L_TCON_DOUBLE_CTL                        (volatile uint32_t *)0xff005124
#define P_L_TCON_PATTERN_HI                        (volatile uint32_t *)0xff005128
#define P_L_TCON_PATTERN_LO                        (volatile uint32_t *)0xff00512c
#define P_LDIM_BL_ADDR_PORT                        (volatile uint32_t *)0xff005138
#define P_LDIM_BL_DATA_PORT                        (volatile uint32_t *)0xff00513c
#define P_L_DE_HS_ADDR                             (volatile uint32_t *)0xff005144
#define P_L_DE_HE_ADDR                             (volatile uint32_t *)0xff005148
#define P_L_DE_VS_ADDR                             (volatile uint32_t *)0xff00514c
#define P_L_DE_VE_ADDR                             (volatile uint32_t *)0xff005150
#define P_L_HSYNC_HS_ADDR                          (volatile uint32_t *)0xff005154
#define P_L_HSYNC_HE_ADDR                          (volatile uint32_t *)0xff005158
#define P_L_HSYNC_VS_ADDR                          (volatile uint32_t *)0xff00515c
#define P_L_HSYNC_VE_ADDR                          (volatile uint32_t *)0xff005160
#define P_L_VSYNC_HS_ADDR                          (volatile uint32_t *)0xff005164
#define P_L_VSYNC_HE_ADDR                          (volatile uint32_t *)0xff005168
#define P_L_VSYNC_VS_ADDR                          (volatile uint32_t *)0xff00516c
#define P_L_VSYNC_VE_ADDR                          (volatile uint32_t *)0xff005170
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define P_L_LCD_MCU_CTL                            (volatile uint32_t *)0xff005174
//**************************************************************************
//*  Dual port mLVDS registers
//**************************************************************************
// bit 3 - enable_u_dual_mlvds_dp_clk
// bit 2 - enable_u_map_mlvds_r_clk
// bit 1 - enable_u_map_mlvds_l_clk
// bit 0 - dual_mlvds_en
//`define DUAL_MLVDS_CTL                8'h60
// bit[12:0] - dual_mlvds_line_start
//`define DUAL_MLVDS_LINE_START         8'h61
// bit[12:0] - dual_mlvds_line_end
//`define DUAL_MLVDS_LINE_END           8'h62
// bit[12:0] - dual_mlvds_w_pixel_start_l
//`define DUAL_MLVDS_PIXEL_W_START_L    8'h63
// bit[12:0] - dual_mlvds_w_pixel_end_l
//`define DUAL_MLVDS_PIXEL_W_END_L      8'h64
// bit[12:0] - dual_mlvds_w_pixel_start_r
//`define DUAL_MLVDS_PIXEL_W_START_R    8'h65
// bit[12:0] - dual_mlvds_w_pixel_end_r
//`define DUAL_MLVDS_PIXEL_W_END_R      8'h66
// bit[12:0] - dual_mlvds_r_pixel_start_l
//`define DUAL_MLVDS_PIXEL_R_START_L    8'h67
// bit[12:0] - dual_mlvds_r_pixel_cnt_l
//`define DUAL_MLVDS_PIXEL_R_CNT_L      8'h68
// bit[12:0] - dual_mlvds_r_pixel_start_r
//`define DUAL_MLVDS_PIXEL_R_START_R    8'h69
// bit[12:0] - dual_mlvds_r_pixel_cnt_r
//`define DUAL_MLVDS_PIXEL_R_CNT_R      8'h6a
// bit[15]   - v_inversion_en
// bit[12:0] - v_inversion_pixel
//`define V_INVERSION_PIXEL             8'h70
// bit[15]   - v_inversion_sync_en
// bit[12:0] - v_inversion_line
//`define V_INVERSION_LINE              8'h71
// bit[15:12]  - v_loop_r
// bit[11:10]  - v_pattern_1_r
// bit[9:8]    - v_pattern_0_r
// bit[7:4]    - v_loop_l
// bit[3:2]    - v_pattern_1_l
// bit[1:0]    - v_pattern_0_l
//`define V_INVERSION_CONTROL           8'h72
//`define MLVDS2_CONTROL           8'h74
   #define     mLVDS2_RESERVED  15    // 15
   #define     mLVDS2_double_pattern  14    // 14
   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS2_dual_gate  7
   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS2_msb_first  4
   #define     mLVDS2_PORT_SWAP  3
   #define     mLVDS2_MLSB_SWAP  2
   #define     mLVDS2_PN_SWAP    1
   #define     mLVDS2_en         0
//`define MLVDS2_CONFIG_HI         8'h75
//`define MLVDS2_CONFIG_LO         8'h76
   #define     mLVDS2_reset_offset         29 // Bit 31:29
   #define     mLVDS2_reset_length         23 // Bit 28:23
   #define     mLVDS2_config_reserved      20 // Bit 22:20
   #define     mLVDS2_reset_start_bit12    19 // Bit 19
   #define     mLVDS2_data_write_toggle    18
   #define     mLVDS2_data_write_ini       17
   #define     mLVDS2_data_latch_1_toggle  16
   #define     mLVDS2_data_latch_1_ini     15
   #define     mLVDS2_data_latch_0_toggle  14
   #define     mLVDS2_data_latch_0_ini     13
   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS2_reset_start           0 // Bit 11:0
//`define MLVDS2_DUAL_GATE_WR_START        8'h77
//   `define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
//`define MLVDS2_DUAL_GATE_WR_END          8'h78
//   `define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
//
//`define MLVDS2_DUAL_GATE_RD_START        8'h79
//   `define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
//`define MLVDS2_DUAL_GATE_RD_END          8'h7a
//   `define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
//`define MLVDS2_SECOND_RESET_CTL          8'h7b
//   `define     mLVDS2_2nd_reset_start       0 // Bit 12:0
//
//`define MLVDS2_DUAL_GATE_CTL_HI        8'h7c
//`define MLVDS2_DUAL_GATE_CTL_LO        8'h7d
//   `define     mlvds2_tcon_field_en        24 // Bit 7:0
//   `define     mlvds2_dual_gate_reserved   21 // Bit 2:0
//   `define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
//   `define     mlvds2_scan_mode_odd        16 // Bit 3:0
//   `define     mlvds2_scan_mode_even       12 // Bit 3:0
//   `define     mlvds2_scan_mode_start_line  0 // Bit 11:0
//
//`define MLVDS2_RESET_CONFIG_HI         8'h7e
//`define MLVDS2_RESET_CONFIG_LO         8'h7f
//   `define     mLVDS2_reset_range_enable   31 // Bit 0
//   `define     mLVDS2_reset_range_inv      30 // Bit 0
//   `define     mLVDS2_reset_config_res1    29 // Bit 0
//   `define     mLVDS2_reset_range_line_0   16 // Bit 11:0
//   `define     mLVDS2_reset_config_res3    13 // Bit 2:0
//   `define     mLVDS2_reset_range_line_1    0 // Bit 11:0
//
//**************************************************************************
//*  Vbyone registers  (Note: no MinLVDS in G9tv, share the register)
//**************************************************************************
#define P_VBO_CTRL_L                               (volatile uint32_t *)0xff005180
#define P_VBO_CTRL_H                               (volatile uint32_t *)0xff005184
#define P_VBO_SOFT_RST                             (volatile uint32_t *)0xff005188
#define P_VBO_LANES                                (volatile uint32_t *)0xff00518c
#define P_VBO_VIN_CTRL                             (volatile uint32_t *)0xff005190
#define P_VBO_ACT_VSIZE                            (volatile uint32_t *)0xff005194
#define P_VBO_REGION_00                            (volatile uint32_t *)0xff005198
#define P_VBO_REGION_01                            (volatile uint32_t *)0xff00519c
#define P_VBO_REGION_02                            (volatile uint32_t *)0xff0051a0
#define P_VBO_REGION_03                            (volatile uint32_t *)0xff0051a4
#define P_VBO_VBK_CTRL_0                           (volatile uint32_t *)0xff0051a8
#define P_VBO_VBK_CTRL_1                           (volatile uint32_t *)0xff0051ac
#define P_VBO_HBK_CTRL                             (volatile uint32_t *)0xff0051b0
#define P_VBO_PXL_CTRL                             (volatile uint32_t *)0xff0051b4
#define P_VBO_LANE_SKEW_L                          (volatile uint32_t *)0xff0051b8
#define P_VBO_LANE_SKEW_H                          (volatile uint32_t *)0xff0051bc
#define P_VBO_GCLK_LANE_L                          (volatile uint32_t *)0xff0051c0
#define P_VBO_GCLK_LANE_H                          (volatile uint32_t *)0xff0051c4
#define P_VBO_GCLK_MAIN                            (volatile uint32_t *)0xff0051c8
#define P_VBO_STATUS_L                             (volatile uint32_t *)0xff0051cc
#define P_VBO_STATUS_H                             (volatile uint32_t *)0xff0051d0
#define P_VBO_LANE_OUTPUT                          (volatile uint32_t *)0xff0051d4
#define P_LCD_PORT_SWAP                            (volatile uint32_t *)0xff0051d8
#define P_VBO_TMCHK_THRD_L                         (volatile uint32_t *)0xff0051e0
#define P_VBO_TMCHK_THRD_H                         (volatile uint32_t *)0xff0051e4
#define P_VBO_FSM_HOLDER_L                         (volatile uint32_t *)0xff0051e8
#define P_VBO_FSM_HOLDER_H                         (volatile uint32_t *)0xff0051ec
#define P_VBO_INTR_STATE_CTRL                      (volatile uint32_t *)0xff0051f0
#define P_VBO_INTR_UNMASK                          (volatile uint32_t *)0xff0051f4
#define P_VBO_TMCHK_HSYNC_STATE_L                  (volatile uint32_t *)0xff0051f8
#define P_VBO_TMCHK_HSYNC_STATE_H                  (volatile uint32_t *)0xff0051fc
#define P_VBO_TMCHK_VSYNC_STATE_L                  (volatile uint32_t *)0xff0053d0
#define P_VBO_TMCHK_VSYNC_STATE_H                  (volatile uint32_t *)0xff0053d4
#define P_VBO_TMCHK_VDE_STATE_L                    (volatile uint32_t *)0xff0053d8
#define P_VBO_TMCHK_VDE_STATE_H                    (volatile uint32_t *)0xff0053dc
#define P_VBO_INTR_STATE                           (volatile uint32_t *)0xff0053e0
#define P_VBO_INFILTER_CTRL                        (volatile uint32_t *)0xff0053e4
#define P_VBO_INSGN_CTRL                           (volatile uint32_t *)0xff0053e8
#define P_VBO_INFILTER_CTRL_H                      (volatile uint32_t *)0xff0051dc
//**************************************************************************
//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
//**************************************************************************
#define P_GAMMA_CNTL_PORT                          (volatile uint32_t *)0xff005200
   #define  GAMMA_VCOM_POL    7     //RW
   #define  GAMMA_RVS_OUT     6     //RW
   #define  ADR_RDY           5     //Read Only
   #define  WR_RDY            4     //Read Only
   #define  RD_RDY            3     //Read Only
   #define  GAMMA_TR          2     //RW
   #define  GAMMA_SET         1     //RW
   #define  GAMMA_EN          0     //RW
#define P_GAMMA_DATA_PORT                          (volatile uint32_t *)0xff005204
#define P_GAMMA_ADDR_PORT                          (volatile uint32_t *)0xff005208
   #define  H_RD              12
   #define  H_AUTO_INC        11
   #define  H_SEL_R           10
   #define  H_SEL_G           9
   #define  H_SEL_B           8
   #define  HADR_MSB          7            //7:0
   #define  HADR              0            //7:0
#define P_GAMMA_VCOM_HSWITCH_ADDR                  (volatile uint32_t *)0xff00520c
#define P_RGB_BASE_ADDR                            (volatile uint32_t *)0xff005214
#define P_RGB_COEFF_ADDR                           (volatile uint32_t *)0xff005218
#define P_POL_CNTL_ADDR                            (volatile uint32_t *)0xff00521c
   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
   #define   CPH3_POL         8
   #define   CPH2_POL         7
   #define   CPH1_POL         6
   #define   TCON_DE_SEL      5
   #define   TCON_VS_SEL      4
   #define   TCON_HS_SEL      3
   #define   DE_POL           2
   #define   VS_POL           1
   #define   HS_POL           0
#define P_DITH_CNTL_ADDR                           (volatile uint32_t *)0xff005220
   #define  DITH10_EN         10
   #define  DITH8_EN          9
   #define  DITH_MD           8
   #define  DITH10_CNTL_MSB   7          //7:4
   #define  DITH10_CNTL       4          //7:4
   #define  DITH8_CNTL_MSB    3          //3:0
   #define  DITH8_CNTL        0          //3:0
//Bit 1 highlight_en
//Bit 0 probe_en
#define P_GAMMA_PROBE_CTRL                         (volatile uint32_t *)0xff005224
//read only
//Bit [15:0]  probe_color[15:0]
#define P_GAMMA_PROBE_COLOR_L                      (volatile uint32_t *)0xff005228
//Read only
//Bit 15: if true valid probed color
//Bit [13:0]  probe_color[29:16]
#define P_GAMMA_PROBE_COLOR_H                      (volatile uint32_t *)0xff00522c
//bit 15:0, 5:6:5 color
#define P_GAMMA_PROBE_HL_COLOR                     (volatile uint32_t *)0xff005230
//12:0 pos_x
#define P_GAMMA_PROBE_POS_X                        (volatile uint32_t *)0xff005234
//12:0 pos_y
#define P_GAMMA_PROBE_POS_Y                        (volatile uint32_t *)0xff005238
#define P_STH1_HS_ADDR                             (volatile uint32_t *)0xff005240
#define P_STH1_HE_ADDR                             (volatile uint32_t *)0xff005244
#define P_STH1_VS_ADDR                             (volatile uint32_t *)0xff005248
#define P_STH1_VE_ADDR                             (volatile uint32_t *)0xff00524c
#define P_STH2_HS_ADDR                             (volatile uint32_t *)0xff005250
#define P_STH2_HE_ADDR                             (volatile uint32_t *)0xff005254
#define P_STH2_VS_ADDR                             (volatile uint32_t *)0xff005258
#define P_STH2_VE_ADDR                             (volatile uint32_t *)0xff00525c
#define P_OEH_HS_ADDR                              (volatile uint32_t *)0xff005260
#define P_OEH_HE_ADDR                              (volatile uint32_t *)0xff005264
#define P_OEH_VS_ADDR                              (volatile uint32_t *)0xff005268
#define P_OEH_VE_ADDR                              (volatile uint32_t *)0xff00526c
#define P_VCOM_HSWITCH_ADDR                        (volatile uint32_t *)0xff005270
#define P_VCOM_VS_ADDR                             (volatile uint32_t *)0xff005274
#define P_VCOM_VE_ADDR                             (volatile uint32_t *)0xff005278
#define P_CPV1_HS_ADDR                             (volatile uint32_t *)0xff00527c
#define P_CPV1_HE_ADDR                             (volatile uint32_t *)0xff005280
#define P_CPV1_VS_ADDR                             (volatile uint32_t *)0xff005284
#define P_CPV1_VE_ADDR                             (volatile uint32_t *)0xff005288
#define P_CPV2_HS_ADDR                             (volatile uint32_t *)0xff00528c
#define P_CPV2_HE_ADDR                             (volatile uint32_t *)0xff005290
#define P_CPV2_VS_ADDR                             (volatile uint32_t *)0xff005294
#define P_CPV2_VE_ADDR                             (volatile uint32_t *)0xff005298
#define P_STV1_HS_ADDR                             (volatile uint32_t *)0xff00529c
#define P_STV1_HE_ADDR                             (volatile uint32_t *)0xff0052a0
#define P_STV1_VS_ADDR                             (volatile uint32_t *)0xff0052a4
#define P_STV1_VE_ADDR                             (volatile uint32_t *)0xff0052a8
#define P_STV2_HS_ADDR                             (volatile uint32_t *)0xff0052ac
#define P_STV2_HE_ADDR                             (volatile uint32_t *)0xff0052b0
#define P_STV2_VS_ADDR                             (volatile uint32_t *)0xff0052b4
#define P_STV2_VE_ADDR                             (volatile uint32_t *)0xff0052b8
#define P_OEV1_HS_ADDR                             (volatile uint32_t *)0xff0052bc
#define P_OEV1_HE_ADDR                             (volatile uint32_t *)0xff0052c0
#define P_OEV1_VS_ADDR                             (volatile uint32_t *)0xff0052c4
#define P_OEV1_VE_ADDR                             (volatile uint32_t *)0xff0052c8
#define P_OEV2_HS_ADDR                             (volatile uint32_t *)0xff0052cc
#define P_OEV2_HE_ADDR                             (volatile uint32_t *)0xff0052d0
#define P_OEV2_VS_ADDR                             (volatile uint32_t *)0xff0052d4
#define P_OEV2_VE_ADDR                             (volatile uint32_t *)0xff0052d8
#define P_OEV3_HS_ADDR                             (volatile uint32_t *)0xff0052dc
#define P_OEV3_HE_ADDR                             (volatile uint32_t *)0xff0052e0
#define P_OEV3_VS_ADDR                             (volatile uint32_t *)0xff0052e4
#define P_OEV3_VE_ADDR                             (volatile uint32_t *)0xff0052e8
#define P_LCD_PWR_ADDR                             (volatile uint32_t *)0xff0052ec
   #define      LCD_VDD        5
   #define      LCD_VBL        4
   #define      LCD_GPI_MSB    3
   #define      LCD_GPIO       0
#define P_LCD_PWM0_LO_ADDR                         (volatile uint32_t *)0xff0052f0
#define P_LCD_PWM0_HI_ADDR                         (volatile uint32_t *)0xff0052f4
#define P_LCD_PWM1_LO_ADDR                         (volatile uint32_t *)0xff0052f8
#define P_LCD_PWM1_HI_ADDR                         (volatile uint32_t *)0xff0052fc
#define P_INV_CNT_ADDR                             (volatile uint32_t *)0xff005300
   #define     INV_EN          4
   #define     INV_CNT_MSB     3
   #define     INV_CNT         0
#define P_TCON_MISC_SEL_ADDR                       (volatile uint32_t *)0xff005304
   #define     STH2_SEL        12
   #define     STH1_SEL        11
   #define     OEH_SEL         10
   #define     VCOM_SEL         9
   #define     DB_LINE_SW       8
   #define     CPV2_SEL         7
   #define     CPV1_SEL         6
   #define     STV2_SEL         5
   #define     STV1_SEL         4
   #define     OEV_UNITE        3
   #define     OEV3_SEL         2
   #define     OEV2_SEL         1
   #define     OEV1_SEL         0
#define P_DUAL_PORT_CNTL_ADDR                      (volatile uint32_t *)0xff005308
   #define     OUTPUT_YUV       15
   #define     DUAL_IDF         12   // 14:12
   #define     DUAL_ISF         9    // 11:9
   #define     LCD_ANALOG_SEL_CPH3   8
   #define     LCD_ANALOG_3PHI_CLK_SEL   7
   #define     LCD_LVDS_SEL54   6
   #define     LCD_LVDS_SEL27   5
   #define     LCD_TTL_SEL      4
   #define     DUAL_LVDC_EN     3
   #define     PORT_SWP         2
   #define     RGB_SWP          1
   #define     BIT_SWP          0
#define P_MLVDS_CONTROL                            (volatile uint32_t *)0xff00530c
   #define     mLVDS_RESERVED  15    // 15
   #define     mLVDS_double_pattern  14    // 14
   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS_dual_gate  7
   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS_msb_first  4
   #define     mLVDS_PORT_SWAP  3
   #define     mLVDS_MLSB_SWAP  2
   #define     mLVDS_PN_SWAP    1
   #define     mLVDS_en         0
#define P_MLVDS_RESET_PATTERN_HI                   (volatile uint32_t *)0xff005310
#define P_MLVDS_RESET_PATTERN_LO                   (volatile uint32_t *)0xff005314
   #define     mLVDS_reset_pattern  0 // Bit 47:16
#define P_MLVDS_RESET_PATTERN_EXT                  (volatile uint32_t *)0xff005318
   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
#define P_MLVDS_CONFIG_HI                          (volatile uint32_t *)0xff00531c
#define P_MLVDS_CONFIG_LO                          (volatile uint32_t *)0xff005320
   #define     mLVDS_reset_offset         29 // Bit 31:29
   #define     mLVDS_reset_length         23 // Bit 28:23
   #define     mLVDS_config_reserved      20 // Bit 22:20
   #define     mLVDS_reset_start_bit12    19 // Bit 19
   #define     mLVDS_data_write_toggle    18
   #define     mLVDS_data_write_ini       17
   #define     mLVDS_data_latch_1_toggle  16
   #define     mLVDS_data_latch_1_ini     15
   #define     mLVDS_data_latch_0_toggle  14
   #define     mLVDS_data_latch_0_ini     13
   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS_reset_start           0 // Bit 11:0
#define P_TCON_DOUBLE_CTL                          (volatile uint32_t *)0xff005324
   #define     tcon_double_ini          8 // Bit 7:0
   #define     tcon_double_inv          0 // Bit 7:0
#define P_TCON_PATTERN_HI                          (volatile uint32_t *)0xff005328
#define P_TCON_PATTERN_LO                          (volatile uint32_t *)0xff00532c
   #define     tcon_pattern_loop_data     16 // Bit 15:0
   #define     tcon_pattern_loop_start    12 // Bit 3:0
   #define     tcon_pattern_loop_end       8 // Bit 3:0
   #define     tcon_pattern_enable         0 // Bit 7:0
#define P_TCON_CONTROL_HI                          (volatile uint32_t *)0xff005330
#define P_TCON_CONTROL_LO                          (volatile uint32_t *)0xff005334
   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
#define P_LVDS_BLANK_DATA_HI                       (volatile uint32_t *)0xff005338
#define P_LVDS_BLANK_DATA_LO                       (volatile uint32_t *)0xff00533c
   #define     LVDS_blank_data_reserved 30  // 31:30
   #define     LVDS_blank_data_r        20  // 29:20
   #define     LVDS_blank_data_g        10  // 19:10
   #define     LVDS_blank_data_b         0  //  9:0
#define P_LVDS_PACK_CNTL_ADDR                      (volatile uint32_t *)0xff005340
   #define     LVDS_USE_TCON    7
   #define     LVDS_DUAL        6
   #define     PN_SWP           5
   #define     LSB_FIRST        4
   #define     LVDS_RESV        3
   #define     ODD_EVEN_SWP     2
   #define     LVDS_REPACK      0
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
#define P_DE_HS_ADDR                               (volatile uint32_t *)0xff005344
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
#define P_DE_HE_ADDR                               (volatile uint32_t *)0xff005348
#define P_DE_VS_ADDR                               (volatile uint32_t *)0xff00534c
#define P_DE_VE_ADDR                               (volatile uint32_t *)0xff005350
#define P_HSYNC_HS_ADDR                            (volatile uint32_t *)0xff005354
#define P_HSYNC_HE_ADDR                            (volatile uint32_t *)0xff005358
#define P_HSYNC_VS_ADDR                            (volatile uint32_t *)0xff00535c
#define P_HSYNC_VE_ADDR                            (volatile uint32_t *)0xff005360
#define P_VSYNC_HS_ADDR                            (volatile uint32_t *)0xff005364
#define P_VSYNC_HE_ADDR                            (volatile uint32_t *)0xff005368
#define P_VSYNC_VS_ADDR                            (volatile uint32_t *)0xff00536c
#define P_VSYNC_VE_ADDR                            (volatile uint32_t *)0xff005370
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define P_LCD_MCU_CTL                              (volatile uint32_t *)0xff005374
// ReadOnly
//   R5G6B5 when R5G6B5_format
//   G8R8   when R8G8B8_format
//   G5R10  Other
#define P_LCD_MCU_DATA_0                           (volatile uint32_t *)0xff005378
// ReadOnly
//   G8B8   when R8G8B8_format
//   G5B10  Other
#define P_LCD_MCU_DATA_1                           (volatile uint32_t *)0xff00537c
// LVDS
#define P_LVDS_GEN_CNTL                            (volatile uint32_t *)0xff005380
//`define LVDS_PHY_CNTL0          8'he1
//`define LVDS_PHY_CNTL1          8'he2
//`define LVDS_PHY_CNTL2          8'he3
//`define LVDS_PHY_CNTL3          8'he4
//`define LVDS_PHY_CNTL4          8'he5
//`define LVDS_PHY_CNTL5          8'he6
#define P_LVDS_SRG_TEST                            (volatile uint32_t *)0xff0053a0
#define P_LVDS_BIST_MUX0                           (volatile uint32_t *)0xff0053a4
#define P_LVDS_BIST_MUX1                           (volatile uint32_t *)0xff0053a8
#define P_LVDS_BIST_FIXED0                         (volatile uint32_t *)0xff0053ac
#define P_LVDS_BIST_FIXED1                         (volatile uint32_t *)0xff0053b0
#define P_LVDS_BIST_CNTL0                          (volatile uint32_t *)0xff0053b4
#define P_LVDS_CLKB_CLKA                           (volatile uint32_t *)0xff0053b8
#define P_LVDS_PHY_CLK_CNTL                        (volatile uint32_t *)0xff0053bc
#define P_LVDS_SER_EN                              (volatile uint32_t *)0xff0053c0
//`define LVDS_PHY_CNTL6        8'hf1
//`define LVDS_PHY_CNTL7        8'hf2
//`define LVDS_PHY_CNTL8        8'hf3
#define P_LVDS_CH_SWAP0                            (volatile uint32_t *)0xff005384
#define P_LVDS_CH_SWAP1                            (volatile uint32_t *)0xff005388
#define P_LVDS_CH_SWAP2                            (volatile uint32_t *)0xff00538c
//`define MLVDS_CLK_CTL0_HI        8'hf4
//`define MLVDS_CLK_CTL0_LO        8'hf5
//   `define     mlvds_clk_pattern_reserved 31 // Bit 31
//   `define     mpclk_dly                  28 // Bit 2:0
//   `define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
//   `define     use_mpclk                  25 // Bit 0
//   `define     mlvds_clk_half_delay       24 // Bit 0
//   `define     mlvds_clk_pattern           0 // Bit 23:0
//`define MLVDS_DUAL_GATE_WR_START        8'hf6
//   `define     mlvds_dual_gate_wr_start    0 // Bit 12:0
//`define MLVDS_DUAL_GATE_WR_END          8'hf7
//   `define     mlvds_dual_gate_wr_end      0 // Bit 12:0
//
//`define MLVDS_DUAL_GATE_RD_START        8'hf8
//   `define     mlvds_dual_gate_rd_start    0 // Bit 12:0
//`define MLVDS_DUAL_GATE_RD_END          8'hf9
//   `define     mlvds_dual_gate_rd_end      0 // Bit 12:0
//`define MLVDS_SECOND_RESET_CTL          8'hfa
//   `define     mLVDS_2nd_reset_start       0 // Bit 12:0
//
#define P_MLVDS_DUAL_GATE_CTL_HI                   (volatile uint32_t *)0xff0053ec
#define P_MLVDS_DUAL_GATE_CTL_LO                   (volatile uint32_t *)0xff0053f0
//   `define     mlvds_tcon_field_en        24 // Bit 7:0
//   `define     mlvds_dual_gate_reserved   21 // Bit 2:0
//   `define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
//   `define     mlvds_scan_mode_odd        16 // Bit 3:0
//   `define     mlvds_scan_mode_even       12 // Bit 3:0
//   `define     mlvds_scan_mode_start_line  0 // Bit 11:0
//
//`define MLVDS_RESET_CONFIG_HI         8'hfd
//`define MLVDS_RESET_CONFIG_LO         8'hfe
//   `define     mLVDS_reset_range_enable   31 // Bit 0
//   `define     mLVDS_reset_range_inv      30 // Bit 0
//   `define     mLVDS_reset_config_res1    29 // Bit 0
//   `define     mLVDS_reset_range_line_0   16 // Bit 11:0
//   `define     mLVDS_reset_config_res3    13 // Bit 2:0
//   `define     mLVDS_reset_range_line_1    0 // Bit 11:0
//===============================================================
//LCD DRIVER BASE   END
//===============================================================
//
// Closing file:  lcd_regs.h
//
//
// Reading file:  vpu_mad_regs.h
//
//DEINTERLACE module start from 8'h90 end to 8'hff
// -----------------------------------------------
// REG_BASE:  MAD_VCBUS_BASE = 0x17
// -----------------------------------------------
#define P_DI_PRE_CTRL                              (volatile uint32_t *)0xff005c00
// bit 31,      cbus_pre_frame_rst
// bit 30,      cbus_pre_soft_rst
// bit 29,      pre_field_num
// bit 27:26,   mode_444c422
// bit 25,      di_cont_read_en
// bit 24:23,   mode_422c444
// bit 22,      mtn_after_nr
// bit 21:16,   pre_hold_fifo_lines
// bit 15,      nr_wr_by
// bit 14,      use_vdin_go_line
// bit 13,      di_prevdin_en
// bit 12,      di_pre_viu_link
// bit 11,      di_pre_repeat
// bit 10,      di_pre_drop_1st
// bit  9,      di_buf2_en
// bit  8,      di_chan2_en
// bit  7,      prenr_hist_en
// bit  6,      chan2_hist_en
// bit  5,      hist_check_en
// bit  4,      check_after_nr
// bit  3,      check222p_en
// bit  2,      check322p_en
// bit  1,      mtn_en
// bit  0,      nr_en
#define P_DI_POST_CTRL                             (volatile uint32_t *)0xff005c04
// bit 31,      cbus_post_frame_rst
// bit 30,      cbus_post_soft_rst
// bit 29,      post_field_num
// bit 21:16,   post_hold_fifo_lines
// bit 13,      prepost_link
// bit 12,      di_post_viu_link
// bit 11,      di_post_repeat
// bit 10,      di_post_drop_1st
// bit  9,      mif0_to_vpp_en
// bit  8,      di_vpp_out_en
// bit  7,      di_wr_bk_en
// bit  6,      di_mux_en
// bit  5,      di_blend_en
// bit  4,      di_mtnp_read_en
// bit  3,      di_mtn_buf_en
// bit  2,      di_ei_en
// bit  1,      di_buf1_en
// bit  0,      di_buf0_en
#define P_DI_POST_SIZE                             (volatile uint32_t *)0xff005c08
//bit 31:29,    diwr_field_mode     field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//bit 28:16,    vsize1post
//bit 12:0,     hsize1post
#define P_DI_PRE_SIZE                              (volatile uint32_t *)0xff005c0c
//bit 31:29,    nrwr_field_mode     field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//bit 28:16,    vsize1pre
//bit 12:0,     hsize1pre
#define P_DI_EI_CTRL0                              (volatile uint32_t *)0xff005c10
//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
//bit 15:8,     ei0_threshold[2:+]
//bit 3,        ei0_vertical
//bit 2,        ei0_bpscf2
//bit 1,        ei0_bpsfar1
#define P_DI_EI_CTRL1                              (volatile uint32_t *)0xff005c14
//bit 31:24,    ei0_diff
//bit 23:16,    ei0_angle45
//bit 15:8,     ei0_peak
//bit 7:0,      ei0_cross
#define P_DI_EI_CTRL2                              (volatile uint32_t *)0xff005c18
//bit 31:24,    ei0_close2
//bit 23:16,    ei0_close1
//bit 15:8,     ei0_far2
//bit 7:0,      ei0_far1
//`define DI_NR_CTRL0               8'h07
//bit 26,       nr_cue_en
//bit 25,       nr2_en
#define P_DI_NR_CTRL1                              (volatile uint32_t *)0xff005c20
//bit 31:30,    mot_p1txtcore_mode
//bit 29:24,    mot_p1txtcore_clmt
//bit 21:16,    mot_p1txtcore_ylmt
//bit 15:8,     mot_p1txtcore_crate
//bit 7:0,      mot_p1txtcore_yrate
#define P_DI_NR_CTRL2                              (volatile uint32_t *)0xff005c24
//bit 29:24,    mot_curtxtcore_clmt
//bit 21:16,    mot_curtxtcore_ylmt
//bit 15:8,     mot_curtxtcore_crate
//bit 7:0,      mot_curtxtcore_yrate
//`define DI_NR_CTRL3               8'h0a
//no use
//`define DI_MTN_CTRL               8'h0b
//`define DI_CANVAS_URGENT0         8'h0a
//`define DI_CANVAS_URGENT1         8'h0b
#define P_DI_MTN_CTRL1                             (volatile uint32_t *)0xff005c30
//bit 11:8,		mtn_paramtnthd
//bit 7:0,      mtn_parafltthd
#define P_DI_BLEND_CTRL                            (volatile uint32_t *)0xff005c34
//bit 31,      blend_1_en
//bit 30,      blend_mtn_lpf
//bit 28,      post_mb_en
//bit 27,      blend_mtn3p_max
//bit 26,      blend_mtn3p_min
//bit 25,      blend_mtn3p_ave
//bit 24,      blend_mtn3p_maxtb
//bit 23,      blend_mtn_flt_en
//bit 22,      blend_data_flt_en
//bit 21:20,   blend_top_mode
//bit 19,      blend_reg3_enable
//bit 18,      blend_reg2_enable
//bit 17,      blend_reg1_enable
//bit 16,      blend_reg0_enable
//bit 15:14,   blend_reg3_mode
//bit 13:12,   blend_reg2_mode
//bit 11:10,   blend_reg1_mode
//bit 9:8,     blend_reg0_mode
//bit 7:0,     kdeint
//`define DI_BLEND_CTRL1            8'h0e
//no use
//`define DI_CANVAS_URGENT2         8'h0e
//`define DI_BLEND_CTRL2            8'h0f
//no use
#define P_DI_ARB_CTRL                              (volatile uint32_t *)0xff005c3c
//bit 31:26,			di_arb_thd1
//bit 25:20,			di_arb_thd0
//bit 19,			di_arb_tid_mode
//bit 18,			di_arb_arb_mode
//bit 17,			di_arb_acq_en
//bit 16,			di_arb_disable_clk
//bit 15:0,			di_arb_req_en
#define P_DI_BLEND_REG0_X                          (volatile uint32_t *)0xff005c40
//bit 27:16,   blend_reg0_startx
//bit 11:0,    blend_reg0_endx
#define P_DI_BLEND_REG0_Y                          (volatile uint32_t *)0xff005c44
#define P_DI_BLEND_REG1_X                          (volatile uint32_t *)0xff005c48
#define P_DI_BLEND_REG1_Y                          (volatile uint32_t *)0xff005c4c
#define P_DI_BLEND_REG2_X                          (volatile uint32_t *)0xff005c50
#define P_DI_BLEND_REG2_Y                          (volatile uint32_t *)0xff005c54
#define P_DI_BLEND_REG3_X                          (volatile uint32_t *)0xff005c58
#define P_DI_BLEND_REG3_Y                          (volatile uint32_t *)0xff005c5c
#define P_DI_CLKG_CTRL                             (volatile uint32_t *)0xff005c60
//bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1, module clk is not gated (always on). [3] for pulldown,[2] for mtn_1,[1] for mtn_0,[0] for nr
//bit 23:16,   post_gclk_ctrl    no clk gate control. [4] for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0
//bit 1,       di_gate_all       clk shut down. if ==1 , all di clock shut down
//bit 0,       di_no_clk_gate    no clk gate control.     if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working.
#define P_DI_EI_CTRL3                              (volatile uint32_t *)0xff005c64
//bit 31,      reg_ei_1
//bit 30,      reg_demon_en
//bit 26:24,   reg_demon_mux
//bit 23:20,   reg_right_win
//bit 19:16,   reg_left_win
//bit 7:4,     reg_ei_sadm_quatize_margin
//bit 1:0,     reg_ei_sad_relative_mode
#define P_DI_EI_CTRL4                              (volatile uint32_t *)0xff005c68
//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
//bit 19,      reg_ei_caldrt_addxla2list_mode
//bit 18:16,   reg_ei_signm_sad_cor_rate
//bit 15:12,   reg_ei_signm_sadi_cor_rate
//bit 11:6,    reg_ei_signm_sadi_cor_ofst
//bit 5:0,     reg_ei_signm_sad_ofst
#define P_DI_EI_CTRL5                              (volatile uint32_t *)0xff005c6c
//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
//bit 21,      reg_ei_caldrt_cnflctchk_en
//bit 20,      reg_ei_caldrt_verfrc_final_en
//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
//bit 15,      reg_ei_caldrt_verfrc_retiming_en
//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
//bit 11:9,    reg_ei_caldrt_ver_thrd
//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
#define P_DI_EI_CTRL6                              (volatile uint32_t *)0xff005c70
//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
//bit 6:4,     reg_ei_caldrt_abext_ratemth
//bit 2:0,     reg_ei_caldrt_abext_drtthrd
#define P_DI_EI_CTRL7                              (volatile uint32_t *)0xff005c74
//bit 29,      reg_ei_caldrt_xlanopeak_codien
//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
//bit 23,      reg_ei_caldrt_xlanopeak_en
//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
//bit 28:24,   reg_ei_caldrt_abext_sad00rate
//bit 28:24,   reg_ei_caldrt_abext_sad12rate
//bit 28:24,   reg_ei_caldrt_abext_sad00thhig
#define P_DI_EI_CTRL8                              (volatile uint32_t *)0xff005c78
//bit 30:28,   reg_ei_assign_headtail_magin
//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
//bit 20,      reg_ei_caldrt_histchk_cnfid
//bit 19:16,   reg_ei_caldrt_histchk_thrd
//bit 15,      reg_ei_caldrt_histchk_abext
//bit 14,      reg_ei_caldrt_histchk_npen
//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
//bit 10:8,    reg_ei_caldrt_amblike2_valmg
//bit 7:4,     reg_ei_caldrt_amblike2_alpha
//bit 3:0,     reg_ei_caldrt_amblike2_drtth
#define P_DI_EI_CTRL9                              (volatile uint32_t *)0xff005c7c
//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
//bit 26:24,   reg_ei_caldrt_conf_drtth
//bit 23:20,   reg_ei_caldrt_conf_absdrtth
//bit 19:18,   reg_ei_caldrt_abcheck_mode1
//bit 17:16,   reg_ei_caldrt_abcheck_mode0
//bit 15:12,   reg_ei_caldrt_abcheck_drth1
//bit 11:8,    reg_ei_caldrt_abcheck_drth0
//bit 6:4,     reg_ei_caldrt_abpnchk1_th
//bit 1,       reg_ei_caldrt_abpnchk1_en
//bit 0,       reg_ei_caldrt_abpnchk0_en
// DEINTERLACE mode check.
#define P_DI_MC_REG0_X                             (volatile uint32_t *)0xff005c80
//bit 27:16,   mc_reg0_start_x
//bit 11:0,    mc_reg0_end_x
#define P_DI_MC_REG0_Y                             (volatile uint32_t *)0xff005c84
#define P_DI_MC_REG1_X                             (volatile uint32_t *)0xff005c88
#define P_DI_MC_REG1_Y                             (volatile uint32_t *)0xff005c8c
#define P_DI_MC_REG2_X                             (volatile uint32_t *)0xff005c90
#define P_DI_MC_REG2_Y                             (volatile uint32_t *)0xff005c94
#define P_DI_MC_REG3_X                             (volatile uint32_t *)0xff005c98
#define P_DI_MC_REG3_Y                             (volatile uint32_t *)0xff005c9c
#define P_DI_MC_REG4_X                             (volatile uint32_t *)0xff005ca0
#define P_DI_MC_REG4_Y                             (volatile uint32_t *)0xff005ca4
#define P_DI_MC_32LVL0                             (volatile uint32_t *)0xff005ca8
//bit 31:24,   mc_reg2_32lvl
//bit 23:16,   mc_reg1_32lvl
//bit 15:8,    mc_reg0_32lvl
//bit 7:0,     field_32lvl
#define P_DI_MC_32LVL1                             (volatile uint32_t *)0xff005cac
//bit 15:8,    mc_reg3_32lvl
//bit 7:0,     mc_reg4_32lvl
#define P_DI_MC_22LVL0                             (volatile uint32_t *)0xff005cb0
//bit 31:16,   mc_reg0_22lvl
//bit 15:0,    field_22lvl
#define P_DI_MC_22LVL1                             (volatile uint32_t *)0xff005cb4
//bit 31:16,   mc_reg2_22lvl
//bit 15:0,    mc_reg1_22lvl
#define P_DI_MC_22LVL2                             (volatile uint32_t *)0xff005cb8
//bit 31:16,   mc_reg4_22lvl
//bit 15:0,    mc_reg3_22lvl
#define P_DI_MC_CTRL                               (volatile uint32_t *)0xff005cbc
//bit 4,       mc_reg4_en
//bit 3,       mc_reg3_en
//bit 2,       mc_reg2_en
//bit 1,       mc_reg1_en
//bit 0,       mc_reg0_en
#define P_DI_INTR_CTRL                             (volatile uint32_t *)0xff005cc0
#define P_DI_INFO_ADDR                             (volatile uint32_t *)0xff005cc4
#define P_DI_INFO_DATA                             (volatile uint32_t *)0xff005cc8
#define P_DI_PRE_HOLD                              (volatile uint32_t *)0xff005ccc
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
//     `define DET3D_MOTN_CFG                8'h34
//     //Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
//     //Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
//     //                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
//     //Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
//     //Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
//
//     `define DET3D_CB_CFG                  8'h35
//     //Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizontal or vertical combing detection.
//     //Bit 3:0,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizontal or vertical combing detection.
//
//     `define DET3D_SPLT_CFG                8'h36
//     //Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
//     //                                      The smaller of this value, the easier of the split line detected.
//     //Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
//     //                                      The smaller of this value, the more samples will be added to the estimation.
//
//     `define DET3D_HV_MUTE                 8'h37
//     //Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
//     //Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
//     //Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//     //Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//     //Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
//     //Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
//
//     `define DET3D_MAT_STA_P1M1            8'h38
//     //Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
//     //Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
//     //Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
//     //Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
//
//     `define DET3D_MAT_STA_P1TH            8'h39
//     //Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
//     //Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
//     //Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
//
//     `define DET3D_MAT_STA_M1TH            8'h3a
//     //Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
//     //Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
//     //Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
//
//     `define DET3D_MAT_STA_RSFT            8'h3b
//     //Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//     //Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//     //Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//
//     `define DET3D_MAT_SYMTC_TH            8'h3c
//     //Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
//     //Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
//     //Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
//     //Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
//
//     `define DET3D_RO_DET_CB_HOR           8'h3d
//     //Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
//     //Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
//
//     `define DET3D_RO_DET_CB_VER           8'h3e
//     //Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
//     //Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
//
//     `define DET3D_RO_SPLT_HT              8'h3f
//     //Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
//     //Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
//     //Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//
//     //// DET 3D REG DEFINE END ////
#define P_DI_MTN_1_CTRL1                           (volatile uint32_t *)0xff005d00
//bit 31,      mtn_1_en
//bit 30,      mtn_init
//bit 29,      di2nr_txt_en
//bit 28,      reserved
//bit 27:24,   mtn_def
//bit 23:16,   mtn_adp_yc
//bit 15:8,    mtn_adp_2c
//bit 7:0,     mtn_adp_2y
#define P_DI_MTN_1_CTRL2                           (volatile uint32_t *)0xff005d04
//bit 31:24,   mtn_ykinter
//bit 23:16,   mtn_ckinter
//bit 15:8,    mtn_ykintra
//bit  7:0,    mtn_ckintra
#define P_DI_MTN_1_CTRL3                           (volatile uint32_t *)0xff005d08
//bit 31:24,   mtn_tyrate
//bit 23:16,   mtn_tcrate
//bit 15: 8,   mtn_mxcmby
//bit  7: 0,   mtn_mxcmbc
#define P_DI_MTN_1_CTRL4                           (volatile uint32_t *)0xff005d0c
//bit 31:24,   mtn_tcorey
//bit 23:16,   mtn_tcorec
//bit 15: 8,   mtn_minth
//bit  7: 0,   mtn_maxth
#define P_DI_MTN_1_CTRL5                           (volatile uint32_t *)0xff005d10
//bit 31:28,   mtn_m1b_extend
//bit 27:24,   mtn_m1b_errod
//bit 21:20,   mtn_mot_txt_mode
//bit 19:18,   mtn_replace_cbyy
//bit 17:16,   mtn_replace_ybyc
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
//// NR2 REG DEFINE BEGIN////
#define P_NR2_MET_NM_CTRL                          (volatile uint32_t *)0xff005d14
//Bit 28,	   reg_NM_reset	          Reset to the status of the Loop filter.
//Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise measurement sample number for statistics.
//                                    0:  256 samples;    1: 512 samples;    2: 1024 samples;   X: 2^(8+x) samples
//Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step.
//Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step.
//Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion for condition of pixels included in Luma Noise measurement.
//Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion for condition of pixels included in Chroma Noise measurement.
#define P_NR2_MET_NM_YCTRL                         (volatile uint32_t *)0xff005d18
//Bit 31:28,   reg_NM_YPLL_target	      Target rate of NM_Ynoise_thrd to mean of the Luma Noise
//Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP portion motion for condition of pixels included in Luma Noise measurement.
//Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
//Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
//Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the Luma noise measurement is lock or not.
#define P_NR2_MET_NM_CCTRL                         (volatile uint32_t *)0xff005d1c
//Bit 31:28,	reg_NM_CPLL_target	     Target rate of NM_Cnoise_thrd to mean of the Chroma Noise
//Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion for condition of pixels included in Chroma Noise measurement.
//Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
//Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
//Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma noise measurement is lock or not;
#define P_NR2_MET_NM_TNR                           (volatile uint32_t *)0xff005d20
//Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell ifLuma channel noise measurement is locked or not.
//Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell if Chroma channel noise measurement is locked or not.
//Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma channel noise level. It was 16x of pixel difference in 8 bits of YHPmot.
//Bit 11:0,	ro_NM_TNR_Clevel	         Read-only register to give Chroma channel noise level. It was 16x of pixel difference in 8 bits of CHPmot.
#define P_NR2_MET_NMFRM_TNR_YLEV                   (volatile uint32_t *)0xff005d24
//Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register to give Luma channel noise level within one frame/field.
#define P_NR2_MET_NMFRM_TNR_YCNT                   (volatile uint32_t *)0xff005d28
//Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels included in Frame/Field based noise level measurement.
#define P_NR2_MET_NMFRM_TNR_CLEV                   (volatile uint32_t *)0xff005d2c
//Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register to give Chroma channel noise level within one frame/field.
#define P_NR2_MET_NMFRM_TNR_CCNT                   (volatile uint32_t *)0xff005d30
//Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels included in Frame/Field based noise level measurement.
#define P_NR2_3DEN_MODE                            (volatile uint32_t *)0xff005d34
//Bit 6:4,	Blend_3dnr_en_r	
//Bit 2:0,	Blend_3dnr_en_l	
//   `define NR2_IIR_CTRL                8'h4e
//   //Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//   //Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute,
//   //Bit 11:8,	 reg_LP_IIR_mute_thrd	Threshold of LP IIR mute to avoid ghost:
//   //Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//   //Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute
//   //Bit 3:0,	reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost
//   //
#define P_NR2_SW_EN                                (volatile uint32_t *)0xff005d3c
//Bit 17:8,	Clk_gate_ctrl	
//Bit 7,	Cfr_enable	
//Bit 5,	Det3d_en	
//Bit 4,	Nr2_proc_en	
//Bit 0,	Nr2_sw_en	
#define P_NR2_FRM_SIZE                             (volatile uint32_t *)0xff005d40
//Bit 27:16,  Frm_heigh	Frame/field height
//Bit 11: 0,  Frm_width	Frame/field width
//   `define NR2_SNR_SAD_CFG             8'h51
//   //Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel position SAD by SAD_min;1: do replacements
//   //Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);sum = (sum<0) ? 0: (sum>255)? 255: sum;
//   //Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
//   //Bit 4:0,	Sad_coef_num	            Sad coeffient
//
//   `define NR2_MATNR_SNR_OS            8'h52
//   //Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control margin for UV channel (X2 to u10 scale)
//   //Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control margin for luma channel (X2 to u10 scale)
//
//   `define NR2_MATNR_SNR_NRM_CFG       8'h53
//   //Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR boosting normalization offset to SAD_max ;
//   //Bit 15:8,	    reg_MATNR_SNR_NRM_max	Edge based SNR boosting normalization Max value
//   //Bit 7:0,	    reg_MATNR_SNR_NRM_min	Edge based SNR boosting normalization Min value
//
//   `define NR2_MATNR_SNR_NRM_GAIN      8'h54
//   //Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting normalization Gain for Chrm channel (norm 32 as 1)
//   //Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting normalization Gain for Luma channel (norm 32 as 1)
//
//   `define NR2_MATNR_SNR_LPF_CFG       8'h55
//   //Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH) SNRLPF_yuv[k] = TNRLPF_yuv[k];
//   //Bit 13:11,reg_MATNR_SNRLPF_Cmode	    LPF based SNR filtering mode on CHRM channel:
//   //                                      0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16;
//   //                                      4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[]
//   //Bit 10:8,	reg_MATNR_SNRLPF_Ymode	    LPF based SNR filtering mode on LUMA channel:
//   //                                      0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16;
//   //                                      4: TNRLPF;               5 : CurLPF3x3_yuv[];       6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[]
//   //Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
//   //Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
//
//   `define NR2_MATNR_SNR_USF_GAIN      8'h56
//   //Bit 15:8,	reg_MATNR_SNR_USF_Cgain	    Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1)
//   //Bit 7:0,	reg_MATNR_SNR_USF_Ygain	    Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1)
//
//   `define NR2_MATNR_SNR_EDGE2B        8'h57
//   //Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,  Offset for Beta based on Edge.
//   //Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.  Gain to SAD_min for Beta based on Edge. (norm 16 as 1)
//
//   `define NR2_MATNR_BETA_EGAIN        8'h58
//   //Bit 15:8,	reg_MATNR_CBeta_Egain	U8,  Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1)
//   //Bit 7:0,	reg_MATNR_YBeta_Egain	U8,  Gain to Edge based Beta for Luma channel. (normalized to 32 as 1)
//
//   `define NR2_MATNR_BETA_BRT          8'h59
//   //Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,  Beta adjustment based on Brightness high side Limit. (X16 to u8 scale)
//   //Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,  Beta adjustment based on Brightness high side slope. Normalized to 16 as 1
//   //Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,  Beta adjustment based on Brightness high threshold.(u8 scale)
//   //Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,  Beta adjustment based on Brightness low side Limit. (X16 to u8 scale)
//   //Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,  Beta adjustment based on Brightness low side slope. Normalized to 16 as 1
//   //Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,  Beta adjustment based on Brightness low threshold.(u8 scale)
//   `define NR2_MATNR_XBETA_CFG         8'h5a
//   //Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Chrm channel;
//   //Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Luma channel;
//   //Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,  Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux)
//   //Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,  Offset to Beta for Luma channel.(after beta_edge and beta_motion mux)
//   `define NR2_MATNR_YBETA_SCL         8'h5b
//   //Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,  Final step Beta scale low limit for Luma channel;
//   //Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,  Final step Beta scale high limit for Luma channe;
//   //Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,  Final step Beta scale Gain for Luma channel (normalized 32 to 1);
//   //Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,  Final step Beta scale offset for Luma channel ;
//   `define NR2_MATNR_CBETA_SCL         8'h5c
//   //Bit 31:24,	reg_MATNR_CBeta_scale_min	Final step Beta scale low limit for Chrm channel.Similar to Y
//   //Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,  Final step Beta scale high limit for Chrm channel.Similar to Y
//   //Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,  Final step Beta scale Gain for Chrm channel Similar to Y
//   //Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,  Final step Beta scale offset for Chrm channel Similar to Y
//   `define NR2_SNR_MASK                8'h5d
//   //Bit 20:0, 	SAD_MSK	                    Valid signal in the 3x7 SAD surface
//   `define NR2_SAD2NORM_LUT0           8'h5e
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3	SAD convert normal LUT node 3
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2	SAD convert normal LUT node 2
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1	SAD convert normal LUT node 1
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0	SAD convert normal LUT node 0
//   `define NR2_SAD2NORM_LUT1           8'h5f
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7	SAD convert normal LUT node 7
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6	SAD convert normal LUT node 6
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5	SAD convert normal LUT node 5
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4	SAD convert normal LUT node 4
//   `define NR2_SAD2NORM_LUT2           8'h60
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11	SAD convert normal LUT node 11
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10	SAD convert normal LUT node 10
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9	SAD convert normal LUT node 9
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8	SAD convert normal LUT node 8
//   `define NR2_SAD2NORM_LUT3           8'h61
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15	SAD convert normal LUT node 15
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14	SAD convert normal LUT node 14
//   //Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13	SAD convert normal LUT node 13
//   //Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12	SAD convert normal LUT node 12
//   `define NR2_EDGE2BETA_LUT0          8'h62
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3	Edge convert beta LUT node 3
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2	Edge convert beta LUT node 2
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1	Edge convert beta LUT node 1
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0	Edge convert beta LUT node 0
//   `define NR2_EDGE2BETA_LUT1          8'h63
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7	Edge convert beta LUT node 7
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6	Edge convert beta LUT node 6
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5	Edge convert beta LUT node 5
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4	Edge convert beta LUT node 4
//   `define NR2_EDGE2BETA_LUT2          8'h64
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11	Edge convert beta LUT node 11
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10	Edge convert beta LUT node 10
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9	Edge convert beta LUT node 9
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8	Edge convert beta LUT node 8
//   `define NR2_EDGE2BETA_LUT3          8'h65
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15	Edge convert beta LUT node 15
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14	Edge convert beta LUT node 14
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13	Edge convert beta LUT node 13
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12	Edge convert beta LUT node 12
//   `define NR2_MOTION2BETA_LUT0        8'h66
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3	Motion convert beta LUT node 3
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2	Motion convert beta LUT node 2
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1	Motion convert beta LUT node 1
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0	Motion convert beta LUT node 0
//   `define NR2_MOTION2BETA_LUT1        8'h67
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7	Motion convert beta LUT node 7
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6	Motion convert beta LUT node 6
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5	Motion convert beta LUT node 5
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4	Motion convert beta LUT node 4
//   `define NR2_MOTION2BETA_LUT2        8'h68
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11	Motion convert beta LUT node 11
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10	Motion convert beta LUT node 10
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9	Motion convert beta LUT node 9
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8	Motion convert beta LUT node 8
//   `define NR2_MOTION2BETA_LUT3        8'h69
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15	Motion convert beta LUT node 15
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14	Motion convert beta LUT node 14
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13	Motion convert beta LUT node 13
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12	Motion convert beta LUT node 12
//    `define NR2_MATNR_MTN_CRTL          8'h6a
//    //Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
//    //Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
//    //Bit 17:16,	reg_MATNR_Ymtn_use_mode	    Motion_yuvLuma channel motion selection mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4; 2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot)
//    //Bit 13:12,	reg_MATNR_mtn_txt_mode	    Texture detection mode for adaptive coring of HP motion
//    //Bit  9: 8,	reg_MATNR_mtn_cor_mode	    Coring selection mode based on texture detection;
//    //Bit  6: 4,	reg_MATNR_mtn_hpf_mode	    video mode of current and previous frame/field for MotHPF_yuv[k] calculation:
//    //Bit  2: 0,	reg_MATNR_mtn_lpf_mode	    LPF video mode of current and previous frame/field for MotLPF_yuv[k] calculation:
//    `define NR2_MATNR_MTN_CRTL2         8'h6b
//    //Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter mode for Luma LPF result generation (Cur and Prev);
//    //Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to motion_brtlp_uv, normalized to 32 as 1
//    //Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to motion_brtlp_y, normalized to 32 as 1
//    `define NR2_MATNR_MTN_COR           8'h6c
//    //Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion.
//    //Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for Chroma Motion. Normalized to 16 as 1
//    //Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion.
//    //Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for Luma Motion. Normalized to 16 as 1
//    `define NR2_MATNR_MTN_GAIN          8'h6d
//    //Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
//    //Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
//    //Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
//    //Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
//    `define NR2_MATNR_DEGHOST           8'h6e
//    //Bit 8,	reg_MATNR_DeGhost_En	Enable signal for DeGhost function:0: disable; 1: enable
//    //Bit 7:4,	reg_MATNR_DeGhost_COS	DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
//    //Bit 3:0,	reg_MATNR_DeGhost_YOS	DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
//
//    `define NR2_MATNR_ALPHALP_LUT0      8'h6f
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_3	    Matnr low-pass filter alpha LUT node 3
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_2	    Matnr low-pass filter alpha LUT node 2
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1	    Matnr low-pass filter alpha LUT node 1
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0	    Matnr low-pass filter alpha LUT node 0
//    `define NR2_MATNR_ALPHALP_LUT1      8'h70
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_7	    Matnr low-pass filter alpha LUT node 7
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_6	    Matnr low-pass filter alpha LUT node 6
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5	    Matnr low-pass filter alpha LUT node 5
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4	    Matnr low-pass filter alpha LUT node 4
//    `define NR2_MATNR_ALPHALP_LUT2      8'h71
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_11	Matnr low-pass filter alpha LUT node 11
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_10	Matnr low-pass filter alpha LUT node 10
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9	    Matnr low-pass filter alpha LUT node 9
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8	    Matnr low-pass filter alpha LUT node 8
//    `define NR2_MATNR_ALPHALP_LUT3      8'h72
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_15	Matnr low-pass filter alpha LUT node 15
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_14	Matnr low-pass filter alpha LUT node 14
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13	Matnr low-pass filter alpha LUT node 13
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12	Matnr low-pass filter alpha LUT node 12
//    `define NR2_MATNR_ALPHAHP_LUT0      8'h73
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_3	    Matnr high-pass filter alpha LUT node 3
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_2	    Matnr high-pass filter alpha LUT node 2
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1	    Matnr high-pass filter alpha LUT node 1
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0	    Matnr high-pass filter alpha LUT node 0
//    `define NR2_MATNR_ALPHAHP_LUT1      8'h74
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_7	    Matnr high-pass filter alpha LUT node 7
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_6	    Matnr high-pass filter alpha LUT node 6
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5	    Matnr high-pass filter alpha LUT node 5
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4	    Matnr high-pass filter alpha LUT node 4
//    `define NR2_MATNR_ALPHAHP_LUT2      8'h75
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_11	Matnr high-pass filter alpha LUT node 11
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_10	Matnr high-pass filter alpha LUT node 10
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9	    Matnr high-pass filter alpha LUT node 9
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8	    Matnr high-pass filter alpha LUT node 8
//    `define NR2_MATNR_ALPHAHP_LUT3      8'h76
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_15	Matnr high-pass filter alpha LUT node 15
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_14	Matnr high-pass filter alpha LUT node 14
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13	Matnr high-pass filter alpha LUT node 13
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12	Matnr high-pass filter alpha LUT node 12
//
//    `define NR2_MATNR_MTNB_BRT          8'h77
//    //Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on Brightness high side Limit. (X16 to u8 scale)
//    //Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on Brightness high side slope. Normalized to 16 as 1
//    //Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on Brightness high threshold.(u8 scale)
//    //Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on Brightness low side Limit. (X16 to u8 scale)
//    //Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on Brightness low side slope. Normalized to 16 as 1
//    //Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on Brightness low threshold.(u8 scale)
// 0x51 - 0x69 | 0x4e | 0x6a - 0x77
//
// Reading file:  vpu_nr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//========== nr2_snr_regs register begin ==========//
#define P_NR2_SNR_SAD_CFG                          (volatile uint32_t *)0xff005d44
//Bit 31:13        reserved
//Bit 12           reg_matnr_snr_sad_cenrpl       // unsigned , default = 1
//Bit 11: 8        reg_matnr_snr_sad_coring       // unsigned , default = 3
//Bit  7            reserved
//Bit  6: 5        reg_matnr_snr_sad_winmod       // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
//Bit  4: 0        sad_coef_num                      // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
#define P_NR2_MATNR_SNR_OS                         (volatile uint32_t *)0xff005d48
//Bit 31: 8        reserved
//Bit  7: 4        reg_matnr_snr_cos              // unsigned , default = 8
//Bit  3: 0        reg_matnr_snr_yos              // unsigned , default = 13
#define P_NR2_MATNR_SNR_NRM_CFG                    (volatile uint32_t *)0xff005d4c
//Bit 31:24        reserved
//Bit 23:16        reg_matnr_snr_nrm_ofst         // signed , default = 64
//Bit 15: 8        reg_matnr_snr_nrm_max          // unsigned , default = 255
//Bit  7: 0        reg_matnr_snr_nrm_min          // unsigned , default = 0
#define P_NR2_MATNR_SNR_NRM_GAIN                   (volatile uint32_t *)0xff005d50
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_nrm_cgain        // unsigned , default = 0     norm 32
//Bit  7: 0        reg_matnr_snr_nrm_ygain        // unsigned , default = 32    norm 32
#define P_NR2_MATNR_SNR_LPF_CFG                    (volatile uint32_t *)0xff005d54
//Bit 31:24        reserved
//Bit 23:16        reg_matnr_snrlpf_sadmaxth      // unsigned , default = 12
//Bit 15:14        reserved
//Bit 13:11        reg_matnr_snrlpf_cmode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
//Bit 10: 8        reg_matnr_snrlpf_ymode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
//Bit  7: 4        reg_matnr_snrlpf_sadmin3th     // unsigned , default = 6     X8
//Bit  3: 0        reg_matnr_snrlpf_sadmin2th     // unsigned , default = 4     X8
#define P_NR2_MATNR_SNR_USF_GAIN                   (volatile uint32_t *)0xff005d58
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_usf_cgain        // unsigned , default = 0     norm 64
//Bit  7: 0        reg_matnr_snr_usf_ygain        // unsigned , default = 0     norm 64
#define P_NR2_MATNR_SNR_EDGE2B                     (volatile uint32_t *)0xff005d5c
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_edge2beta_ofst   // unsigned , default = 128
//Bit  7: 0        reg_matnr_snr_edge2beta_gain   // unsigned , default = 16
#define P_NR2_MATNR_BETA_EGAIN                     (volatile uint32_t *)0xff005d60
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_cbeta_egain          // unsigned , default = 32    normalized to 32
//Bit  7: 0        reg_matnr_ybeta_egain          // unsigned , default = 32    normalized to 32
#define P_NR2_MATNR_BETA_BRT                       (volatile uint32_t *)0xff005d64
//Bit 31:28        reg_matnr_beta_brt_limt_hi     // unsigned , default = 0
//Bit 27:24        reg_matnr_beta_brt_slop_hi     // unsigned , default = 0
//Bit 23:16        reg_matnr_beta_brt_thrd_hi     // unsigned , default = 160
//Bit 15:12        reg_matnr_beta_brt_limt_lo     // unsigned , default = 6
//Bit 11: 8        reg_matnr_beta_brt_slop_lo     // unsigned , default = 6
//Bit  7: 0        reg_matnr_beta_brt_thrd_lo     // unsigned , default = 100
#define P_NR2_MATNR_XBETA_CFG                      (volatile uint32_t *)0xff005d68
//Bit 31:20        reserved
//Bit 19:18        reg_matnr_cbeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2
//Bit 17:16        reg_matnr_ybeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2;
//Bit 15: 8        reg_matnr_cbeta_ofst           // unsigned , default = 0
//Bit  7: 0        reg_matnr_ybeta_ofst           // unsigned , default = 0
#define P_NR2_MATNR_YBETA_SCL                      (volatile uint32_t *)0xff005d6c
//Bit 31:24        reg_matnr_ybeta_scale_min      // unsigned , default = 60
//Bit 23:16        reg_matnr_ybeta_scale_max      // unsigned , default = 255
//Bit 15: 8        reg_matnr_ybeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
//Bit  7: 0        reg_matnr_ybeta_scale_ofst     // signed , default = 0
#define P_NR2_MATNR_CBETA_SCL                      (volatile uint32_t *)0xff005d70
//Bit 31:24        reg_matnr_cbeta_scale_min      // unsigned , default = 0
//Bit 23:16        reg_matnr_cbeta_scale_max      // unsigned , default = 255
//Bit 15: 8        reg_matnr_cbeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
//Bit  7: 0        reg_matnr_cbeta_scale_ofst     // signed , default = 0
#define P_NR2_SNR_MASK                             (volatile uint32_t *)0xff005d74
//Bit 31:21        reserved
//Bit 20: 0        sad_msk                        // unsigned , default = 0x0f9f3e
#define P_NR2_SAD2NORM_LUT0                        (volatile uint32_t *)0xff005d78
//Bit 31:24        reg_matnr_sad2norm_lut3      // unsigned , default = 114
//Bit 23:16        reg_matnr_sad2norm_lut2      // unsigned , default = 146
//Bit 15: 8        reg_matnr_sad2norm_lut1      // unsigned , default = 171
//Bit  7: 0        reg_matnr_sad2norm_lut0      // unsigned , default = 205
#define P_NR2_SAD2NORM_LUT1                        (volatile uint32_t *)0xff005d7c
//Bit 31:24        reg_matnr_sad2norm_lut7      // unsigned , default = 28
//Bit 23:16        reg_matnr_sad2norm_lut6      // unsigned , default = 35
//Bit 15: 8        reg_matnr_sad2norm_lut5      // unsigned , default = 49
//Bit  7: 0        reg_matnr_sad2norm_lut4      // unsigned , default = 79
#define P_NR2_SAD2NORM_LUT2                        (volatile uint32_t *)0xff005d80
//Bit 31:24        reg_matnr_sad2norm_lut11     // unsigned , default = 15
//Bit 23:16        reg_matnr_sad2norm_lut10     // unsigned , default = 17
//Bit 15: 8        reg_matnr_sad2norm_lut9      // unsigned , default = 19
//Bit  7: 0        reg_matnr_sad2norm_lut8      // unsigned , default = 23
#define P_NR2_SAD2NORM_LUT3                        (volatile uint32_t *)0xff005d84
//Bit 31:24        reg_matnr_sad2norm_lut15     // unsigned , default = 8
//Bit 23:16        reg_matnr_sad2norm_lut14     // unsigned , default = 9
//Bit 15: 8        reg_matnr_sad2norm_lut13     // unsigned , default = 10
//Bit  7: 0        reg_matnr_sad2norm_lut12     // unsigned , default = 12
#define P_NR2_EDGE2BETA_LUT0                       (volatile uint32_t *)0xff005d88
//Bit 31:24        reg_matnr_edge2beta_lut3    // unsigned , default = 128
//Bit 23:16        reg_matnr_edge2beta_lut2    // unsigned , default = 160
//Bit 15: 8        reg_matnr_edge2beta_lut1    // unsigned , default = 224
//Bit  7: 0        reg_matnr_edge2beta_lut0    // unsigned , default = 255
#define P_NR2_EDGE2BETA_LUT1                       (volatile uint32_t *)0xff005d8c
//Bit 31:24        reg_matnr_edge2beta_lut7    // unsigned , default = 4
//Bit 23:16        reg_matnr_edge2beta_lut6    // unsigned , default = 16
//Bit 15: 8        reg_matnr_edge2beta_lut5    // unsigned , default = 32
//Bit  7: 0        reg_matnr_edge2beta_lut4    // unsigned , default = 80
#define P_NR2_EDGE2BETA_LUT2                       (volatile uint32_t *)0xff005d90
//Bit 31:24        reg_matnr_edge2beta_lut11    // unsigned , default = 0
//Bit 23:16        reg_matnr_edge2beta_lut10    // unsigned , default = 0
//Bit 15: 8        reg_matnr_edge2beta_lut9    // unsigned , default = 0
//Bit  7: 0        reg_matnr_edge2beta_lut8    // unsigned , default = 2
#define P_NR2_EDGE2BETA_LUT3                       (volatile uint32_t *)0xff005d94
//Bit 31:24        reg_matnr_edge2beta_lut15    // unsigned , default = 0
//Bit 23:16        reg_matnr_edge2beta_lut14    // unsigned , default = 0
//Bit 15: 8        reg_matnr_edge2beta_lut13    // unsigned , default = 0
//Bit  7: 0        reg_matnr_edge2beta_lut12    // unsigned , default = 0
#define P_NR2_MOTION2BETA_LUT0                     (volatile uint32_t *)0xff005d98
//Bit 31:24        reg_matnr_mot2beta_lut3     // unsigned , default = 32
//Bit 23:16        reg_matnr_mot2beta_lut2     // unsigned , default = 16
//Bit 15: 8        reg_matnr_mot2beta_lut1     // unsigned , default = 4
//Bit  7: 0        reg_matnr_mot2beta_lut0     // unsigned , default = 0
#define P_NR2_MOTION2BETA_LUT1                     (volatile uint32_t *)0xff005d9c
//Bit 31:24        reg_matnr_mot2beta_lut7     // unsigned , default = 196
//Bit 23:16        reg_matnr_mot2beta_lut6     // unsigned , default = 128
//Bit 15: 8        reg_matnr_mot2beta_lut5     // unsigned , default = 64
//Bit  7: 0        reg_matnr_mot2beta_lut4     // unsigned , default = 48
#define P_NR2_MOTION2BETA_LUT2                     (volatile uint32_t *)0xff005da0
//Bit 31:24        reg_matnr_mot2beta_lut11     // unsigned , default = 255
//Bit 23:16        reg_matnr_mot2beta_lut10     // unsigned , default = 255
//Bit 15: 8        reg_matnr_mot2beta_lut9     // unsigned , default = 240
//Bit  7: 0        reg_matnr_mot2beta_lut8     // unsigned , default = 224
#define P_NR2_MOTION2BETA_LUT3                     (volatile uint32_t *)0xff005da4
//Bit 31:24        reg_matnr_mot2beta_lut15     // unsigned , default = 255
//Bit 23:16        reg_matnr_mot2beta_lut14     // unsigned , default = 255
//Bit 15: 8        reg_matnr_mot2beta_lut13     // unsigned , default = 255
//Bit  7: 0        reg_matnr_mot2beta_lut12     // unsigned , default = 255
//========== nr2_snr_regs register end ==========//
//========== nr2_tnr_regs register begin ==========//
#define P_NR2_IIR_CTRL                             (volatile uint32_t *)0xff005d38
//Bit 31:16        reserved
//Bit 15:14        reg_lp_iir_8bit_mode      // unsigned , default = 0  10bits; 1: 9bits; 2: 8bits 3: 7bits
//Bit 13:12        reg_hp_iir_mute_mode      // unsigned , default = 0
//Bit 11: 8        reg_hp_iir_mute_thrd      // unsigned , default = 0
//Bit  7: 6        reg_hp_iir_8bit_mode      // unsigned , default = 0
//Bit  5: 4        reg_lp_iir_mute_mode      // unsigned , default = 0
//Bit  3: 0        reg_lp_iir_mute_thrd      // unsigned , default = 0
#define P_NR2_MATNR_MTN_CRTL                       (volatile uint32_t *)0xff005da8
//Bit 31:20        reserved
//Bit 19:18        reg_matnr_vmtn_use_mode   // unsigned , default = 0  0- Vmot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 17:16        reg_matnr_umtn_use_mode   // unsigned , default = 0  0- Umot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 15:14        reg_matnr_ymtn_use_mode   // unsigned , default = 0  0- Ymot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 13:12        reg_matnr_mtn_txt_mode    // unsigned , default = 1
//Bit 11            reserved
//Bit 10: 8        reg_matnr_mtn_cor_mode    // unsigned , default = 1  changes)
//Bit  7: 4        reg_matnr_mtn_hpf_mode    // unsigned , default = 8  extend to u4 for nr4, 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6:3x3 SAD, 7: 5x3 SAD, 8-15: drt adaptive
//Bit  3            reserved
//Bit  2: 0        reg_matnr_mtn_lpf_mode    // unsigned , default = 6  0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6,7: drt adaptive
#define P_NR2_MATNR_MTN_CRTL2                      (volatile uint32_t *)0xff005dac
//Bit 31:19        reserved
//Bit 18:16        reg_matnr_iir_bs_ymode      // unsigned , default = 6  LPF~~ 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5; 6/7: 0
//Bit 15: 8        reg_matnr_mtnb_alplp_cgain  // unsigned , default = 64  to 32
//Bit  7: 0        reg_matnr_mtnb_alplp_ygain  // unsigned , default = 64  to 32
#define P_NR2_MATNR_MTN_COR                        (volatile uint32_t *)0xff005db0
//Bit 31:16        reserved
//Bit 15:12        reg_matnr_mtn_cor_cofst   // unsigned , default = 3  Offset for Chroma Motion.
//Bit 11: 8        reg_matnr_mtn_cor_cgain   // unsigned , default = 3  to texture based coring for Chroma Motion. Normalized to 16 as 1
//Bit  7: 4        reg_matnr_mtn_cor_yofst   // unsigned , default = 3  Offset for Luma Motion.
//Bit  3: 0        reg_matnr_mtn_cor_ygain   // unsigned , default = 3  to texture based coring for Luma Motion. Normalized to 16 as 1
#define P_NR2_MATNR_MTN_GAIN                       (volatile uint32_t *)0xff005db4
//Bit 31:24        reg_matnr_mtn_hp_cgain    // unsigned , default = 64  to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
//Bit 23:16        reg_matnr_mtn_hp_ygain    // unsigned , default = 64  to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
//Bit 15: 8        reg_matnr_mtn_lp_cgain    // unsigned , default = 64  to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
//Bit  7: 0        reg_matnr_mtn_lp_ygain    // unsigned , default = 64  to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
#define P_NR2_MATNR_DEGHOST                        (volatile uint32_t *)0xff005db8
//Bit 31            reserved
//Bit 30:28        reg_matnr_deghost_mode    // unsigned , default = 0  0:old_deghost; 1:soft_denoise & strong_deghost; 2:strong_denoise & soft_deghost; 3:strong_denoise & strong_deghost
//Bit 27:25        reserved
//Bit 24:20        reg_matnr_deghost_ygain   // unsigned , default = 4
//Bit 19:17        reserved
//Bit 16:12        reg_matnr_deghost_cgain   // unsigned , default = 4
//Bit 11: 9        reserved
//Bit  8           reg_matnr_deghost_en      // unsigned , default = 1  0: disable; 1: enable Enable signal for DeGhost function:0: disable; 1: enable
//Bit  7: 4        reg_matnr_deghost_cos     // unsigned , default = 3  DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
//Bit  3: 0        reg_matnr_deghost_yos     // unsigned , default = 3  DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
#define P_NR2_MATNR_ALPHALP_LUT0                   (volatile uint32_t *)0xff005dbc
//Bit 31:24        reg_matnr_alphalp_lut3    // unsigned , default = 64  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut2    // unsigned , default = 128  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut1    // unsigned , default = 128  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut0    // unsigned , default = 128  low-pass filter alpha LUT
#define P_NR2_MATNR_ALPHALP_LUT1                   (volatile uint32_t *)0xff005dc0
//Bit 31:24        reg_matnr_alphalp_lut7    // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut6    // unsigned , default = 128  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut5    // unsigned , default = 80  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut4    // unsigned , default = 64  low-pass filter alpha LUT
#define P_NR2_MATNR_ALPHALP_LUT2                   (volatile uint32_t *)0xff005dc4
//Bit 31:24        reg_matnr_alphalp_lut11   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut10   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut9    // unsigned , default = 255  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut8    // unsigned , default = 255  low-pass filter alpha LUT
#define P_NR2_MATNR_ALPHALP_LUT3                   (volatile uint32_t *)0xff005dc8
//Bit 31:24        reg_matnr_alphalp_lut15   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut14   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut13   // unsigned , default = 255  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut12   // unsigned , default = 255  low-pass filter alpha LUT
#define P_NR2_MATNR_ALPHAHP_LUT0                   (volatile uint32_t *)0xff005dcc
//Bit 31:24        reg_matnr_alphahp_lut3    // unsigned , default = 64  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut2    // unsigned , default = 128  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut1    // unsigned , default = 128  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut0    // unsigned , default = 128  high-pass filter alpha LUT
#define P_NR2_MATNR_ALPHAHP_LUT1                   (volatile uint32_t *)0xff005dd0
//Bit 31:24        reg_matnr_alphahp_lut7    // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut6    // unsigned , default = 128  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut5    // unsigned , default = 80  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut4    // unsigned , default = 64  high-pass filter alpha LUT
#define P_NR2_MATNR_ALPHAHP_LUT2                   (volatile uint32_t *)0xff005dd4
//Bit 31:24        reg_matnr_alphahp_lut11   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut10   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut9    // unsigned , default = 255  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut8    // unsigned , default = 255  high-pass filter alpha LUT
#define P_NR2_MATNR_ALPHAHP_LUT3                   (volatile uint32_t *)0xff005dd8
//Bit 31:24        reg_matnr_alphahp_lut15   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut14   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut13   // unsigned , default = 255  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut12   // unsigned , default = 255  high-pass filter alpha LUT
#define P_NR2_MATNR_MTNB_BRT                       (volatile uint32_t *)0xff005ddc
//Bit 31:28        reg_matnr_mtnb_brt_limt_hi  // unsigned , default = 0
//Bit 27:24        reg_matnr_mtnb_brt_slop_hi  // unsigned , default = 0
//Bit 23:16        reg_matnr_mtnb_brt_thrd_hi  // unsigned , default = 160
//Bit 15:12        reg_matnr_mtnb_brt_limt_lo  // unsigned , default = 6
//Bit 11: 8        reg_matnr_mtnb_brt_slop_lo  // unsigned , default = 6
//Bit  7: 0        reg_matnr_mtnb_brt_thrd_lo  // unsigned , default = 100
//========== nr2_tnr_regs register end ==========//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_nr2_regs.h
//
//
// Reading file:  nr2_cue_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR2_CUE_MODE                             (volatile uint32_t *)0xff005de0
//Bit 31:20        reserved
//Bit 19           reg_cue2_isabv_org_invert1  // unsigned , default = 0
//Bit 18           reg_cue2_valid_condition    // unsigned , default = 1
//Bit 17:16        reg_cue2_orgline_flt_sel    // unsigned , default = 1
//Bit 15:12        reg_cue2_orgline_flt_alph   // unsigned , default = 4
//Bit 11           reg_cue2_isabv_org_invert   // unsigned , default = 0
//Bit 10           reg_cue2_iscur_org_invert   // unsigned , default = 0
//Bit  9           reg_cue_enable_r	          // unsigned , default = 1  right half frame enable
//Bit  8           reg_cue_enable_l            // unsigned , default = 1  left half frame enable
//Bit  7            reserved
//Bit  6: 4        reg_cue_con_rplc_mode       // unsigned , default = 7  pixel chroma replace mode;
//Bit  3: 0        reg_cue_chrm_flt_mode       // unsigned , default = 5  improvement filter mode,
#define P_NR2_CUE_CON_MOT_TH                       (volatile uint32_t *)0xff005de4
//Bit 31:24        reg_cue_con_cmot_thrd2	   // unsigned , default = 20  Detection threshold of up/down two rows,  Chroma channel in Chroma Up-sampling Error (CUE) Detection (tighter).
//Bit 23:16        reg_cue_con_ymot_thrd2	   // unsigned , default = 20  Detection threshold of up/mid/down three rows,  Luma channel in Chroma Up-sampling Error (CUE) Detection (tighter).
//Bit 15: 8        reg_cue_con_cmot_thrd	      // unsigned , default = 20  Detection threshold of up/down two rows, Chroma channel in Chroma Up-sampling Error (CUE) Detection.
//Bit  7: 0        reg_cue_con_ymot_thrd	      // unsigned , default = 20  Detection threshold of up/mid/down three rows, Luma channel in Chroma Up-sampling Error (CUE) Detection.
#define P_NR2_CUE_CON_DIF0                         (volatile uint32_t *)0xff005de8
//Bit 31:16        reserved
//Bit 15: 8        reg_cue_con_difp1_thrd	   // unsigned , default = 20  field Intra-Field top/below line chroma difference threshold,
//Bit  7: 0        reg_cue_con_difcur_thrd	  // unsigned , default = 0  Field/Frame Intra-Field up/down line chroma difference threshold,
#define P_NR2_CUE_CON_DIF1                         (volatile uint32_t *)0xff005dec
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate0	         // unsigned , default = 8  Krate to decide CUE by relationship between CUE_diflG and CUE_difEG
//Bit 15: 8        reg_cue_con_difeg_thrd	   // unsigned , default = 0  to the difference between current Field/Frame middle line to down line color channel(CUE_difEG).
//Bit  7: 0        reg_cue_con_diflg_thrd	   // unsigned , default = 100  to the difference between P1 field top line to current Field/Frame down line color channel (CUE_diflG).
#define P_NR2_CUE_CON_DIF2                         (volatile uint32_t *)0xff005df0
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate1	        // unsigned , default = 8  Krate to decide CUE by relationship between CUE_difnC and CUE_difEC
//Bit 15: 8        reg_cue_con_difec_thrd    // unsigned , default = 0  to the difference between current Field/Frame middle line to up line color channel(CUE_difEC).
//Bit  7: 0        reg_cue_con_difnc_thrd    // unsigned , default = 100  to the difference between P1 field bot line to current Field/Frame up line color channel (CUE_difnC).
#define P_NR2_CUE_CON_DIF3                         (volatile uint32_t *)0xff005df4
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate2	        // unsigned , default = 8  Krate to decide CUE by relationship between CUE_difP1 and CUE_difEP1
//Bit 15: 8        reg_cue_con_difep1_thrd   // unsigned , default = 10  top/below line to current field/frame middle line chroma difference (CUE_difEP1) threshold.
//Bit  7: 0        reg_cue_con_difp1_thrd2   // unsigned , default = 10  field Intra-Field top/below line chroma difference threshold (tighter),
#define P_NR2_CUE_PRG_DIF                          (volatile uint32_t *)0xff005df8
//Bit 31:21        reserved
//Bit 20           reg_cue_prg_enable	       // unsigned , default = 0  bit for progressive video CUE detection.If interlace input video,
//Bit 19:16        reg_cue_prg_rate	         // unsigned , default = 4  Krate to decide CUE by relationship between CUE_difCur and (CUE_difEC+CUE_difEG)
//Bit 15: 8        reg_cue_prg_difceg_thrd   // unsigned , default = 40  Frame Intra-Field up-mid and mid-down line chroma difference threshold for progressive video CUE detection,
//Bit  7: 0        reg_cue_prg_difcur_thrd   // unsigned , default = 30  Frame Intra-Field up/down line chroma difference threshold,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr2_cue_regs.h
//
#define P_NR2_CONV_MODE                            (volatile uint32_t *)0xff005dfc
//Bit 3:2,	Conv_c444_mode	The format convert mode about 422 to 444 when data read out line buffer
//Bit 1:0,	Conv_c422_mode	the format convert mode about 444 to 422 when data write to line buffer
//// NR2 REG DEFINE END ////
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f | 8'h80~8'h8f | 0x9a-0x9b
//
// Reading file:  vpu_det3d_regs.h
//
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
//// DET 3D REG DEFINE END ////
#define P_DET3D_MOTN_CFG                           (volatile uint32_t *)0xff005cd0
//Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
//Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
//                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
//Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
//Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
#define P_DET3D_CB_CFG                             (volatile uint32_t *)0xff005cd4
//Bit 7:4,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizontal or vertical combing detection.
//Bit 3:0,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizontal or vertical combing detection.
#define P_DET3D_SPLT_CFG                           (volatile uint32_t *)0xff005cd8
//Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
//                                      The smaller of this value, the easier of the split line detected.
//Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
//                                      The smaller of this value, the more samples will be added to the estimation.
#define P_DET3D_HV_MUTE                            (volatile uint32_t *)0xff005cdc
//Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
//Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
//Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
//Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
#define P_DET3D_MAT_STA_P1M1                       (volatile uint32_t *)0xff005ce0
//Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
//Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
//Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
//Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
#define P_DET3D_MAT_STA_P1TH                       (volatile uint32_t *)0xff005ce4
//Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
//Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
#define P_DET3D_MAT_STA_M1TH                       (volatile uint32_t *)0xff005ce8
//Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
//Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
#define P_DET3D_MAT_STA_RSFT                       (volatile uint32_t *)0xff005cec
//Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
#define P_DET3D_MAT_SYMTC_TH                       (volatile uint32_t *)0xff005cf0
//Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
//Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
//Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
//Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
#define P_DET3D_RO_DET_CB_HOR                      (volatile uint32_t *)0xff005cf4
//Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
#define P_DET3D_RO_DET_CB_VER                      (volatile uint32_t *)0xff005cf8
//Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
#define P_DET3D_RO_SPLT_HT                         (volatile uint32_t *)0xff005cfc
//Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
//Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
//Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//// DET 3D REG DEFINE BEGIN ////
////  8'h80~8'h8f
#define P_DET3D_RO_SPLT_HB                         (volatile uint32_t *)0xff005e00
//Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define P_DET3D_RO_SPLT_VL                         (volatile uint32_t *)0xff005e04
//Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define P_DET3D_RO_SPLT_VR                         (volatile uint32_t *)0xff005e08
//Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define P_DET3D_RO_MAT_LUMA_LR                     (volatile uint32_t *)0xff005e0c
//Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
//Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
//                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
//Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
//                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
#define P_DET3D_RO_MAT_LUMA_TB                     (volatile uint32_t *)0xff005e10
//Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
//Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
//Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
#define P_DET3D_RO_MAT_CHRU_LR                     (volatile uint32_t *)0xff005e14
//Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
//Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
#define P_DET3D_RO_MAT_CHRU_TB                     (volatile uint32_t *)0xff005e18
//Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
#define P_DET3D_RO_MAT_CHRV_LR                     (volatile uint32_t *)0xff005e1c
//Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
#define P_DET3D_RO_MAT_CHRV_TB                     (volatile uint32_t *)0xff005e20
//Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
#define P_DET3D_RO_MAT_HEDG_LR                     (volatile uint32_t *)0xff005e24
//Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
#define P_DET3D_RO_MAT_HEDG_TB                     (volatile uint32_t *)0xff005e28
//Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
#define P_DET3D_RO_MAT_VEDG_LR                     (volatile uint32_t *)0xff005e2c
//Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
#define P_DET3D_RO_MAT_VEDG_TB                     (volatile uint32_t *)0xff005e30
//Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
#define P_DET3D_RO_MAT_MOTN_LR                     (volatile uint32_t *)0xff005e34
//Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
#define P_DET3D_RO_MAT_MOTN_TB                     (volatile uint32_t *)0xff005e38
//Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
#define P_DET3D_RO_FRM_MOTN                        (volatile uint32_t *)0xff005e3c
//Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
/// mat ram read enter addr
#define P_DET3D_RAMRD_ADDR_PORT                    (volatile uint32_t *)0xff005e68
#define P_DET3D_RAMRD_DATA_PORT                    (volatile uint32_t *)0xff005e6c
//
// Closing file:  vpu_det3d_regs.h
//
//   `define DET3D_RO_SPLT_HB            8'h80
//   //Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_SPLT_VL            8'h81
//   //Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_SPLT_VR            8'h82
//   //Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_MAT_LUMA_LR        8'h83
//   //Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//   //                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
//   //Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
//   //                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
//   //Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
//   //                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
//   `define DET3D_RO_MAT_LUMA_TB        8'h84
//   //Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
//   //Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
//   //Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
//   `define DET3D_RO_MAT_CHRU_LR        8'h85
//   //Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//   //Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
//   //Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
//   `define DET3D_RO_MAT_CHRU_TB        8'h86
//   //Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
//   `define DET3D_RO_MAT_CHRV_LR        8'h87
//   //Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
//   `define DET3D_RO_MAT_CHRV_TB        8'h88
//   //Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
//   `define DET3D_RO_MAT_HEDG_LR        8'h89
//   //Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
//   `define DET3D_RO_MAT_HEDG_TB        8'h8a
//   //Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
//   `define DET3D_RO_MAT_VEDG_LR        8'h8b
//   //Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
//   `define DET3D_RO_MAT_VEDG_TB        8'h8c
//   //Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
//   `define DET3D_RO_MAT_MOTN_LR        8'h8d
//   //Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
//   `define DET3D_RO_MAT_MOTN_TB        8'h8e
//   //Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
//   `define DET3D_RO_FRM_MOTN           8'h8f
//   //Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
#define P_DI_EI_CTRL10                             (volatile uint32_t *)0xff005e4c
//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
//bit 15,      reg_ei_caldrt_hstrrgchk_en
//bit 14:13,   reg_ei_caldrt_hpncheck_mode
//bit 12,      reg_ei_caldrt_hpncheck_mute
//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
#define P_DI_NR_1_CTRL0                            (volatile uint32_t *)0xff005e50
#define P_DI_NR_1_CTRL1                            (volatile uint32_t *)0xff005e54
#define P_DI_NR_1_CTRL2                            (volatile uint32_t *)0xff005e58
#define P_DI_NR_1_CTRL3                            (volatile uint32_t *)0xff005e5c
#define P_DI_EI_XWIN0                              (volatile uint32_t *)0xff005e60
//bit 27:16,   ei_xend0
//bit 11:0,    ei_xstart0
#define P_DI_EI_XWIN1                              (volatile uint32_t *)0xff005e64
/// mat ram read enter addr
//   `define DET3D_RAMRD_ADDR_PORT       8'h9a
//   `define DET3D_RAMRD_DATA_PORT       8'h9b
#define P_NR2_CFR_PARA_CFG0                        (volatile uint32_t *)0xff005e70
//Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma difference calculation mode
//Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based phase register that need to be set by FW phase to phase:
//                                      this will be calculated based on dbdr_phase of the specific line of this frame.
//                                      u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center line is Dr in current line;
//Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line Luma/Chroma transition level calculation mode,
//Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2; 2: min(motAlp,curAlp); 3: max(motAlp,curAlp);
//Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion 2: top/bot + middle motion; 3: max(top/tot motion, middle motion)
#define P_NR2_CFR_PARA_CFG1                        (volatile uint32_t *)0xff005e74
//Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp to alpha that will be used for final blending.
//Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as the level of motion that we consider it at moving.
//Bit  7: 0,	reg_CFR_CurDif_gain	    gain to CurDif to map to alpha, normalized to 32;
//// DET 3D REG DEFINE END ////
#define P_DI_EI_CTRL11                             (volatile uint32_t *)0xff005e78
//bit 30:29,   reg_ei_amb_detect_mode
//bit 28:24,   reg_ei_amb_detect_winth
//bit 23:21,   reg_ei_amb_decide_rppth
//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
//bit 11:8,    reg_ei_retime_lastpnchk_drtth
//bit 6,       reg_ei_retime_lastpnchk_en
//bit 5:4,     reg_ei_retime_mode
//bit 3,       reg_ei_retime_last_en
//bit 2,       reg_ei_retime_ab_en
//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
//bit 0,       reg_ei_caldrt_hstrrgchk_mode
#define P_DI_EI_CTRL12                             (volatile uint32_t *)0xff005e7c
//bit 31:28,   reg_ei_drtdelay2_lmt
//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
//bit 25:24,   reg_ei_drtdelay_mode
//bit 23,      reg_ei_drtdelay2_mode
//bit 22:20,   reg_ei_assign_xla_signm0th
//bit 19,      reg_ei_assign_pkbiasvert_en
//bit 18,      reg_ei_assign_xla_en
//bit 17:16,   reg_ei_assign_xla_mode
//bit 15:12,   reg_ei_assign_nlfilter_magin
//bit 11:8,    reg_ei_localsearch_maxrange
//bit 7:4,     reg_ei_xla_drtth
//bit 3:0,     reg_ei_flatmsad_thrd
//`define DI_DIWR_CANVAS      8'ha0
//`define DI_DIWR_URGENT      8'ha1
//`define DI_NRWR_CANVAS      8'ha2
//`define DI_NRWR_URGENT      8'ha7
//`define DI_CONTWR_X                8'ha0
//`define DI_CONTWR_Y                8'ha1
//`define DI_CONTWR_CTRL             8'ha2
//`define DI_CONTPRD_X               8'ha3
//`define DI_CONTPRD_Y               8'ha4
//`define DI_CONTP2RD_X              8'ha5
//`define DI_CONTP2RD_Y              8'ha6
#define P_DI_RO_PRE_FIELD_CNT0                     (volatile uint32_t *)0xff005e8c
#define P_DI_RO_PRE_FIELD_CNT1                     (volatile uint32_t *)0xff005e90
#define P_DI_RO_POS_FRAME_CNT0                     (volatile uint32_t *)0xff005e94
#define P_DI_RO_POS_FRAME_CNT1                     (volatile uint32_t *)0xff005e98
//`define DI_CONTRD_CTRL             8'ha7
#define P_DI_EI_CTRL13                             (volatile uint32_t *)0xff005ea0
//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
//bit 23:20,   reg_ei_int_drt16x_core
//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
#define P_DI_MTN_1_CTRL6                           (volatile uint32_t *)0xff005ea4
//bit 31:24,   mtn_m1b_extend
//bit 23:16,   mtn_m1b_errod
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
#define P_DI_MTN_1_CTRL7                           (volatile uint32_t *)0xff005ea8
//bit 31:24,   mtn_core_mxcmby
//bit 23:16,   mtn_core_mxcmbc
//bit 15: 8,   mtn_core_y
//bit  7: 0,   mtn_core_c
#define P_DI_MTN_1_CTRL8                           (volatile uint32_t *)0xff005eac
//bit 31:24,   mtn_fcore_ykinter
//bit 23:16,   mtn_fcore_ckinter
//bit 15: 8,   mtn_fcore_ykintra
//bit  7: 0,   mtn_fcore_ckintra
#define P_DI_MTN_1_CTRL9                           (volatile uint32_t *)0xff005eb0
//bit 31:24,   mtn_fcore_2yrate
//bit 23:16,   mtn_fcore_2crate
//bit 15: 8,   mtn_fcore_y
//bit  7: 0,   mtn_fcore_c
#define P_DI_MTN_1_CTRL10                          (volatile uint32_t *)0xff005eb4
//bit 27:24,   mtn_motfld0
//bit 19:16,   mtn_stlfld0
//bit 11: 8,   mtn_motfld1
//bit  3: 0,   mtn_stlfld1
#define P_DI_MTN_1_CTRL11                          (volatile uint32_t *)0xff005eb8
//bit 27:24,   mtn_smotevn
//bit 20:16,   mtn_smotodd
//bit 11: 8,   mtn_sstlevn
//bit  4: 0,   mtn_sstlodd
#define P_DI_MTN_1_CTRL12                          (volatile uint32_t *)0xff005ebc
//bit 31:24,   mtn_mgain
//bit 17:16,   mtn_mmode
//bit 15: 8,   mtn_sthrd
//bit  4: 0,   mtn_sgain
//`define DI_NRWR_X                 8'hc0
//`define DI_NRWR_Y                 8'hc1
//bit 31:30				nrwr_words_lim
//bit 29				nrwr_rev_y
//bit 28:16				nrwr_start_y
//bit 15				nrwr_ext_en
//bit 12:0				nrwr_end_y
//`define DI_NRWR_CTRL              8'hc2
//bit 31				pending_ddr_wrrsp_diwr
//bit 30				nrwr_reg_swap
//bit 29:26				nrwr_burst_lim
//bit 25				nrwr_canvas_syncen
//bit 24				nrwr_no_clk_gate
//bit 23:22				nrwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
					             //2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20				nrwr_hconv_mode
//bit 19:18				nrwr_vconv_mode
//bit 17				nrwr_swap_cbcr
//bit 16				nrwr_urgent
//bit 15:8				nrwr_canvas_index_chroma
//bit 7:0				nrwr_canvas_index_luma
//`define DI_MTNWR_X                8'hc3
//`define DI_MTNWR_Y                8'hc4
//`define DI_MTNWR_CTRL             8'hc5
#define P_DI_RO_CRC_NRWR                           (volatile uint32_t *)0xff005f00
#define P_DI_RO_CRC_MTNWR                          (volatile uint32_t *)0xff005f04
#define P_DI_RO_CRC_DEINT                          (volatile uint32_t *)0xff005f08
#define P_DI_CRC_CHK0                              (volatile uint32_t *)0xff005f0c
#define P_DI_CRC_CHK1                              (volatile uint32_t *)0xff005f10
//`define DI_DIWR_X                 8'hc6
//`define DI_DIWR_Y                 8'hc7
//bit 31:30				diwr_words_lim
//bit 29				diwr_rev_y
//bit 28:16				diwr_start_y
//bit 15				diwr_ext_en
//bit 12:0				diwr_end_y
//`define DI_DIWR_CTRL              8'hc8
//bit 31				pending_ddr_wrrsp_diwr
//bit 30				diwr_reg_swap
//bit 29:26				diwr_burst_lim
//bit 25				diwr_canvas_syncen
//bit 24				diwr_no_clk_gate
//bit 23:22				diwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
						     //2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20				diwr_hconv_mode
//bit 19:18				diwr_vconv_mode
//bit 17				diwr_swap_cbcr
//bit 16				diwr_urgent
//bit 15:8				diwr_canvas_index_chroma
//bit 7:0				diwr_canvas_index_luma
//`define DI_MTNCRD_X               8'hc9
//`define DI_MTNCRD_Y               8'hca
//`define DI_MTNPRD_X               8'hcb
//`define DI_MTNPRD_Y               8'hcc
//`define DI_MTNRD_CTRL             8'hcd
#define P_DI_TOP_PRE_CTRL                          (volatile uint32_t *)0xff005f14
#define P_DI_TOP_POST_CTRL                         (volatile uint32_t *)0xff005f18
#define P_DI_PRE_GL_CTRL                           (volatile uint32_t *)0xff005f1c
#define P_DI_PRE_GL_THD                            (volatile uint32_t *)0xff005f20
#define P_DI_POST_GL_CTRL                          (volatile uint32_t *)0xff005f24
#define P_DI_POST_GL_THD                           (volatile uint32_t *)0xff005f28
#define P_DI_RO_PRE_DBG                            (volatile uint32_t *)0xff005f2c
#define P_DI_RO_POST_DBG                           (volatile uint32_t *)0xff005f30
#define P_DI_TOP_CTRL                              (volatile uint32_t *)0xff005f34
#define P_DI_AFBCD_GCLK0                           (volatile uint32_t *)0xff005f38
#define P_DI_AFBCD_GCLK1                           (volatile uint32_t *)0xff005f3c
#define P_DI_RDMIF_DEPTH0                          (volatile uint32_t *)0xff005f40
#define P_DI_RDMIF_DEPTH1                          (volatile uint32_t *)0xff005f44
#define P_DI_RDMIF_DEPTH2                          (volatile uint32_t *)0xff005f48
#define P_DI_TOP_CTRL1                             (volatile uint32_t *)0xff005f4c
#define P_DI_AFBCE0_HOLD_CTRL                      (volatile uint32_t *)0xff005f50
#define P_DI_AFBCE1_HOLD_CTRL                      (volatile uint32_t *)0xff005f54
// 0xe0 - 0xff
//
// Reading file:  di_pd_grad_reg.h
//
#define P_DI_PD_GRAD_CTRL                          (volatile uint32_t *)0xff005f80
//Bit 31:12  reserved
//Bit 11:4   reg_fd_min_grad_th           // default 255 //u8, for cur/pre1 field. cur_min_grad_err > th, will be excluded of statistic
//Bit 3      reg_fd_min_grad_th_adjust_en // default 1   //u1, reg_fd_min_grad_err_th adjustment enable/disable
//Bit 2      reg_fd_err_grad_bf_flt_en    // default 1   //u1, 1:comput err_grad_sum before horizontal filtering; 0: ...after...; default=1;
//Bit 1      reg_fd_comb_field_sel        // default 0   //u1, comb consists of 2 field; 0: cur-pre; 1:pre-pre2;
//Bit 0      reg_fd_iscur_top_inver       // default 0   //u1, current field is top flag invert; 0 no invert, 1, invert
#define P_DI_PD_GRAD_TH_P                          (volatile uint32_t *)0xff005f84
//Bit 31:24  reg_fd_min_grad_th_p0        //default 2     //u8,
//Bit 23:16  reg_fd_min_grad_th_p1        //default 4     //u8,
//Bit 15:8   reg_fd_min_grad_th_p2        //default 8     //u8,
//Bit 7:0    reg_fd_min_grad_th_p3        //default 12    //u8,
#define P_DI_PD_GRAD_TH_N                          (volatile uint32_t *)0xff005f88
//Bit 31:24  reg_fd_min_grad_th_n0        //default 4     //u8,
//Bit 23:16  reg_fd_min_grad_th_n1        //default 8     //u8,
//Bit 15:8   reg_fd_min_grad_th_n2        //default 16    //u8,
//Bit 7:0    reg_fd_min_grad_th_n3        //default 32    //u8,
#define P_DI_PD_GRAD_GAIN_P                        (volatile uint32_t *)0xff005f8c
//Bit 31:29  reserved
//Bit 28:24  reg_fd_min_grad_gain_p0      //default 16    //u5,
//Bit 23:21  reserved
//Bit 20:16  reg_fd_min_grad_gain_p1      //default 16    //u5,
//Bit 15:13  reserved
//Bit 12:8   reg_fd_min_grad_gain_p2      //default 16    //u5,
//Bit 7:5    reserved
//Bit 4:0    reg_fd_min_grad_gain_p3      //default 16    //u5,
#define P_DI_PD_GRAD_GAIN_N                        (volatile uint32_t *)0xff005f90
//Bit 31:29  reserved
//Bit 28:24  reg_fd_min_grad_gain_n0      //default 12    //u5,
//Bit 23:21  reserved
//Bit 20:16  reg_fd_min_grad_gain_n1      //default 12    //u5,
//Bit 15:13  reserved
//Bit 12:8   reg_fd_min_grad_gain_n2      //default 14    //u5,
//Bit 7:5    reserved
//Bit 4:0    reg_fd_min_grad_gain_n3      //default 15    //u5,
#define P_DI_PD_RO_SUM_P_WIN0                      (volatile uint32_t *)0xff005f94
//Bit 31:0   ro_fd_err_grad_sum_p0
#define P_DI_PD_RO_SUM_P_WIN1                      (volatile uint32_t *)0xff005f98
//Bit 31:0   ro_fd_err_grad_sum_p1
#define P_DI_PD_RO_SUM_P_WIN2                      (volatile uint32_t *)0xff005f9c
//Bit 31:0   ro_fd_err_grad_sum_p2
#define P_DI_PD_RO_SUM_P_WIN3                      (volatile uint32_t *)0xff005fa0
//Bit 31:0   ro_fd_err_grad_sum_p3
#define P_DI_PD_RO_SUM_P_WIN4                      (volatile uint32_t *)0xff005fa4
//Bit 31:0   ro_fd_err_grad_sum_p4
#define P_DI_PD_RO_SUM_N_WIN0                      (volatile uint32_t *)0xff005fa8
//Bit 31:0   ro_fd_err_grad_sum_n0
#define P_DI_PD_RO_SUM_N_WIN1                      (volatile uint32_t *)0xff005fac
//Bit 31:0   ro_fd_err_grad_sum_n1
#define P_DI_PD_RO_SUM_N_WIN2                      (volatile uint32_t *)0xff005fb0
//Bit 31:0   ro_fd_err_grad_sum_n2
#define P_DI_PD_RO_SUM_N_WIN3                      (volatile uint32_t *)0xff005fb4
//Bit 31:0   ro_fd_err_grad_sum_n3
#define P_DI_PD_RO_SUM_N_WIN4                      (volatile uint32_t *)0xff005fb8
//Bit 31:0   ro_fd_err_grad_sum_n4
#define P_DI_PD_RO_CNT_P_WIN0                      (volatile uint32_t *)0xff005fbc
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p0
#define P_DI_PD_RO_CNT_P_WIN1                      (volatile uint32_t *)0xff005fc0
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p1
#define P_DI_PD_RO_CNT_P_WIN2                      (volatile uint32_t *)0xff005fc4
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p2
#define P_DI_PD_RO_CNT_P_WIN3                      (volatile uint32_t *)0xff005fc8
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p3
#define P_DI_PD_RO_CNT_P_WIN4                      (volatile uint32_t *)0xff005fcc
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p4
#define P_DI_PD_RO_CNT_N_WIN0                      (volatile uint32_t *)0xff005fd0
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n0
#define P_DI_PD_RO_CNT_N_WIN1                      (volatile uint32_t *)0xff005fd4
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n1
#define P_DI_PD_RO_CNT_N_WIN2                      (volatile uint32_t *)0xff005fd8
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n2
#define P_DI_PD_RO_CNT_N_WIN3                      (volatile uint32_t *)0xff005fdc
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n3
#define P_DI_PD_RO_CNT_N_WIN4                      (volatile uint32_t *)0xff005fe0
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n4
#define P_DI_PD_RO_SUM_P                           (volatile uint32_t *)0xff005fe4
//Bit 31:0   ro_fd_err_grad_sum_p_glb
#define P_DI_PD_RO_SUM_N                           (volatile uint32_t *)0xff005fe8
//Bit 31:0   ro_fd_err_grad_sum_n_glb
#define P_DI_PD_RO_CNT_P                           (volatile uint32_t *)0xff005fec
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p_glb
#define P_DI_PD_RO_CNT_N                           (volatile uint32_t *)0xff005ff0
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n_glb
//
// Closing file:  di_pd_grad_reg.h
//
//`define DI_INP_GEN_REG            8'hce
//`define DI_INP_CANVAS0            8'hcf
//`define DI_INP_LUMA_X0            8'hd0
//`define DI_INP_LUMA_Y0            8'hd1
//`define DI_INP_CHROMA_X0          8'hd2
//`define DI_INP_CHROMA_Y0          8'hd3
//`define DI_INP_RPT_LOOP           8'hd4
//`define DI_INP_LUMA0_RPT_PAT      8'hd5
//`define DI_INP_CHROMA0_RPT_PAT    8'hd6
//`define DI_INP_DUMMY_PIXEL        8'hd7
//`define DI_INP_LUMA_FIFO_SIZE     8'hd8
//`define DI_INP_RANGE_MAP_Y        8'hba
//`define DI_INP_RANGE_MAP_CB       8'hbb
//`define DI_INP_RANGE_MAP_CR       8'hbc
//`define DI_INP_GEN_REG2           8'h91
//
//`define DI_INP_FMT_CTRL           8'hd9
//`define DI_INP_FMT_W              8'hda
////
//`define DI_MEM_GEN_REG            8'hdb
//`define DI_MEM_CANVAS0            8'hdc
//`define DI_MEM_LUMA_X0            8'hdd
//`define DI_MEM_LUMA_Y0            8'hde
//`define DI_MEM_CHROMA_X0          8'hdf
//`define DI_MEM_CHROMA_Y0          8'he0
//`define DI_MEM_RPT_LOOP           8'he1
//`define DI_MEM_LUMA0_RPT_PAT      8'he2
//`define DI_MEM_CHROMA0_RPT_PAT    8'he3
//`define DI_MEM_DUMMY_PIXEL        8'he4
//`define DI_MEM_LUMA_FIFO_SIZE     8'he5
//`define DI_MEM_RANGE_MAP_Y        8'hbd
//`define DI_MEM_RANGE_MAP_CB       8'hbe
//`define DI_MEM_RANGE_MAP_CR       8'hbf
//`define DI_MEM_GEN_REG2           8'h92
//
//`define DI_MEM_FMT_CTRL           8'he6
//`define DI_MEM_FMT_W              8'he7
//
//`define DI_IF1_GEN_REG            8'he8
//`define DI_IF1_CANVAS0            8'he9
//`define DI_IF1_LUMA_X0            8'hea
//`define DI_IF1_LUMA_Y0            8'heb
//`define DI_IF1_CHROMA_X0          8'hec
//`define DI_IF1_CHROMA_Y0          8'hed
//`define DI_IF1_RPT_LOOP           8'hee
//`define DI_IF1_LUMA0_RPT_PAT      8'hef
//`define DI_IF1_CHROMA0_RPT_PAT    8'hf0
//`define DI_IF1_DUMMY_PIXEL        8'hf1
//`define DI_IF1_LUMA_FIFO_SIZE     8'hf2
//`define DI_IF1_RANGE_MAP_Y        8'hfc
//`define DI_IF1_RANGE_MAP_CB       8'hfd
//`define DI_IF1_RANGE_MAP_CR       8'hfe
//`define DI_IF1_GEN_REG2           8'h90
//
//`define DI_IF1_FMT_CTRL           8'hf3
//`define DI_IF1_FMT_W              8'hf4
//
//
//`define DI_CHAN2_GEN_REG          8'hf5
//`define DI_CHAN2_CANVAS0          8'hf6
//`define DI_CHAN2_LUMA_X0          8'hf7
//`define DI_CHAN2_LUMA_Y0          8'hf8
//`define DI_CHAN2_CHROMA_X0        8'hf9
//`define DI_CHAN2_CHROMA_Y0        8'hfa
//`define DI_CHAN2_RPT_LOOP         8'hfb
//`define DI_CHAN2_LUMA0_RPT_PAT    8'hb0
//`define DI_CHAN2_CHROMA0_RPT_PAT  8'hb1
//`define DI_CHAN2_DUMMY_PIXEL      8'hb2
//`define DI_CHAN2_LUMA_FIFO_SIZE   8'hb3
//`define DI_CHAN2_RANGE_MAP_Y      8'hb4
//`define DI_CHAN2_RANGE_MAP_CB     8'hb5
//`define DI_CHAN2_RANGE_MAP_CR     8'hb6
//`define DI_CHAN2_GEN_REG2         8'hb7
//`define DI_CHAN2_FMT_CTRL         8'hb8
//`define DI_CHAN2_FMT_W            8'hb9
//
// Closing file:  vpu_mad_regs.h
//
// -----------------------------------------------
// REG_BASE:  MADD_VCBUS_BASE = 0x18
// -----------------------------------------------
//
// Reading file:  di_dolby_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_CORE1C_REG_START                   (volatile uint32_t *)0xff006000
#define P_DOLBY_CORE1C_CLKGATE_CTRL                (volatile uint32_t *)0xff0063c8
#define P_DOLBY_CORE1C_SWAP_CTRL0                  (volatile uint32_t *)0xff0063cc
#define P_DOLBY_CORE1C_SWAP_CTRL1                  (volatile uint32_t *)0xff0063d0
#define P_DOLBY_CORE1C_SWAP_CTRL2                  (volatile uint32_t *)0xff0063d4
#define P_DOLBY_CORE1C_SWAP_CTRL3                  (volatile uint32_t *)0xff0063d8
#define P_DOLBY_CORE1C_SWAP_CTRL4                  (volatile uint32_t *)0xff0063dc
#define P_DOLBY_CORE1C_SWAP_CTRL5                  (volatile uint32_t *)0xff0063e0
#define P_DOLBY_CORE1C_DMA_CTRL                    (volatile uint32_t *)0xff0063e4
#define P_DOLBY_CORE1C_DMA_STATUS                  (volatile uint32_t *)0xff0063e8
#define P_DOLBY_CORE1C_STATUS0                     (volatile uint32_t *)0xff0063ec
#define P_DOLBY_CORE1C_STATUS1                     (volatile uint32_t *)0xff0063f0
#define P_DOLBY_CORE1C_STATUS2                     (volatile uint32_t *)0xff0063f4
#define P_DOLBY_CORE1C_STATUS3                     (volatile uint32_t *)0xff0063f8
#define P_DOLBY_CORE1C_DMA_PORT                    (volatile uint32_t *)0xff0063fc
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_dolby_regs.h
//
//`include "di_inp_afbc_dec_regs.h"
//`include "di_mem_afbc_dec_regs.h"
//`include "fgrain_di_regs.h"
// -----------------------------------------------
// REG_BASE:  VPP2_VCBUS_BASE = 0x19
// -----------------------------------------------
//`include "vpp2_regs.h"
//
// Reading file:  vregs_clk2.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VIU_VCBUS_BASE = 0x1a
// -----------------------------------------------
#define P_VIU_ADDR_START                           (volatile uint32_t *)0xff006800
#define P_VIU_ADDR_END                             (volatile uint32_t *)0xff006bfc
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define P_VIU_SW_RESET                             (volatile uint32_t *)0xff006804
#define P_VIU_SW_RESET0                            (volatile uint32_t *)0xff006808
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
#define P_VIU_SECURE_REG                           (volatile uint32_t *)0xff006810
// Bit 0 RW, dolby core1_tv secure w and r
// Bit 1 RW, dolby core2 secure w and r
// Bit 2 RW, dolby core3 secure w and r
// Bit 3 RW, for osd1 secure read
// Bit 4 RW, for osd2 secure read
#define P_DOLBY_INT_STAT                           (volatile uint32_t *)0xff006814
// todo
//bit 15:12 osdbld_gclk_ctrl 3:2 regclk ctrl 1:0 blending clk control
//bit 8 if true, vsync interrup is generate only field == 0
//bit 7:0 fix_disable
#define P_VIU_MISC_CTRL0                           (volatile uint32_t *)0xff006818
#define P_VIU_MISC_CTRL1                           (volatile uint32_t *)0xff00681c
// Bit 15:14  mali_afbcd_gclk_ctrl      mali_afbcd clock gate control[5:4]
// Bit 12     osd1_afbcd_axi_mux        0 : use the osd mif as input; 1 : use afbcd as input
// Bit 11:8   mali_afbcd_gclk_ctrl      mali_afbcd clock gate control[3:0]
// Bit  7:2   vd2_afbcd_gclk_ctrl       vd2_afbcd clock gate control
// Bit  1     vpp_vd2_din_sel           0: vpp vd2 sel the mif input; 1: vpp vd2 sel the dos afbcd
// Bit  0     vd2_afbcd_out_sel         0: vd2_afbcd output to vpp; 1 : vd2_afbcd output to di inp
#define P_VIU_SECURE_DUMMY                         (volatile uint32_t *)0xff006820
#define P_VIU_SECURE_ST_RO                         (volatile uint32_t *)0xff006824
// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path
// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path
// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path
// Bit 23 if true, turn on clk_d2d3_reg (register clock)
// Bit 22 if true, turn on clk_d2d3
// Bit 21 reg_v1_go_line
// Bit 20 reg_v1_go_field
// Bit 19 reg_v0_go_field
// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line,
//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
// reg_v0_go_field(bit19)
// Bit 12:6 hole_lines for d2d3 depth read interface
// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 format output), 2'b10: scale output, otherwise nothing as v1
// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 format output), 101: vpp scale output
//
// `define D2D3_INTF_CTRL0                 8'h09
#define P_VD1_AFBCD0_MISC_CTRL                     (volatile uint32_t *)0xff006828
#define P_VD2_AFBCD1_MISC_CTRL                     (volatile uint32_t *)0xff00682c
#define P_DOLBY_PATH_CTRL                          (volatile uint32_t *)0xff006830
#define P_WR_BACK_MISC_CTRL                        (volatile uint32_t *)0xff006834
#define P_OSD_PATH_MISC_CTRL                       (volatile uint32_t *)0xff006838
#define P_MALI_AFBCD_TOP_CTRL                      (volatile uint32_t *)0xff00683c
#define P_VIU_DATA_SEC                             (volatile uint32_t *)0xff006940
#define P_VIU_FRM_CTRL                             (volatile uint32_t *)0xff006944
#define P_VIU_RDMIF_DEPTH                          (volatile uint32_t *)0xff006948
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logic;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD1_CTRL_STAT                       (volatile uint32_t *)0xff006840
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15    RW, osd_dpath_sel   0-osd1 mif 1-vpu mali afbcd
// Bit 14    RW, replaced_alpha_en
// Bit 13: 6 RW, replaced_alpha
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD1_CTRL_STAT2                      (volatile uint32_t *)0xff0068b4
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD1_COLOR_ADDR                      (volatile uint32_t *)0xff006844
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_COLOR                           (volatile uint32_t *)0xff006848
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_TCOLOR_AG0                      (volatile uint32_t *)0xff00685c
#define P_VIU_OSD1_TCOLOR_AG1                      (volatile uint32_t *)0xff006860
#define P_VIU_OSD1_TCOLOR_AG2                      (volatile uint32_t *)0xff006864
#define P_VIU_OSD1_TCOLOR_AG3                      (volatile uint32_t *)0xff006868
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD1_BLK0_CFG_W0                     (volatile uint32_t *)0xff00686c
#define P_VIU_OSD1_BLK1_CFG_W0                     (volatile uint32_t *)0xff00687c
#define P_VIU_OSD1_BLK2_CFG_W0                     (volatile uint32_t *)0xff00688c
#define P_VIU_OSD1_BLK3_CFG_W0                     (volatile uint32_t *)0xff00689c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD1_BLK0_CFG_W1                     (volatile uint32_t *)0xff006870
#define P_VIU_OSD1_BLK1_CFG_W1                     (volatile uint32_t *)0xff006880
#define P_VIU_OSD1_BLK2_CFG_W1                     (volatile uint32_t *)0xff006890
#define P_VIU_OSD1_BLK3_CFG_W1                     (volatile uint32_t *)0xff0068a0
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD1_BLK0_CFG_W2                     (volatile uint32_t *)0xff006874
#define P_VIU_OSD1_BLK1_CFG_W2                     (volatile uint32_t *)0xff006884
#define P_VIU_OSD1_BLK2_CFG_W2                     (volatile uint32_t *)0xff006894
#define P_VIU_OSD1_BLK3_CFG_W2                     (volatile uint32_t *)0xff0068a4
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD1_BLK0_CFG_W3                     (volatile uint32_t *)0xff006878
#define P_VIU_OSD1_BLK1_CFG_W3                     (volatile uint32_t *)0xff006888
#define P_VIU_OSD1_BLK2_CFG_W3                     (volatile uint32_t *)0xff006898
#define P_VIU_OSD1_BLK3_CFG_W3                     (volatile uint32_t *)0xff0068a8
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD1_BLK0_CFG_W4                     (volatile uint32_t *)0xff00684c
#define P_VIU_OSD1_BLK1_CFG_W4                     (volatile uint32_t *)0xff006850
#define P_VIU_OSD1_BLK2_CFG_W4                     (volatile uint32_t *)0xff006854
#define P_VIU_OSD1_BLK3_CFG_W4                     (volatile uint32_t *)0xff006858
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
// Bit    19 R,  fifo_overflow
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD1_FIFO_CTRL_STAT                  (volatile uint32_t *)0xff0068ac
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD1_TEST_RDDATA                     (volatile uint32_t *)0xff0068b0
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU_OSD1_PROT_CTRL                       (volatile uint32_t *)0xff0068b8
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define P_VIU_OSD1_MATRIX_CTRL                     (volatile uint32_t *)0xff006a40
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VIU_OSD1_MATRIX_COEF00_01                (volatile uint32_t *)0xff006a44
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VIU_OSD1_MATRIX_COEF02_10                (volatile uint32_t *)0xff006a48
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VIU_OSD1_MATRIX_COEF11_12                (volatile uint32_t *)0xff006a4c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VIU_OSD1_MATRIX_COEF20_21                (volatile uint32_t *)0xff006a50
//Bit 31:30    mat_clmod
//Bit 18:16    mat_convrs
//Bit 12:0     mat_coef42
#define P_VIU_OSD1_MATRIX_COLMOD_COEF42            (volatile uint32_t *)0xff006a54
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VIU_OSD1_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff006a58
//Bit 10:0  offset2
#define P_VIU_OSD1_MATRIX_OFFSET2                  (volatile uint32_t *)0xff006a5c
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VIU_OSD1_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff006a60
//Bit 10:0  pre_offset2
#define P_VIU_OSD1_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff006a64
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VIU_OSD1_MATRIX_PROBE_COLOR              (volatile uint32_t *)0xff006a68
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VIU_OSD1_MATRIX_HL_COLOR                 (volatile uint32_t *)0xff006a6c
//28:16 probe x, postion
//12:0  probe y, position
#define P_VIU_OSD1_MATRIX_PROBE_POS                (volatile uint32_t *)0xff006a70
//Bit 28:16 coef22
//Bit 12:0  coef30
#define P_VIU_OSD1_MATRIX_COEF22_30                (volatile uint32_t *)0xff006a74
//Bit 28:16 coef31
//Bit 12:0  coef32
#define P_VIU_OSD1_MATRIX_COEF31_32                (volatile uint32_t *)0xff006a78
//Bit 28:16 coef40
//Bit 12:0  coef41
#define P_VIU_OSD1_MATRIX_COEF40_41                (volatile uint32_t *)0xff006a7c
//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
//Bit 17:6  for clock gating
//Bit 5:4   pscale_mode ch2
//Bit 3:2   pscale_mode ch1
//Bit 1:0   pscale_mode ch0
#define P_VIU_OSD1_EOTF_CTL                        (volatile uint32_t *)0xff006b50
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VIU_OSD1_EOTF_COEF00_01                  (volatile uint32_t *)0xff006b54
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VIU_OSD1_EOTF_COEF02_10                  (volatile uint32_t *)0xff006b58
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VIU_OSD1_EOTF_COEF11_12                  (volatile uint32_t *)0xff006b5c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VIU_OSD1_EOTF_COEF20_21                  (volatile uint32_t *)0xff006b60
//Bit 28:16 coef22
//Bit   2:0 coef_rs
#define P_VIU_OSD1_EOTF_COEF22_RS                  (volatile uint32_t *)0xff006b64
#define P_VIU_OSD1_EOTF_LUT_ADDR_PORT              (volatile uint32_t *)0xff006b68
#define P_VIU_OSD1_EOTF_LUT_DATA_PORT              (volatile uint32_t *)0xff006b6c
//Bit 31:29  for OETF ch0~ch2
//Bit 21:12  for clock gating
//Bit 11:8   for oetf_scl_ch2
//Bit  7:4   for oetf_scl_ch1
//Bit  3:0   for oetf_scl_ch0
#define P_VIU_OSD1_OETF_CTL                        (volatile uint32_t *)0xff006b70
#define P_VIU_OSD1_OETF_LUT_ADDR_PORT              (volatile uint32_t *)0xff006b74
#define P_VIU_OSD1_OETF_LUT_DATA_PORT              (volatile uint32_t *)0xff006b78
#define P_VIU_OSD1_OETF_3X3_OFST_0                 (volatile uint32_t *)0xff006a80
#define P_VIU_OSD1_OETF_3X3_OFST_1                 (volatile uint32_t *)0xff006a84
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logic;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD2_CTRL_STAT                       (volatile uint32_t *)0xff0068c0
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15    Reserved
// Bit 14    RW, replaced_alpha_en
// Bit 13: 6 RW, replaced_alpha
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD2_CTRL_STAT2                      (volatile uint32_t *)0xff006934
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD2_COLOR_ADDR                      (volatile uint32_t *)0xff0068c4
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_COLOR                           (volatile uint32_t *)0xff0068c8
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define P_VIU_OSD2_HL1_H_START_END                 (volatile uint32_t *)0xff0068cc
#define P_VIU_OSD2_HL1_V_START_END                 (volatile uint32_t *)0xff0068d0
#define P_VIU_OSD2_HL2_H_START_END                 (volatile uint32_t *)0xff0068d4
#define P_VIU_OSD2_HL2_V_START_END                 (volatile uint32_t *)0xff0068d8
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_TCOLOR_AG0                      (volatile uint32_t *)0xff0068dc
#define P_VIU_OSD2_TCOLOR_AG1                      (volatile uint32_t *)0xff0068e0
#define P_VIU_OSD2_TCOLOR_AG2                      (volatile uint32_t *)0xff0068e4
#define P_VIU_OSD2_TCOLOR_AG3                      (volatile uint32_t *)0xff0068e8
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD2_BLK0_CFG_W0                     (volatile uint32_t *)0xff0068ec
#define P_VIU_OSD2_BLK1_CFG_W0                     (volatile uint32_t *)0xff0068fc
#define P_VIU_OSD2_BLK2_CFG_W0                     (volatile uint32_t *)0xff00690c
#define P_VIU_OSD2_BLK3_CFG_W0                     (volatile uint32_t *)0xff00691c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD2_BLK0_CFG_W1                     (volatile uint32_t *)0xff0068f0
#define P_VIU_OSD2_BLK1_CFG_W1                     (volatile uint32_t *)0xff006900
#define P_VIU_OSD2_BLK2_CFG_W1                     (volatile uint32_t *)0xff006910
#define P_VIU_OSD2_BLK3_CFG_W1                     (volatile uint32_t *)0xff006920
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD2_BLK0_CFG_W2                     (volatile uint32_t *)0xff0068f4
#define P_VIU_OSD2_BLK1_CFG_W2                     (volatile uint32_t *)0xff006904
#define P_VIU_OSD2_BLK2_CFG_W2                     (volatile uint32_t *)0xff006914
#define P_VIU_OSD2_BLK3_CFG_W2                     (volatile uint32_t *)0xff006924
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD2_BLK0_CFG_W3                     (volatile uint32_t *)0xff0068f8
#define P_VIU_OSD2_BLK1_CFG_W3                     (volatile uint32_t *)0xff006908
#define P_VIU_OSD2_BLK2_CFG_W3                     (volatile uint32_t *)0xff006918
#define P_VIU_OSD2_BLK3_CFG_W3                     (volatile uint32_t *)0xff006928
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD2_BLK0_CFG_W4                     (volatile uint32_t *)0xff006990
#define P_VIU_OSD2_BLK1_CFG_W4                     (volatile uint32_t *)0xff006994
#define P_VIU_OSD2_BLK2_CFG_W4                     (volatile uint32_t *)0xff006998
#define P_VIU_OSD2_BLK3_CFG_W4                     (volatile uint32_t *)0xff00699c
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD2_FIFO_CTRL_STAT                  (volatile uint32_t *)0xff00692c
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD2_TEST_RDDATA                     (volatile uint32_t *)0xff006930
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU_OSD2_PROT_CTRL                       (volatile uint32_t *)0xff006938
//     //todo add comment
#define P_LDIM_STTS_GCLK_CTRL0                     (volatile uint32_t *)0xff006b00
#define P_LDIM_STTS_CTRL0                          (volatile uint32_t *)0xff006b04
#define P_LDIM_STTS_WIDTHM1_HEIGHTM1               (volatile uint32_t *)0xff006b08
#define P_LDIM_STTS_MATRIX_COEF00_01               (volatile uint32_t *)0xff006b0c
#define P_LDIM_STTS_MATRIX_COEF02_10               (volatile uint32_t *)0xff006b10
#define P_LDIM_STTS_MATRIX_COEF11_12               (volatile uint32_t *)0xff006b14
#define P_LDIM_STTS_MATRIX_COEF20_21               (volatile uint32_t *)0xff006b18
#define P_LDIM_STTS_MATRIX_COEF22                  (volatile uint32_t *)0xff006b1c
#define P_LDIM_STTS_MATRIX_OFFSET0_1               (volatile uint32_t *)0xff006b20
#define P_LDIM_STTS_MATRIX_OFFSET2                 (volatile uint32_t *)0xff006b24
#define P_LDIM_STTS_MATRIX_PRE_OFFSET0_1           (volatile uint32_t *)0xff006b28
#define P_LDIM_STTS_MATRIX_PRE_OFFSET2             (volatile uint32_t *)0xff006b2c
#define P_LDIM_STTS_MATRIX_HL_COLOR                (volatile uint32_t *)0xff006b30
#define P_LDIM_STTS_MATRIX_PROBE_POS               (volatile uint32_t *)0xff006b34
//
//     //read only
#define P_LDIM_STTS_MATRIX_PROBE_COLOR             (volatile uint32_t *)0xff006b38
//
//     //Bit 31, local dimming statistic enable
//     //Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit
//     //Bit 28, eol enable
//     //Bit 27:25, vertical line overlap number for max finding
//     //Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//     //Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//     //Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//     //Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//     //			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//     //			 0/3: disable read index self increase
//     //Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
//     //Bit 6:0, region read index
#define P_LDIM_STTS_HIST_REGION_IDX                (volatile uint32_t *)0xff006b40
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//     //hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//     //hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//     //vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//     //hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//     //vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//     //hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//     //vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//     //hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//     //vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//     //hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//     //vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define P_LDIM_STTS_HIST_SET_REGION                (volatile uint32_t *)0xff006b44
//
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2},
//     //										   comp0_hist3 ... comp2_hist16
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//     //										   comp0_hist3 ... comp2_hist16
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//     //										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
//
#define P_LDIM_STTS_HIST_READ_REGION               (volatile uint32_t *)0xff006b48
#define P_LDIM_STTS_HIST_START_RD_REGION           (volatile uint32_t *)0xff006b4c
#define P_LDIM_STTS_PCTL_TH                        (volatile uint32_t *)0xff006abc
//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di if1 chroma path
//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di if1 luma path
//     `define DI_IF1_URGENT_CTRL						8'ha3
//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//     `define DI_INP_URGENT_CTRL						8'ha4
//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
//     `define DI_MEM_URGENT_CTRL						8'ha5
//     //bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
//     //bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
//     `define DI_CHAN2_URGENT_CTRL					8'ha6
#define P_OSD_BLENDO_H_START_END                   (volatile uint32_t *)0xff006aa4
//OSD blending output horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_OSD_BLENDO_V_START_END                   (volatile uint32_t *)0xff006aa8
//OSD blending output vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_OSD_BLEND_GEN_CTRL0                      (volatile uint32_t *)0xff006aac
//Bit 31:23 const_out_alpha
//Bit 22:14 const_op_alpha
//Bit 13 if true, OSD2 foreground otherwise OSD1 foreground
//Bit 12  OSD BLENDing enable
//Bit 9:8 alpha_op_sel 00: output alpha use osd1_alpha, 01: use osd2_alpha, else use const_out_alpha
//Bit 5:4 color_op_sel 00: use osd1_alpha, 01: use osd2_alpha, else use const_op_alpha
//Bit 1  OSD2 enable
//Bit 0  OSD1 enable
#define P_OSD_BLEND_GEN_CTRL1                      (volatile uint32_t *)0xff006ab0
//Bit 31    osd1_alpha_premult, if true, osd1 alpha is premultiplied
//Bit 30    osd2_alpha_premult, if true, osd2 alpha is premultiplied
//Bit 23:16 osd blending hold lines
//Bit 13:0  osd blending h_size
#define P_OSD_BLEND_DUMMY_DATA                     (volatile uint32_t *)0xff006ab4
//Bit 29:20   Y/R
//Bit 19:10   CB/G
//Bit 9:0     Cr/B
#define P_OSD_BLEND_CURRENT_XY                     (volatile uint32_t *)0xff006ab8
//Bit 28:16 current_x
//Bit 12:0 current_y
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define P_VIU_OSD2_MATRIX_CTRL                     (volatile uint32_t *)0xff006ac0
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VIU_OSD2_MATRIX_COEF00_01                (volatile uint32_t *)0xff006ac4
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VIU_OSD2_MATRIX_COEF02_10                (volatile uint32_t *)0xff006ac8
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VIU_OSD2_MATRIX_COEF11_12                (volatile uint32_t *)0xff006acc
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VIU_OSD2_MATRIX_COEF20_21                (volatile uint32_t *)0xff006ad0
#define P_VIU_OSD2_MATRIX_COEF22                   (volatile uint32_t *)0xff006ad4
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VIU_OSD2_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff006ad8
//Bit 10:0  offset2
#define P_VIU_OSD2_MATRIX_OFFSET2                  (volatile uint32_t *)0xff006adc
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VIU_OSD2_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff006ae0
//Bit 10:0  pre_offset2
#define P_VIU_OSD2_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff006ae4
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VIU_OSD2_MATRIX_PROBE_COLOR              (volatile uint32_t *)0xff006ae8
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VIU_OSD2_MATRIX_HL_COLOR                 (volatile uint32_t *)0xff006aec
//28:16 probe x, postion
//12:0  probe y, position
#define P_VIU_OSD2_MATRIX_PROBE_POS                (volatile uint32_t *)0xff006af0
////add for OSD1/2 mali_unpack
#define P_VIU_OSD1_MALI_UNPACK_CTRL                (volatile uint32_t *)0xff0068bc
//`define VIU_OSD1_MALI_UNPACK_CTRL         8'h4f //todo
//`define VIU_OSD1_MALI_UNPACK_CTRL         8'haf //todo
#define P_VIU_OSD2_MALI_UNPACK_CTRL                (volatile uint32_t *)0xff006af4
//`define VIU_OSD2_MATRIX_HL_COLOR          8'hbe
//`define VIU_OSD2_MATRIX_PROBE_POS         8'hbf
#define P_VIU_OSD1_NORMAL_SWAP                     (volatile uint32_t *)0xff006af8
// Bit 31:16 Reserved
// Bit 15: 0 reg_normal_swap
#define P_VIU_OSD2_NORMAL_SWAP                     (volatile uint32_t *)0xff006afc
//can use 8'hdf 8'hcf
#define P_VIU_OSD1_DIMM_CTRL                       (volatile uint32_t *)0xff006b7c
#define P_VIU_OSD2_DIMM_CTRL                       (volatile uint32_t *)0xff006b3c
#define P_VIU_GCLK_CTRL                            (volatile uint32_t *)0xff00693c
//the segment of afbc dec is 8'he0-8'hfe
//`define AFBC_DEC_OFFSET   8'he0
//
// Reading file:  afbc_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define P_AFBC_ENABLE                              (volatile uint32_t *)0xff006b80
//Bit   31:29,    reserved
//Bit   28:23,    reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22,       reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21,       reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20,       reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19,       reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16,    soft_rst          unsigned  , default = 4
//Bit   15:14,    reserved
//Bit   13:12,    ddr_blk_size      unsigned  , default = 1
//Bit   11:9,     cmd_blk_size      unsigned  , default = 3
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:2,      reserved
//Bit   1,        head_len_sel      unsigned  , default = 1
//Bit   0,        dec_frm_start     unsigned  , default = 0
#define P_AFBC_MODE                                (volatile uint32_t *)0xff006b84
//Bit   31:30,    reserved
//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num     uns, default = 4 ,
//Bit   15:14,    burst_len         uns, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8,     compbits_yuv      uns, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horizontal skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horizontal skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define P_AFBC_SIZE_IN                             (volatile uint32_t *)0xff006b88
//Bit   31:29,    reserved
//Bit   28:16     hsize_in          uns, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in          uns, default = 1080 , pic vertical size in  unit: pixel
#define P_AFBC_DEC_DEF_COLOR                       (volatile uint32_t *)0xff006b8c
//Bit   31:30,   reserved
//Bit   29:20,   def_color_y        uns, default = 255, afbc dec y default setting value
//Bit   19:10,   def_color_u        uns, default = 128, afbc dec u default setting value
//Bit    9: 0,   def_color_v        uns, default = 128, afbc dec v default setting value
#define P_AFBC_CONV_CTRL                           (volatile uint32_t *)0xff006b90
//Bit   31:14,   reserved
//Bit   13:12,   fmt_mode            uns, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
#define P_AFBC_LBUF_DEPTH                          (volatile uint32_t *)0xff006b94
//Bit   31:28,   reserved
//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
//Bit   15:12,   reserved
//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
#define P_AFBC_HEAD_BADDR                          (volatile uint32_t *)0xff006b98
//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
#define P_AFBC_BODY_BADDR                          (volatile uint32_t *)0xff006b9c
//Bit   31:0,   mif_data_baddr      uns, default = 32'h00010000;
#define P_AFBC_SIZE_OUT                            (volatile uint32_t *)0xff006ba0
//Bit   31:29,   reserved
//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
#define P_AFBC_OUT_YSCOPE                          (volatile uint32_t *)0xff006ba4
//Bit   31:29,   reserved
//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
#define P_AFBC_STAT                                (volatile uint32_t *)0xff006ba8
//Bit   31:0,   ro_dbg_top_info      uns,
#define P_AFBC_VD_CFMT_CTRL                        (volatile uint32_t *)0xff006bac
//Bit 31    cfmt_gclk_bit_dis      uns, default = 0    ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      uns, default = 0    ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         uns, default = 0    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               uns, default = 0    ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en uns, default = 0    ; //if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     uns, default = 0    ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   uns, default = 0    ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     uns, default = 0    ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    uns, default = 0    ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        uns, default = 0    ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       uns, default = 0    ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               uns, default = 0    ; //vertical formatter enable
#define P_AFBC_VD_CFMT_W                           (volatile uint32_t *)0xff006bb0
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                uns, default = 0    ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                uns, default = 0    ;vertical formatter width
#define P_AFBC_MIF_HOR_SCOPE                       (volatile uint32_t *)0xff006bb4
//Bit   31:26,   reserved
//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10,   reserved
//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
#define P_AFBC_MIF_VER_SCOPE                       (volatile uint32_t *)0xff006bb8
//Bit   31:28,   reserved
//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12,   reserved
//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
#define P_AFBC_PIXEL_HOR_SCOPE                     (volatile uint32_t *)0xff006bbc
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
#define P_AFBC_PIXEL_VER_SCOPE                     (volatile uint32_t *)0xff006bc0
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
#define P_AFBC_VD_CFMT_H                           (volatile uint32_t *)0xff006bc4
//Bit 31:13,    reserved
//Bit 12:0      cfmt_h  uns, default = 142  ; //vertical formatter height
#define P_AFBCDEC_IQUANT_ENABLE                    (volatile uint32_t *)0xff006bc8
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1  //unsigned, RW, enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0  //unsigned, RW, enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst               //signed ,  RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_AFBCDEC_IQUANT_LUT_1                     (volatile uint32_t *)0xff006bcc
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDEC_IQUANT_LUT_2                     (volatile uint32_t *)0xff006bd0
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDEC_IQUANT_LUT_3                     (volatile uint32_t *)0xff006bd4
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDEC_IQUANT_LUT_4                     (volatile uint32_t *)0xff006bd8
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  afbc_dec_regs.h
//
//
// Closing file:  vregs_clk2.h
//
//
// Reading file:  venc_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC_VCBUS_BASE = 0x1b
// -----------------------------------------------
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define P_ENCP_VFIFO2VD_CTL                        (volatile uint32_t *)0xff006d60
// bit 12:0 -- vfifo2vd_pixel_start
#define P_ENCP_VFIFO2VD_PIXEL_START                (volatile uint32_t *)0xff006d64
// bit 12:00 -- vfifo2vd_pixel_end
#define P_ENCP_VFIFO2VD_PIXEL_END                  (volatile uint32_t *)0xff006d68
// bit 10:0 -- vfifo2vd_line_top_start
#define P_ENCP_VFIFO2VD_LINE_TOP_START             (volatile uint32_t *)0xff006d6c
// bit 10:00 -- vfifo2vd_line_top_end
#define P_ENCP_VFIFO2VD_LINE_TOP_END               (volatile uint32_t *)0xff006d70
// bit 10:00 -- vfifo2vd_line_bot_start
#define P_ENCP_VFIFO2VD_LINE_BOT_START             (volatile uint32_t *)0xff006d74
// bit 10:00 -- vfifo2vd_line_bot_end
#define P_ENCP_VFIFO2VD_LINE_BOT_END               (volatile uint32_t *)0xff006d78
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define P_VENC_SYNC_ROUTE                          (volatile uint32_t *)0xff006d80
		//			 encoder address space is assigned
		//			 to the video encoder interface status
		//			 register
#define P_VENC_VIDEO_EXSRC                         (volatile uint32_t *)0xff006d84
#define P_VENC_DVI_SETTING                         (volatile uint32_t *)0xff006d88
#define P_VENC_C656_CTRL                           (volatile uint32_t *)0xff006d8c
#define P_VENC_UPSAMPLE_CTRL0                      (volatile uint32_t *)0xff006d90
#define P_VENC_UPSAMPLE_CTRL1                      (volatile uint32_t *)0xff006d94
#define P_VENC_UPSAMPLE_CTRL2                      (volatile uint32_t *)0xff006d98
// Invert control for tcon output
// bit[15:14] -- vsync, hsync,
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define P_TCON_INVERT_CTL                          (volatile uint32_t *)0xff006d9c
#define P_VENC_VIDEO_PROG_MODE                     (volatile uint32_t *)0xff006da0
//---- Venc pixel/line info
#define P_VENC_ENCI_LINE                           (volatile uint32_t *)0xff006da4
#define P_VENC_ENCI_PIXEL                          (volatile uint32_t *)0xff006da8
#define P_VENC_ENCP_LINE                           (volatile uint32_t *)0xff006dac
#define P_VENC_ENCP_PIXEL                          (volatile uint32_t *)0xff006db0
//---- Status
#define P_VENC_STATA                               (volatile uint32_t *)0xff006db4
//---- Interrupt setting
#define P_VENC_INTCTRL                             (volatile uint32_t *)0xff006db8
#define P_VENC_INTFLAG                             (volatile uint32_t *)0xff006dbc
//--------- Video test configuration
#define P_VENC_VIDEO_TST_EN                        (volatile uint32_t *)0xff006dc0
#define P_VENC_VIDEO_TST_MDSEL                     (volatile uint32_t *)0xff006dc4
#define P_VENC_VIDEO_TST_Y                         (volatile uint32_t *)0xff006dc8
#define P_VENC_VIDEO_TST_CB                        (volatile uint32_t *)0xff006dcc
#define P_VENC_VIDEO_TST_CR                        (volatile uint32_t *)0xff006dd0
#define P_VENC_VIDEO_TST_CLRBAR_STRT               (volatile uint32_t *)0xff006dd4
#define P_VENC_VIDEO_TST_CLRBAR_WIDTH              (volatile uint32_t *)0xff006dd8
#define P_VENC_VIDEO_TST_VDCNT_STSET               (volatile uint32_t *)0xff006ddc
//----- Video dac setting
#define P_VENC_VDAC_DACSEL0                        (volatile uint32_t *)0xff006de0
#define P_VENC_VDAC_DACSEL1                        (volatile uint32_t *)0xff006de4
#define P_VENC_VDAC_DACSEL2                        (volatile uint32_t *)0xff006de8
#define P_VENC_VDAC_DACSEL3                        (volatile uint32_t *)0xff006dec
#define P_VENC_VDAC_DACSEL4                        (volatile uint32_t *)0xff006df0
#define P_VENC_VDAC_DACSEL5                        (volatile uint32_t *)0xff006df4
#define P_VENC_VDAC_SETTING                        (volatile uint32_t *)0xff006df8
#define P_VENC_VDAC_TST_VAL                        (volatile uint32_t *)0xff006dfc
#define P_VENC_VDAC_DAC0_GAINCTRL                  (volatile uint32_t *)0xff006fc0
#define P_VENC_VDAC_DAC0_OFFSET                    (volatile uint32_t *)0xff006fc4
#define P_VENC_VDAC_DAC1_GAINCTRL                  (volatile uint32_t *)0xff006fc8
#define P_VENC_VDAC_DAC1_OFFSET                    (volatile uint32_t *)0xff006fcc
#define P_VENC_VDAC_DAC2_GAINCTRL                  (volatile uint32_t *)0xff006fd0
#define P_VENC_VDAC_DAC2_OFFSET                    (volatile uint32_t *)0xff006fd4
#define P_VENC_VDAC_DAC3_GAINCTRL                  (volatile uint32_t *)0xff006fd8
#define P_VENC_VDAC_DAC3_OFFSET                    (volatile uint32_t *)0xff006fdc
#define P_VENC_VDAC_DAC4_GAINCTRL                  (volatile uint32_t *)0xff006fe0
#define P_VENC_VDAC_DAC4_OFFSET                    (volatile uint32_t *)0xff006fe4
#define P_VENC_VDAC_DAC5_GAINCTRL                  (volatile uint32_t *)0xff006fe8
#define P_VENC_VDAC_DAC5_OFFSET                    (volatile uint32_t *)0xff006fec
#define P_VENC_VDAC_FIFO_CTRL                      (volatile uint32_t *)0xff006ff0
#define P_ENCL_TCON_INVERT_CTL                     (volatile uint32_t *)0xff006ff4
//
// Closing file:  venc_regs.h
//
//
// Reading file:  enc480p_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define P_ENCP_VIDEO_EN                            (volatile uint32_t *)0xff006e00
#define P_ENCP_VIDEO_SYNC_MODE                     (volatile uint32_t *)0xff006e04
#define P_ENCP_MACV_EN                             (volatile uint32_t *)0xff006e08
#define P_ENCP_VIDEO_Y_SCL                         (volatile uint32_t *)0xff006e0c
#define P_ENCP_VIDEO_PB_SCL                        (volatile uint32_t *)0xff006e10
#define P_ENCP_VIDEO_PR_SCL                        (volatile uint32_t *)0xff006e14
#define P_ENCP_VIDEO_SYNC_SCL                      (volatile uint32_t *)0xff006e18
#define P_ENCP_VIDEO_MACV_SCL                      (volatile uint32_t *)0xff006e1c
#define P_ENCP_VIDEO_Y_OFFST                       (volatile uint32_t *)0xff006e20
#define P_ENCP_VIDEO_PB_OFFST                      (volatile uint32_t *)0xff006e24
#define P_ENCP_VIDEO_PR_OFFST                      (volatile uint32_t *)0xff006e28
#define P_ENCP_VIDEO_SYNC_OFFST                    (volatile uint32_t *)0xff006e2c
#define P_ENCP_VIDEO_MACV_OFFST                    (volatile uint32_t *)0xff006e30
//----- Video mode
#define P_ENCP_VIDEO_MODE                          (volatile uint32_t *)0xff006e34
#define P_ENCP_VIDEO_MODE_ADV                      (volatile uint32_t *)0xff006e38
//--------------- Debug pins
#define P_ENCP_DBG_PX_RST                          (volatile uint32_t *)0xff006e40
#define P_ENCP_DBG_LN_RST                          (volatile uint32_t *)0xff006e44
#define P_ENCP_DBG_PX_INT                          (volatile uint32_t *)0xff006e48
#define P_ENCP_DBG_LN_INT                          (volatile uint32_t *)0xff006e4c
//----------- Video Advanced setting
#define P_ENCP_VIDEO_YFP1_HTIME                    (volatile uint32_t *)0xff006e50
#define P_ENCP_VIDEO_YFP2_HTIME                    (volatile uint32_t *)0xff006e54
#define P_ENCP_VIDEO_YC_DLY                        (volatile uint32_t *)0xff006e58
#define P_ENCP_VIDEO_MAX_PXCNT                     (volatile uint32_t *)0xff006e5c
#define P_ENCP_VIDEO_HSPULS_BEGIN                  (volatile uint32_t *)0xff006e60
#define P_ENCP_VIDEO_HSPULS_END                    (volatile uint32_t *)0xff006e64
#define P_ENCP_VIDEO_HSPULS_SWITCH                 (volatile uint32_t *)0xff006e68
#define P_ENCP_VIDEO_VSPULS_BEGIN                  (volatile uint32_t *)0xff006e6c
#define P_ENCP_VIDEO_VSPULS_END                    (volatile uint32_t *)0xff006e70
#define P_ENCP_VIDEO_VSPULS_BLINE                  (volatile uint32_t *)0xff006e74
#define P_ENCP_VIDEO_VSPULS_ELINE                  (volatile uint32_t *)0xff006e78
#define P_ENCP_VIDEO_EQPULS_BEGIN                  (volatile uint32_t *)0xff006e7c
#define P_ENCP_VIDEO_EQPULS_END                    (volatile uint32_t *)0xff006e80
#define P_ENCP_VIDEO_EQPULS_BLINE                  (volatile uint32_t *)0xff006e84
#define P_ENCP_VIDEO_EQPULS_ELINE                  (volatile uint32_t *)0xff006e88
#define P_ENCP_VIDEO_HAVON_END                     (volatile uint32_t *)0xff006e8c
#define P_ENCP_VIDEO_HAVON_BEGIN                   (volatile uint32_t *)0xff006e90
#define P_ENCP_VIDEO_VAVON_ELINE                   (volatile uint32_t *)0xff006ebc
#define P_ENCP_VIDEO_VAVON_BLINE                   (volatile uint32_t *)0xff006e98
#define P_ENCP_VIDEO_HSO_BEGIN                     (volatile uint32_t *)0xff006e9c
#define P_ENCP_VIDEO_HSO_END                       (volatile uint32_t *)0xff006ea0
#define P_ENCP_VIDEO_VSO_BEGIN                     (volatile uint32_t *)0xff006ea4
#define P_ENCP_VIDEO_VSO_END                       (volatile uint32_t *)0xff006ea8
#define P_ENCP_VIDEO_VSO_BLINE                     (volatile uint32_t *)0xff006eac
#define P_ENCP_VIDEO_VSO_ELINE                     (volatile uint32_t *)0xff006eb0
#define P_ENCP_VIDEO_SYNC_WAVE_CURVE               (volatile uint32_t *)0xff006eb4
#define P_ENCP_VIDEO_MAX_LNCNT                     (volatile uint32_t *)0xff006eb8
#define P_ENCP_VIDEO_SY_VAL                        (volatile uint32_t *)0xff006ec0
#define P_ENCP_VIDEO_SY2_VAL                       (volatile uint32_t *)0xff006ec4
#define P_ENCP_VIDEO_BLANKY_VAL                    (volatile uint32_t *)0xff006ec8
#define P_ENCP_VIDEO_BLANKPB_VAL                   (volatile uint32_t *)0xff006ecc
#define P_ENCP_VIDEO_BLANKPR_VAL                   (volatile uint32_t *)0xff006ed0
#define P_ENCP_VIDEO_HOFFST                        (volatile uint32_t *)0xff006ed4
#define P_ENCP_VIDEO_VOFFST                        (volatile uint32_t *)0xff006ed8
#define P_ENCP_VIDEO_RGB_CTRL                      (volatile uint32_t *)0xff006edc
#define P_ENCP_VIDEO_FILT_CTRL                     (volatile uint32_t *)0xff006ee0
#define P_ENCP_VIDEO_OFLD_VPEQ_OFST                (volatile uint32_t *)0xff006ee4
#define P_ENCP_VIDEO_OFLD_VOAV_OFST                (volatile uint32_t *)0xff006ee8
#define P_ENCP_VIDEO_MATRIX_CB                     (volatile uint32_t *)0xff006eec
#define P_ENCP_VIDEO_MATRIX_CR                     (volatile uint32_t *)0xff006ef0
#define P_ENCP_VIDEO_RGBIN_CTRL                    (volatile uint32_t *)0xff006ef4
//------------------Macrovision advanced setting
#define P_ENCP_MACV_BLANKY_VAL                     (volatile uint32_t *)0xff006f00
#define P_ENCP_MACV_MAXY_VAL                       (volatile uint32_t *)0xff006f04
#define P_ENCP_MACV_1ST_PSSYNC_STRT                (volatile uint32_t *)0xff006f08
#define P_ENCP_MACV_PSSYNC_STRT                    (volatile uint32_t *)0xff006f0c
#define P_ENCP_MACV_AGC_STRT                       (volatile uint32_t *)0xff006f10
#define P_ENCP_MACV_AGC_END                        (volatile uint32_t *)0xff006f14
#define P_ENCP_MACV_WAVE_END                       (volatile uint32_t *)0xff006f18
#define P_ENCP_MACV_STRTLINE                       (volatile uint32_t *)0xff006f1c
#define P_ENCP_MACV_ENDLINE                        (volatile uint32_t *)0xff006f20
#define P_ENCP_MACV_TS_CNT_MAX_L                   (volatile uint32_t *)0xff006f24
#define P_ENCP_MACV_TS_CNT_MAX_H                   (volatile uint32_t *)0xff006f28
#define P_ENCP_MACV_TIME_DOWN                      (volatile uint32_t *)0xff006f2c
#define P_ENCP_MACV_TIME_LO                        (volatile uint32_t *)0xff006f30
#define P_ENCP_MACV_TIME_UP                        (volatile uint32_t *)0xff006f34
#define P_ENCP_MACV_TIME_RST                       (volatile uint32_t *)0xff006f38
//---------------- VBI control -------------------
#define P_ENCP_VBI_CTRL                            (volatile uint32_t *)0xff006f40
#define P_ENCP_VBI_SETTING                         (volatile uint32_t *)0xff006f44
#define P_ENCP_VBI_BEGIN                           (volatile uint32_t *)0xff006f48
#define P_ENCP_VBI_WIDTH                           (volatile uint32_t *)0xff006f4c
#define P_ENCP_VBI_HVAL                            (volatile uint32_t *)0xff006f50
#define P_ENCP_VBI_DATA0                           (volatile uint32_t *)0xff006f54
#define P_ENCP_VBI_DATA1                           (volatile uint32_t *)0xff006f58
//----------------C656 OUT Control------------- Grant
#define P_C656_HS_ST                               (volatile uint32_t *)0xff006f80
#define P_C656_HS_ED                               (volatile uint32_t *)0xff006f84
#define P_C656_VS_LNST_E                           (volatile uint32_t *)0xff006f88
#define P_C656_VS_LNST_O                           (volatile uint32_t *)0xff006f8c
#define P_C656_VS_LNED_E                           (volatile uint32_t *)0xff006f90
#define P_C656_VS_LNED_O                           (volatile uint32_t *)0xff006f94
#define P_C656_FS_LNST                             (volatile uint32_t *)0xff006f98
#define P_C656_FS_LNED                             (volatile uint32_t *)0xff006f9c
#define P_ENCP_VRR_CTRL                            (volatile uint32_t *)0xff006fa0
#define P_ENCP_VRR_ADJ_LMT                         (volatile uint32_t *)0xff006fa4
#define P_ENCP_VRR_CTRL1                           (volatile uint32_t *)0xff006fa8
#define P_ENCP_RO_VRR                              (volatile uint32_t *)0xff006fb0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  enc480p_regs.h
//
//
// Reading file:  enci_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define P_ENCI_VIDEO_MODE                          (volatile uint32_t *)0xff006c00
#define P_ENCI_VIDEO_MODE_ADV                      (volatile uint32_t *)0xff006c04
#define P_ENCI_VIDEO_FSC_ADJ                       (volatile uint32_t *)0xff006c08
#define P_ENCI_VIDEO_BRIGHT                        (volatile uint32_t *)0xff006c0c
#define P_ENCI_VIDEO_CONT                          (volatile uint32_t *)0xff006c10
#define P_ENCI_VIDEO_SAT                           (volatile uint32_t *)0xff006c14
#define P_ENCI_VIDEO_HUE                           (volatile uint32_t *)0xff006c18
#define P_ENCI_VIDEO_SCH                           (volatile uint32_t *)0xff006c1c
#define P_ENCI_SYNC_MODE                           (volatile uint32_t *)0xff006c20
#define P_ENCI_SYNC_CTRL                           (volatile uint32_t *)0xff006c24
#define P_ENCI_SYNC_HSO_BEGIN                      (volatile uint32_t *)0xff006c28
#define P_ENCI_SYNC_HSO_END                        (volatile uint32_t *)0xff006c2c
#define P_ENCI_SYNC_VSO_EVN                        (volatile uint32_t *)0xff006c30
#define P_ENCI_SYNC_VSO_ODD                        (volatile uint32_t *)0xff006c34
#define P_ENCI_SYNC_VSO_EVNLN                      (volatile uint32_t *)0xff006c38
#define P_ENCI_SYNC_VSO_ODDLN                      (volatile uint32_t *)0xff006c3c
#define P_ENCI_SYNC_HOFFST                         (volatile uint32_t *)0xff006c40
#define P_ENCI_SYNC_VOFFST                         (volatile uint32_t *)0xff006c44
#define P_ENCI_SYNC_ADJ                            (volatile uint32_t *)0xff006c48
#define P_ENCI_RGB_SETTING                         (volatile uint32_t *)0xff006c4c
//`define	ENCI_CMPN_MATRIX_CB		8'h14
//`define	ENCI_CMPN_MATRIX_CR		8'h15
#define P_ENCI_DE_H_BEGIN                          (volatile uint32_t *)0xff006c58
#define P_ENCI_DE_H_END                            (volatile uint32_t *)0xff006c5c
#define P_ENCI_DE_V_BEGIN_EVEN                     (volatile uint32_t *)0xff006c60
#define P_ENCI_DE_V_END_EVEN                       (volatile uint32_t *)0xff006c64
#define P_ENCI_DE_V_BEGIN_ODD                      (volatile uint32_t *)0xff006c68
#define P_ENCI_DE_V_END_ODD                        (volatile uint32_t *)0xff006c6c
#define P_ENCI_VBI_SETTING                         (volatile uint32_t *)0xff006c80
#define P_ENCI_VBI_CCDT_EVN                        (volatile uint32_t *)0xff006c84
#define P_ENCI_VBI_CCDT_ODD                        (volatile uint32_t *)0xff006c88
#define P_ENCI_VBI_CC525_LN                        (volatile uint32_t *)0xff006c8c
#define P_ENCI_VBI_CC625_LN                        (volatile uint32_t *)0xff006c90
#define P_ENCI_VBI_WSSDT                           (volatile uint32_t *)0xff006c94
#define P_ENCI_VBI_WSS_LN                          (volatile uint32_t *)0xff006c98
#define P_ENCI_VBI_CGMSDT_L                        (volatile uint32_t *)0xff006c9c
#define P_ENCI_VBI_CGMSDT_H                        (volatile uint32_t *)0xff006ca0
#define P_ENCI_VBI_CGMS_LN                         (volatile uint32_t *)0xff006ca4
#define P_ENCI_VBI_TTX_HTIME                       (volatile uint32_t *)0xff006ca8
#define P_ENCI_VBI_TTX_LN                          (volatile uint32_t *)0xff006cac
#define P_ENCI_VBI_TTXDT0                          (volatile uint32_t *)0xff006cb0
#define P_ENCI_VBI_TTXDT1                          (volatile uint32_t *)0xff006cb4
#define P_ENCI_VBI_TTXDT2                          (volatile uint32_t *)0xff006cb8
#define P_ENCI_VBI_TTXDT3                          (volatile uint32_t *)0xff006cbc
#define P_ENCI_MACV_N0                             (volatile uint32_t *)0xff006cc0
#define P_ENCI_MACV_N1                             (volatile uint32_t *)0xff006cc4
#define P_ENCI_MACV_N2                             (volatile uint32_t *)0xff006cc8
#define P_ENCI_MACV_N3                             (volatile uint32_t *)0xff006ccc
#define P_ENCI_MACV_N4                             (volatile uint32_t *)0xff006cd0
#define P_ENCI_MACV_N5                             (volatile uint32_t *)0xff006cd4
#define P_ENCI_MACV_N6                             (volatile uint32_t *)0xff006cd8
#define P_ENCI_MACV_N7                             (volatile uint32_t *)0xff006cdc
#define P_ENCI_MACV_N8                             (volatile uint32_t *)0xff006ce0
#define P_ENCI_MACV_N9                             (volatile uint32_t *)0xff006ce4
#define P_ENCI_MACV_N10                            (volatile uint32_t *)0xff006ce8
#define P_ENCI_MACV_N11                            (volatile uint32_t *)0xff006cec
#define P_ENCI_MACV_N12                            (volatile uint32_t *)0xff006cf0
#define P_ENCI_MACV_N13                            (volatile uint32_t *)0xff006cf4
#define P_ENCI_MACV_N14                            (volatile uint32_t *)0xff006cf8
#define P_ENCI_MACV_N15                            (volatile uint32_t *)0xff006cfc
#define P_ENCI_MACV_N16                            (volatile uint32_t *)0xff006d00
#define P_ENCI_MACV_N17                            (volatile uint32_t *)0xff006d04
#define P_ENCI_MACV_N18                            (volatile uint32_t *)0xff006d08
#define P_ENCI_MACV_N19                            (volatile uint32_t *)0xff006d0c
#define P_ENCI_MACV_N20                            (volatile uint32_t *)0xff006d10
#define P_ENCI_MACV_N21                            (volatile uint32_t *)0xff006d14
#define P_ENCI_MACV_N22                            (volatile uint32_t *)0xff006d18
//`define	ENCI_MACV_P_AGC			8'h47
#define P_ENCI_DBG_PX_RST                          (volatile uint32_t *)0xff006d20
#define P_ENCI_DBG_FLDLN_RST                       (volatile uint32_t *)0xff006d24
#define P_ENCI_DBG_PX_INT                          (volatile uint32_t *)0xff006d28
#define P_ENCI_DBG_FLDLN_INT                       (volatile uint32_t *)0xff006d2c
#define P_ENCI_DBG_MAXPX                           (volatile uint32_t *)0xff006d30
#define P_ENCI_DBG_MAXLN                           (volatile uint32_t *)0xff006d34
#define P_ENCI_MACV_MAX_AMP                        (volatile uint32_t *)0xff006d40
#define P_ENCI_MACV_PULSE_LO                       (volatile uint32_t *)0xff006d44
#define P_ENCI_MACV_PULSE_HI                       (volatile uint32_t *)0xff006d48
#define P_ENCI_MACV_BKP_MAX                        (volatile uint32_t *)0xff006d4c
#define P_ENCI_CFILT_CTRL                          (volatile uint32_t *)0xff006d50
#define P_ENCI_CFILT7                              (volatile uint32_t *)0xff006d54
#define P_ENCI_YC_DELAY                            (volatile uint32_t *)0xff006d58
#define P_ENCI_VIDEO_EN                            (volatile uint32_t *)0xff006d5c
//
// Closing file:  enci_regs.h
//
//
// Reading file:  venc2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef)
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC2_VCBUS_BASE = 0x1c
// -----------------------------------------------
// Program video control signals from ENCI core to DVI/HDMI interface
#define P_ENCI_DVI_HSO_BEGIN                       (volatile uint32_t *)0xff007000
#define P_ENCI_DVI_HSO_END                         (volatile uint32_t *)0xff007004
#define P_ENCI_DVI_VSO_BLINE_EVN                   (volatile uint32_t *)0xff007008
#define P_ENCI_DVI_VSO_BLINE_ODD                   (volatile uint32_t *)0xff00700c
#define P_ENCI_DVI_VSO_ELINE_EVN                   (volatile uint32_t *)0xff007010
#define P_ENCI_DVI_VSO_ELINE_ODD                   (volatile uint32_t *)0xff007014
#define P_ENCI_DVI_VSO_BEGIN_EVN                   (volatile uint32_t *)0xff007018
#define P_ENCI_DVI_VSO_BEGIN_ODD                   (volatile uint32_t *)0xff00701c
#define P_ENCI_DVI_VSO_END_EVN                     (volatile uint32_t *)0xff007020
#define P_ENCI_DVI_VSO_END_ODD                     (volatile uint32_t *)0xff007024
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define P_ENCI_CFILT_CTRL2                         (volatile uint32_t *)0xff007028
#define P_ENCI_DACSEL_0                            (volatile uint32_t *)0xff00702c
#define P_ENCI_DACSEL_1                            (volatile uint32_t *)0xff007030
#define P_ENCP_DACSEL_0                            (volatile uint32_t *)0xff007034
#define P_ENCP_DACSEL_1                            (volatile uint32_t *)0xff007038
#define P_ENCP_MAX_LINE_SWITCH_POINT               (volatile uint32_t *)0xff00703c
#define P_ENCI_TST_EN                              (volatile uint32_t *)0xff007040
#define P_ENCI_TST_MDSEL                           (volatile uint32_t *)0xff007044
#define P_ENCI_TST_Y                               (volatile uint32_t *)0xff007048
#define P_ENCI_TST_CB                              (volatile uint32_t *)0xff00704c
#define P_ENCI_TST_CR                              (volatile uint32_t *)0xff007050
#define P_ENCI_TST_CLRBAR_STRT                     (volatile uint32_t *)0xff007054
#define P_ENCI_TST_CLRBAR_WIDTH                    (volatile uint32_t *)0xff007058
#define P_ENCI_TST_VDCNT_STSET                     (volatile uint32_t *)0xff00705c
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCI_VFIFO2VD_CTL                        (volatile uint32_t *)0xff007060
// bit 12:0 -- vfifo2vd_pixel_start
#define P_ENCI_VFIFO2VD_PIXEL_START                (volatile uint32_t *)0xff007064
// bit 12:00 -- vfifo2vd_pixel_end
#define P_ENCI_VFIFO2VD_PIXEL_END                  (volatile uint32_t *)0xff007068
// bit 10:0 -- vfifo2vd_line_top_start
#define P_ENCI_VFIFO2VD_LINE_TOP_START             (volatile uint32_t *)0xff00706c
// bit 10:00 -- vfifo2vd_line_top_end
#define P_ENCI_VFIFO2VD_LINE_TOP_END               (volatile uint32_t *)0xff007070
// bit 10:00 -- vfifo2vd_line_bot_start
#define P_ENCI_VFIFO2VD_LINE_BOT_START             (volatile uint32_t *)0xff007074
// bit 10:00 -- vfifo2vd_line_bot_end
#define P_ENCI_VFIFO2VD_LINE_BOT_END               (volatile uint32_t *)0xff007078
#define P_ENCI_VFIFO2VD_CTL2                       (volatile uint32_t *)0xff00707c
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCT_VFIFO2VD_CTL                        (volatile uint32_t *)0xff007080
// bit 12:0 -- vfifo2vd_pixel_start
#define P_ENCT_VFIFO2VD_PIXEL_START                (volatile uint32_t *)0xff007084
// bit 12:00 -- vfifo2vd_pixel_end
#define P_ENCT_VFIFO2VD_PIXEL_END                  (volatile uint32_t *)0xff007088
// bit 10:0 -- vfifo2vd_line_top_start
#define P_ENCT_VFIFO2VD_LINE_TOP_START             (volatile uint32_t *)0xff00708c
// bit 10:00 -- vfifo2vd_line_top_end
#define P_ENCT_VFIFO2VD_LINE_TOP_END               (volatile uint32_t *)0xff007090
// bit 10:00 -- vfifo2vd_line_bot_start
#define P_ENCT_VFIFO2VD_LINE_BOT_START             (volatile uint32_t *)0xff007094
// bit 10:00 -- vfifo2vd_line_bot_end
#define P_ENCT_VFIFO2VD_LINE_BOT_END               (volatile uint32_t *)0xff007098
#define P_ENCT_VFIFO2VD_CTL2                       (volatile uint32_t *)0xff00709c
#define P_ENCT_TST_EN                              (volatile uint32_t *)0xff0070a0
#define P_ENCT_TST_MDSEL                           (volatile uint32_t *)0xff0070a4
#define P_ENCT_TST_Y                               (volatile uint32_t *)0xff0070a8
#define P_ENCT_TST_CB                              (volatile uint32_t *)0xff0070ac
#define P_ENCT_TST_CR                              (volatile uint32_t *)0xff0070b0
#define P_ENCT_TST_CLRBAR_STRT                     (volatile uint32_t *)0xff0070b4
#define P_ENCT_TST_CLRBAR_WIDTH                    (volatile uint32_t *)0xff0070b8
#define P_ENCT_TST_VDCNT_STSET                     (volatile uint32_t *)0xff0070bc
// Program video control signals from ENCP core to DVI/HDMI interface
#define P_ENCP_DVI_HSO_BEGIN                       (volatile uint32_t *)0xff0070c0
#define P_ENCP_DVI_HSO_END                         (volatile uint32_t *)0xff0070c4
#define P_ENCP_DVI_VSO_BLINE_EVN                   (volatile uint32_t *)0xff0070c8
#define P_ENCP_DVI_VSO_BLINE_ODD                   (volatile uint32_t *)0xff0070cc
#define P_ENCP_DVI_VSO_ELINE_EVN                   (volatile uint32_t *)0xff0070d0
#define P_ENCP_DVI_VSO_ELINE_ODD                   (volatile uint32_t *)0xff0070d4
#define P_ENCP_DVI_VSO_BEGIN_EVN                   (volatile uint32_t *)0xff0070d8
#define P_ENCP_DVI_VSO_BEGIN_ODD                   (volatile uint32_t *)0xff0070dc
#define P_ENCP_DVI_VSO_END_EVN                     (volatile uint32_t *)0xff0070e0
#define P_ENCP_DVI_VSO_END_ODD                     (volatile uint32_t *)0xff0070e4
#define P_ENCP_DE_H_BEGIN                          (volatile uint32_t *)0xff0070e8
#define P_ENCP_DE_H_END                            (volatile uint32_t *)0xff0070ec
#define P_ENCP_DE_V_BEGIN_EVEN                     (volatile uint32_t *)0xff0070f0
#define P_ENCP_DE_V_END_EVEN                       (volatile uint32_t *)0xff0070f4
#define P_ENCP_DE_V_BEGIN_ODD                      (volatile uint32_t *)0xff0070f8
#define P_ENCP_DE_V_END_ODD                        (volatile uint32_t *)0xff0070fc
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCI_SYNC_LINE_LENGTH                    (volatile uint32_t *)0xff007100
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCI_SYNC_PIXEL_EN                       (volatile uint32_t *)0xff007104
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCI_SYNC_TO_LINE_EN                     (volatile uint32_t *)0xff007108
// Bit 12:0 - sync target pixel
#define P_ENCI_SYNC_TO_PIXEL                       (volatile uint32_t *)0xff00710c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCP_SYNC_LINE_LENGTH                    (volatile uint32_t *)0xff007110
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCP_SYNC_PIXEL_EN                       (volatile uint32_t *)0xff007114
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCP_SYNC_TO_LINE_EN                     (volatile uint32_t *)0xff007118
// Bit 12:0 - sync target pixel
#define P_ENCP_SYNC_TO_PIXEL                       (volatile uint32_t *)0xff00711c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCT_SYNC_LINE_LENGTH                    (volatile uint32_t *)0xff007120
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCT_SYNC_PIXEL_EN                       (volatile uint32_t *)0xff007124
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCT_SYNC_TO_LINE_EN                     (volatile uint32_t *)0xff007128
// Bit 12:0 - sync target pixel
#define P_ENCT_SYNC_TO_PIXEL                       (volatile uint32_t *)0xff00712c
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define P_ENCL_SYNC_LINE_LENGTH                    (volatile uint32_t *)0xff007130
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define P_ENCL_SYNC_PIXEL_EN                       (volatile uint32_t *)0xff007134
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define P_ENCL_SYNC_TO_LINE_EN                     (volatile uint32_t *)0xff007138
// Bit 12:0 - sync target pixel
#define P_ENCL_SYNC_TO_PIXEL                       (volatile uint32_t *)0xff00713c
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define P_ENCP_VFIFO2VD_CTL2                       (volatile uint32_t *)0xff007140
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define P_VENC_DVI_SETTING_MORE                    (volatile uint32_t *)0xff007144
#define P_VENC_VDAC_DAC4_FILT_CTRL0                (volatile uint32_t *)0xff007150
#define P_VENC_VDAC_DAC4_FILT_CTRL1                (volatile uint32_t *)0xff007154
#define P_VENC_VDAC_DAC5_FILT_CTRL0                (volatile uint32_t *)0xff007158
#define P_VENC_VDAC_DAC5_FILT_CTRL1                (volatile uint32_t *)0xff00715c
//Bit 0   filter_en
#define P_VENC_VDAC_DAC0_FILT_CTRL0                (volatile uint32_t *)0xff007160
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define P_VENC_VDAC_DAC0_FILT_CTRL1                (volatile uint32_t *)0xff007164
//Bit 0   filter_en
#define P_VENC_VDAC_DAC1_FILT_CTRL0                (volatile uint32_t *)0xff007168
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define P_VENC_VDAC_DAC1_FILT_CTRL1                (volatile uint32_t *)0xff00716c
//Bit 0   filter_en
#define P_VENC_VDAC_DAC2_FILT_CTRL0                (volatile uint32_t *)0xff007170
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define P_VENC_VDAC_DAC2_FILT_CTRL1                (volatile uint32_t *)0xff007174
//Bit 0   filter_en
#define P_VENC_VDAC_DAC3_FILT_CTRL0                (volatile uint32_t *)0xff007178
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define P_VENC_VDAC_DAC3_FILT_CTRL1                (volatile uint32_t *)0xff00717c
//===========================================================================
// ENCT registers
#define P_ENCT_VIDEO_EN                            (volatile uint32_t *)0xff007180
#define P_ENCT_VIDEO_Y_SCL                         (volatile uint32_t *)0xff007184
#define P_ENCT_VIDEO_PB_SCL                        (volatile uint32_t *)0xff007188
#define P_ENCT_VIDEO_PR_SCL                        (volatile uint32_t *)0xff00718c
#define P_ENCT_VIDEO_Y_OFFST                       (volatile uint32_t *)0xff007190
#define P_ENCT_VIDEO_PB_OFFST                      (volatile uint32_t *)0xff007194
#define P_ENCT_VIDEO_PR_OFFST                      (volatile uint32_t *)0xff007198
//----- Video mode
#define P_ENCT_VIDEO_MODE                          (volatile uint32_t *)0xff00719c
#define P_ENCT_VIDEO_MODE_ADV                      (volatile uint32_t *)0xff0071a0
//--------------- Debug pins
#define P_ENCT_DBG_PX_RST                          (volatile uint32_t *)0xff0071a4
#define P_ENCT_DBG_LN_RST                          (volatile uint32_t *)0xff0071a8
#define P_ENCT_DBG_PX_INT                          (volatile uint32_t *)0xff0071ac
#define P_ENCT_DBG_LN_INT                          (volatile uint32_t *)0xff0071b0
//----------- Video Advanced setting
#define P_ENCT_VIDEO_YFP1_HTIME                    (volatile uint32_t *)0xff0071b4
#define P_ENCT_VIDEO_YFP2_HTIME                    (volatile uint32_t *)0xff0071b8
#define P_ENCT_VIDEO_YC_DLY                        (volatile uint32_t *)0xff0071bc
#define P_ENCT_VIDEO_MAX_PXCNT                     (volatile uint32_t *)0xff0071c0
#define P_ENCT_VIDEO_HAVON_END                     (volatile uint32_t *)0xff0071c4
#define P_ENCT_VIDEO_HAVON_BEGIN                   (volatile uint32_t *)0xff0071c8
#define P_ENCT_VIDEO_VAVON_ELINE                   (volatile uint32_t *)0xff0071cc
#define P_ENCT_VIDEO_VAVON_BLINE                   (volatile uint32_t *)0xff0071d0
#define P_ENCT_VIDEO_HSO_BEGIN                     (volatile uint32_t *)0xff0071d4
#define P_ENCT_VIDEO_HSO_END                       (volatile uint32_t *)0xff0071d8
#define P_ENCT_VIDEO_VSO_BEGIN                     (volatile uint32_t *)0xff0071dc
#define P_ENCT_VIDEO_VSO_END                       (volatile uint32_t *)0xff0071e0
#define P_ENCT_VIDEO_VSO_BLINE                     (volatile uint32_t *)0xff0071e4
#define P_ENCT_VIDEO_VSO_ELINE                     (volatile uint32_t *)0xff0071e8
#define P_ENCT_VIDEO_MAX_LNCNT                     (volatile uint32_t *)0xff0071ec
#define P_ENCT_VIDEO_BLANKY_VAL                    (volatile uint32_t *)0xff0071f0
#define P_ENCT_VIDEO_BLANKPB_VAL                   (volatile uint32_t *)0xff0071f4
#define P_ENCT_VIDEO_BLANKPR_VAL                   (volatile uint32_t *)0xff0071f8
#define P_ENCT_VIDEO_HOFFST                        (volatile uint32_t *)0xff0071fc
#define P_ENCT_VIDEO_VOFFST                        (volatile uint32_t *)0xff007200
#define P_ENCT_VIDEO_RGB_CTRL                      (volatile uint32_t *)0xff007204
#define P_ENCT_VIDEO_FILT_CTRL                     (volatile uint32_t *)0xff007208
#define P_ENCT_VIDEO_OFLD_VPEQ_OFST                (volatile uint32_t *)0xff00720c
#define P_ENCT_VIDEO_OFLD_VOAV_OFST                (volatile uint32_t *)0xff007210
#define P_ENCT_VIDEO_MATRIX_CB                     (volatile uint32_t *)0xff007214
#define P_ENCT_VIDEO_MATRIX_CR                     (volatile uint32_t *)0xff007218
#define P_ENCT_VIDEO_RGBIN_CTRL                    (volatile uint32_t *)0xff00721c
#define P_ENCT_MAX_LINE_SWITCH_POINT               (volatile uint32_t *)0xff007220
#define P_ENCT_DACSEL_0                            (volatile uint32_t *)0xff007224
#define P_ENCT_DACSEL_1                            (volatile uint32_t *)0xff007228
#define P_ENCT_INBUF_CNTL0                         (volatile uint32_t *)0xff00722c
#define P_ENCT_INBUF_CNTL1                         (volatile uint32_t *)0xff007230
#define P_ENCT_INBUF_CNT                           (volatile uint32_t *)0xff007234
#define P_ENCT_INBUF_HOLD_CNT                      (volatile uint32_t *)0xff007238
#define P_ENCT_INBUF_FIX_PIX_NUM                   (volatile uint32_t *)0xff00723c
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define P_ENCL_VFIFO2VD_CTL                        (volatile uint32_t *)0xff007240
// bit 12:0 -- vfifo2vd_pixel_start
#define P_ENCL_VFIFO2VD_PIXEL_START                (volatile uint32_t *)0xff007244
// bit 12:00 -- vfifo2vd_pixel_end
#define P_ENCL_VFIFO2VD_PIXEL_END                  (volatile uint32_t *)0xff007248
// bit 10:0 -- vfifo2vd_line_top_start
#define P_ENCL_VFIFO2VD_LINE_TOP_START             (volatile uint32_t *)0xff00724c
// bit 10:00 -- vfifo2vd_line_top_end
#define P_ENCL_VFIFO2VD_LINE_TOP_END               (volatile uint32_t *)0xff007250
// bit 10:00 -- vfifo2vd_line_bot_start
#define P_ENCL_VFIFO2VD_LINE_BOT_START             (volatile uint32_t *)0xff007254
// bit 10:00 -- vfifo2vd_line_bot_end
#define P_ENCL_VFIFO2VD_LINE_BOT_END               (volatile uint32_t *)0xff007258
#define P_ENCL_VFIFO2VD_CTL2                       (volatile uint32_t *)0xff00725c
#define P_ENCL_TST_EN                              (volatile uint32_t *)0xff007260
#define P_ENCL_TST_MDSEL                           (volatile uint32_t *)0xff007264
#define P_ENCL_TST_Y                               (volatile uint32_t *)0xff007268
#define P_ENCL_TST_CB                              (volatile uint32_t *)0xff00726c
#define P_ENCL_TST_CR                              (volatile uint32_t *)0xff007270
#define P_ENCL_TST_CLRBAR_STRT                     (volatile uint32_t *)0xff007274
#define P_ENCL_TST_CLRBAR_WIDTH                    (volatile uint32_t *)0xff007278
#define P_ENCL_TST_VDCNT_STSET                     (volatile uint32_t *)0xff00727c
//===========================================================================
// ENCL registers
#define P_ENCL_VIDEO_EN                            (volatile uint32_t *)0xff007280
#define P_ENCL_VIDEO_Y_SCL                         (volatile uint32_t *)0xff007284
#define P_ENCL_VIDEO_PB_SCL                        (volatile uint32_t *)0xff007288
#define P_ENCL_VIDEO_PR_SCL                        (volatile uint32_t *)0xff00728c
#define P_ENCL_VIDEO_Y_OFFST                       (volatile uint32_t *)0xff007290
#define P_ENCL_VIDEO_PB_OFFST                      (volatile uint32_t *)0xff007294
#define P_ENCL_VIDEO_PR_OFFST                      (volatile uint32_t *)0xff007298
//----- Video mode
#define P_ENCL_VIDEO_MODE                          (volatile uint32_t *)0xff00729c
#define P_ENCL_VIDEO_MODE_ADV                      (volatile uint32_t *)0xff0072a0
//--------------- Debug pins
#define P_ENCL_DBG_PX_RST                          (volatile uint32_t *)0xff0072a4
#define P_ENCL_DBG_LN_RST                          (volatile uint32_t *)0xff0072a8
#define P_ENCL_DBG_PX_INT                          (volatile uint32_t *)0xff0072ac
#define P_ENCL_DBG_LN_INT                          (volatile uint32_t *)0xff0072b0
//----------- Video Advanced setting
#define P_ENCL_VIDEO_YFP1_HTIME                    (volatile uint32_t *)0xff0072b4
#define P_ENCL_VIDEO_YFP2_HTIME                    (volatile uint32_t *)0xff0072b8
#define P_ENCL_VIDEO_YC_DLY                        (volatile uint32_t *)0xff0072bc
#define P_ENCL_VIDEO_MAX_PXCNT                     (volatile uint32_t *)0xff0072c0
#define P_ENCL_VIDEO_HAVON_END                     (volatile uint32_t *)0xff0072c4
#define P_ENCL_VIDEO_HAVON_BEGIN                   (volatile uint32_t *)0xff0072c8
#define P_ENCL_VIDEO_VAVON_ELINE                   (volatile uint32_t *)0xff0072cc
#define P_ENCL_VIDEO_VAVON_BLINE                   (volatile uint32_t *)0xff0072d0
#define P_ENCL_VIDEO_HSO_BEGIN                     (volatile uint32_t *)0xff0072d4
#define P_ENCL_VIDEO_HSO_END                       (volatile uint32_t *)0xff0072d8
#define P_ENCL_VIDEO_VSO_BEGIN                     (volatile uint32_t *)0xff0072dc
#define P_ENCL_VIDEO_VSO_END                       (volatile uint32_t *)0xff0072e0
#define P_ENCL_VIDEO_VSO_BLINE                     (volatile uint32_t *)0xff0072e4
#define P_ENCL_VIDEO_VSO_ELINE                     (volatile uint32_t *)0xff0072e8
#define P_ENCL_VIDEO_MAX_LNCNT                     (volatile uint32_t *)0xff0072ec
#define P_ENCL_VIDEO_BLANKY_VAL                    (volatile uint32_t *)0xff0072f0
#define P_ENCL_VIDEO_BLANKPB_VAL                   (volatile uint32_t *)0xff0072f4
#define P_ENCL_VIDEO_BLANKPR_VAL                   (volatile uint32_t *)0xff0072f8
#define P_ENCL_VIDEO_HOFFST                        (volatile uint32_t *)0xff0072fc
#define P_ENCL_VIDEO_VOFFST                        (volatile uint32_t *)0xff007300
#define P_ENCL_VIDEO_RGB_CTRL                      (volatile uint32_t *)0xff007304
#define P_ENCL_VIDEO_FILT_CTRL                     (volatile uint32_t *)0xff007308
#define P_ENCL_VIDEO_OFLD_VPEQ_OFST                (volatile uint32_t *)0xff00730c
#define P_ENCL_VIDEO_OFLD_VOAV_OFST                (volatile uint32_t *)0xff007310
#define P_ENCL_VIDEO_MATRIX_CB                     (volatile uint32_t *)0xff007314
#define P_ENCL_VIDEO_MATRIX_CR                     (volatile uint32_t *)0xff007318
#define P_ENCL_VIDEO_RGBIN_CTRL                    (volatile uint32_t *)0xff00731c
#define P_ENCL_MAX_LINE_SWITCH_POINT               (volatile uint32_t *)0xff007320
#define P_ENCL_DACSEL_0                            (volatile uint32_t *)0xff007324
#define P_ENCL_DACSEL_1                            (volatile uint32_t *)0xff007328
#define P_ENCT_VIDEO_H_PRE_DE_END                  (volatile uint32_t *)0xff00732c
#define P_ENCT_VIDEO_H_PRE_DE_BEGIN                (volatile uint32_t *)0xff007330
#define P_ENCT_VIDEO_V_PRE_DE_ELINE                (volatile uint32_t *)0xff007334
#define P_ENCT_VIDEO_V_PRE_DE_BLINE                (volatile uint32_t *)0xff007338
#define P_ENCL_VIDEO_H_PRE_DE_END                  (volatile uint32_t *)0xff00733c
#define P_ENCL_VIDEO_H_PRE_DE_BEGIN                (volatile uint32_t *)0xff007340
#define P_ENCL_VIDEO_V_PRE_DE_ELINE                (volatile uint32_t *)0xff007344
#define P_ENCL_VIDEO_V_PRE_DE_BLINE                (volatile uint32_t *)0xff007348
#define P_ENCL_INBUF_CNTL0                         (volatile uint32_t *)0xff00734c
#define P_ENCL_INBUF_CNTL1                         (volatile uint32_t *)0xff007350
#define P_ENCL_INBUF_CNT                           (volatile uint32_t *)0xff007354
#define P_ENCL_INBUF_HOLD_CNT                      (volatile uint32_t *)0xff007358
#define P_ENCL_INBUF_FIX_PIX_NUM                   (volatile uint32_t *)0xff00735c
//
// Closing file:  venc2_regs.h
//
//
// Reading file:  vpp_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_VCBUS_BASE = 0x1d
// -----------------------------------------------
#define VPP_VD1_SC_OFFSET                 	0x00	//just used in vpp_vd1_scale	
//===========================================================================
// Video postprocessing Registers
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define P_VPP_DUMMY_DATA                           (volatile uint32_t *)0xff007400
//input line length used in VPP
#define P_VPP_LINE_IN_LENGTH                       (volatile uint32_t *)0xff007404
//input Picture height used in VPP
#define P_VPP_PIC_IN_HEIGHT                        (volatile uint32_t *)0xff007408
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
//Bit 6:0 	coef index
#define P_VPP_SCALE_COEF_IDX                       (volatile uint32_t *)0xff00740c
//coefficients for vertical filter and horizontal filter
#define P_VPP_SCALE_COEF                           (volatile uint32_t *)0xff007410
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		.
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region	
//		.
//  ---------------------------
//  ---------------------------  <------ region1_startp
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP_VSC_REGION12_STARTP                  (volatile uint32_t *)0xff007414
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP_VSC_REGION34_STARTP                  (volatile uint32_t *)0xff007418
#define P_VPP_VSC_REGION4_ENDP                     (volatile uint32_t *)0xff00741c
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define P_VPP_VSC_START_PHASE_STEP                 (volatile uint32_t *)0xff007420
//vertical scaler region0 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION0_PHASE_SLOPE              (volatile uint32_t *)0xff007424
//vertical scaler region1 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION1_PHASE_SLOPE              (volatile uint32_t *)0xff007428
//vertical scaler region3 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION3_PHASE_SLOPE              (volatile uint32_t *)0xff00742c
//vertical scaler region4 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION4_PHASE_SLOPE              (volatile uint32_t *)0xff007430
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field
#define P_VPP_VSC_PHASE_CTRL                       (volatile uint32_t *)0xff007434
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define P_VPP_VSC_INI_PHASE                        (volatile uint32_t *)0xff007438
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_VPP_HSC_REGION12_STARTP                  (volatile uint32_t *)0xff007440
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_VPP_HSC_REGION34_STARTP                  (volatile uint32_t *)0xff007444
#define P_VPP_HSC_REGION4_ENDP                     (volatile uint32_t *)0xff007448
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define P_VPP_HSC_START_PHASE_STEP                 (volatile uint32_t *)0xff00744c
//horizontal scaler region0 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION0_PHASE_SLOPE              (volatile uint32_t *)0xff007450
//horizontal scaler region1 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION1_PHASE_SLOPE              (volatile uint32_t *)0xff007454
//horizontal scaler region3 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION3_PHASE_SLOPE              (volatile uint32_t *)0xff007458
//horizontal scaler region4 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION4_PHASE_SLOPE              (volatile uint32_t *)0xff00745c
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0
//Bit 15:0    horizontal scaler top field initial phase0
#define P_VPP_HSC_PHASE_CTRL                       (volatile uint32_t *)0xff007460
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwidth needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
// Bit 2:0 vertical scaler bank length
#define P_VPP_SC_MISC                              (volatile uint32_t *)0xff007464
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_PREBLEND_VD1_H_START_END             (volatile uint32_t *)0xff007468
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_PREBLEND_VD1_V_START_END             (volatile uint32_t *)0xff00746c
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_POSTBLEND_VD1_H_START_END            (volatile uint32_t *)0xff007470
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_POSTBLEND_VD1_V_START_END            (volatile uint32_t *)0xff007474
// preblend/postblend video2 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_BLEND_VD2_H_START_END                (volatile uint32_t *)0xff007478
// preblend/postblend video2 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_BLEND_VD2_V_START_END                (volatile uint32_t *)0xff00747c
// preblend horizontal size
#define P_VPP_PREBLEND_H_SIZE                      (volatile uint32_t *)0xff007480
// postblend horizontal size
#define P_VPP_POSTBLEND_H_SIZE                     (volatile uint32_t *)0xff007484
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define P_VPP_HOLD_LINES                           (volatile uint32_t *)0xff007488
//Bit 26   if true, automatic change post blend output to one color if field ==1
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define P_VPP_BLEND_ONECOLOR_CTRL                  (volatile uint32_t *)0xff00748c
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP_PREBLEND_CURRENT_XY                  (volatile uint32_t *)0xff007490
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define P_VPP_POSTBLEND_CURRENT_XY                 (volatile uint32_t *)0xff007494
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// Bit 28   color management enable
// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory
// Bit 26:18, vd2 alpha
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, vd2 enable for preblend
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, vd2 enable for postblend
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultiplied
// Bit 8,  if true, osd2 is alpha premultiplied
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//			 the aync fifo will be reseted.
// Bit 1,	
// Bit 0	if true, the output result of VPP is saturated
#define P_VPP_MISC                                 (volatile uint32_t *)0xff007498
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define P_VPP_OFIFO_SIZE                           (volatile uint32_t *)0xff00749c
//Read only
//Bit 28:18 current scale out fifo counter
//Bit 17:13 current afifo counter
//Bit 12:0 current ofifo counter
#define P_VPP_FIFO_STATUS                          (volatile uint32_t *)0xff0074a0
// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable
// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable
#define P_VPP_SMOKE_CTRL                           (volatile uint32_t *)0xff0074a4
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 channel
//smoke2 for OSD2 channel
//smoke3 for VD2 channel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define P_VPP_SMOKE1_VAL                           (volatile uint32_t *)0xff0074a8
#define P_VPP_SMOKE2_VAL                           (volatile uint32_t *)0xff0074ac
#define P_VPP_SMOKE3_VAL                           (volatile uint32_t *)0xff0074b0
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE1_H_START_END                   (volatile uint32_t *)0xff0074b4
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE1_V_START_END                   (volatile uint32_t *)0xff0074b8
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE2_H_START_END                   (volatile uint32_t *)0xff0074bc
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE2_V_START_END                   (volatile uint32_t *)0xff0074c0
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE3_H_START_END                   (volatile uint32_t *)0xff0074c4
//Bit 28:16 start
//Bit 12:0 end
#define P_VPP_SMOKE3_V_START_END                   (volatile uint32_t *)0xff0074c8
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define P_VPP_SCO_FIFO_CTRL                        (volatile uint32_t *)0xff0074cc
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1
//Bit 15:0    horizontal scaler top field initial phase1
#define P_VPP_HSC_PHASE_CTRL1                      (volatile uint32_t *)0xff0074d0
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
//6:4  hsc pattern start
//2:0  hsc pattern end
#define P_VPP_HSC_INI_PAT_CTRL                     (volatile uint32_t *)0xff0074d4
#define P_VPP_SC_GCLK_CTRL1                        (volatile uint32_t *)0xff0074d8
#define P_VPP_PREHSC_COEF                          (volatile uint32_t *)0xff0074dc
#define P_VPP_PRE_SCALE_CTRL                       (volatile uint32_t *)0xff0074e0
#define P_VPP_PREVSC_COEF                          (volatile uint32_t *)0xff0074e4
#define P_VPP_PREHSC_COEF1                         (volatile uint32_t *)0xff0074e8
//Bit 3			minus black level enable for vadj2
//Bit 2			Video adjustment enable for vadj2
//Bit 1			minus black level enable for vadj1
//Bit 0			Video adjustment enable for vadj1
#define P_VPP_VADJ_CTRL                            (volatile uint32_t *)0xff007500
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
//`define VPP_VADJ1_Y                    8'h41      //'h00080
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
//`define VPP_VADJ1_MA_MB                8'h42   //26'h100_0000
//`define VPP_VADJ1_MC_MD                8'h43   //26'h000_0100
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
//`define VPP_VADJ2_Y                    8'h44      //'h00080
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
//`define VPP_VADJ2_MA_MB                8'h45   //26'h100_0000
//`define VPP_VADJ2_MC_MD                8'h46   //26'h000_0100
//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur
//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur
//Bit 0 horizontal sharpness enable
#define P_VPP_HSHARP_CTRL                          (volatile uint32_t *)0xff007540
//{1'b0,threshold} < diff
//Bit 26:16  luma threshold0
//Bit 10:0   luma threshold1
#define P_VPP_HSHARP_LUMA_THRESH01                 (volatile uint32_t *)0xff007544
//
//Bit 26:16  luma threshold2
//Bit 10:0   luma threshold3
#define P_VPP_HSHARP_LUMA_THRESH23                 (volatile uint32_t *)0xff007548
//Bit 26:16  chroma threshold0
//Bit 10:0   chroma threshold1
#define P_VPP_HSHARP_CHROMA_THRESH01               (volatile uint32_t *)0xff00754c
//Bit 26:16  chroma threshold2
//Bit 10:0   chroma threshold3
#define P_VPP_HSHARP_CHROMA_THRESH23               (volatile uint32_t *)0xff007550
//Bit 23:16 luma gain2
//Bit 15:8  luma gain1
//Bit 7:0   luma gain0
#define P_VPP_HSHARP_LUMA_GAIN                     (volatile uint32_t *)0xff007554
//
//Bit 23:16 chroma gain2
//Bit 15:8  chroma gain1
//Bit 7:0   chroma gain0
#define P_VPP_HSHARP_CHROMA_GAIN                   (volatile uint32_t *)0xff007558
//Read only
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define P_VPP_MATRIX_PROBE_COLOR                   (volatile uint32_t *)0xff007570
#define P_VPP_MATRIX_PROBE_COLOR1                  (volatile uint32_t *)0xff00775c
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define P_VPP_MATRIX_HL_COLOR                      (volatile uint32_t *)0xff007574
//28:16 probe x, postion
//12:0  probe y, position
#define P_VPP_MATRIX_PROBE_POS                     (volatile uint32_t *)0xff007578
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    vd2 conversion matrix enable
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define P_VPP_MATRIX_CTRL                          (volatile uint32_t *)0xff00757c
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VPP_MATRIX_COEF00_01                     (volatile uint32_t *)0xff007580
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VPP_MATRIX_COEF02_10                     (volatile uint32_t *)0xff007584
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VPP_MATRIX_COEF11_12                     (volatile uint32_t *)0xff007588
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VPP_MATRIX_COEF20_21                     (volatile uint32_t *)0xff00758c
#define P_VPP_MATRIX_COEF22                        (volatile uint32_t *)0xff007590
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VPP_MATRIX_OFFSET0_1                     (volatile uint32_t *)0xff007594
//Bit 10:0  offset2
#define P_VPP_MATRIX_OFFSET2                       (volatile uint32_t *)0xff007598
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VPP_MATRIX_PRE_OFFSET0_1                 (volatile uint32_t *)0xff00759c
//Bit 10:0  pre_offset2
#define P_VPP_MATRIX_PRE_OFFSET2                   (volatile uint32_t *)0xff0075a0
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define P_VPP_DUMMY_DATA1                          (volatile uint32_t *)0xff0075a4
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define P_VPP_GAINOFF_CTRL0                        (volatile uint32_t *)0xff0075a8
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define P_VPP_GAINOFF_CTRL1                        (volatile uint32_t *)0xff0075ac
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define P_VPP_GAINOFF_CTRL2                        (volatile uint32_t *)0xff0075b0
//Bit 26:16, pre_offset0, signed data
//Bit 10:0, pre_offset1, signed data
#define P_VPP_GAINOFF_CTRL3                        (volatile uint32_t *)0xff0075b4
//Bit 10:0, pre_offset2, signed data
#define P_VPP_GAINOFF_CTRL4                        (volatile uint32_t *)0xff0075b8
#define P_VPP_GAINOFF_GCLK_CTRL                    (volatile uint32_t *)0xff0075bc
//only two registers used in the color management, which are defined in the chroma_reg.h
//`define VPP_CHROMA_ADDR_PORT    8'h70
//`define VPP_CHROMA_DATA_PORT    8'h71
//
// Reading file:  chroma_reg.h
//
//**********************************************************************************
//* Copyright (c) 2008, AMLOGIC Inc.
//* All rights reserved
//**********************************************************************************
//* File :  chroma_reg.v
//* Author : Terrence Wang
//* Date : Dec 2008
//* Description :
//*
//**********************************************************************************
//* Modification History:
//* Date    Modified By         Reason
//**********************************************************************************
// synopsys translate_off
// synopsys translate_on
#define P_VPP_CHROMA_ADDR_PORT                     (volatile uint32_t *)0xff0075c0
#define P_VPP_CHROMA_DATA_PORT                     (volatile uint32_t *)0xff0075c4
//`define CHROMA_ADDR_PORT        8'h67
//`define CHROMA_DATA_PORT        8'h68

//  CHROMA_GAIN_REG_XX(00-07)
//  hue gain, sat gain function control
//  Bit 31      reg_sat_en                  enable sat adjustment in current region
//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
//                                          1'b1: increase  1'b0: decrease
//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
//                                          2'b01 central biggest   2'b00 one side biggest
//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
//                                          1'b1: left side biggest 1'b0 right side biggest
//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
//                                          0x00-0xff
//  Bit 15      reg_hue_en                  enable hue adjustment in current region
//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
//                                          1'b1: clockwise 1'b0: anti-clockwise
//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
//                                          1'b1: parabola curve    1'b0: non-symmetry curve
//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
//                                          1'b1: right side change more    1'b0: left side change more
//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
//                                          0x00-0x80, note: should be no bigger than 0x80

    #define CHROMA_GAIN_REG00       0x00


//  HUE_HUE_RANGE_REG_XX(00-07)
//  hue range select
//  Bit 31:24   no use now
//  Bit 23:16   reg_hue_shift_range         define the angle of target region
//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
//                                          must be greater or equal than 8'd8
//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
//                                          the symmetry region hue_shift_range = reg_hue_shift_range
//                                          in symmetry region, all the sat and hue setting will be same with original region,
//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
//                                          0x6000 means 360 degree
//                                          only region 0 and 1 can exceed 360 degrees.

    #define HUE_HUE_RANGE_REG00     0x01


//  HUE_RANGE_INV_REG_XX
//  Calculation should be follow
//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
//  HUE_RANGE_INV_REG_XX is to used to save divider

    #define HUE_RANGE_INV_REG00     0x02



//  for belowing each low, high, low_slope, high_slope group:
//            a_____________b
//            /             \               a = low  + 2^low_slope
//           /               \              b = high - 2^high_slope
//          /                 \             low_slope <= 7; high_slope <= 7
//         /                   \            b >= a
//  ______/_____________________\________
//       low                    high
//
//
//  HUE_LUM_RANGE_REG_XX(00-07)
//  luma range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
//                                          0x00-0xff

    #define HUE_LUM_RANGE_REG00     0x03

//  HUE_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
//                                          0x00-0xff

    #define HUE_SAT_RANGE_REG00     0x04

//  SAT_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
//                                          0x00-0xff

    #define SAT_SAT_RANGE_REG00     0x05


    #define CHROMA_GAIN_REG01       0x06
    #define HUE_HUE_RANGE_REG01     0x07
    #define HUE_RANGE_INV_REG01     0x08
    #define HUE_LUM_RANGE_REG01     0x09
    #define HUE_SAT_RANGE_REG01     0x0a
    #define SAT_SAT_RANGE_REG01     0x0b

    #define CHROMA_GAIN_REG02       0x0c
    #define HUE_HUE_RANGE_REG02     0x0d
    #define HUE_RANGE_INV_REG02     0x0e
    #define HUE_LUM_RANGE_REG02     0x0f
    #define HUE_SAT_RANGE_REG02     0x10
    #define SAT_SAT_RANGE_REG02     0x11


    #define CHROMA_GAIN_REG03       0x12
    #define HUE_HUE_RANGE_REG03     0x13
    #define HUE_RANGE_INV_REG03     0x14
    #define HUE_LUM_RANGE_REG03     0x15
    #define HUE_SAT_RANGE_REG03     0x16
    #define SAT_SAT_RANGE_REG03     0x17

    #define CHROMA_GAIN_REG04       0x18
    #define HUE_HUE_RANGE_REG04     0x19
    #define HUE_RANGE_INV_REG04     0x1a
    #define HUE_LUM_RANGE_REG04     0x1b
    #define HUE_SAT_RANGE_REG04     0x1c
    #define SAT_SAT_RANGE_REG04     0x1d

    #define CHROMA_GAIN_REG05       0x1e
    #define HUE_HUE_RANGE_REG05     0x1f
    #define HUE_RANGE_INV_REG05     0x20
    #define HUE_LUM_RANGE_REG05     0x21
    #define HUE_SAT_RANGE_REG05     0x22
    #define SAT_SAT_RANGE_REG05     0x23

    #define CHROMA_GAIN_REG06       0x24
    #define HUE_HUE_RANGE_REG06     0x25
    #define HUE_RANGE_INV_REG06     0x26
    #define HUE_LUM_RANGE_REG06     0x27
    #define HUE_SAT_RANGE_REG06     0x28
    #define SAT_SAT_RANGE_REG06     0x29

    #define CHROMA_GAIN_REG07       0x2a
    #define HUE_HUE_RANGE_REG07     0x2b
    #define HUE_RANGE_INV_REG07     0x2c
    #define HUE_LUM_RANGE_REG07     0x2d
    #define HUE_SAT_RANGE_REG07     0x2e
    #define SAT_SAT_RANGE_REG07     0x2f

//  REG_CHROMA_CONTROL
//  Bit 31      reg_chroma_en               enable color manage function
//                                          1'b1: enable    1'b0: bypass
//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
//  Bit 5       uv_adj_en                   final uv_adjust enable
//                                          1'b1: enable    1'b0: bypass
//  Bit 2       hue_en                      rgb to hue enable
//                                          1'b1: enable(default)   1'b0: bypass
//  Bit 1:0     csc_sel                     define input YUV with different color type
//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0


////===========================================////
//// CM2 ADDR
////===========================================////

    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0
//Bit 31:24, sat_byyb_node3    the 4th node
//Bit 23:16, sat_byyb_node2    the 3th node
//Bit 15: 8, sat_byyb_node1    signed, the 2th node about saturation
//Bit  7: 0, sat_byyb_node0    signed, the 1th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"

	#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
//Bit 31:24, sat_byyb_node7     the 8th node
//Bit 23:16, sat_byyb_node6     the 7th node
//Bit 15: 8, sat_byyb_node5     signed, the 6th node about saturation
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"

    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
//Bit 31: 8, reserved
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation


    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, sat_src_node1
//Bit 15:12, reserved
//Bit 11: 0, sat_src_node0     usigned, threshold of input saturation for  first and second piece

    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
//Bit 31: 9, reserved
//Bit  8: 6, hue_lsft_mode        hue offset adjustments scale
//Bit  5: 4, luma_lsft_mode       luma offset adjustments scale for reg_cm2_adj_luma_via_hue
//Bit  3: 2, sat_byy_rsft_mode    saturation gain adjustments scale for reg_cm2_adj_sat_via_y
//Bit  1: 0, sat_byhs_rsft_mode   saturation gain adjustments scale for reg_cm2_adj_sat_via_hs[:][:] 0:no scale up/down 1:dnscale by 2(-128,127)/2

    #define FRM_SIZE_REG                0x205   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, reg_frm_height       the frame height size
//Bit 15:13, reserved
//Bit 12: 0, reg_frm_width        the frame width size

    #define FITLER_CFG_REG              0x206   // default 32'h0
//Bit 31: 5, reserved
//Bit  4: 4, inteleav_mod         horizontal interleave filter(zero-padding) for 3D considerations 0:using non-zero padding lpf 1:using zero-padding lpf
//Bit  3: 2, lpf_slt_uv           apply cm on lp portion or original video pixels options
//Bit  1: 0, lpf_slt_y            apply cm on lp portion or original video pixels options

    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, cm2_global_sat     global saturation gain for general color adjustments(0~4095 <=> 0~8),512 normalized to "1"
//Bit 15:12, reserved
//Bit 11: 0, cm2_global_hue     global hue offsets for general color adjustments(0~4095 <=> 0~360 degree)

    #define CM_ENH_CTL_REG              0x208   // default 32'h0
//Bit  31:7, reserved
//Bit     6, hue_adj_en        cm2 hue adjustments
//Bit     5, sat_adj_en        cm2 saturation adjustments
//Bit     4, luma_adj_en       enable signal for cm2 luma adjustments
//Bit     3, reserved
//Bit     2, cm2_filt_en       apply cm on lp portion enable
//Bit     1, cm2_en            cm2 enable signal
//Bit     0, cm1_en

    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, roi_x_end      ending col index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, roi_x_beg      start col index of the region of interest

   #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, roi_y_end      ending row index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, roi_y_beg      start row index of the region of interest

    #define POI_XY_DIR_REG              0x20b   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, poi_y_dir      ending row index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, poi_x_dir      start row index of the region of interest

    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
//Bit 31:16, reserved
//Bit 15: 8, coi_y_end
//Bit  7: 0, coi_y_beg

    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, coi_h_end
//Bit 15:12, reserved
//Bit 11: 0, coi_h_beg        lower bound of hue value for color of interest ,12 bits precision

    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, coi_s_end
//Bit 15:12, reserved
//Bit 11: 0, coi_s_beg        lower bound of sat value for color of interest ,12 bits precision
    #define IFO_MODE_REG                0x20f   // default 32'h0
//Bit 31:8, reserved
//Bit  7:6, ifo_mode3
//Bit  5:4, ifo_mode2
//Bit  3:2, ifo_mode1
//Bit  1:0, ifo_mode0
    #define POI_RPL_MODE_REG            0x210   // default 32'h0
//Bit 31:4, reserved
//Bit  3:0, poi_rpl_mode          enhance mode control of pixels inside and outside region of interest bit[3:2]control roi
    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
//Bit 31: 0, demo_owr_yhs

    #define DEMO_POI_Y_REG              0x212   // default 32'h0
//Bit 31: 8, reserved
//Bit  7: 0, luma_data_poi_r       only get locked higher 8bits
    #define DEMO_POI_H_REG              0x213   // default 32'h0
//Bit 31: 12, reserved
//Bit 11: 0, hue_data_poi_r        only get locked higher 12bits
    #define DEMO_POI_S_REG              0x214   // default 32'h0
//Bit 31: 12, reserved
//Bit 11: 0, sat_data_poi_r         only get locked higher 12bits
    //`define LUMA_BYH_LIMT_REG           10'h215   // default 32'h0
    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
//Bit 31:24, reserved
//Bit 23:16, luma_lmt_satslp         slope to do the luma adjustment degrade
//Bit 15:12, reserved
//Bit 11:0, luma_lmt_satth           threshold to saturation
    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
//Bit 31:24, reserved
//Bit 23:16, sat_lmt_satslp        slope to do the adjustment degrade
//Bit 15:12, reserved
//Bit 11:0, sat_lmt_satth          threshold to saturation
    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
//Bit 31: 24, reserved
//Bit 23: 16, hue_lmt_satslp        slope to do the adjustment degrade
//Bit 15: 12, reserved
//Bit 11: 0,  hue_lmt_satth          threshold to saturation
    #define UVHS_OFST_REG               0x218   // default 32'h0
//Bit 31: 24, hs2uv_v_ofst
//Bit 23: 16, hs2uv_u_ofst
//Bit 15: 8,  uv2hs_v_ofst
//Bit  7: 0,  uv2hs_u_ofst
    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
//Bit 31: 17, reserved
//Bit     16, hue_protect_en
//Bit 15: 13, cm2_hue_byhs_mode
//Bit     12, cm2_hue_div_mode
//Bit 11: 0, cm2_before_hue_ofst
    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
//Bit 31: 22, reserved
//Bit 21: 20, demo_split_mode
//Bit 19: 16, demo_split_width        slope to do the adjustment degrade
//Bit 15: 13, reserved
//Bit 12: 0,  demo_split_post           threshold to saturation
    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0
//Bit 31: 0,  demo_splt_yhs             threshold to saturation

    #define XVYCC_YSCP_REG              0x21c   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_y_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_y_min
    #define XVYCC_USCP_REG              0x21d   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_u_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_u_min
    #define XVYCC_VSCP_REG              0x21e   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_v_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_v_min
    #define LUMA_ADJ0_REG               0x21f   // default 32'h0
//Bit 21: 12, reg_cm_luma_blacklevel
//Bit 11: 0,  reg_cm_luma_contrast
    #define LUMA_ADJ1_REG               0x220   // default 32'h0

    #define STA_WIN_XYXY0_REG           0x221   // default 32'h0
    #define STA_WIN_XYXY1_REG           0x222   // default 32'h0
    #define STA_CFG_REG                 0x223   // default 32'h0
    #define STA_SAT_HIST0_REG           0x224   // default 32'h0
    #define STA_SAT_HIST1_REG           0x225   // default 32'h0
    #define RO_CM_HUE_HIST_BIN0         0x226   // default 32'h0
    #define RO_CM_HUE_HIST_BIN1         0x227   // default 32'h0
    #define RO_CM_HUE_HIST_BIN2         0x228   // default 32'h0
    #define RO_CM_HUE_HIST_BIN3         0x229   // default 32'h0
    #define RO_CM_HUE_HIST_BIN4         0x22a   // default 32'h0
    #define RO_CM_HUE_HIST_BIN5         0x22b   // default 32'h0
    #define RO_CM_HUE_HIST_BIN6         0x22c   // default 32'h0
    #define RO_CM_HUE_HIST_BIN7         0x22d   // default 32'h0
    #define RO_CM_HUE_HIST_BIN8         0x22e   // default 32'h0
    #define RO_CM_HUE_HIST_BIN9         0x22f   // default 32'h0
    #define RO_CM_HUE_HIST_BIN10        0x230   // default 32'h0
    #define RO_CM_HUE_HIST_BIN11        0x231   // default 32'h0
    #define RO_CM_HUE_HIST_BIN12        0x232   // default 32'h0
    #define RO_CM_HUE_HIST_BIN13        0x233   // default 32'h0
    #define RO_CM_HUE_HIST_BIN14        0x234   // default 32'h0
    #define RO_CM_HUE_HIST_BIN15        0x235   // default 32'h0
    #define RO_CM_HUE_HIST_BIN16        0x236   // default 32'h0
    #define RO_CM_HUE_HIST_BIN17        0x237   // default 32'h0
    #define RO_CM_HUE_HIST_BIN18        0x238   // default 32'h0
    #define RO_CM_HUE_HIST_BIN19        0x239   // default 32'h0
    #define RO_CM_HUE_HIST_BIN20        0x23a   // default 32'h0
    #define RO_CM_HUE_HIST_BIN21        0x23b   // default 32'h0
    #define RO_CM_HUE_HIST_BIN22        0x23c   // default 32'h0
    #define RO_CM_HUE_HIST_BIN23        0x23d   // default 32'h0
    #define RO_CM_HUE_HIST_BIN24        0x23e   // default 32'h0
    #define RO_CM_HUE_HIST_BIN25        0x23f   // default 32'h0
    #define RO_CM_HUE_HIST_BIN26        0x240   // default 32'h0
    #define RO_CM_HUE_HIST_BIN27        0x241   // default 32'h0
    #define RO_CM_HUE_HIST_BIN28        0x242   // default 32'h0
    #define RO_CM_HUE_HIST_BIN29        0x243   // default 32'h0
    #define RO_CM_HUE_HIST_BIN30        0x244   // default 32'h0
    #define RO_CM_HUE_HIST_BIN31        0x245   // default 32'h0
    #define RO_CM_SAT_HIST_BIN0         0x246   // default 32'h0
    #define RO_CM_SAT_HIST_BIN1         0x247   // default 32'h0
    #define RO_CM_SAT_HIST_BIN2         0x248   // default 32'h0
    #define RO_CM_SAT_HIST_BIN3         0x249   // default 32'h0
    #define RO_CM_SAT_HIST_BIN4         0x24a   // default 32'h0
    #define RO_CM_SAT_HIST_BIN5         0x24b   // default 32'h0
    #define RO_CM_SAT_HIST_BIN6         0x24c   // default 32'h0
    #define RO_CM_SAT_HIST_BIN7         0x24d   // default 32'h0
    #define RO_CM_SAT_HIST_BIN8         0x24e   // default 32'h0
    #define RO_CM_SAT_HIST_BIN9         0x24f   // default 32'h0
    #define RO_CM_SAT_HIST_BIN10        0x250   // default 32'h0
    #define RO_CM_SAT_HIST_BIN11        0x251   // default 32'h0
    #define RO_CM_SAT_HIST_BIN12        0x252   // default 32'h0
    #define RO_CM_SAT_HIST_BIN13        0x253   // default 32'h0
    #define RO_CM_SAT_HIST_BIN14        0x254   // default 32'h0
    #define RO_CM_SAT_HIST_BIN15        0x255   // default 32'h0
    #define RO_CM_SAT_HIST_BIN16        0x256   // default 32'h0
    #define RO_CM_SAT_HIST_BIN17        0x257   // default 32'h0
    #define RO_CM_SAT_HIST_BIN18        0x258   // default 32'h0
    #define RO_CM_SAT_HIST_BIN19        0x259   // default 32'h0
    #define RO_CM_SAT_HIST_BIN20        0x25a   // default 32'h0
    #define RO_CM_SAT_HIST_BIN21        0x25b   // default 32'h0
    #define RO_CM_SAT_HIST_BIN22        0x25c   // default 32'h0
    #define RO_CM_SAT_HIST_BIN23        0x25d   // default 32'h0
    #define RO_CM_SAT_HIST_BIN24        0x25e   // default 32'h0
    #define RO_CM_SAT_HIST_BIN25        0x25f   // default 32'h0
    #define RO_CM_SAT_HIST_BIN26        0x260   // default 32'h0
    #define RO_CM_SAT_HIST_BIN27        0x261   // default 32'h0
    #define RO_CM_SAT_HIST_BIN28        0x262   // default 32'h0
    #define RO_CM_SAT_HIST_BIN29        0x263   // default 32'h0
    #define RO_CM_SAT_HIST_BIN30        0x264   // default 32'h0
    #define RO_CM_SAT_HIST_BIN31        0x265   // default 32'h0
    #define RO_CM_BLK_BIN               0x266   // default 32'h0
    #define RO_CM_BRT_BIN               0x267   // default 32'h0

////========= NODE 0 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
//Bit 31: 24, reg_cm2_adj_sat_via_hs_2
//Bit 23: 16, reg_cm2_adj_sat_via_hs_1
//Bit 15: 8,  reg_cm2_adj_sat_via_hs_0
//Bit  7: 0, reg_cm2_adj_luma_via_h
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 1 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 2 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 3 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 4 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 5 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 6 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 7 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 8 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 9 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 10 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 11 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 12 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 13 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx


/* Constraints
0)
  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
  the 8 regions for hue adjustment are defined by: (example are for region 0)
    a) hue:
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_hue_sat_low_00
        end:   reg_hue_sat_high_00

  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
  the 8 regions for sat adjustment are defined by: (example are for region 0)
    a) hue: same as that for hue adjustment.
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_sat_sat_low_00
        end:   reg_sat_sat_high_00

1)
  reg_hue_hue_shift_range_00[7:0]:
  reg_hue_hue_shift_range_01[7:0]:
  reg_hue_hue_shift_range_02[7:0]:
  reg_hue_hue_shift_range_03[7:0]:
  reg_hue_hue_shift_range_04[7:0]:
  reg_hue_hue_shift_range_05[7:0]:
  reg_hue_hue_shift_range_06[7:0]:
  reg_hue_hue_shift_range_07[7:0]:
  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx

2)
  all regions of 0-7 should meet below requirement. below is just an example for region 7.
  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >=
        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)

  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)

  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)

  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)

3)
  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
  only region 0 and 1 can exceed 360 degrees. ie:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
  but below should be met:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1

  others could not exceed 360 degrees. ie:
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.

4)
  reg_hue_gain_00[7:0] <= 0x80.
  reg_hue_gain_01[7:0] <= 0x80.
  reg_hue_gain_02[7:0] <= 0x80.
  reg_hue_gain_03[7:0] <= 0x80.
  reg_hue_gain_04[7:0] <= 0x80.
  reg_hue_gain_05[7:0] <= 0x80.
  reg_hue_gain_06[7:0] <= 0x80.
  reg_hue_gain_07[7:0] <= 0x80.

5)
  below registers can only have two setting: 00 and 01.
    reg_hue_central_en_00[1:0]  .. _07[1:0]
    reg_sat_central_en_00[1:0]  .. _07[1:0]

6)
  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
   for example: below is for region 0:
   reg_hue_lum_low_slope_00[3:0]  <= 7
   reg_hue_lum_high_slope_00[3:0] <= 7
   reg_hue_sat_low_slope_00[3:0]  <= 7
   reg_hue_sat_high_slope_00[3:0] <= 7
   reg_sat_lum_low_slope_00[3:0]  <= 7
   reg_sat_lum_high_slope_00[3:0] <= 7
   reg_sat_sat_low_slope_00[3:0]  <= 7
   reg_sat_sat_high_slope_00[3:0] <= 7
*/

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  chroma_reg.h
//
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again
//because the register itself canot be set again without clk
//Bit 31:0
#define P_VPP_GCLK_CTRL0                           (volatile uint32_t *)0xff0075c8
//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 13:0
#define P_VPP_GCLK_CTRL1                           (volatile uint32_t *)0xff0075cc
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define P_VPP_SC_GCLK_CTRL                         (volatile uint32_t *)0xff0075d0
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define P_VPP_MISC1                                (volatile uint32_t *)0xff0075d8
//Bit 31:0 super scalar clock control
#define P_VPP_SRSCL_GCLK_CTRL                      (volatile uint32_t *)0xff0075dc
//Bit 31:0 OSD super scalar clock control
#define P_VPP_OSDSR_GCLK_CTRL                      (volatile uint32_t *)0xff0075e0
//Bit 31:0 vvycc clock control
#define P_VPP_XVYCC_GCLK_CTRL                      (volatile uint32_t *)0xff0075e4
//Bit 31:24     blackext_start
//Bit 23:16     blackext_slope1
//Bit 15:8      blackext_midpt
//Bit 7:0       blackext_slope2
#define P_VPP_BLACKEXT_CTRL                        (volatile uint32_t *)0xff007600
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define P_VPP_DNLP_CTRL_00                         (volatile uint32_t *)0xff007604
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define P_VPP_DNLP_CTRL_01                         (volatile uint32_t *)0xff007608
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define P_VPP_DNLP_CTRL_02                         (volatile uint32_t *)0xff00760c
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define P_VPP_DNLP_CTRL_03                         (volatile uint32_t *)0xff007610
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define P_VPP_DNLP_CTRL_04                         (volatile uint32_t *)0xff007614
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define P_VPP_DNLP_CTRL_05                         (volatile uint32_t *)0xff007618
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define P_VPP_DNLP_CTRL_06                         (volatile uint32_t *)0xff00761c
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define P_VPP_DNLP_CTRL_07                         (volatile uint32_t *)0xff007620
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define P_VPP_DNLP_CTRL_08                         (volatile uint32_t *)0xff007624
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define P_VPP_DNLP_CTRL_09                         (volatile uint32_t *)0xff007628
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define P_VPP_DNLP_CTRL_10                         (volatile uint32_t *)0xff00762c
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define P_VPP_DNLP_CTRL_11                         (volatile uint32_t *)0xff007630
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define P_VPP_DNLP_CTRL_12                         (volatile uint32_t *)0xff007634
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define P_VPP_DNLP_CTRL_13                         (volatile uint32_t *)0xff007638
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define P_VPP_DNLP_CTRL_14                         (volatile uint32_t *)0xff00763c
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define P_VPP_DNLP_CTRL_15                         (volatile uint32_t *)0xff007640
// `define VPP_PEAKING_HGAIN       8'h91   //32'h0
// `define VPP_PEAKING_VGAIN       8'h92   //32'h0
// `define VPP_PEAKING_NLP_1       8'h93   //32'h0
// `define VPP_PEAKING_NLP_2       8'h94   //32'h0
// `define VPP_PEAKING_NLP_3       8'h95   //32'h0
// `define VPP_PEAKING_NLP_4       8'h96   //32'h0
// `define VPP_PEAKING_NLP_5       8'h97   //32'h0
// `define VPP_SHARP_LIMIT         8'h98   //32'h0
// `define VPP_VLTI_CTRL           8'h99   //32'h0
// `define VPP_HLTI_CTRL           8'h9a   //32'h0
// `define VPP_CTI_CTRL            8'h9b   //32'h0
#define P_VPP_SRSHARP0_CTRL                        (volatile uint32_t *)0xff007644
//Bit 31:29  reserved
//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
//Bit 15:6   reserved
//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
//Bit 3      srsharp_demo_en         srsharp demo enable
//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
//Bit 1,     srsharp_buf_en          srsharp buffer enable
//Bit 0,     srsharp_en              srsharp enable
#define P_VPP_SRSHARP1_CTRL                        (volatile uint32_t *)0xff007648
//Bit 31:29  reserved
//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
//Bit 15:6   reserved
//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
//Bit 3      srsharp_demo_en         srsharp demo enable
//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
//Bit 1,     srsharp_buf_en          srsharp buffer enable
//Bit 0,     srsharp_en              srsharp enable
#define P_VPP_DOLBY_CTRL                           (volatile uint32_t *)0xff00764c
//todo
#define P_VPP_DAT_CONV_PARA0                       (volatile uint32_t *)0xff007650
#define P_VPP_DAT_CONV_PARA1                       (volatile uint32_t *)0xff007654
//todo
#define P_VPP_SYNC_SEL0                            (volatile uint32_t *)0xff007658
//`define VPP_VADJ1_BLACK_VAL         8'h97   //32'h0
//`define VPP_VADJ2_BLACK_VAL         8'h98   //32'h0
//Bit 29        blue_stretch_cb_inc
//Bit 28        blue_stretch_cr_inc
//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
//Bit 23:16     blue_stretch_gain
//Bit 15:8      blue_stretch_gain_cb4cr
//Bit 7:0       blue_stretch_luma_high
#define P_VPP_BLUE_STRETCH_1                       (volatile uint32_t *)0xff007670
//Bit 31:27     blue_stretch_error_crp
//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
//Bit 15:11     blue_stretch_error_crn
//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
#define P_VPP_BLUE_STRETCH_2                       (volatile uint32_t *)0xff007674
//Bit 31:27     blue_stretch_error_cbp
//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
//Bit 15:11     blue_stretch_error_cbn
//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
#define P_VPP_BLUE_STRETCH_3                       (volatile uint32_t *)0xff007678
#define P_VPP_CCORING_CTRL                         (volatile uint32_t *)0xff007680
//Bit 31:26 reserved
//Bit 25:16 reg_bypass_ccoring_ythd    // unsigned , default = 0   bypass_ccoring_ythd
//Bit 15:8  ccoring_th                 // unsigned , default = 0   Chroma coring threshold
//Bit 7:0   reserved
//Bit 3:0   ccoring_slope              // unsigned , default = 0   Chroma coring slope
#define P_VPP_VE_ENABLE_CTRL                       (volatile uint32_t *)0xff007684
//Bit 31:21  reserved
//Bit 20     demo_ccoring_enable     // unsigned  , default = 0 demo chroma coring enable
//Bit 19     demo_blackext_enable    // unsigned  , default = 0 demo black extension enable
//Bit 18     demo_dnlp_enable        // unsigned  , default = 0 demo dynamic nonlinear luma processing enable
//Bit 17     demo_hsvsharp_enable    // unsigned  , default = 0 demo hsvsharp enable
//Bit 16     demo_bluestretch_enable // unsigned  , default = 0 demo bluestretch enable
//Bit 15:14  demo_disp_position      // unsigned  , default = 0 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 13:7   reserved
//Bit 6      sr4c0_path_sel          // unsigned  , default = 0
//Bit 5      srscl_path_sel          // unsigned  , default = 0
//Bit 4      ccoring_en              // unsigned  , default = 0  chroma coring enable
//Bit 3      blackext_en             // unsigned  , default = 0  black extension enable
//Bit 2      dnlp_en                 // unsigned  , default = 0  dynamic nonlinear luma processing enable
//Bit 1      hsvsharp_en             // unsigned  , default = 0  hsvsharp enable
//Bit 0      blue_stretch_en         // unsigned  , default = 0  bluestretch enable
#define P_VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH        (volatile uint32_t *)0xff007688
//Bit 31:13  reserved
//Bit 12:0   ve_demo_left_top_screen_width // unsigned  , default = 0 demo left or top screen width
#define P_VPP_VE_DEMO_CENTER_BAR                   (volatile uint32_t *)0xff00768c
 //Bit 31      ve_demo_center_bar // unsigned  , default = 0 center bar enable
 //Bit 27:24   ve_demo_center_bar // unsigned  , default = 0 center bar width    (*2)
 //Bit 23:16   ve_demo_center_bar // unsigned  , default = 0 center bar Cr       (*4)
 //Bit 15:8    ve_demo_center_bar // unsigned  , default = 0 center bar Cb       (*4)
 //Bit 7:0     ve_demo_center_bar // unsigned  , default = 0 center bar y        (*4)
#define P_VPP_VE_H_V_SIZE                          (volatile uint32_t *)0xff007690
//Bit 31:29  reserved
//Bit 28:16  ve_line_length  // unsigned  , default = 780  ve_line_length
//Bit 15:13  reserved
//Bit 12:0   ve_pic_height   // unsigned  , default = 438  ve_pic_height
#define P_VPP_OUT_H_V_SIZE                         (volatile uint32_t *)0xff007694
//Bit 31:29  reserved
//Bit 28:16  vppout_line_length  / unsigned  , default = 780   vppout_line_length
//Bit 15:13  reserved
//Bit 12:0   vppout_pic_height   // unsigned  , default = 438  vppout_pic_height
#define P_VPP_IN_H_V_SIZE                          (volatile uint32_t *)0xff007698
//Bit 31:29  reserved
//Bit 28:16  vppin_line_length  / unsigned  , default = 780   vppout_line_length
//Bit 15:13  reserved
//Bit 12:0   vppin_pic_height   // unsigned  , default = 438  vppout_pic_height
#define P_VPP_VDO_MEAS_CTRL                        (volatile uint32_t *)0xff0076a0
//Bit 31:11  reserved
//Bit 10:0   vdo_meas_ctrl    // unsigned  , default = 0  vdo_meas_ctrl
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define P_VPP_VDO_MEAS_VS_COUNT_HI                 (volatile uint32_t *)0xff0076a4
//Read only
//31:0, low bit portion of counter
#define P_VPP_VDO_MEAS_VS_COUNT_LO                 (volatile uint32_t *)0xff0076a8
//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.
//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving,
// 100: 2 line interleaving
#define P_VPP_INPUT_CTRL                           (volatile uint32_t *)0xff0076ac
//bit 25:24 cti_bpf_sel
//bit 20:16 cti_blend_factor_gama
//bit 12:8 cti_blend_factor_beta
//bit 4:0 cti_blend_factor_alpha
#define P_VPP_CTI_CTRL2                            (volatile uint32_t *)0xff0076b0
// `define VPP_PEAKING_SAT_THD1 8'had
// `define VPP_PEAKING_SAT_THD2 8'hae
// `define VPP_PEAKING_SAT_THD3 8'haf
// `define VPP_PEAKING_SAT_THD4 8'hb0
// `define VPP_PEAKING_SAT_THD5 8'hb1
// `define VPP_PEAKING_SAT_THD6 8'hb2
// `define VPP_PEAKING_SAT_THD7 8'hb3
// `define VPP_PEAKING_SAT_THD8 8'hb4
// `define VPP_PEAKING_SAT_THD9 8'hb5
// `define VPP_PEAKING_GAIN_ADD1 8'hb6
// `define VPP_PEAKING_GAIN_ADD2 8'hb7
#define P_VPP_WRBAK_CTRL_SEC                       (volatile uint32_t *)0xff0076b4
#define P_VD1_BLEND_SRC_CTRL_SEC                   (volatile uint32_t *)0xff0076b8
#define P_VD2_BLEND_SRC_CTRL_SEC                   (volatile uint32_t *)0xff0076bc
#define P_OSD1_BLEND_SRC_CTRL_SEC                  (volatile uint32_t *)0xff0076c0
#define P_OSD2_BLEND_SRC_CTRL_SEC                  (volatile uint32_t *)0xff0076c4
//crc check , new add
#define P_VPP_RO_CRCSUM                            (volatile uint32_t *)0xff0076c8
#define P_VPP_CRC_CHK                              (volatile uint32_t *)0xff0076cc
//bit 23:16 peaking_dnlp_gain, u5.3, DNLP effect
//bit 15:8  peaking_factor
//bit 5     peaking_dnlp_demo_en
//bit 4     peaking_dnlp_en
//bit 3:0   peaking_filter_sel
#define P_VPP_PEAKING_DNLP                         (volatile uint32_t *)0xff0076e0
//bit 24    sharp_demo_win_en
//bit 23:12 sharp_demo_win_vend
//bit 11:0  sharp_demo_win_vstart
#define P_VPP_SHARP_DEMO_WIN_CTRL1                 (volatile uint32_t *)0xff0076e4
//bit 23:12 sharp_demo_win_hend
//bit 11:0  sharp_demo_win_hstart
#define P_VPP_SHARP_DEMO_WIN_CTRL2                 (volatile uint32_t *)0xff0076e8
//Bit 31:24     front_hlti_neg_gain
//Bit 23:16     front_hlti_pos_gain
//Bit 15:8      front_hlti_threshold
//Bit 7:0       front_hlti_blend_factor
#define P_VPP_FRONT_HLTI_CTRL                      (volatile uint32_t *)0xff0076ec
//Bit 31        front_enable, enable the front LTI&CTI before scaler
//Bit 26:24     front_cti_step2
//Bit 23:21     front_cti_step
//Bit 20:16     front_cti_blend_factor
//Bit 15        front_cti_median_mode
//Bit 14:8      front_cti_threshold
//Bit 7:0       front_cti_gain
#define P_VPP_FRONT_CTI_CTRL                       (volatile uint32_t *)0xff0076f0
//bit 29:28 front_hlti_step
//bit 25:24 front_cti_bpf_sel
//bit 20:16 front_cti_blend_factor_gama
//bit 12:8  front_cti_blend_factor_beta
//bit 4:0   front_cti_blend_factor_alpha
#define P_VPP_FRONT_CTI_CTRL2                      (volatile uint32_t *)0xff0076f4
//Bit 7   reg_mul_alp_en
//Bit 5:4 reg_alp_map_mode
//Bit 2:1 reg_div_gclk_en
//Bit 0   reg_div_alpha_en
#define P_VPP_OSD_SC_DIV_ALPHA                     (volatile uint32_t *)0xff0076fc
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP_OSD_VSC_PHASE_STEP                   (volatile uint32_t *)0xff007700
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define P_VPP_OSD_VSC_INI_PHASE                    (volatile uint32_t *)0xff007704
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define P_VPP_OSD_VSC_CTRL0                        (volatile uint32_t *)0xff007708
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define P_VPP_OSD_HSC_PHASE_STEP                   (volatile uint32_t *)0xff00770c
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define P_VPP_OSD_HSC_INI_PHASE                    (volatile uint32_t *)0xff007710
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define P_VPP_OSD_HSC_CTRL0                        (volatile uint32_t *)0xff007714
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define P_VPP_OSD_HSC_INI_PAT_CTRL                 (volatile uint32_t *)0xff007718
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define P_VPP_OSD_SC_DUMMY_DATA                    (volatile uint32_t *)0xff00771c
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define P_VPP_OSD_SC_CTRL0                         (volatile uint32_t *)0xff007720
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define P_VPP_OSD_SCI_WH_M1                        (volatile uint32_t *)0xff007724
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define P_VPP_OSD_SCO_H_START_END                  (volatile uint32_t *)0xff007728
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define P_VPP_OSD_SCO_V_START_END                  (volatile uint32_t *)0xff00772c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define P_VPP_OSD_SCALE_COEF_IDX                   (volatile uint32_t *)0xff007730
//coefficients for vertical filter and horizontal filter
#define P_VPP_OSD_SCALE_COEF                       (volatile uint32_t *)0xff007734
//Bit 12:0 line number use to generate interrupt when line == this number
#define P_VPP_INT_LINE_NUM                         (volatile uint32_t *)0xff007738
#define P_VPP_XVYCC_MISC                           (volatile uint32_t *)0xff00773c
// new add lti/cti in 120924
//Bit  3: 0        //default== 0  reg_hlti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hlti_dn_flt_coe[1]
//Bit 11: 8        //default== 0  reg_hlti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hlti_dn_flt_coe[3]
//Bit 19:16        //default== 4  reg_hlti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hlti_dn_flt_nrm  u3: 3~7
#define P_VPP_HLTI_DN_FLT                          (volatile uint32_t *)0xff007740
//Bit  7: 0        //default== 8  reg_hlti_bst_gain  u8, norm 16 as "1"
//Bit 15: 8        //default== 20 reg_hlti_bst_core  u8, norm 32 as "1"
//Bit 23:16        //default== 32 reg_hlti_oob_gain  u8, norm 32 as "1"
//Bit 28:24        //default== 0  reg_hlti_oob_core  u5
#define P_VPP_HLTI_GAIN                            (volatile uint32_t *)0xff007744
//Bit  7: 0        //default== 2  reg_hlti_clp_ofst  u8,
//Bit     8        //default== 0  reg_hlti_clp_mode  u1,
//Bit 11: 9        //default== 1  reg_hlti_clp_wind  u3,
//Bit 14:12        //default== 1  reg_hlti_bst_fltr  u3,
//Bit    15        //default== 1  reg_hlti_enable    u1,
#define P_VPP_HLTI_PARA                            (volatile uint32_t *)0xff007748
//Bit  3: 0        //default== 0  reg_hcti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hcti_dn_flt_coe[1]
//Bit 11: 8        //default== 1  reg_hcti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hcti_dn_flt_coe[3]
//Bit 19:16        //default== 2  reg_hcti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hcti_dn_flt_nrm   u3: 3~7
#define P_VPP_HCTI_DN_FLT                          (volatile uint32_t *)0xff00774c
//Bit 7: 0        //default== 48 reg_hcti_bst_gain  u8, norm 16 as "1"
//Bit15: 8        //default== 17 reg_hcti_bst_core  u8, norm 32 as "1"
//Bit23:16        //default== 16 reg_hcti_oob_gain  u8, norm 32 as "1"
//Bit28:24        //default==  0 reg_hcti_oob_core  u5
#define P_VPP_HCTI_GAIN                            (volatile uint32_t *)0xff007750
//Bit  7: 0        //default==  0 reg_hcti_clp_ofst  u8,
//Bit     8        //default==  1 reg_hcti_clp_mode  u1,
//Bit 11: 9        //default==  3 reg_hcti_clp_wind  u3,
//Bit 14:12        //default==  6 reg_hcti_bst_fltr  u3,
//Bit    15        //default==  1 reg_hcti_enable    u1,
#define P_VPP_HCTI_PARA                            (volatile uint32_t *)0xff007754
//Bit  7: 0        //default== 48 reg_vcti_bst_gain  u8, normalize 16 as "1"
//Bit 15: 8        //default== 10 reg_vcti_bst_core  u8
//Bit 19:16        //default== 10 reg_vcti_clp_ofst  u4
//Bit    20        //default==  1 reg_vcti_clp_wind  u1, 0: wind 3, 1: wind5
#define P_VPP_VCTI_PARA                            (volatile uint32_t *)0xff007758
//`define VPP_MATRIX_PROBE_COLOR1 8'hd7  //defined before
//Bit 31          //default== 0, urgent fifo hold enable
//Bit 28:12       //default== 0, urgent fifo hold line threshold
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define P_VPP_OFIFO_URG_CTRL                       (volatile uint32_t *)0xff007760
#define P_VPP_CLIP_MISC0                           (volatile uint32_t *)0xff007764
//Bit 29:20       // default == 1023, final clip r channel top
//Bit 19:10       // default == 1023, final clip g channel top
//Bit  9: 0       // default == 1023, final clip b channel top
#define P_VPP_CLIP_MISC1                           (volatile uint32_t *)0xff007768
//Bit 29:20       // default ==    0, final clip r channel bottom
//Bit 19:10       // default ==    0, final clip g channel bottom
//Bit  9: 0       // default ==    0, final clip b channel bottom
#define P_VPP_MATRIX_COEF13_14                     (volatile uint32_t *)0xff00776c
//Bit 28:16       // default == 0, matrix coef13
//Bit 12:0        // default == 0, matrix coef14
#define P_VPP_MATRIX_COEF23_24                     (volatile uint32_t *)0xff007770
//Bit 28:16       // default == 0, matrix coef23
//Bit 12:0        // default == 0, matrix coef24
#define P_VPP_MATRIX_COEF15_25                     (volatile uint32_t *)0xff007774
//Bit 28:16       // default == 0, matrix coef15
//Bit 12:0        // default == 0, matrix coef25
#define P_VPP_MATRIX_CLIP                          (volatile uint32_t *)0xff007778
//Bit 7:5         //  default == 0,   mat rs
//Bit 4:3         //  default == 0,   mat clmod
//Bit 2:0         //  default == 0,   mat clip enable
#define P_VPP_XVYCC_MISC0                          (volatile uint32_t *)0xff00777c
//Bit 29:20       // default == 1023, xvycc clip r channel top
//Bit 19:10       // default == 1023, xvycc clip g channel top
//Bit  9: 0       // default == 1023, xvycc clip b channel top
#define P_VPP_XVYCC_MISC1                          (volatile uint32_t *)0xff007780
//Bit 29:20       // default ==    0, xvycc clip r channel bottom
//Bit 19:10       // default ==    0, xvycc clip g channel bottom
//Bit  9: 0       // default ==    0, xvycc clip b channel bottom
#define P_VPP_VD1_CLIP_MISC0                       (volatile uint32_t *)0xff007784
//Bit 29:20       // default == 1023, vd1 clip r channel top
//Bit 19:10       // default == 1023, vd1 clip g channel top
//Bit  9: 0       // default == 1023, vd1 clip b channel top
#define P_VPP_VD1_CLIP_MISC1                       (volatile uint32_t *)0xff007788
//Bit 29:20       // default ==    0, vd1 clip r channel bottom
//Bit 19:10       // default ==    0, vd1 clip g channel bottom
//Bit  9: 0       // default ==    0, vd1 clip b channel bottom
#define P_VPP_VD2_CLIP_MISC0                       (volatile uint32_t *)0xff00778c
//Bit 29:20       // default == 1023, vd2 clip r channel top
//Bit 19:10       // default == 1023, vd2 clip g channel top
//Bit  9: 0       // default == 1023, vd2 clip b channel top
#define P_VPP_VD2_CLIP_MISC1                       (volatile uint32_t *)0xff007790
//Bit 29:20       // default ==    0, vd2 clip r channel bottom
//Bit 19:10       // default ==    0, vd2 clip g channel bottom
//Bit  9: 0       // default ==    0, vd2 clip b channel bottom
#define P_VPP_VD2_HDR_IN_SIZE                      (volatile uint32_t *)0xff0077c0
//Bit 31:16       // default ==    0
//Bit 15:0        // default ==    0
#define P_VPP_OSD1_IN_SIZE                         (volatile uint32_t *)0xff0077c4
//Bit 31:16       // default ==    0
//Bit 15:0        // default ==    0
#define P_VPP_GCLK_CTRL2                           (volatile uint32_t *)0xff0077c8
//`define VPP_BLEND_SRC_SEL               8'hf3
#define P_VD2_PPS_DUMMY_DATA                       (volatile uint32_t *)0xff0077d0
#define P_VPP_OSD1_BLD_H_SCOPE                     (volatile uint32_t *)0xff0077d4
#define P_VPP_OSD1_BLD_V_SCOPE                     (volatile uint32_t *)0xff0077d8
#define P_VPP_OSD2_BLD_H_SCOPE                     (volatile uint32_t *)0xff0077dc
#define P_VPP_OSD2_BLD_V_SCOPE                     (volatile uint32_t *)0xff0077e0
#define P_VPP_WRBAK_CTRL                           (volatile uint32_t *)0xff0077e4
#define P_VPP_SLEEP_CTRL                           (volatile uint32_t *)0xff0077e8
#define P_VD1_BLEND_SRC_CTRL                       (volatile uint32_t *)0xff0077ec
#define P_VD2_BLEND_SRC_CTRL                       (volatile uint32_t *)0xff0077f0
#define P_OSD1_BLEND_SRC_CTRL                      (volatile uint32_t *)0xff0077f4
#define P_OSD2_BLEND_SRC_CTRL                      (volatile uint32_t *)0xff0077f8
#define P_VPP_OSD_SCALE_CTRL                       (volatile uint32_t *)0xff0077fc
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_regs.h
//
//`include "v2regs.h"
//
// Reading file:  viu2_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VIU2_VCBUS_BASE = 0x1e
// -----------------------------------------------
//------------------------------------------------------------------------------
// VIU2 top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, OSD1_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  7 RW, vpp_reset
#define P_VIU2_SW_RESET                            (volatile uint32_t *)0xff007804
#define P_VIU2_SW_RESET0                           (volatile uint32_t *)0xff007808
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
#define P_VIU2_SECURE_REG                          (volatile uint32_t *)0xff007814
//bit 8 if true, vsync interrup is generate only field == 0
//bit 7:0 fix_disable
#define P_VIU2_MISC_CTRL0                          (volatile uint32_t *)0xff007818
#define P_VIU2_DATA_SEC_IN                         (volatile uint32_t *)0xff00781c
//------------------------------------------------------------------------------
// VPP2 top-level registers
//------------------------------------------------------------------------------
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// bit 28   color management enable
// Bit 27,  reserved
// Bit 26:18, reserved
// Bit 17, OSD1 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, reserved
// Bit 14, vd1 enable for preblend
// Bit 13, OSD1 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, reserved
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultiplied
// Bit 8,  if true, OSD1 is alpha premultiplied
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, OSD1 foreground compared with osd1 in preblend
// Bit 4,  if true, OSD1 foreground compared with osd1 in postblend
// Bit 3,
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//           the aync fifo will be reseted.
// Bit 1,
// Bit 0    if true, the output result of VPP is saturated
#define P_VPP2_MISC                                (volatile uint32_t *)0xff007898
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define P_VPP2_OFIFO_SIZE                          (volatile uint32_t *)0xff00789c
//Read only
//Bit 28:17 current scale out fifo counter
//Bit 16:12 current afifo counter
//Bit 11:0 current ofifo counter
#define P_VPP2_FIFO_STATUS                         (volatile uint32_t *)0xff0078a0
//Bit 12:0 line number use to generate interrupt when line == this number
#define P_VPP2_INT_LINE_NUM                        (volatile uint32_t *)0xff007880
#define P_VPP2_OFIFO_URG_CTRL                      (volatile uint32_t *)0xff007884
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logic;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU2_OSD1_CTRL_STAT                      (volatile uint32_t *)0xff0078c0
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15: 6 Reserved
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define P_VIU2_OSD1_CTRL_STAT2                     (volatile uint32_t *)0xff007934
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU2_OSD1_COLOR_ADDR                     (volatile uint32_t *)0xff0078c4
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD1_COLOR                          (volatile uint32_t *)0xff0078c8
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define P_VIU2_OSD1_HL1_H_START_END                (volatile uint32_t *)0xff0078cc
#define P_VIU2_OSD1_HL1_V_START_END                (volatile uint32_t *)0xff0078d0
#define P_VIU2_OSD1_HL2_H_START_END                (volatile uint32_t *)0xff0078d4
#define P_VIU2_OSD1_HL2_V_START_END                (volatile uint32_t *)0xff0078d8
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU2_OSD1_TCOLOR_AG0                     (volatile uint32_t *)0xff0078dc
#define P_VIU2_OSD1_TCOLOR_AG1                     (volatile uint32_t *)0xff0078e0
#define P_VIU2_OSD1_TCOLOR_AG2                     (volatile uint32_t *)0xff0078e4
#define P_VIU2_OSD1_TCOLOR_AG3                     (volatile uint32_t *)0xff0078e8
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU2_OSD1_BLK0_CFG_W0                    (volatile uint32_t *)0xff0078ec
#define P_VIU2_OSD1_BLK1_CFG_W0                    (volatile uint32_t *)0xff0078fc
#define P_VIU2_OSD1_BLK2_CFG_W0                    (volatile uint32_t *)0xff00790c
#define P_VIU2_OSD1_BLK3_CFG_W0                    (volatile uint32_t *)0xff00791c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU2_OSD1_BLK0_CFG_W1                    (volatile uint32_t *)0xff0078f0
#define P_VIU2_OSD1_BLK1_CFG_W1                    (volatile uint32_t *)0xff007900
#define P_VIU2_OSD1_BLK2_CFG_W1                    (volatile uint32_t *)0xff007910
#define P_VIU2_OSD1_BLK3_CFG_W1                    (volatile uint32_t *)0xff007920
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU2_OSD1_BLK0_CFG_W2                    (volatile uint32_t *)0xff0078f4
#define P_VIU2_OSD1_BLK1_CFG_W2                    (volatile uint32_t *)0xff007904
#define P_VIU2_OSD1_BLK2_CFG_W2                    (volatile uint32_t *)0xff007914
#define P_VIU2_OSD1_BLK3_CFG_W2                    (volatile uint32_t *)0xff007924
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU2_OSD1_BLK0_CFG_W3                    (volatile uint32_t *)0xff0078f8
#define P_VIU2_OSD1_BLK1_CFG_W3                    (volatile uint32_t *)0xff007908
#define P_VIU2_OSD1_BLK2_CFG_W3                    (volatile uint32_t *)0xff007918
#define P_VIU2_OSD1_BLK3_CFG_W3                    (volatile uint32_t *)0xff007928
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU2_OSD1_BLK0_CFG_W4                    (volatile uint32_t *)0xff007990
#define P_VIU2_OSD1_BLK1_CFG_W4                    (volatile uint32_t *)0xff007994
#define P_VIU2_OSD1_BLK2_CFG_W4                    (volatile uint32_t *)0xff007998
#define P_VIU2_OSD1_BLK3_CFG_W4                    (volatile uint32_t *)0xff00799c
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
// Bit    19 R,  fifo_overflow
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU2_OSD1_FIFO_CTRL_STAT                 (volatile uint32_t *)0xff00792c
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU2_OSD1_TEST_RDDATA                    (volatile uint32_t *)0xff007930
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define P_VIU2_OSD1_PROT_CTRL                      (volatile uint32_t *)0xff007938
#define P_VIU2_OSD1_MALI_UNPACK_CTRL               (volatile uint32_t *)0xff00793c
#define P_VIU2_OSD1_DIMM_CTRL                      (volatile uint32_t *)0xff007940
//`define VIU2_MATRIX_CTRL                       8'h70
#define P_VIU2_OSD1_MATRIX_COEF00_01               (volatile uint32_t *)0xff0079c0
#define P_VIU2_OSD1_MATRIX_COEF02_10               (volatile uint32_t *)0xff0079c4
#define P_VIU2_OSD1_MATRIX_COEF11_12               (volatile uint32_t *)0xff0079c8
#define P_VIU2_OSD1_MATRIX_COEF20_21               (volatile uint32_t *)0xff0079cc
#define P_VIU2_OSD1_MATRIX_COEF22                  (volatile uint32_t *)0xff0079d0
#define P_VIU2_OSD1_MATRIX_COEF13_14               (volatile uint32_t *)0xff0079d4
#define P_VIU2_OSD1_MATRIX_COEF23_24               (volatile uint32_t *)0xff0079d8
#define P_VIU2_OSD1_MATRIX_COEF15_25               (volatile uint32_t *)0xff0079dc
#define P_VIU2_OSD1_MATRIX_CLIP                    (volatile uint32_t *)0xff0079e0
#define P_VIU2_OSD1_MATRIX_OFFSET0_1               (volatile uint32_t *)0xff0079e4
#define P_VIU2_OSD1_MATRIX_OFFSET2                 (volatile uint32_t *)0xff0079e8
#define P_VIU2_OSD1_MATRIX_PRE_OFFSET0_1           (volatile uint32_t *)0xff0079ec
#define P_VIU2_OSD1_MATRIX_PRE_OFFSET2             (volatile uint32_t *)0xff0079f0
#define P_VIU2_OSD1_MATRIX_EN_CTRL                 (volatile uint32_t *)0xff0079f4
#define P_VIU2_RMIF_CTRL0                          (volatile uint32_t *)0xff007a00
#define P_VIU2_RMIF_CTRL1                          (volatile uint32_t *)0xff007a04
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_big_endian    // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define P_VIU2_RMIF_CTRL2                          (volatile uint32_t *)0xff007a08
//Bit 31    reg_sw_rst        // unsigned , default = 0,
//Bit 30:17 reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define P_VIU2_RMIF_SCOPE_X                        (volatile uint32_t *)0xff007a0c
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 0, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define P_VIU2_RMIF_SCOPE_Y                        (volatile uint32_t *)0xff007a10
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define P_VIU2_ROT_BLK_SIZE                        (volatile uint32_t *)0xff007a14
#define P_VIU2_ROT_LBUF_SIZE                       (volatile uint32_t *)0xff007a18
#define P_VIU2_ROT_FMT_CTRL                        (volatile uint32_t *)0xff007a1c
#define P_VIU2_ROT_WIND_CTRL                       (volatile uint32_t *)0xff007a20
#define P_VIU2_ROT_OUT_VCROP                       (volatile uint32_t *)0xff007a24
#define P_VIU2_ROT_BUF_SIZE                        (volatile uint32_t *)0xff007a28
#define P_VIU2_ROT_RO_MIF0_STAT                    (volatile uint32_t *)0xff007a2c
//Bit 15:0  reg_status        // unsigned ,
#define P_VIU2_ROT_RO_MIF1_STAT                    (volatile uint32_t *)0xff007a30
#define P_VIU2_ROT_RO_STAT                         (volatile uint32_t *)0xff007a34
#define P_VIU2_GAINOFF_GCLK_CTRL                   (volatile uint32_t *)0xff007a80
#define P_VIU2_GAINOFF_CTRL0                       (volatile uint32_t *)0xff007a84
#define P_VIU2_GAINOFF_CTRL1                       (volatile uint32_t *)0xff007a88
#define P_VIU2_GAINOFF_CTRL2                       (volatile uint32_t *)0xff007a8c
#define P_VIU2_GAINOFF_CTRL3                       (volatile uint32_t *)0xff007a90
#define P_VIU2_GAINOFF_CTRL4                       (volatile uint32_t *)0xff007a94
#define P_VPP2_CRC_CHK                             (volatile uint32_t *)0xff007ac0
#define P_VPP2_RO_CRCSUM                           (volatile uint32_t *)0xff007ac4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  viu2_regs.h
//
//
// Reading file:  vregs_clk1.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VIUB_VCBUS_BASE = 0x20
// -----------------------------------------------
#define P_VIUB_ADDR_START                          (volatile uint32_t *)0xff008000
#define P_VIUB_ADDR_END                            (volatile uint32_t *)0xff0083fc
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define P_VIUB_SW_RESET                            (volatile uint32_t *)0xff008004
#define P_VIUB_SW_RESET0                           (volatile uint32_t *)0xff008008
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
#define P_DI_AFBCE_CTRL                            (volatile uint32_t *)0xff00800c
#define P_VIUB_SECURE_ST_RO                        (volatile uint32_t *)0xff008010
//bit 8 if true, vsync interrup is generate only field == 0
//bit 7:0 fix_disable
#define P_VIUB_MISC_CTRL0                          (volatile uint32_t *)0xff008018
#define P_VIUB_GCLK_CTRL0                          (volatile uint32_t *)0xff00801c
//// gclk_ctrl0_gl[ 0] : def=1 di_top_wrap clk enable
////
//// gclk_ctrl0_gl[ 8] : def=0 mad pre clock enable, from mad clock
//// gclk_ctrl0_gl[ 9] : def=0 mad post clock enable, from mad clock
//// gclk_ctrl0_gl[10] : def=0 div clock enable, di slow clock including di&mcdi
//// gclk_ctrl0_gl[11] : def=0 mcdi clock enable, from div clock
//// gclk_ctrl0_gl[12] : def=0 di post clock enable, from div clock
//// gclk_ctrl0_gl[13] : def=0 reserved
//// gclk_ctrl0_gl[14] : def=1 di_no_clk_gate, for old di
//// gclk_ctrl0_gl[15] : def=0 di_gate_all, for old di
#define P_VIUB_GCLK_CTRL1                          (volatile uint32_t *)0xff008020
//// gclk_ctrl1_gl[ 1: 0] : def=2'b00 mif-sub-arb clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 3: 2] : def=2'b00 if1 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 5: 4] : def=2'b00 if2 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 7: 6] : def=2'b00 de wrmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 9: 8] : def=2'b00 mtnrd post mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[11:10] : def=2'b00 mcdi post mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[17:16] : def=2'b00 inp rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[19:18] : def=2'b00 mem rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[21:20] : def=2'b00 chan rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[23:22] : def=2'b00 nr wrmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[25:24] : def=2'b00 mtn mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[27:26] : def=2'b00 mcdi pre mif clock gate ctrl [1]: clock valid, [0]: clock close
////
#define P_VIUB_GCLK_CTRL2                          (volatile uint32_t *)0xff008024
//// gclk_ctrl_pre[ 1: 0] : def=2'b00 nr clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 3: 2] : def=2'b00 pd clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 5: 4] : def=2'b00 mtn det clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 7: 6] : def=2'b00 debanding clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 9: 8] : def=2'b00 dnr clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[11:10] : def=2'b00 nr&dnr blend clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[13:12] : def=2'b00 mcdi clock gate ctrl [1]: clock valid, [0]: clock close
#define P_VIUB_GCLK_CTRL3                          (volatile uint32_t *)0xff008028
//// gclk_ctrl_post[ 1: 0] : def=2'b00 di blend clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_post[ 3: 2] : def=2'b00 ei clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_post[ 5: 4] : def=2'b00 ei_0 clock gate ctrl [1]: clock valid, [0]: clock close
#define P_DI_DBG_CTRL                              (volatile uint32_t *)0xff00802c
#define P_DI_DBG_CTRL1                             (volatile uint32_t *)0xff008030
#define P_DI_DBG_SRDY_INF                          (volatile uint32_t *)0xff008034
#define P_DI_DBG_RRDY_INF                          (volatile uint32_t *)0xff008038
#define P_VIUB_SECURE_REG                          (volatile uint32_t *)0xff00803c
#define P_DI_PRE_SEC_IN                            (volatile uint32_t *)0xff008040
#define P_DI_POST_SEC_IN                           (volatile uint32_t *)0xff008044
//`define DI_IF2_GEN_REG            8'h10
//`define DI_IF2_CANVAS0            8'h11
//`define DI_IF2_LUMA_X0            8'h12
//`define DI_IF2_LUMA_Y0            8'h13
//`define DI_IF2_CHROMA_X0          8'h14
//`define DI_IF2_CHROMA_Y0          8'h15
//`define DI_IF2_RPT_LOOP           8'h16
//`define DI_IF2_LUMA0_RPT_PAT      8'h17
//`define DI_IF2_CHROMA0_RPT_PAT    8'h18
//`define DI_IF2_DUMMY_PIXEL        8'h19
//`define DI_IF2_LUMA_FIFO_SIZE     8'h1a
//`define DI_IF2_RANGE_MAP_Y        8'h1b
//`define DI_IF2_RANGE_MAP_CB       8'h1c
//`define DI_IF2_RANGE_MAP_CR       8'h1d
//`define DI_IF2_GEN_REG2           8'h1e
//`define DI_IF2_FMT_CTRL           8'h1f
//`define DI_IF2_FMT_W              8'h20
//
//`define DI_IF2_URGENT_CTRL		  8'h21
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//`define DI_IF2_GEN_REG3           8'h22
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//==================================
#define P_DI_EI_DRT_CTRL                           (volatile uint32_t *)0xff0080a0
//Bit 31,     reg_rectg_en      ;u1
//Bit 30,     reg_recbld_en     ;u1
//Bit 29:28,  reg_rectg_ws      ;u2
//Bit 27,     reserved
//Bit 26:24,  reg_abq_margin    ;u3
//Bit 23,     reserved
//Bit 22:20,  reg_trend_mg      ;u3
//Bit 19:16,  reg_int_d16xc1    ;u4
//Bit 15:14,  reserved
//Bit 13: 8,  reg_int_chlmt1    ;u6
//Bit  7,     reserved
//Bit  6: 4,  reg_nscheck_thrd  ;u3
//Bit  3,     reserved
//Bit  2: 0,  reg_horsl_ws      ;u3
#define P_DI_EI_DRT_PIXTH                          (volatile uint32_t *)0xff0080a4
//Bit 31:24,  reg_min_pix        ;u8
//Bit 23:16,  reg_max_pix        ;u8
//Bit 15: 8,  reg_dmaxmin_thrdma ;u8
//Bit  7: 0,  reg_dmaxmin_thrdmi ;u8
#define P_DI_EI_DRT_CORRPIXTH                      (volatile uint32_t *)0xff0080a8
//Bit 31:24,  reg_newcorrpix_maxthrd ;u8
//Bit 23:16,  reg_corrpix_diffthrd   ;u8
//Bit 15: 8,  reg_corrpix_minthrd    ;u8
//Bit  7: 0,  reg_corrpix_maxthrd    ;u8
#define P_DI_EI_DRT_RECTG_WAVE                     (volatile uint32_t *)0xff0080ac
//Bit 31:29,  reserved
//Bit 28:24,  reg_max_pixwave  ;u5
//Bit 23:21,  reserved
//Bit 20:16,  reg_pix_wave     ;u5
//Bit 15:14,  reserved
//Bit 13: 8,  reg_maxdrt_thrd  ;u6
//Bit  7: 0,  reg_wave_thrd    ;u8
#define P_DI_EI_DRT_PIX_DIFFTH                     (volatile uint32_t *)0xff0080b0
//Bit 31:24,  reg_newraw_thrd    ;u8
//Bit 23:16,  reg_tb_max_thrd    ;u8
//Bit 15: 8,  reg_diffpix_thrd   ;u8
//Bit  7: 6,  reserved
//Bit  5: 0,  reg_bilt_trendnumt ;u8
#define P_DI_EI_DRT_UNBITREND_TH                   (volatile uint32_t *)0xff0080b4
//Bit 31:29,  reserved
//Bit 28:24,  reg_trend_numb     ;u5
//Bit 23:21,  reserved
//Bit 20:16,  reg_bilt_trendnum  ;u5
//Bit 15:13,  reserved
//Bit 12: 8,  reg_unil_trendnumt ;u5
//Bit  7: 5,  reserved
//Bit  4: 0,  reg_trend_num      ;u5
//`define DI_IF0_GEN_REG            8'h30
//`define DI_IF0_CANVAS0            8'h31
//`define DI_IF0_LUMA_X0            8'h32
//`define DI_IF0_LUMA_Y0            8'h33
//`define DI_IF0_CHROMA_X0          8'h34
//`define DI_IF0_CHROMA_Y0          8'h35
//`define DI_IF0_RPT_LOOP           8'h36
//`define DI_IF0_LUMA0_RPT_PAT      8'h37
//`define DI_IF0_CHROMA0_RPT_PAT    8'h38
//`define DI_IF0_DUMMY_PIXEL        8'h39
//`define DI_IF0_LUMA_FIFO_SIZE     8'h3a
//`define DI_IF0_RANGE_MAP_Y        8'h3b
//`define DI_IF0_RANGE_MAP_CB       8'h3c
//`define DI_IF0_RANGE_MAP_CR       8'h3d
//`define DI_IF0_GEN_REG2           8'h3e
//`define DI_IF0_FMT_CTRL           8'h3f
//`define DI_IF0_FMT_W              8'h40
//
//`define DI_IF0_URGENT_CTRL		  8'h41
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//`define DI_IF0_GEN_REG3           8'h42
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
// di arbitration :
// the segment is 8'h50-8'h5f
//
// Reading file:  di_arb_axi_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define P_DI_RDARB_MODE_L1C1                       (volatile uint32_t *)0xff008140
//Bit   31:22,    reserved
//Bit   21:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define P_DI_RDARB_REQEN_SLV_L1C1                  (volatile uint32_t *)0xff008144
//Bit   31:12,     reserved
//Bit   11:0,     rdarb_dc_req_en     unsigned  , default = 12'hfff
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[6]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[10]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[11]: the slv5 req to mst port1 enable,
#define P_DI_RDARB_WEIGH0_SLV_L1C1                 (volatile uint32_t *)0xff008148
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_DI_RDARB_WEIGH1_SLV_L1C1                 (volatile uint32_t *)0xff00814c
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define P_DI_WRARB_MODE_L1C1                       (volatile uint32_t *)0xff008150
//Bit   31:22,    reserved
//Bit   21:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//                                    wrarb_sel[4]==0 slave dc4 connect master port0 wrarb_sel[4]==1 slave dc4 connect master port1
//                                    wrarb_sel[5]==0 slave dc5 connect master port0 wrarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define P_DI_WRARB_REQEN_SLV_L1C1                  (volatile uint32_t *)0xff008154
//Bit   31:12,     reserved
//Bit   11:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define P_DI_WRARB_WEIGH0_SLV_L1C1                 (volatile uint32_t *)0xff008158
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_DI_WRARB_WEIGH1_SLV_L1C1                 (volatile uint32_t *)0xff00815c
//Bit   31:6,    reserved
//Bit   5:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define P_DI_RDWR_ARB_STATUS_L1C1                  (volatile uint32_t *)0xff008160
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define P_DI_ARB_DBG_CTRL_L1C1                     (volatile uint32_t *)0xff008164
#define P_DI_ARB_DBG_STAT_L1C1                     (volatile uint32_t *)0xff008168
#define P_DI_RDARB_UGT_L1C1                        (volatile uint32_t *)0xff00816c
#define P_DI_RDARB_LIMT0_L1C1                      (volatile uint32_t *)0xff008170
#define P_DI_WRARB_UGT_L1C1                        (volatile uint32_t *)0xff008174
#define P_DI_ARB_AXIWR_PROT                        (volatile uint32_t *)0xff008178
#define P_DI_ARB_AXIRD0_PROT                       (volatile uint32_t *)0xff00817c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_arb_axi_regs.h
//
// di afbc_enc
// the segment is 8'h60-8'h8f
//
// Reading file:  di_afbc_enc0_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DI_AFBCE_ENABLE                          (volatile uint32_t *)0xff008180
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    di_afbce_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define P_DI_AFBCE_MODE                            (volatile uint32_t *)0xff008184
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define P_DI_AFBCE_SIZE_IN                         (volatile uint32_t *)0xff008188
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vertical size in  unit: pixel
#define P_DI_AFBCE_BLK_SIZE_IN                     (volatile uint32_t *)0xff00818c
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vertical size in  unit: pixel
#define P_DI_AFBCE_HEAD_BADDR                      (volatile uint32_t *)0xff008190
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define P_DI_AFBCE_MIF_SIZE                        (volatile uint32_t *)0xff008194
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define P_DI_AFBCE_PIXEL_IN_HOR_SCOPE              (volatile uint32_t *)0xff008198
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define P_DI_AFBCE_PIXEL_IN_VER_SCOPE              (volatile uint32_t *)0xff00819c
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define P_DI_AFBCE_CONV_CTRL                       (volatile uint32_t *)0xff0081a0
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define P_DI_AFBCE_MIF_HOR_SCOPE                   (volatile uint32_t *)0xff0081a4
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define P_DI_AFBCE_MIF_VER_SCOPE                   (volatile uint32_t *)0xff0081a8
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define P_DI_AFBCE_STAT1                           (volatile uint32_t *)0xff0081ac
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define P_DI_AFBCE_STAT2                           (volatile uint32_t *)0xff0081b0
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define P_DI_AFBCE_FORMAT                          (volatile uint32_t *)0xff0081b4
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define P_DI_AFBCE_MODE_EN                         (volatile uint32_t *)0xff0081b8
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define P_DI_AFBCE_DWSCALAR                        (volatile uint32_t *)0xff0081bc
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define P_DI_AFBCE_DEFCOLOR_1                      (volatile uint32_t *)0xff0081c0
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define P_DI_AFBCE_DEFCOLOR_2                      (volatile uint32_t *)0xff0081c4
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define P_DI_AFBCE_QUANT_ENABLE                    (volatile uint32_t *)0xff0081c8
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_DI_AFBCE_IQUANT_LUT_1                    (volatile uint32_t *)0xff0081cc
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE_IQUANT_LUT_2                    (volatile uint32_t *)0xff0081d0
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE_IQUANT_LUT_3                    (volatile uint32_t *)0xff0081d4
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE_IQUANT_LUT_4                    (volatile uint32_t *)0xff0081d8
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE_RQUANT_LUT_1                    (volatile uint32_t *)0xff0081dc
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define P_DI_AFBCE_RQUANT_LUT_2                    (volatile uint32_t *)0xff0081e0
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define P_DI_AFBCE_RQUANT_LUT_3                    (volatile uint32_t *)0xff0081e4
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define P_DI_AFBCE_RQUANT_LUT_4                    (volatile uint32_t *)0xff0081e8
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define P_DI_AFBCE_YUV_FORMAT_CONV_MODE            (volatile uint32_t *)0xff0081ec
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define P_DI_AFBCE_DUMMY_DATA                      (volatile uint32_t *)0xff0081f0
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define P_DI_AFBCE_CLR_FLAG                        (volatile uint32_t *)0xff0081f4
//Bit 31:0         reg_di_afbce_clr_flag           // unsigned, default = 0  ;
#define P_DI_AFBCE_STA_FLAGT                       (volatile uint32_t *)0xff0081f8
//Bit 31:0         ro_di_afbce__sta_flag        // unsigned, RO,default = 0  ;
#define P_DI_AFBCE_MMU_NUM                         (volatile uint32_t *)0xff0081fc
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define P_DI_AFBCE_MMU_RMIF_CTRL1                  (volatile uint32_t *)0xff008200
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define P_DI_AFBCE_MMU_RMIF_CTRL2                  (volatile uint32_t *)0xff008204
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define P_DI_AFBCE_MMU_RMIF_CTRL3                  (volatile uint32_t *)0xff008208
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define P_DI_AFBCE_MMU_RMIF_CTRL4                  (volatile uint32_t *)0xff00820c
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define P_DI_AFBCE_MMU_RMIF_SCOPE_X                (volatile uint32_t *)0xff008210
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define P_DI_AFBCE_MMU_RMIF_SCOPE_Y                (volatile uint32_t *)0xff008214
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define P_DI_AFBCE_MMU_RMIF_RO_STAT                (volatile uint32_t *)0xff008218
//Bit 15:0  reg_status        // unsigned ,
#define P_DI_AFBCE_PIP_CTRL                        (volatile uint32_t *)0xff008228
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define P_DI_AFBCE_ROT_CTRL                        (volatile uint32_t *)0xff00822c
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define P_DI_AFBCE_DIMM_CTRL                       (volatile uint32_t *)0xff008230
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define P_DI_AFBCE_BND_DEC_MISC                    (volatile uint32_t *)0xff008234
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define P_DI_AFBCE_RD_ARB_MISC                     (volatile uint32_t *)0xff008238
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_afbc_enc0_regs.h
//
// the segment is 8'h90-8'h9f
//
// Reading file:  di_wrmif0_regs.h
//
#define P_NRWR_DBG_AXI_CMD_CNT                     (volatile uint32_t *)0xff008240
#define P_NRWR_DBG_AXI_DAT_CNT                     (volatile uint32_t *)0xff008244
#define P_DI_NRWR_CANVAS                           (volatile uint32_t *)0xff008248
#define P_DI_NRWR_URGENT                           (volatile uint32_t *)0xff00824c
#define P_DI_NRWR_X                                (volatile uint32_t *)0xff008250
#define P_DI_NRWR_Y                                (volatile uint32_t *)0xff008254
//bit 31:30		  NRWR_words_lim
//bit 29		  NRWR_rev_y
//bit 28:16		  NRWR_start_y
//bit 15		  NRWR_ext_en
//bit 12:0		  NRWR_end_y
#define P_DI_NRWR_CTRL                             (volatile uint32_t *)0xff008258
//bit 31		  pending_ddr_wrrsp_NRWR
//bit 30		  NRWR_reg_swap
//bit 29:26		  NRWR_burst_lim
//bit 25		  NRWR_canvas_syncen
//bit 24		  NRWR_no_clk_gate
//bit 23:22		  NRWR_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas 2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20		  NRWR_hconv_mode
//bit 19:18		  NRWR_vconv_mode
//bit 17		  NRWR_swap_cbcr
//bit 16		  NRWR_urgent
//bit 15:8		  NRWR_canvas_index_chroma
//bit 7:0		  NRWR_canvas_index_luma
#define P_DI_NRWR_SHRK_CTRL                        (volatile uint32_t *)0xff00825c
//bit   31:10     reserved
//bit   9:8       reg_vshrk_mode        unsigned, default = 0, 0:1/2 horizontal shrink 1:1/4 horizontal shrink 2:1/8 horizontal shrink
//bit   7:6       reg_hshrk_mode        unsigned, default = 0, 0:1/2 vertical shrink 1:1/4 vertical shrink 2:1/8 vertical shrink
//bit   5:2       reg_gclk_ctrl         unsigned, default = 0
//bit   1         reg_frm_rst           unsigned, default = 0
//bit   0         reg_shrk_en           unsigned, default = 0
#define P_DI_NRWR_SHRK_SIZE                        (volatile uint32_t *)0xff008260
//bit   31:26     reserved
//bit   25:13     reg_frm_hsize         unsigned, default = 1920, hsize in
//bit   12:0      reg_frm_vsize         unsigned, default = 1080, vsize in
#define P_DI_NRWR_CROP_CTRL                        (volatile uint32_t *)0xff008268
//Bit   31        reg_crop_en           unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30:4      reserved
//Bit   3:0       reg_hold_line         unsigned  , RW,default = 4,dimm_layer data
#define P_DI_NRWR_CROP_DIMM_CTRL                   (volatile uint32_t *)0xff00826c
//Bit   31        reg_dimm_layer_en     unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data         unsigned  , RW,default = 29'h00080200,dimm_layer data
#define P_DI_NRWR_CROP_SIZE_IN                     (volatile uint32_t *)0xff008270
//Bit   31:29,    reserved
//Bit   28:16     reg_crop_hsize         unsigned, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     reg_crop_vsize         unsigned, default = 1080 , pic vertical size in  unit: pixel
#define P_DI_NRWR_CROP_HSCOPE                      (volatile uint32_t *)0xff008274
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_h      unsigned, default = 1919 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_h      unsigned, default = 0    ;
#define P_DI_NRWR_CROP_VSCOPE                      (volatile uint32_t *)0xff008278
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_v      unsigned, default = 1079 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_v      unsigned, default = 0    ;
#define P_DI_NRWR_BADDR0                           (volatile uint32_t *)0xff008280
//Bit   31:0      wmif_baddr_luma        unsigned, default = 0x20000
#define P_DI_NRWR_STRIDE0                          (volatile uint32_t *)0xff008284
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_luma       unsigned, default = 0x1000;
#define P_DI_NRWR_BADDR1                           (volatile uint32_t *)0xff008288
//Bit   31:0      wmif_baddr_chroma      unsigned, default = 0x20000
#define P_DI_NRWR_STRIDE1                          (volatile uint32_t *)0xff00828c
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_chroma     unsigned, default = 0x1000;
//
// Closing file:  di_wrmif0_regs.h
//
// the segment is 8'ha0-8'hbf
//`define DI_IF1_URGENT_CTRL						8'ha3
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//`define DI_INP_URGENT_CTRL						8'ha4
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di mem chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di mem luma path
//`define DI_MEM_URGENT_CTRL						8'ha5
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di chan2 chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di chan2 luma path
//`define DI_CHAN2_URGENT_CTRL					8'ha6
//`define DI_IF1_GEN_REG3              8'ha7
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//`define DI_INP_GEN_REG3              8'ha8
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//`define DI_MEM_GEN_REG3              8'ha9
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//`define DI_CHAN2_GEN_REG3            8'haa
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//`define DI_PRE_GL_CTRL             8'hab
//bit 31,pre go field cnt enable
//bit 30,pre go field cnt reset
//bit 29:16, total pre go line
//bit 13:0, total  pre go frame
//`define DI_PRE_GL_THD              8'hac
//bit 31:0  go line size
//`define DI_POST_GL_CTRL            8'had
//bit 31,post go field cnt enable
//bit 30,post go field cnt reset
//bit 28:16, total post go line
//bit 13:0, total  post go frame
//`define DI_POST_GL_THD            8'hae
//bit 31:0  go line size
//`define DI_IF0_AXI_CMD_CNT        8'hb0
//`define DI_IF0_AXI_RDAT_CNT       8'hb1
//
//`define DI_IF1_AXI_CMD_CNT        8'hb2
//`define DI_IF1_AXI_RDAT_CNT       8'hb3
//
//`define DI_IF2_AXI_CMD_CNT        8'hb4
//`define DI_IF2_AXI_RDAT_CNT       8'hb5
//
//`define DI_INP_AXI_CMD_CNT        8'hb6
//`define DI_INP_AXI_RDAT_CNT       8'hb7
//
//`define DI_MEM_AXI_CMD_CNT        8'hb8
//`define DI_MEM_AXI_RDAT_CNT       8'hb9
//
//`define DI_CHAN2_AXI_CMD_CNT      8'hba
//`define DI_CHAN2_AXI_RDAT_CNT     8'hbb
// di afbc_enc
// the segment is 8'hc0-8'hef
//
// Reading file:  di_afbc_enc1_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DI_AFBCE1_ENABLE                         (volatile uint32_t *)0xff008300
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    di_AFBCE1_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define P_DI_AFBCE1_MODE                           (volatile uint32_t *)0xff008304
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved         unsigned, default = 0 , enable singal of crop
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define P_DI_AFBCE1_SIZE_IN                        (volatile uint32_t *)0xff008308
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vertical size in  unit: pixel
#define P_DI_AFBCE1_BLK_SIZE_IN                    (volatile uint32_t *)0xff00830c
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vertical size in  unit: pixel
#define P_DI_AFBCE1_HEAD_BADDR                     (volatile uint32_t *)0xff008310
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define P_DI_AFBCE1_MIF_SIZE                       (volatile uint32_t *)0xff008314
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define P_DI_AFBCE1_PIXEL_IN_HOR_SCOPE             (volatile uint32_t *)0xff008318
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define P_DI_AFBCE1_PIXEL_IN_VER_SCOPE             (volatile uint32_t *)0xff00831c
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define P_DI_AFBCE1_CONV_CTRL                      (volatile uint32_t *)0xff008320
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define P_DI_AFBCE1_MIF_HOR_SCOPE                  (volatile uint32_t *)0xff008324
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define P_DI_AFBCE1_MIF_VER_SCOPE                  (volatile uint32_t *)0xff008328
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define P_DI_AFBCE1_STAT1                          (volatile uint32_t *)0xff00832c
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define P_DI_AFBCE1_STAT2                          (volatile uint32_t *)0xff008330
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define P_DI_AFBCE1_FORMAT                         (volatile uint32_t *)0xff008334
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define P_DI_AFBCE1_MODE_EN                        (volatile uint32_t *)0xff008338
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define P_DI_AFBCE1_DWSCALAR                       (volatile uint32_t *)0xff00833c
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define P_DI_AFBCE1_DEFCOLOR_1                     (volatile uint32_t *)0xff008340
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define P_DI_AFBCE1_DEFCOLOR_2                     (volatile uint32_t *)0xff008344
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define P_DI_AFBCE1_QUANT_ENABLE                   (volatile uint32_t *)0xff008348
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_DI_AFBCE1_IQUANT_LUT_1                   (volatile uint32_t *)0xff00834c
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE1_IQUANT_LUT_2                   (volatile uint32_t *)0xff008350
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE1_IQUANT_LUT_3                   (volatile uint32_t *)0xff008354
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE1_IQUANT_LUT_4                   (volatile uint32_t *)0xff008358
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_DI_AFBCE1_RQUANT_LUT_1                   (volatile uint32_t *)0xff00835c
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define P_DI_AFBCE1_RQUANT_LUT_2                   (volatile uint32_t *)0xff008360
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define P_DI_AFBCE1_RQUANT_LUT_3                   (volatile uint32_t *)0xff008364
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define P_DI_AFBCE1_RQUANT_LUT_4                   (volatile uint32_t *)0xff008368
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define P_DI_AFBCE1_YUV_FORMAT_CONV_MODE           (volatile uint32_t *)0xff00836c
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define P_DI_AFBCE1_DUMMY_DATA                     (volatile uint32_t *)0xff008370
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define P_DI_AFBCE1_CLR_FLAG                       (volatile uint32_t *)0xff008374
//Bit 31:0         reg_di_AFBCE1_clr_flag           // unsigned, default = 0  ;
#define P_DI_AFBCE1_STA_FLAGT                      (volatile uint32_t *)0xff008378
//Bit 31:0         ro_di_AFBCE1__sta_flag        // unsigned, RO,default = 0  ;
#define P_DI_AFBCE1_MMU_NUM                        (volatile uint32_t *)0xff00837c
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define P_DI_AFBCE1_MMU_RMIF_CTRL1                 (volatile uint32_t *)0xff008380
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define P_DI_AFBCE1_MMU_RMIF_CTRL2                 (volatile uint32_t *)0xff008384
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define P_DI_AFBCE1_MMU_RMIF_CTRL3                 (volatile uint32_t *)0xff008388
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define P_DI_AFBCE1_MMU_RMIF_CTRL4                 (volatile uint32_t *)0xff00838c
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define P_DI_AFBCE1_MMU_RMIF_SCOPE_X               (volatile uint32_t *)0xff008390
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define P_DI_AFBCE1_MMU_RMIF_SCOPE_Y               (volatile uint32_t *)0xff008394
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define P_DI_AFBCE1_MMU_RMIF_RO_STAT               (volatile uint32_t *)0xff008398
//Bit 15:0  reg_status        // unsigned ,
#define P_DI_AFBCE1_PIP_CTRL                       (volatile uint32_t *)0xff0083a8
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define P_DI_AFBCE1_ROT_CTRL                       (volatile uint32_t *)0xff0083ac
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define P_DI_AFBCE1_DIMM_CTRL                      (volatile uint32_t *)0xff0083b0
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define P_DI_AFBCE1_BND_DEC_MISC                   (volatile uint32_t *)0xff0083b4
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define P_DI_AFBCE1_RD_ARB_MISC                    (volatile uint32_t *)0xff0083b8
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_afbc_enc1_regs.h
//
// the segment is 8'hf0-8'hff
//
// Reading file:  di_wrmif1_regs.h
//
#define P_DIWR_DBG_AXI_CMD_CNT                     (volatile uint32_t *)0xff0083c0
#define P_DIWR_DBG_AXI_DAT_CNT                     (volatile uint32_t *)0xff0083c4
#define P_DI_DIWR_CANVAS                           (volatile uint32_t *)0xff0083c8
#define P_DI_DIWR_URGENT                           (volatile uint32_t *)0xff0083cc
#define P_DI_DIWR_X                                (volatile uint32_t *)0xff0083d0
#define P_DI_DIWR_Y                                (volatile uint32_t *)0xff0083d4
//bit 31:30		  diwr_words_lim
//bit 29		  diwr_rev_y
//bit 28:16		  diwr_start_y
//bit 15		  diwr_ext_en
//bit 12:0		  diwr_end_y
#define P_DI_DIWR_CTRL                             (volatile uint32_t *)0xff0083d8
//bit 31		  pending_ddr_wrrsp_diwr
//bit 30		  diwr_reg_swap
//bit 29:26		  diwr_burst_lim
//bit 25		  diwr_canvas_syncen
//bit 24		  diwr_no_clk_gate
//bit 23:22		  diwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas 2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20		  diwr_hconv_mode
//bit 19:18		  diwr_vconv_mode
//bit 17		  diwr_swap_cbcr
//bit 16		  diwr_urgent
//bit 15:8		  diwr_canvas_index_chroma
//bit 7:0		  diwr_canvas_index_luma
#define P_DI_DIWR_SHRK_CTRL                        (volatile uint32_t *)0xff0083dc
//bit   31:10     reserved
//bit   9:8       reg_vshrk_mode        unsigned, default = 0, 0:1/2 horizontal shrink 1:1/4 horizontal shrink 2:1/8 horizontal shrink
//bit   7:6       reg_hshrk_mode        unsigned, default = 0, 0:1/2 vertical shrink 1:1/4 vertical shrink 2:1/8 vertical shrink
//bit   5:2       reg_gclk_ctrl         unsigned, default = 0
//bit   1         reg_frm_rst           unsigned, default = 0
//bit   0         reg_shrk_en           unsigned, default = 0
#define P_DI_DIWR_SHRK_SIZE                        (volatile uint32_t *)0xff0083e0
//bit   31:26     reserved
//bit   25:13     reg_frm_hsize         unsigned, default = 1920, hsize in
//bit   12:0      reg_frm_vsize         unsigned, default = 1080, vsize in
#define P_DI_DIWR_CROP_CTRL                        (volatile uint32_t *)0xff0083e8
//Bit   31        reg_crop_en           unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30:4      reserved
//Bit   3:0       reg_hold_line         unsigned  , RW,default = 4,dimm_layer data
#define P_DI_DIWR_CROP_DIMM_CTRL                   (volatile uint32_t *)0xff0083ec
//Bit   31        reg_dimm_layer_en     unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data         unsigned  , RW,default = 29'h00080200,dimm_layer data
#define P_DI_DIWR_CROP_SIZE_IN                     (volatile uint32_t *)0xff0083f0
//Bit   31:29,    reserved
//Bit   28:16     reg_crop_hsize         unsigned, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     reg_crop_vsize         unsigned, default = 1080 , pic vertical size in  unit: pixel
#define P_DI_DIWR_CROP_HSCOPE                      (volatile uint32_t *)0xff0083f4
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_h      unsigned, default = 1919 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_h      unsigned, default = 0    ;
#define P_DI_DIWR_CROP_VSCOPE                      (volatile uint32_t *)0xff0083f8
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_v      unsigned, default = 1079 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_v      unsigned, default = 0    ;
#define P_DI_DIWR_BADDR0                           (volatile uint32_t *)0xff0082a0
//Bit   31:0      wmif_baddr_luma        unsigned, default = 0x20000
#define P_DI_DIWR_STRIDE0                          (volatile uint32_t *)0xff0082a4
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_luma       unsigned, default = 0x1000;
#define P_DI_DIWR_BADDR1                           (volatile uint32_t *)0xff0082a8
//Bit   31:0      wmif_baddr_chroma      unsigned, default = 0x20000
#define P_DI_DIWR_STRIDE1                          (volatile uint32_t *)0xff0082ac
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_chroma     unsigned, default = 0x1000;
//
// Closing file:  di_wrmif1_regs.h
//
//
// Closing file:  vregs_clk1.h
//
//======================================================================
//   vpu  register.
//======================================================================
//
// Reading file:  vpu_top_regs.h
//
// synopsys translate_off
// synopsys translate_on
//======================================================================
//   vpu  register.
//======================================================================
// -----------------------------------------------
// REG_BASE:  VPU_VCBUS_BASE = 0x27
// -----------------------------------------------
//`define     VPU_OSD1_MMC_CTRL     8'h01
#define P_VPU_CRC_CTRL                             (volatile uint32_t *)0xff009c04
#define P_VPU_RO_CRC0                              (volatile uint32_t *)0xff009c08
#define P_VPU_RO_CRC1                              (volatile uint32_t *)0xff009c0c
#define P_VPU_RO_CRC2                              (volatile uint32_t *)0xff009c10
#define P_VPU_RO_CRC3                              (volatile uint32_t *)0xff009c14
#define P_VPU_RO_CRC4                              (volatile uint32_t *)0xff009c18
#define P_VPU_RO_CRC5                              (volatile uint32_t *)0xff009c1c
#define P_VPU_RO_CRC6                              (volatile uint32_t *)0xff009c20
#define P_VPU_LUT_DMA_SEC_IN                       (volatile uint32_t *)0xff009c24
#define P_VPU_INTF_CTRL                            (volatile uint32_t *)0xff009c28
#define P_VPU_APB_PROT_CTRL                        (volatile uint32_t *)0xff009c2c
#define P_VPU_ENC_ERROR                            (volatile uint32_t *)0xff009c30
#define P_VPU_SECURE_REG                           (volatile uint32_t *)0xff009c34
#define P_VPU_SECURE_ST_RO                         (volatile uint32_t *)0xff009c38
#define P_VPU_VDIN_SEC_IN                          (volatile uint32_t *)0xff009c3c
#define P_VPU_AXI_QOS_RD0                          (volatile uint32_t *)0xff009c40
#define P_VPU_AXI_QOS_RD1                          (volatile uint32_t *)0xff009c44
#define P_VPU_AXI_QOS_WR0                          (volatile uint32_t *)0xff009c48
//`define     VPU_OSD2_MMC_CTRL     8'h02
//`define     VPU_VD1_MMC_CTRL      8'h03
//`define     VPU_VD2_MMC_CTRL      8'h04
//`define     VPU_DI_IF1_MMC_CTRL   8'h05
//`define     VPU_DI_MEM_MMC_CTRL   8'h06
//`define     VPU_DI_INP_MMC_CTRL   8'h07
//`define     VPU_DI_MTNRD_MMC_CTRL 8'h08
//`define     VPU_DI_CHAN2_MMC_CTRL 8'h09
//`define     VPU_DI_MTNWR_MMC_CTRL 8'h0a
//`define     VPU_DI_NRWR_MMC_CTRL  8'h0b
//`define     VPU_DI_DIWR_MMC_CTRL  8'h0c
//`define     VPU_VDIN0_MMC_CTRL    8'h0d
//`define     VPU_VDIN1_MMC_CTRL    8'h0e
//`define     VPU_BT656_MMC_CTRL    8'h0f
//`define     VPU_TVD3D_MMC_CTRL    8'h10
//`define     VPU_TVDVBI_MMC_CTRL   8'h11
//Read only
//`define     VPU_TVDVBI_VSLATCH_ADDR   8'h12
//Read only
//`define     VPU_TVDVBI_WRRSP_ADDR 8'h13
#define P_VPU_VDIN_PRE_ARB_CTRL                    (volatile uint32_t *)0xff009c50
#define P_VPU_VDISP_PRE_ARB_CTRL                   (volatile uint32_t *)0xff009c54
#define P_VPU_VPUARB2_PRE_ARB_CTRL                 (volatile uint32_t *)0xff009c58
#define P_VPU_OSD3_MMC_CTRL                        (volatile uint32_t *)0xff009c5c
#define P_VPU_OSD4_MMC_CTRL                        (volatile uint32_t *)0xff009c60
#define P_VPU_VD3_MMC_CTRL                         (volatile uint32_t *)0xff009c64
// [31:21] Reserved.
// [20:18] cntl_encx_clk_sel
// [17:16] cntl_vencl_dpi_sel_clk
// [15: 8] Reserved
// [ 6: 4] Reserved
// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
#define P_VPU_VIU_VENC_MUX_CTRL                    (volatile uint32_t *)0xff009c68
// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
//                          0=output CrYCb(BRG);
//                          1=output YCbCr(RGB);
//                          2=output YCrCb(RBG);
//                          3=output CbCrY(GBR);
//                          4=output CbYCr(GRB);
//                          5=output CrCbY(BGR);
//                          6,7=Rsrv.
// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
// [    3] inv_vsync. 1=Invert Vsync polarity.
// [    2] inv_hsync. 1=Invert Hsync polarity.
// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
#define P_VPU_HDMI_SETTING                         (volatile uint32_t *)0xff009c6c
#define P_ENCI_INFO_READ                           (volatile uint32_t *)0xff009c70
#define P_ENCP_INFO_READ                           (volatile uint32_t *)0xff009c74
#define P_ENCT_INFO_READ                           (volatile uint32_t *)0xff009c78
#define P_ENCL_INFO_READ                           (volatile uint32_t *)0xff009c7c
// Bit  0 RW, viu_rst_n
// Bit  1 RW, vdin_mmc_arb_rst_n
// Bit  2 RW, vdisp_mmc_arb_rst_n
// Bit  3 RW, vpuarb2_mmc_arb_rst_n
#define P_VPU_SW_RESET                             (volatile uint32_t *)0xff009c80
//Bit 30     d2d3_depr_req_sel,  0:vdisp_pre_arb, 1: vpuarb2_pre_arb
//Bit 27:22  d2d3_depr_brst_num
//Bit 21:16  d2d3_depr_id
//Bit 14     d2d3_depw_req_sel, 0: vdin_pre_arb, 1: vdisp_pre_arb
//Bit 11:6   d2d3_depw_brst_num
//Bit 5:0    d2d3_depw_id
#define P_VPU_D2D3_MMC_CTRL                        (volatile uint32_t *)0xff009c84
//Bit 30     mtn_contrd_req_pre,  0:disp1_arb, 1: vdin_pre_arb
//Bit 27:22  mtn_contrd_brst_num
//Bit 21:16  mtn_contrd_id
//Bit 14     mtn_contwr_req_pre, 0: vdisp1_arb, 1: vdin_pre_arb
//Bit 11:6   mtn_contwr_brst_num
//Bit 5:0    mtn_contwr_id
#define P_VPU_CONT_MMC_CTRL                        (volatile uint32_t *)0xff009c88
// Bit  6 RW, gclk_mpeg_vpu_misc
// Bit  5 RW, gclk_mpeg_venc_l_top
// Bit  4 RW, gclk_mpeg_vencl_int
// Bit  3 RW, gclk_mpeg_vencp_int
// Bit  2 RW, gclk_mpeg_vi2_top
// Bit  1 RW, gclk_mpeg_vi_top
// Bit  0 RW, gclk_mpeg_venc_p_top
#define P_VPU_CLK_GATE                             (volatile uint32_t *)0xff009c8c
//Bit    12 RW, rdma_pre
//Bit 11: 6 RW, rdma_num
//Bit  5: 0 RW, rdma_id
#define P_VPU_RDMA_MMC_CTRL                        (volatile uint32_t *)0xff009c90
#define P_VPU_MEM_PD_REG0                          (volatile uint32_t *)0xff009c94
#define P_VPU_MEM_PD_REG1                          (volatile uint32_t *)0xff009c98
// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
// [   30] Reserved.                                                                                            Default 0
// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
#define P_VPU_HDMI_DATA_OVR                        (volatile uint32_t *)0xff009c9c
//Bit    15 RW, prot1_sel_osd4
//Bit    14 RW, prot1_sel_osd3
//Bit    13 RW, prot1_sel_osd2
//Bit    12 RW, prot1_sel_osd1
//Bit 11: 6 RW, prot1_brst_num
//Bit  5: 0 RW, prot1_id
#define P_VPU_PROT1_MMC_CTRL                       (volatile uint32_t *)0xff009ca0
//Bit    14 RW, prot2_sel_vd3
//Bit    13 RW, prot2_sel_vd2
//Bit    12 RW, prot2_sel_vd1
//Bit 11: 6 RW, prot2_brst_num
//Bit  5: 0 RW, prot2_id
#define P_VPU_PROT2_MMC_CTRL                       (volatile uint32_t *)0xff009ca4
//Bit    14 RW, prot3_sel_vd3
//Bit    13 RW, prot3_sel_vd2
//Bit    12 RW, prot3_sel_vd1
//Bit 11: 6 RW, prot3_brst_num
//Bit  5: 0 RW, prot3_id
#define P_VPU_PROT3_MMC_CTRL                       (volatile uint32_t *)0xff009ca8
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define P_VPU_ARB4_V1_MMC_CTRL                     (volatile uint32_t *)0xff009cac
//Bit 29:24 RW, s3_brst_num
//Bit 21:16 RW, s2_brst_num
//Bit 13: 8 RW, s1_brst_num
//Bit  5: 0 RW, s0_brst_num
#define P_VPU_ARB4_V2_MMC_CTRL                     (volatile uint32_t *)0xff009cb0
//Bit 27:22 RW, mcvecwr_num
//Bit 21:16 RW, mcvecwr_id
//Bit 11:6  RW, mcvecrd_num
//Bit 5:0   RW, mcvecrd_id
#define P_VPU_MCVEC_MMC_CTRL                       (volatile uint32_t *)0xff009cb4
//Bit 27:22 RW, mcinfwr_num
//Bit 21:16 RW, mcinfwr_id
//Bit 11:6  RW, mcinfrd_num
//Bit 5:0   RW, mcinfrd_id
#define P_VPU_MCINF_MMC_CTRL                       (volatile uint32_t *)0xff009cb8
//Bit 31    reg_vpu_pwm_inv, 1: invert the pwm signal, active low
//Bit 30:29 reg_vpu_pwm_src_sel, 00: encl, enct, encp
//Bit 28:16 reg_vpu_pwm_v_end0
//Bit 12:0  reg_vpu_pwm_v_start0
#define P_VPU_VPU_PWM_V0                           (volatile uint32_t *)0xff009cc0
//Bit 28:16 reg_vpu_pwm_v_end1
//Bit 12:0  reg_vpu_pwm_v_start1
#define P_VPU_VPU_PWM_V1                           (volatile uint32_t *)0xff009cc4
//Bit 28:16 reg_vpu_pwm_v_end2
//Bit 12:0  reg_vpu_pwm_v_start2
#define P_VPU_VPU_PWM_V2                           (volatile uint32_t *)0xff009cc8
//Bit 28:16 reg_vpu_pwm_v_end3
//Bit 12:0  reg_vpu_pwm_v_start3
#define P_VPU_VPU_PWM_V3                           (volatile uint32_t *)0xff009ccc
//Bit 28:16 reg_vpu_pwm_h_end0
//Bit 12:0  reg_vpu_pwm_h_start0
#define P_VPU_VPU_PWM_H0                           (volatile uint32_t *)0xff009cd0
//Bit 28:16 reg_vpu_pwm_h_end1
//Bit 12:0  reg_vpu_pwm_h_start1
#define P_VPU_VPU_PWM_H1                           (volatile uint32_t *)0xff009cd4
//Bit 28:16 reg_vpu_pwm_h_end2
//Bit 12:0  reg_vpu_pwm_h_start2
#define P_VPU_VPU_PWM_H2                           (volatile uint32_t *)0xff009cd8
//Bit 28:16 reg_vpu_pwm_h_end3
//Bit 12:0  reg_vpu_pwm_h_start3
#define P_VPU_VPU_PWM_H3                           (volatile uint32_t *)0xff009cdc
//Bit 18   reg_vpu_3d_go_high_fld_pol: 0: go high at field 0, 1: go high at field 1
//Bit 17   reg_vpu_3d_sync_setting_vsync_latch
//Bit 16   reg_vpu_3d_sync_enable
//Bit 14:8 reg_vpu_3d_sync_v_end
//Bit 6:0  reg_vpu_3d_sync_v_start
#define P_VPU_VPU_3D_SYNC1                         (volatile uint32_t *)0xff009ce0
//Bit 28:16 reg_vpu_3d_sync_h_end
//Bit 12:0  reg_vpu_3d_sync_h_start
#define P_VPU_VPU_3D_SYNC2                         (volatile uint32_t *)0xff009ce4
#define P_VPU_HDMI_MATRIX_COEF00_01                (volatile uint32_t *)0xff009ce8
#define P_VPU_HDMI_MATRIX_COEF02_10                (volatile uint32_t *)0xff009cec
#define P_VPU_HDMI_MATRIX_COEF11_12                (volatile uint32_t *)0xff009cf0
#define P_VPU_HDMI_MATRIX_COEF20_21                (volatile uint32_t *)0xff009cf4
#define P_VPU_HDMI_MATRIX_COEF22                   (volatile uint32_t *)0xff009cf8
#define P_VPU_HDMI_MATRIX_COEF13_14                (volatile uint32_t *)0xff009cfc
//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI
#define P_VPU_MISC_CTRL                            (volatile uint32_t *)0xff009d00
#define P_VPU_ISP_GCLK_CTRL0                       (volatile uint32_t *)0xff009d04
#define P_VPU_ISP_GCLK_CTRL1                       (volatile uint32_t *)0xff009d08
#define P_VPU_HDMI_FMT_CTRL                        (volatile uint32_t *)0xff009d0c
#define P_VPU_VDIN_ASYNC_HOLD_CTRL                 (volatile uint32_t *)0xff009d10
#define P_VPU_VDISP_ASYNC_HOLD_CTRL                (volatile uint32_t *)0xff009d14
#define P_VPU_VPUARB2_ASYNC_HOLD_CTRL              (volatile uint32_t *)0xff009d18
//    arb0_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[0] |
//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[1]
//                        ;
//
//    arb1_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[2] |
//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[3]
//                        ;
//
//    arb2_rd_urg_ctrl_o <=  vpp_off_urg_ctrl &  vpu_arb_urg_ctrl[4] |
//                        rdma_ddr_req_busy_sync_d1 & vpu_arb_urg_ctrl[5]
//                        ;
//
//    arb0_wr_urg_ctrl_o <=  vdin0_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[6] |
//                        vdin1_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[7]
//                        ;
//
//    arb1_wr_urg_ctrl_o <=  vdin0_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[8] |
//                        vdin1_lff_urg_ctrl_sync_d1 & vpu_arb_urg_ctrl[9]
//
#define P_VPU_ARB_URG_CTRL                         (volatile uint32_t *)0xff009d1c
#define P_VPU_SECURE_DUMMY                         (volatile uint32_t *)0xff009d20
#define P_VPU_VENCL_DITH_EN                        (volatile uint32_t *)0xff009d24
// todo :
#define P_VPU_422TO444_RST                         (volatile uint32_t *)0xff009d28
// todo :
#define P_VPU_422TO444_CTRL0                       (volatile uint32_t *)0xff009d2c
// todo :
#define P_VPU_422TO444_CTRL1                       (volatile uint32_t *)0xff009d30
// todo :
#define P_VPU_422TO444_CTRL2                       (volatile uint32_t *)0xff009d34
// Picture Rotate (PROT) module 1 (for OSD) registers:
//`define VPU_PROT1_CLK_GATE          8'h50
//`define VPU_PROT1_GEN_CNTL          8'h51
//`define VPU_PROT1_X_START_END       8'h52
//`define VPU_PROT1_Y_START_END       8'h53
//`define VPU_PROT1_Y_LEN_STEP        8'h54
//`define VPU_PROT1_RPT_LOOP          8'h55
//`define VPU_PROT1_RPT_PAT           8'h56
//`define VPU_PROT1_DDR               8'h57
//`define VPU_PROT1_RBUF_ROOM         8'h58
//`define VPU_PROT1_STAT_0            8'h59
//`define VPU_PROT1_STAT_1            8'h5a
//`define VPU_PROT1_STAT_2            8'h5b
//`define VPU_PROT1_REQ_ONOFF         8'h5c
// Picture Rotate (PROT) module 2 (for VD) registers:
//`define VPU_PROT2_CLK_GATE          8'h60
//`define VPU_PROT2_GEN_CNTL          8'h61
//`define VPU_PROT2_X_START_END       8'h62
//`define VPU_PROT2_Y_START_END       8'h63
//`define VPU_PROT2_Y_LEN_STEP        8'h64
//`define VPU_PROT2_RPT_LOOP          8'h65
//`define VPU_PROT2_RPT_PAT           8'h66
//`define VPU_PROT2_DDR               8'h67
//`define VPU_PROT2_RBUF_ROOM         8'h68
//`define VPU_PROT2_STAT_0            8'h69
//`define VPU_PROT2_STAT_1            8'h6a
//`define VPU_PROT2_STAT_2            8'h6b
//`define VPU_PROT2_REQ_ONOFF         8'h6c
// Picture Rotate (PROT) module 3 (for VD) registers:
//`define VPU_PROT3_CLK_GATE          8'h70
//`define VPU_PROT3_GEN_CNTL          8'h71
//`define VPU_PROT3_X_START_END       8'h72
//`define VPU_PROT3_Y_START_END       8'h73
//`define VPU_PROT3_Y_LEN_STEP        8'h74
//`define VPU_PROT3_RPT_LOOP          8'h75
//`define VPU_PROT3_RPT_PAT           8'h76
//`define VPU_PROT3_DDR               8'h77
//`define VPU_PROT3_RBUF_ROOM         8'h78
//`define VPU_PROT3_STAT_0            8'h79
//`define VPU_PROT3_STAT_1            8'h7a
//`define VPU_PROT3_STAT_2            8'h7b
//`define VPU_PROT3_REQ_ONOFF         8'h7c
//Bit 20    reg_viu2vdin0_sw_reset:   software reset
//Bit 19:18 reg_viu2vdin0_dn_ratio:   down-scale ratio; 0: no scale; 1: 1/2;  2:1/4; 3: reserved
//Bit 17:16 reg_viu2vdin0_flt_mode:   filter mode; 0: no filter; 1:[0 2 2 0]/4; 2:[1 1 1 1]/4; 3:[1 3 3 1]/8
//Bit 15:14 reversed
//Bit 13:0  reg_viu2vdin0_hsize:      source horizontal size
#define P_VPU_VIU2VDIN0_HDN_CTRL                   (volatile uint32_t *)0xff009e00
#define P_VPU_VIU_ASYNC_MASK                       (volatile uint32_t *)0xff009e04
#define P_VPU_VDIN_MISC_CTRL                       (volatile uint32_t *)0xff009e08
// [31:29] Reserved.
// [28:24] cntl_viu2vdin1_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          5'b00000=Disable VIU to VDIN path;
//          5'b00001=Enable VIU of ENC_I domain to VDIN;
//          5'b00010=Enable VIU of ENC_P domain to VDIN;
//          5'b00100=Enable VIU of ENC_T domain to VDIN;
//          5'b01000=Enable VIU WriteBack 1 domain to VDIN;
//          5'b10000=Enable VIU WriteBack 2 domain to VDIN;
// [23:21] Reserved.
// [20:16] cntl_viu2vdin1_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          5'b00000=Disable VIU to VDIN clock;
//          5'b00001=Select encI clock to VDIN;
//          5'b00010=Select encP clock to VDIN;
//          5'b00100=Select encT clock to VDIN;
//          5'b01000=Select VIU WriteBack 1 clock to VDIN;
//          5'b10000=Select VIU WriteBack 2 clock to VDIN;
// [15:13] Reserved.
// [12: 8] cntl_viu2vdin0_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          5'b00000=Disable VIU to VDIN path;
//          5'b00001=Enable VIU of ENC_I domain to VDIN;
//          5'b00010=Enable VIU of ENC_P domain to VDIN;
//          5'b00100=Enable VIU of ENC_T domain to VDIN;
//          5'b01000=Enable VIU WriteBack 1 domain to VDIN;
//          5'b10000=Enable VIU WriteBack 2 domain to VDIN;
// [ 7:5]  Reserved.
// [ 4: 0] cntl_viu2vdin0_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          5'b00000=Disable VIU to VDIN clock;
//          5'b00001=Select encI clock to VDIN;
//          5'b00010=Select encP clock to VDIN;
//          5'b00100=Select encT clock to VDIN;
//          5'b01000=Select VIU WriteBack 1 clock to VDIN;
//          5'b10000=Select VIU WriteBack 2 clock to VDIN;
#define P_VPU_VIU_VDIN_IF_MUX_CTRL                 (volatile uint32_t *)0xff009e0c
//Bit 20    reg_viu2vdin1_sw_reset:   software reset
//Bit 19:18 reg_viu2vdin1_dn_ratio:   down-scale ratio; 0: no scale; 1: 1/2;  2:1/4; 3: reserved
//Bit 17:16 reg_viu2vdin1_flt_mode:   filter mode; 0: no filter; 1:[0 2 2 0]/4; 2:[1 1 1 1]/4; 3:[1 3 3 1]/8
//Bit 15:14 reversed
//Bit 13:0  reg_viu2vdin1_hsize:      source horizontal size
#define P_VPU_VIU2VDIN1_HDN_CTRL                   (volatile uint32_t *)0xff009e10
#define P_VPU_VENCX_CLK_CTRL                       (volatile uint32_t *)0xff009e14
//Bit 0  encp_afifo_clk
//Bit 1  encl_afifo_clk
//Bit 2  enci_afifo_clk
#define P_VPU_HDMI_MATRIX_COEF23_24                (volatile uint32_t *)0xff009e20
#define P_VPU_HDMI_MATRIX_COEF15_25                (volatile uint32_t *)0xff009e24
#define P_VPU_HDMI_MATRIX_CLIP                     (volatile uint32_t *)0xff009e28
#define P_VPU_HDMI_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff009e2c
#define P_VPU_HDMI_MATRIX_OFFSET2                  (volatile uint32_t *)0xff009e30
#define P_VPU_HDMI_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff009e34
#define P_VPU_HDMI_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff009e38
#define P_VPU_HDMI_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff009e3c
// vpu arbitration :
// the segment is 8'h90-8'hc8
//
// Reading file:  vpu_arb_axi_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define P_VPU_RDARB_MODE_L1C1                      (volatile uint32_t *)0xff009e40
//Bit   31:22,    reserved
//Bit   21:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define P_VPU_RDARB_REQEN_SLV_L1C1                 (volatile uint32_t *)0xff009e44
//Bit   31:12,     reserved
//Bit   11:0,     rdarb_dc_req_en     unsigned  , default = 12'hfff
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[6]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[10]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[11]: the slv5 req to mst port1 enable,
#define P_VPU_RDARB_WEIGH0_SLV_L1C1                (volatile uint32_t *)0xff009e48
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_VPU_RDARB_WEIGH1_SLV_L1C1                (volatile uint32_t *)0xff009e4c
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define P_VPU_WRARB_MODE_L1C1                      (volatile uint32_t *)0xff009e50
//Bit   31:22,    reserved
//Bit   21:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//                                    wrarb_sel[4]==0 slave dc4 connect master port0 wrarb_sel[4]==1 slave dc4 connect master port1
//                                    wrarb_sel[5]==0 slave dc5 connect master port0 wrarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define P_VPU_WRARB_REQEN_SLV_L1C1                 (volatile uint32_t *)0xff009e54
//Bit   31:12,     reserved
//Bit   11:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define P_VPU_WRARB_WEIGH0_SLV_L1C1                (volatile uint32_t *)0xff009e58
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_VPU_WRARB_WEIGH1_SLV_L1C1                (volatile uint32_t *)0xff009e5c
//Bit   31:6,    reserved
//Bit   5:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define P_VPU_RDWR_ARB_STATUS_L1C1                 (volatile uint32_t *)0xff009e60
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define P_VPU_RDARB_MODE_L1C2                      (volatile uint32_t *)0xff009e64
//Bit   31:21,    reserved
//Bit   20:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port0 clk gate control
#define P_VPU_RDARB_REQEN_SLV_L1C2                 (volatile uint32_t *)0xff009e68
//Bit   31:10,     reserved
//Bit    9:0,     rdarb_dc_req_en     unsigned  , default = 0
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[6]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv4 req to mst port1 enable,
#define P_VPU_RDARB_WEIGH0_SLV_L1C2                (volatile uint32_t *)0xff009e6c
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_VPU_RDWR_ARB_STATUS_L1C2                 (volatile uint32_t *)0xff009e70
//Bit   31:3,    reserved
//Bit      2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define P_VPU_RDARB_MODE_L2C1                      (volatile uint32_t *)0xff009e74
//Bit   31:28,    reserved
//Bit   27:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:11,    reserved
//Bit   10:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:6,      reserved
//Bit   5:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
//                                    rdarb_gate_clk_ctrl[5:4] master port2 clk gate control
#define P_VPU_RDARB_REQEN_SLV_L2C1                 (volatile uint32_t *)0xff009e78
//Bit   31:18,     reserved
//Bit   17:0,     rdarb_dc_req_en     unsigned  , default = 0
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define P_VPU_RDARB_WEIGH0_SLV_L2C1                (volatile uint32_t *)0xff009e7c
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define P_VPU_RDARB_WEIGH1_SLV_L2C1                (volatile uint32_t *)0xff009e80
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define P_VPU_RDWR_ARB_STATUS_L2C1                 (volatile uint32_t *)0xff009e84
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define P_VPU_WRARB_MODE_L2C1                      (volatile uint32_t *)0xff009e88
//Bit   31:20,    reserved
//Bit   19:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port0 clk gate control
#define P_VPU_WRARB_REQEN_SLV_L2C1                 (volatile uint32_t *)0xff009e8c
//Bit   31:8,     reserved
//Bit    7:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
#define P_VPU_WRARB_WEIGH0_SLV_L2C1                (volatile uint32_t *)0xff009e90
//Bit   31:24,    reserved
//Bit   23:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
#define P_VPU_ASYNC_RD_MODE0                       (volatile uint32_t *)0xff009e94
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define P_VPU_ASYNC_RD_MODE1                       (volatile uint32_t *)0xff009e98
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define P_VPU_ASYNC_RD_MODE2                       (volatile uint32_t *)0xff009e9c
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define P_VPU_ASYNC_RD_MODE3                       (volatile uint32_t *)0xff009ea0
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define P_VPU_ASYNC_RD_MODE4                       (volatile uint32_t *)0xff009ea4
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define P_VPU_ASYNC_WR_MODE0                       (volatile uint32_t *)0xff009ea8
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define P_VPU_ASYNC_WR_MODE1                       (volatile uint32_t *)0xff009eac
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define P_VPU_ASYNC_WR_MODE2                       (volatile uint32_t *)0xff009eb0
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arugt
//Bit   8,        argument_cfg       unsigned  , default = 0  register arugt control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define P_VPU_ASYNC_STAT                           (volatile uint32_t *)0xff009eb4
//Bit   31:19,    reserved
//Bit   18,       axiwr2_chan_idle  unsigned  , RO, axi write channel2 idle state
//Bit   17,       axiwr1_chan_idle  unsigned  , RO, axi write channel1 idle state
//Bit   16,       axiwr0_chan_idle  unsigned  , RO, axi write channel0 idle state
//Bit   15:5,     reserved
//Bit   4,        axird4_chan_idle  unsigned  , RO, axi read channel4 idle state
//Bit   3,        axird3_chan_idle  unsigned  , RO, axi read channel3 idle state
//Bit   2,        axird2_chan_idle  unsigned  , RO, axi read channel2 idle state
//Bit   1,        axird1_chan_idle  unsigned  , RO, axi read channel1 idle state
//Bit   0,        axird0_chan_idle  unsigned  , RO, axi read channel0 idle state
#define P_VPU_WRARB_MODE_L1C2                      (volatile uint32_t *)0xff009eb8
//Bit   31:18,    reserved
//Bit   17:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//Bit   15:9,     reserved
//Bit   8,        wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//Bit   7:2,      reserved
//Bit   1:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
#define P_VPU_WRARB_REQEN_SLV_L1C2                 (volatile uint32_t *)0xff009ebc
//Bit   31:2,     reserved
//Bit    1:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
#define P_VPU_WRARB_WEIGH0_SLV_L1C2                (volatile uint32_t *)0xff009ec0
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv1 req weigh number
#define P_VPU_WRARB_WEIGH1_SLV_L1C2                (volatile uint32_t *)0xff009ec4
//Bit   31:18,    reserved
//Bit   17:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[6*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[7*6+:6]: the slv1 req weigh number
#define P_VPU_RDARB_WEIGH1_SLV_L1C2                (volatile uint32_t *)0xff009ec8
//Bit   31:18,    reserved
//Bit   17:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[6*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[7*6+:6]: the slv2 req weigh number
#define P_VPU_ARB_DBG_CTRL_L1C1                    (volatile uint32_t *)0xff009ecc
#define P_VPU_ARB_DBG_STAT_L1C1                    (volatile uint32_t *)0xff009ed0
#define P_VPU_ARB_DBG_CTRL_L1C2                    (volatile uint32_t *)0xff009ed4
#define P_VPU_ARB_DBG_STAT_L1C2                    (volatile uint32_t *)0xff009ed8
#define P_VPU_ARB_DBG_CTRL_L2C1                    (volatile uint32_t *)0xff009edc
#define P_VPU_ARB_DBG_STAT_L2C1                    (volatile uint32_t *)0xff009ee0
#define P_VPU_ARB_PATH_CTRL                        (volatile uint32_t *)0xff009ee4
#define P_VPU_ARB_PATH_MAP00                       (volatile uint32_t *)0xff009ee8
#define P_VPU_ARB_PATH_MAP01                       (volatile uint32_t *)0xff009eec
#define P_VPU_ARB_PATH_MAP02                       (volatile uint32_t *)0xff009ef0
#define P_VPU_ARB_PATH_MAP03                       (volatile uint32_t *)0xff009ef4
#define P_VPU_ARB_PATH_MAP10                       (volatile uint32_t *)0xff009ef8
#define P_VPU_ARB_PATH_MAP11                       (volatile uint32_t *)0xff009efc
#define P_VPU_ARB_PATH_MAP12                       (volatile uint32_t *)0xff009f00
#define P_VPU_ARB_PATH_MAP13                       (volatile uint32_t *)0xff009f04
#define P_VPU_RDARB_UGT_L2C1                       (volatile uint32_t *)0xff009f08
#define P_VPU_WRARB_UGT_L2C1                       (volatile uint32_t *)0xff009f0c
#define P_VPU_RDARB_LIMT0_L2C1                     (volatile uint32_t *)0xff009f10
#define P_VPU_RDARB_LIMT1_L2C1                     (volatile uint32_t *)0xff009f14
#define P_VPU_ARB_AXIWR_PROT                       (volatile uint32_t *)0xff009f18
#define P_VPU_ARB_AXIRD0_PROT                      (volatile uint32_t *)0xff009f1c
#define P_VPU_ARB_AXIRD1_PROT                      (volatile uint32_t *)0xff009f20
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_arb_axi_regs.h
//
// vpu lut dma
// the segment is 8'h50~8'h7f & 8'hca-8'hdf
//
// Reading file:  vpu_lut_dma_regs.h
//
// synopsys translate_off
// synopsys translate_on
// 0x50~0x7f
//
// Reading file:  viu_dma_top.h
//
#define P_VPU_DMA_RDMIF0_CTRL                      (volatile uint32_t *)0xff009d40
//Bit 31:28        reserved
//Bit    27        reg_rd0_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd0_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd0_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd0_enable_int           // unsigned ,    RW , default = 0     channel0 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd0_stride               // unsigned ,    RW , default = 512   channel0 send number
#define P_VPU_DMA_RDMIF1_CTRL                      (volatile uint32_t *)0xff009d44
//Bit 31:28        reserved
//Bit    27        reg_rd1_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd1_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd1_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd1_enable_int           // unsigned ,    RW , default = 0     channel1 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd1_stride               // unsigned ,    RW , default = 512   channel1 send number
#define P_VPU_DMA_RDMIF2_CTRL                      (volatile uint32_t *)0xff009d48
//Bit 31:28        reserved
//Bit    27        reg_rd2_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd2_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd2_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd2_enable_int           // unsigned ,    RW , default = 0     channel2 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd2_stride               // unsigned ,    RW , default = 512   channel2 send number
#define P_VPU_DMA_RDMIF3_CTRL                      (volatile uint32_t *)0xff009d4c
//Bit 31:28        reserved
//Bit    27        reg_rd3_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd3_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd3_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd3_enable_int           // unsigned ,    RW , default = 0     channel3 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd3_stride               // unsigned ,    RW , default = 512   channel3 send number
#define P_VPU_DMA_RDMIF4_CTRL                      (volatile uint32_t *)0xff009d50
//Bit 31:28        reserved
//Bit    27        reg_rd4_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd4_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd4_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd4_enable_int           // unsigned ,    RW , default = 0     channel4 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd4_stride               // unsigned ,    RW , default = 512   channel4 send number
#define P_VPU_DMA_RDMIF5_CTRL                      (volatile uint32_t *)0xff009d54
//Bit 31:28        reserved
//Bit    27        reg_rd5_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd5_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd5_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd5_enable_int           // unsigned ,    RW , default = 0     channel5 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd5_stride               // unsigned ,    RW , default = 512   channel5 send number
#define P_VPU_DMA_RDMIF6_CTRL                      (volatile uint32_t *)0xff009d58
//Bit 31:28        reserved
//Bit    27        reg_rd6_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd6_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd6_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd6_enable_int           // unsigned ,    RW , default = 0     channel6 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd6_stride               // unsigned ,    RW , default = 512   channel6 send number
#define P_VPU_DMA_RDMIF7_CTRL                      (volatile uint32_t *)0xff009d5c
//Bit 31:28        reserved
//Bit    27        reg_rd7_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd7_frm_froce            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd7_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd7_enable_int           // unsigned ,    RW , default = 0     channel7 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd7_stride               // unsigned ,    RW , default = 512   channel7 send number
#define P_VPU_DMA_RDMIF0_BADR0                     (volatile uint32_t *)0xff009d60
//Bit 31:0  lut0_reg_baddr0
#define P_VPU_DMA_RDMIF0_BADR1                     (volatile uint32_t *)0xff009d64
//Bit 31:0  lut0_reg_baddr1
#define P_VPU_DMA_RDMIF0_BADR2                     (volatile uint32_t *)0xff009d68
//Bit 31:0  lut0_reg_baddr2
#define P_VPU_DMA_RDMIF0_BADR3                     (volatile uint32_t *)0xff009d6c
//Bit 31:0  lut0_reg_baddr3
#define P_VPU_DMA_RDMIF1_BADR0                     (volatile uint32_t *)0xff009d70
//Bit 31:0  lut1_reg_baddr0
#define P_VPU_DMA_RDMIF1_BADR1                     (volatile uint32_t *)0xff009d74
//Bit 31:0  lut1_reg_baddr1
#define P_VPU_DMA_RDMIF1_BADR2                     (volatile uint32_t *)0xff009d78
//Bit 31:0  lut1_reg_baddr2
#define P_VPU_DMA_RDMIF1_BADR3                     (volatile uint32_t *)0xff009d7c
//Bit 31:0  lut1_reg_baddr3
#define P_VPU_DMA_RDMIF2_BADR0                     (volatile uint32_t *)0xff009d80
//Bit 31:0  lut2_reg_baddr0
#define P_VPU_DMA_RDMIF2_BADR1                     (volatile uint32_t *)0xff009d84
//Bit 31:0  lut2_reg_baddr1
#define P_VPU_DMA_RDMIF2_BADR2                     (volatile uint32_t *)0xff009d88
//Bit 31:0  lut2_reg_baddr2
#define P_VPU_DMA_RDMIF2_BADR3                     (volatile uint32_t *)0xff009d8c
//Bit 31:0  lut2_reg_baddr3
#define P_VPU_DMA_RDMIF3_BADR0                     (volatile uint32_t *)0xff009d90
//Bit 31:0  lut3_reg_baddr0
#define P_VPU_DMA_RDMIF3_BADR1                     (volatile uint32_t *)0xff009d94
//Bit 31:0  lut3_reg_baddr1
#define P_VPU_DMA_RDMIF3_BADR2                     (volatile uint32_t *)0xff009d98
//Bit 31:0  lut3_reg_baddr2
#define P_VPU_DMA_RDMIF3_BADR3                     (volatile uint32_t *)0xff009d9c
//Bit 31:0  lut3_reg_baddr3
#define P_VPU_DMA_RDMIF4_BADR0                     (volatile uint32_t *)0xff009da0
//Bit 31:0  lut4_reg_baddr0
#define P_VPU_DMA_RDMIF4_BADR1                     (volatile uint32_t *)0xff009da4
//Bit 31:0  lut4_reg_baddr1
#define P_VPU_DMA_RDMIF4_BADR2                     (volatile uint32_t *)0xff009da8
//Bit 31:0  lut4_reg_baddr2
#define P_VPU_DMA_RDMIF4_BADR3                     (volatile uint32_t *)0xff009dac
//Bit 31:0  lut4_reg_baddr3
#define P_VPU_DMA_RDMIF5_BADR0                     (volatile uint32_t *)0xff009db0
//Bit 31:0  lut5_reg_baddr0
#define P_VPU_DMA_RDMIF5_BADR1                     (volatile uint32_t *)0xff009db4
//Bit 31:0  lut5_reg_baddr1
#define P_VPU_DMA_RDMIF5_BADR2                     (volatile uint32_t *)0xff009db8
//Bit 31:0  lut5_reg_baddr2
#define P_VPU_DMA_RDMIF5_BADR3                     (volatile uint32_t *)0xff009dbc
//Bit 31:0  lut5_reg_baddr3
#define P_VPU_DMA_RDMIF6_BADR0                     (volatile uint32_t *)0xff009dc0
//Bit 31:0  lut6_reg_baddr0
#define P_VPU_DMA_RDMIF6_BADR1                     (volatile uint32_t *)0xff009dc4
//Bit 31:0  lut6_reg_baddr1
#define P_VPU_DMA_RDMIF6_BADR2                     (volatile uint32_t *)0xff009dc8
//Bit 31:0  lut6_reg_baddr2
#define P_VPU_DMA_RDMIF6_BADR3                     (volatile uint32_t *)0xff009dcc
//Bit 31:0  lut6_reg_baddr3
#define P_VPU_DMA_RDMIF7_BADR0                     (volatile uint32_t *)0xff009dd0
//Bit 31:0  lut7_reg_baddr0
#define P_VPU_DMA_RDMIF7_BADR1                     (volatile uint32_t *)0xff009dd4
//Bit 31:0  lut7_reg_baddr1
#define P_VPU_DMA_RDMIF7_BADR2                     (volatile uint32_t *)0xff009dd8
//Bit 31:0  lut7_reg_baddr2
#define P_VPU_DMA_RDMIF7_BADR3                     (volatile uint32_t *)0xff009ddc
//Bit 31:0  lut7_reg_baddr3
//
// Closing file:  viu_dma_top.h
//
// 0x00~0x06
//`include"viu_com_rdmif_regs.h"
#define P_VPU_DMA_RDMIF_CTRL1                      (volatile uint32_t *)0xff009f28
#define P_VPU_DMA_RDMIF_CTRL2                      (volatile uint32_t *)0xff009f2c
#define P_VPU_DMA_RDMIF_RO_STAT                    (volatile uint32_t *)0xff009f40
//0x07~0x0d
//`include"viu_com_wrmif_regs.h"
#define P_VPU_DMA_WRMIF_CTRL1                      (volatile uint32_t *)0xff009f44
#define P_VPU_DMA_WRMIF_CTRL2                      (volatile uint32_t *)0xff009f48
#define P_VPU_DMA_WRMIF_CTRL3                      (volatile uint32_t *)0xff009f4c
#define P_VPU_DMA_WRMIF_BADDR0                     (volatile uint32_t *)0xff009f50
#define P_VPU_DMA_WRMIF_RO_STAT                    (volatile uint32_t *)0xff009f5c
#define P_VPU_DMA_RDMIF_CTRL                       (volatile uint32_t *)0xff009f60
#define P_VPU_DMA_RDMIF_BADDR1                     (volatile uint32_t *)0xff009f64
#define P_VPU_DMA_RDMIF_BADDR2                     (volatile uint32_t *)0xff009f68
#define P_VPU_DMA_RDMIF_BADDR3                     (volatile uint32_t *)0xff009f6c
#define P_VPU_DMA_WRMIF_CTRL                       (volatile uint32_t *)0xff009f70
#define P_VPU_DMA_WRMIF_BADDR1                     (volatile uint32_t *)0xff009f74
#define P_VPU_DMA_WRMIF_BADDR2                     (volatile uint32_t *)0xff009f78
#define P_VPU_DMA_WRMIF_BADDR3                     (volatile uint32_t *)0xff009f7c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_lut_dma_regs.h
//
// the segment is 8'he0-8'hef
#define P_VPU_VENCL_DITH_CTRL                      (volatile uint32_t *)0xff009f80
#define P_VPU_VENCL_DITH_LUT_1                     (volatile uint32_t *)0xff009f84
#define P_VPU_VENCL_DITH_LUT_2                     (volatile uint32_t *)0xff009f88
#define P_VPU_VENCL_DITH_LUT_3                     (volatile uint32_t *)0xff009f8c
#define P_VPU_VENCL_DITH_LUT_4                     (volatile uint32_t *)0xff009f90
#define P_VPU_VENCL_DITH_LUT_5                     (volatile uint32_t *)0xff009f94
#define P_VPU_VENCL_DITH_LUT_6                     (volatile uint32_t *)0xff009f98
#define P_VPU_VENCL_DITH_LUT_7                     (volatile uint32_t *)0xff009f9c
#define P_VPU_VENCL_DITH_LUT_8                     (volatile uint32_t *)0xff009fa0
#define P_VPU_VENCL_DITH_LUT_9                     (volatile uint32_t *)0xff009fa4
#define P_VPU_VENCL_DITH_LUT_10                    (volatile uint32_t *)0xff009fa8
#define P_VPU_VENCL_DITH_LUT_11                    (volatile uint32_t *)0xff009fac
#define P_VPU_VENCL_DITH_LUT_12                    (volatile uint32_t *)0xff009fb0
//new added 4x4 dither
// the segment is 8'hf0
#define P_VPU_HDMI_DITH_01_04                      (volatile uint32_t *)0xff009fc0
#define P_VPU_HDMI_DITH_01_15                      (volatile uint32_t *)0xff009fc4
#define P_VPU_HDMI_DITH_01_26                      (volatile uint32_t *)0xff009fc8
#define P_VPU_HDMI_DITH_01_37                      (volatile uint32_t *)0xff009fcc
#define P_VPU_HDMI_DITH_10_04                      (volatile uint32_t *)0xff009fd0
#define P_VPU_HDMI_DITH_10_15                      (volatile uint32_t *)0xff009fd4
#define P_VPU_HDMI_DITH_10_26                      (volatile uint32_t *)0xff009fd8
#define P_VPU_HDMI_DITH_10_37                      (volatile uint32_t *)0xff009fdc
#define P_VPU_HDMI_DITH_11_04                      (volatile uint32_t *)0xff009fe0
#define P_VPU_HDMI_DITH_11_15                      (volatile uint32_t *)0xff009fe4
#define P_VPU_HDMI_DITH_11_26                      (volatile uint32_t *)0xff009fe8
#define P_VPU_HDMI_DITH_11_37                      (volatile uint32_t *)0xff009fec
#define P_VPU_HDMI_DITH_CNTL                       (volatile uint32_t *)0xff009ff0
#define P_VPU_HDMI_TIMING_STAT                     (volatile uint32_t *)0xff009ff4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_top_regs.h
//
//========================================================================
//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
//
//========================================================================
//`include "csi2_regs.h"
//======================================================================
// D2D3 registers
//======================================================================
//
// Reading file:  d2d3_regs.h
//
//===========================================================================
// D2D3 Registers    0x - 0x
//===========================================================================
// -----------------------------------------------
// REG_BASE:  D2D3_VCBUS_BASE = 0x2b
// -----------------------------------------------
//------------------------------------------------------------------------------
// D2D3 top-level registers
//------------------------------------------------------------------------------
// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
//                               [28] DPG clock disable
// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit
//                               [25:24] gated clock control for DBR unit
//                               [23:22] gated clock control for LBDG unit
//                               [21:20] gated clock control for MBDG unit
//                               [19:18] gated clock control for CBDG unit
//                               [17:16] gated clock control for DBLD unit and SCD81 unit
// Bit 15:12 Reserved
// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass
// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
// Bit 7:5   Reserved
// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock
// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
#define P_D2D3_GLB_CTRL                            (volatile uint32_t *)0xff00ac00
// Indicate the input picture size in DPG unit
// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
#define P_D2D3_DPG_INPIC_SIZE                      (volatile uint32_t *)0xff00ac04
// Indicate the output picture size in DBR unit
// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
#define P_D2D3_DBR_OUTPIC_SIZE                     (volatile uint32_t *)0xff00ac08
// Indicate the rectangular window to generate the "depth" in DPG unit
// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
#define P_D2D3_DGEN_WIN_HOR                        (volatile uint32_t *)0xff00ac0c
// Indicate the rectangular window to generate the "depth" in DPG unit
// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
#define P_D2D3_DGEN_WIN_VER                        (volatile uint32_t *)0xff00ac10
//------------------------------------------------------------------------------
// CBDG SCU18 SCD81 SCD81_PRE registers
// cg: color based depth generate module
// scu18: scale up module
// scd81: scale down module
// scd81_pre: scd81 pre-scale-down module
//------------------------------------------------------------------------------
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_hphs_step, horizontal step
// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
#define P_D2D3_PRE_SCD_H                           (volatile uint32_t *)0xff00ac14
// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18,
//                               [23:16] indicate the horizontal phase offset from the first data of every line
//                               [31:24] indicate the vertical phase offset from the first line of every frame
// Bit 15:12 Reserved
// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG
//                               0: BT.601 (16-235/240)
//                               1: BT.709 (16-235/240)
//                               2: BT.601 (0-255)
//                               3: BT.709 (0-255)
// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output
// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data
//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video
//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
#define P_D2D3_SCALER_CTRL                         (volatile uint32_t *)0xff00ac18
// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect
// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect
// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect
// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect
#define P_D2D3_CG_THRESHOLD_1                      (volatile uint32_t *)0xff00ac1c
// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect
#define P_D2D3_CG_THRESHOLD_2                      (volatile uint32_t *)0xff00ac20
// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap
// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
#define P_D2D3_CG_PARAM_1                          (volatile uint32_t *)0xff00ac24
// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
// Bit 15:8  Reserved
// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap.
//                               It is only valid when cg_vpos_en=1.
//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1.
// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter
//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
#define P_D2D3_CG_PARAM_2                          (volatile uint32_t *)0xff00ac28
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_vphs_step, vertical step
// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
#define P_D2D3_PRE_SCD_V                           (volatile uint32_t *)0xff00ac2c
//------------------------------------------------------------------------------
// D2P registers
// d2p: depth to parallax transform module
//------------------------------------------------------------------------------
// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary,
//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
// Bit 23:22 Reserved
// Bit 21:20 RW, d2p_lomode,     line output mode,
//                               0:whole line is left or right;  1:whole line is left or right;
//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
// Bit 18    Reserved
// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
// Bit 13:12 RW, d2p_out_mode,   Parallax output mode
//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
// Bit 11:8  RW, d2p_smode,      Shift mode,
//                               0: no shift; 1: enable left shift;
//                               2: enable right shift; 3: both left and right shift are enabled
// Bit 7:0   RW, d2p_offset,     depth offset, signed,
#define P_D2D3_D2P_PARAM_1                         (volatile uint32_t *)0xff00ac30
// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
#define P_D2D3_D2P_PARAM_2                         (volatile uint32_t *)0xff00ac34
// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
#define P_D2D3_D2P_PARAM_3                         (volatile uint32_t *)0xff00ac38
// Indicate step parameters of SCU18 unit
// Bit 31:17 Reserved
// Bit 16    RW, scu18_step_en,   step set enable in SCU18
// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
#define P_D2D3_SCU18_STEP                          (volatile uint32_t *)0xff00ac3c
//------------------------------------------------------------------------------
// LBDG and DBLD registers
// lg: luma based depth generate module
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:22 Reserved
// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter,
//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
//                               [20]:Horizontal factor of low pass filter,
//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 15:10 Reserved
// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
#define P_D2D3_DPF_LPF_CTRL                        (volatile uint32_t *)0xff00ac40
//------------------------------------------------------------------------------
// DBLD registers
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
#define P_D2D3_DBLD_CG_PARAM                       (volatile uint32_t *)0xff00ac44
// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
#define P_D2D3_DBLD_MG_PARAM                       (volatile uint32_t *)0xff00ac48
// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
#define P_D2D3_DBLD_LG_PARAM                       (volatile uint32_t *)0xff00ac4c
// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define P_D2D3_DBLD_LPF_HCOEFF                     (volatile uint32_t *)0xff00ac50
// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define P_D2D3_DBLD_LPF_VCOEFF                     (volatile uint32_t *)0xff00ac54
// Bit 31:28 RW, hist_depth_idx,
// Bit 27:26 Reserved
// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
#define P_D2D3_DBLD_PATH_CTRL                      (volatile uint32_t *)0xff00ac58
// Indicate the input picture size in SCU18 unit
// Bit 31:16 RW, szy_scui,       The vertical size
// Bit 15:0  RW, szx_scui,       The horizontal size
#define P_D2D3_SCU18_INPIC_SIZE                    (volatile uint32_t *)0xff00ac5c
//------------------------------------------------------------------------------
// MBDG registers
// mg: model based depth generate module
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
//                               [6]:bypass, 1:bypass, 0:not bypass
#define P_D2D3_MBDG_CTRL                           (volatile uint32_t *)0xff00ac60
// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
#define P_D2D3_MBDG_PARAM_0                        (volatile uint32_t *)0xff00ac64
// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced
// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
#define P_D2D3_MBDG_PARAM_1                        (volatile uint32_t *)0xff00ac68
// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
#define P_D2D3_MBDG_PARAM_2                        (volatile uint32_t *)0xff00ac6c
// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
#define P_D2D3_MBDG_PARAM_3                        (volatile uint32_t *)0xff00ac70
// Bit 31:27 Reserved
// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
#define P_D2D3_MBDG_PARAM_4                        (volatile uint32_t *)0xff00ac74
// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
#define P_D2D3_MBDG_PARAM_5                        (volatile uint32_t *)0xff00ac78
// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
#define P_D2D3_MBDG_PARAM_6                        (volatile uint32_t *)0xff00ac7c
// Bit 31:16 Reserved
// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
#define P_D2D3_MBDG_PARAM_7                        (volatile uint32_t *)0xff00ac80
// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
// Bit 27:25 Reserved
// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
//                               [15:14]: 0 for constant mode, 1 for step1 mode
// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
//                               [11:10]: 0 for constant mode, 1 for step1 mode
// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
//                               [7:6]: 0 for constant mode, 1 for step1 mode
// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
//                               [3:2]: 0 for constant mode, 1 for step1 mode
#define P_D2D3_DBG_CTRL                            (volatile uint32_t *)0xff00ac8c
//------------------------------------------------------------------------------
// DWMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
//                               1: Reversed write data from left to right in horizontal
// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
//                               1: Reversed write data from bottom to top in horizontal
// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
// Bit 11    RW, dw_urgent,      urgent index
// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
// Bit 8     RW, dw_req_en,      1 to enable write request
// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
#define P_D2D3_DWMIF_CTRL                          (volatile uint32_t *)0xff00ac90
// Bit 31    Reserved
// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
#define P_D2D3_DWMIF_HPOS                          (volatile uint32_t *)0xff00ac94
// Bit 31:29 Reserved
// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
#define P_D2D3_DWMIF_VPOS                          (volatile uint32_t *)0xff00ac98
// Bit 31:28 Reserved
// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
// Bit 15:12 Reserved
// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
#define P_D2D3_DWMIF_SIZE                          (volatile uint32_t *)0xff00ac9c
//------------------------------------------------------------------------------
// DRMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
//                               1: Reversed read data from bottom to top in horizontal
// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
//                               1: Reversed read data from right to left in horizontal
// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
//                               2: interlaced, even line;  3: interlaced, odd line
// Bit 11    RW, dr_urgent,      urgent index, no use in this system
// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
// Bit 8     RW, dr_req_en,      1 to enable read request
// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
#define P_D2D3_DRMIF_CTRL                          (volatile uint32_t *)0xff00aca0
// Bit 31    Reserved
// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
#define P_D2D3_DRMIF_HPOS                          (volatile uint32_t *)0xff00aca4
// Bit 31:29 Reserved
// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
#define P_D2D3_DRMIF_VPOS                          (volatile uint32_t *)0xff00aca8
//------------------------------------------------------------------------------
// PDR registers
// ddd: parallax based render
//------------------------------------------------------------------------------
// Bit 31:8  Reserved
// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
// Bit 5     RW, ddd_wrap_en,    Reserved
// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line.
// Bit 3:2   RW, ddd_out_mode,   Reserved
// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:
//                               2'b0x: whole line is left or right;
//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl inteleave in one line,
//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr inteleave in one line,
//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrrlllll, half line is right, another half is left,
//                                      d2p_lar=0(D2P_PARAM_1), lllllrrrrr, half line is left, another half is right,
#define P_D2D3_DBR_DDD_CTRL                        (volatile uint32_t *)0xff00acb0
// Bit 31:0  RW, ddd_dbg_ctrl,   no use
#define P_D2D3_DBR_DDD_DBG                         (volatile uint32_t *)0xff00acb4
//------------------------------------------------------------------------------
// LRDMX registers
//------------------------------------------------------------------------------
// Bit 31:9  Reserved
// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
//                               00: ff0  01:ff1   10: left input  11:right input
// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
//                               00: ff1  01:ff0   10: left input  11:right input
#define P_D2D3_DBR_LRDMX_CTRL                      (volatile uint32_t *)0xff00acbc
//------------------------------------------------------------------------------
// Read Only registers
//------------------------------------------------------------------------------
// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
#define P_D2D3_CBDG_STATUS_1                       (volatile uint32_t *)0xff00acc0
// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
#define P_D2D3_MBDG_STATUS_1                       (volatile uint32_t *)0xff00acc4
// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
#define P_D2D3_MBDG_STATUS_2                       (volatile uint32_t *)0xff00acc8
// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
// Bit 30:8  Reserved
// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
#define P_D2D3_MBDG_STATUS_3                       (volatile uint32_t *)0xff00accc
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
#define P_D2D3_MBDG_STATUS_4                       (volatile uint32_t *)0xff00acd0
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
#define P_D2D3_MBDG_STATUS_5                       (volatile uint32_t *)0xff00acd4
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
#define P_D2D3_MBDG_STATUS_6                       (volatile uint32_t *)0xff00acd8
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
#define P_D2D3_MBDG_STATUS_7                       (volatile uint32_t *)0xff00acdc
// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
#define P_D2D3_DBG_STATUS_1                        (volatile uint32_t *)0xff00ace0
// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
//                               dbg_hscnt_sel == 4'h1, output cg hscnt
//                               dbg_hscnt_sel == 4'h2, output mg hscnt
//                               dbg_hscnt_sel == 4'h3, output bld hscnt
//                               dbg_hscnt_sel == other value, output 32'h0
#define P_D2D3_DBG_STATUS_2                        (volatile uint32_t *)0xff00ace4
// Bit 31:0 RO, drmif_status,    drmif module internal status
#define P_D2D3_DRMIF_STATUS                        (volatile uint32_t *)0xff00ace8
// Bit 31:2 RO, Reserved
// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
#define P_D2D3_DWMIF_STATUS                        (volatile uint32_t *)0xff00acec
// Bit 31:24 Reserved
// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
#define P_D2D3_CBDG_STATUS_2                       (volatile uint32_t *)0xff00acf0
// Bit 31:20 Reserved
// Bit 19:0  RO, ro_hist_depth,
#define P_D2D3_DBLD_STATUS                         (volatile uint32_t *)0xff00acf4
// Bit 31:0 Reserved
#define P_D2D3_RESEV_STATUS1                       (volatile uint32_t *)0xff00acf8
// Bit 31:0  Reserved
#define P_D2D3_RESEV_STATUS2                       (volatile uint32_t *)0xff00acfc
//
// Closing file:  d2d3_regs.h
//
//========================================================================
//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
//
//========================================================================
//`include "dsi_regs.h"
//========================================================================
//  ISP register    (16'h2d00 - 16'h2dff)
//========================================================================
//`include "isp_reg.h"
//
// Reading file:  vpu_dnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MADB_VCBUS_BASE = 0x2d
// -----------------------------------------------
#define P_DNR_CTRL                                 (volatile uint32_t *)0xff00b400
//Bit 31:17,        reserved
//Bit 16,            reg_dnr_en		                                , dnr enable                  . unsigned  , default = 1
//Bit 15,            reg_dnr_db_vdbstep                          , vdb step, 0: 4, 1: 8        . unsigned  , default = 1
//Bit 14,            reg_dnr_db_vdbprten                         , vdb protection enable       . unsigned  , default = 1
//Bit 13,            reg_dnr_gbs_difen                           , enable dif (between LR and LL/RR) condition for gbs stat.. unsigned  , default = 0
//Bit 12,            reg_dnr_luma_en                             , enable ycbcr2luma module    . unsigned  , default = 1
//Bit 11:10,        reg_dnr_db_mod                              , deblocking mode, 0: disable, 1: horizontal deblocking, 2: vertical deblocking, 3: horizontal & vertical deblocking. unsigned  , default = 3
//Bit  9,            reg_dnr_db_chrmen                           , enable chroma deblocking    . unsigned  , default = 1
//Bit  8,            reg_dnr_hvdif_mod                           , 0: calc. difs by original Y, 1: by new luma. unsigned  , default = 1
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_demo_lften                          , b0: Y b1:U b2:V             . unsigned  , default = 7
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_demo_rgten                          , b0: Y b1:U b2:V             . unsigned  , default = 7
#define P_DNR_HVSIZE                               (volatile uint32_t *)0xff00b404
//Bit 31:29,        reserved
//Bit 28:16,        reg_dnr_hsize                               , hsize                       . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 0,        reg_dnr_vsize                               , vsize                       . unsigned  , default = 0
#define P_DNR_DBLK_BLANK_NUM                       (volatile uint32_t *)0xff00b408
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dblk_hblank_num                         , deblock hor blank num       . unsigned  , default = 16
//Bit  7: 0,        reg_dblk_vblank_num                         , deblock ver blank num       . unsigned  , default = 45
#define P_DNR_BLK_OFFST                            (volatile uint32_t *)0xff00b40c
//Bit 31: 7,        reserved
//Bit  6: 4,        reg_dnr_hbofst                              , horizontal block offset may provide by software calc.. unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_vbofst                              , vertical block offset may provide by software calc.. unsigned  , default = 0
#define P_DNR_GBS                                  (volatile uint32_t *)0xff00b410
//Bit 31: 2,        reserved
//Bit  1: 0,        reg_dnr_gbs                                 , global block strength may update by software calc.. unsigned  , default = 0
#define P_DNR_HBOFFST_STAT                         (volatile uint32_t *)0xff00b414
//Bit 31:24,        reg_dnr_hbof_difthd                         , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
//Bit 23:16,        reg_dnr_hbof_edgethd                        , edge threshold (<=) for LR  . unsigned  , default = 32
//Bit 15: 8,        reg_dnr_hbof_flatthd                        , flat threshold (>=) for LR  . unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_hbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_hbof_statmod                        , statistic mode for horizontal block offset, 0: count flags for 8-bin, 1: count LRs for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count LRs for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
#define P_DNR_VBOFFST_STAT                         (volatile uint32_t *)0xff00b418
//Bit 31:24,        reg_dnr_vbof_difthd                         , dif threshold (>=) between Up and Dw. unsigned  , default = 1
//Bit 23:16,        reg_dnr_vbof_edgethd                        , edge threshold (<=) for Up/Dw. unsigned  , default = 16
//Bit 15: 8,        reg_dnr_vbof_flatthd                        , flat threshold (>=) for Up/Dw. unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_vbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_vbof_statmod                        , statistic mode for vertical block offset, 0: count flags for 8-bin, 1: count Ups for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count Ups for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
#define P_DNR_GBS_STAT                             (volatile uint32_t *)0xff00b41c
//Bit 31:24,        reg_dnr_gbs_edgethd                         , edge threshold (<=) for LR  . unsigned  , default = 32
//Bit 23:16,        reg_dnr_gbs_flatthd                         , flat threshold (>=) for LR  . unsigned  , default = 0
//Bit 15: 8,        reg_dnr_gbs_varthd                          , variation threshold (<=) for Lvar/Rvar. unsigned  , default = 16
//Bit  7: 0,        reg_dnr_gbs_difthd                          , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
#define P_DNR_STAT_X_START_END                     (volatile uint32_t *)0xff00b420
//Bit 31:30,        reserved
//Bit 29:16,        reg_dnr_stat_xst                                                          . unsigned  , default = 24
//Bit 15:14,        reserved
//Bit 13: 0,        reg_dnr_stat_xed                                                          . unsigned  , default = HSIZE - 25
#define P_DNR_STAT_Y_START_END                     (volatile uint32_t *)0xff00b424
//Bit 31:30,        reserved
//Bit 29:16,        reg_dnr_stat_yst                                                          . unsigned  , default = 24
//Bit 15:14,        reserved
//Bit 13: 0,        reg_dnr_stat_yed                                                          . unsigned  , default = VSIZE - 25
#define P_DNR_LUMA                                 (volatile uint32_t *)0xff00b428
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_luma_sqrtshft                       , left shift for fast squart of chroma, [0, 4]. unsigned  , default = 2
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_luma_sqrtoffst                      , offset for fast squart of chroma. signed    , default = 0
//Bit 15,            reserved
//Bit 14:12,        reg_dnr_luma_wcmod                          , theta related to warm/cool segment line, 0: 0, 1: 45, 2: 90, 3: 135, 4: 180, 5: 225, 6: 270, 7: 315. . unsigned  , default = 3
//Bit 11: 8,        reg_dnr_luma_cshft                          , shift for calc. delta part, 0~8,  . unsigned  , default = 8
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_luma_cgain                          , final gain for delta part, 32 normalized to "1". unsigned  , default = 4
#define P_DNR_DB_YEDGE_THD                         (volatile uint32_t *)0xff00b42c
//Bit 31:24,        reg_dnr_db_yedgethd0                        , edge threshold0 for luma    . unsigned  , default = 12
//Bit 23:16,        reg_dnr_db_yedgethd1                        , edge threshold1 for luma    . unsigned  , default = 15
//Bit 15: 8,        reg_dnr_db_yedgethd2                        , edge threshold2 for luma    . unsigned  , default = 18
//Bit  7: 0,        reg_dnr_db_yedgethd3                        , edge threshold3 for luma    . unsigned  , default = 25
#define P_DNR_DB_CEDGE_THD                         (volatile uint32_t *)0xff00b430
//Bit 31:24,        reg_dnr_db_cedgethd0                        , edge threshold0 for chroma  . unsigned  , default = 12
//Bit 23:16,        reg_dnr_db_cedgethd1                        , edge threshold1 for chroma  . unsigned  , default = 15
//Bit 15: 8,        reg_dnr_db_cedgethd2                        , edge threshold2 for chroma  . unsigned  , default = 18
//Bit  7: 0,        reg_dnr_db_cedgethd3                        , edge threshold3 for chroma  . unsigned  , default = 25
#define P_DNR_DB_HGAP                              (volatile uint32_t *)0xff00b434
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_db_hgapthd                          , horizontal gap thd (<=) for very sure blockiness . unsigned  , default = 8
//Bit 15: 8,        reg_dnr_db_hgapdifthd                       , dif thd between hgap and lft/rgt hdifs. unsigned  , default = 1
//Bit  7: 1,        reserved
//Bit  0,            reg_dnr_db_hgapmod                          , horizontal gap calc. mode, 0: just use current col x, 1: find max between (x-1, x, x+1) . unsigned  , default = 0
#define P_DNR_DB_HBS                               (volatile uint32_t *)0xff00b438
//Bit 31: 6,        reserved
//Bit  5: 4,        reg_dnr_db_hbsup                            , horizontal bs up value      . unsigned  , default = 1
//Bit  3: 2,        reg_dnr_db_hbsmax                           , max value of hbs for global control. unsigned  , default = 3
//Bit  1: 0,        reg_dnr_db_hgbsthd                          , gbs thd (>=) for hbs calc.  . unsigned  , default = 1
#define P_DNR_DB_HACT                              (volatile uint32_t *)0xff00b43c
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_db_hactthd0                         , thd0 of hact, for block classification. unsigned  , default = 10
//Bit  7: 0,        reg_dnr_db_hactthd1                         , thd1 of hact, for block classification. unsigned  , default = 32
#define P_DNR_DB_YHDELTA_GAIN                      (volatile uint32_t *)0xff00b440
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_db_yhdeltagain1                     , (p1-q1) gain for Y's delta calc. when bs=1, normalized 8 as "1" . unsigned  , default = 2
//Bit 23,            reserved
//Bit 22:20,        reg_dnr_db_yhdeltagain2                     , (p1-q1) gain for Y's delta calc. when bs=2, normalized 8 as "1" . unsigned  , default = 0
//Bit 19,            reserved
//Bit 18:16,        reg_dnr_db_yhdeltagain3                     , (p1-q1) gain for Y's delta calc. when bs=3, normalized 8 as "1" . unsigned  , default = 0
//Bit 15,            reserved
//Bit 14: 8,        reg_dnr_db_yhdeltaadjoffst                  , offset for adjust Y's hdelta (-64, 63). signed    , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_db_yhdeltaadjgain                   , gain for adjust Y's hdelta, normalized 32 as "1" . unsigned  , default = 32
#define P_DNR_DB_YHDELTA2_GAIN                     (volatile uint32_t *)0xff00b444
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_yhdelta2gain2                    , gain for bs=2's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 8
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_db_yhdelta2offst2                   , offset for bs=2's adjust Y's hdelta2 (-16, 15). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_yhdelta2gain3                    , gain for bs=3's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_yhdelta2offst3                   , offset for bs=3's adjust Y's hdelta2 (-16, 15). signed    , default = 0
#define P_DNR_DB_CHDELTA_GAIN                      (volatile uint32_t *)0xff00b448
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_db_chdeltagain1                     , (p1-q1) gain for UV's delta calc. when bs=1, normalized 8 as "1". unsigned  , default = 2
//Bit 23,            reserved
//Bit 22:20,        reg_dnr_db_chdeltagain2                     , (p1-q1) gain for UV's delta calc. when bs=2, normalized 8 as "1". unsigned  , default = 0
//Bit 19,            reserved
//Bit 18:16,        reg_dnr_db_chdeltagain3                     , (p1-q1) gain for UV's delta calc. when bs=3, normalized 8 as "1". unsigned  , default = 0
//Bit 15,            reserved
//Bit 14: 8,        reg_dnr_db_chdeltaadjoffst                  , offset for adjust UV's hdelta (-64, 63). signed    , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_db_chdeltaadjgain                   , gain for adjust UV's hdelta, normalized 32 as "1". unsigned  , default = 32
#define P_DNR_DB_CHDELTA2_GAIN                     (volatile uint32_t *)0xff00b44c
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_chdelta2gain2                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 8
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_db_chdelta2offst2                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_chdelta2gain3                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_chdelta2offst3                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
#define P_DNR_DB_YC_VEDGE_THD                      (volatile uint32_t *)0xff00b450
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_db_yvedgethd                        , special Y's edge thd for vdb. unsigned  , default = 12
//Bit  7: 0,        reg_dnr_db_cvedgethd                        , special UV's edge thd for vdb. unsigned  , default = 12
#define P_DNR_DB_VBS_MISC                          (volatile uint32_t *)0xff00b454
//Bit 31:24,        reg_dnr_db_vgapthd                          , vertical gap thd (<=) for very sure blockiness . unsigned  , default = 8
//Bit 23:16,        reg_dnr_db_vactthd                          , thd of vact, for block classification . unsigned  , default = 10
//Bit 15: 8,        reg_dnr_db_vgapdifthd                       , dif thd between vgap and vact. unsigned  , default = 4
//Bit  7: 4,        reserved
//Bit  3: 2,        reg_dnr_db_vbsmax                           , max value of vbs for global control. unsigned  , default = 2
//Bit  1: 0,        reg_dnr_db_vgbsthd                          , gbs thd (>=) for vbs calc.  . unsigned  , default = 1
#define P_DNR_DB_YVDELTA_GAIN                      (volatile uint32_t *)0xff00b458
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_yvdeltaadjgain                   , gain for adjust Y's vdelta, normalized 32 as "1". unsigned  , default = 32
//Bit 23,            reserved
//Bit 22:16,        reg_dnr_db_yvdeltaadjoffst                  , offset for adjust Y's vdelta (-64, 63). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_yvdelta2gain                     , gain for adjust Y's vdelta2, normalized 64 as "1". unsigned  , default = 8
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_yvdelta2offst                    , offset for adjust Y's vdelta2 (-16, 15). signed    , default = 0
#define P_DNR_DB_CVDELTA_GAIN                      (volatile uint32_t *)0xff00b45c
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_cvdeltaadjgain                   , gain for adjust UV's vdelta, normalized 32 as "1". unsigned  , default = 32
//Bit 23,            reserved
//Bit 22:16,        reg_dnr_db_cvdeltaadjoffst                  , offset for adjust UV's vdelta (-64, 63). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_cvdelta2gain                     , gain for adjust UV's vdelta2, normalized 64 as "1". unsigned  , default = 8
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_cvdelta2offst                    , offset for adjust UV's vdelta2 (-16, 15). signed    , default = 0
#define P_DNR_RO_GBS_STAT_LR                       (volatile uint32_t *)0xff00b460
//Bit 31: 0,        ro_gbs_stat_lr                                                            . unsigned  , default = 0
#define P_DNR_RO_GBS_STAT_LL                       (volatile uint32_t *)0xff00b464
//Bit 31: 0,        ro_gbs_stat_ll                                                            . unsigned  , default = 0
#define P_DNR_RO_GBS_STAT_RR                       (volatile uint32_t *)0xff00b468
//Bit 31: 0,        ro_gbs_stat_rr                                                            . unsigned  , default = 0
#define P_DNR_RO_GBS_STAT_DIF                      (volatile uint32_t *)0xff00b46c
//Bit 31: 0,        ro_gbs_stat_dif                                                           . unsigned  , default = 0
#define P_DNR_RO_GBS_STAT_CNT                      (volatile uint32_t *)0xff00b470
//Bit 31: 0,        ro_gbs_stat_cnt                                                           . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_0                   (volatile uint32_t *)0xff00b474
//Bit 31: 0,        ro_hbof_stat_cnt0                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_1                   (volatile uint32_t *)0xff00b478
//Bit 31: 0,        ro_hbof_stat_cnt1                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_2                   (volatile uint32_t *)0xff00b47c
//Bit 31: 0,        ro_hbof_stat_cnt2                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_3                   (volatile uint32_t *)0xff00b480
//Bit 31: 0,        ro_hbof_stat_cnt3                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_4                   (volatile uint32_t *)0xff00b484
//Bit 31: 0,        ro_hbof_stat_cnt4                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_5                   (volatile uint32_t *)0xff00b488
//Bit 31: 0,        ro_hbof_stat_cnt5                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_6                   (volatile uint32_t *)0xff00b48c
//Bit 31: 0,        ro_hbof_stat_cnt6                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_7                   (volatile uint32_t *)0xff00b490
//Bit 31: 0,        ro_hbof_stat_cnt7                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_8                   (volatile uint32_t *)0xff00b494
//Bit 31: 0,        ro_hbof_stat_cnt8                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_9                   (volatile uint32_t *)0xff00b498
//Bit 31: 0,        ro_hbof_stat_cnt9                                                         . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_10                  (volatile uint32_t *)0xff00b49c
//Bit 31: 0,        ro_hbof_stat_cnt10                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_11                  (volatile uint32_t *)0xff00b4a0
//Bit 31: 0,        ro_hbof_stat_cnt11                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_12                  (volatile uint32_t *)0xff00b4a4
//Bit 31: 0,        ro_hbof_stat_cnt12                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_13                  (volatile uint32_t *)0xff00b4a8
//Bit 31: 0,        ro_hbof_stat_cnt13                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_14                  (volatile uint32_t *)0xff00b4ac
//Bit 31: 0,        ro_hbof_stat_cnt14                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_15                  (volatile uint32_t *)0xff00b4b0
//Bit 31: 0,        ro_hbof_stat_cnt15                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_16                  (volatile uint32_t *)0xff00b4b4
//Bit 31: 0,        ro_hbof_stat_cnt16                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_17                  (volatile uint32_t *)0xff00b4b8
//Bit 31: 0,        ro_hbof_stat_cnt17                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_18                  (volatile uint32_t *)0xff00b4bc
//Bit 31: 0,        ro_hbof_stat_cnt18                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_19                  (volatile uint32_t *)0xff00b4c0
//Bit 31: 0,        ro_hbof_stat_cnt19                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_20                  (volatile uint32_t *)0xff00b4c4
//Bit 31: 0,        ro_hbof_stat_cnt20                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_21                  (volatile uint32_t *)0xff00b4c8
//Bit 31: 0,        ro_hbof_stat_cnt21                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_22                  (volatile uint32_t *)0xff00b4cc
//Bit 31: 0,        ro_hbof_stat_cnt22                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_23                  (volatile uint32_t *)0xff00b4d0
//Bit 31: 0,        ro_hbof_stat_cnt23                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_24                  (volatile uint32_t *)0xff00b4d4
//Bit 31: 0,        ro_hbof_stat_cnt24                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_25                  (volatile uint32_t *)0xff00b4d8
//Bit 31: 0,        ro_hbof_stat_cnt25                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_26                  (volatile uint32_t *)0xff00b4dc
//Bit 31: 0,        ro_hbof_stat_cnt26                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_27                  (volatile uint32_t *)0xff00b4e0
//Bit 31: 0,        ro_hbof_stat_cnt27                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_28                  (volatile uint32_t *)0xff00b4e4
//Bit 31: 0,        ro_hbof_stat_cnt28                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_29                  (volatile uint32_t *)0xff00b4e8
//Bit 31: 0,        ro_hbof_stat_cnt29                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_30                  (volatile uint32_t *)0xff00b4ec
//Bit 31: 0,        ro_hbof_stat_cnt30                                                        . unsigned  , default = 0
#define P_DNR_RO_HBOF_STAT_CNT_31                  (volatile uint32_t *)0xff00b4f0
//Bit 31: 0,        ro_hbof_stat_cnt31                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_0                   (volatile uint32_t *)0xff00b4f4
//Bit 31: 0,        ro_vbof_stat_cnt0                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_1                   (volatile uint32_t *)0xff00b4f8
//Bit 31: 0,        ro_vbof_stat_cnt1                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_2                   (volatile uint32_t *)0xff00b4fc
//Bit 31: 0,        ro_vbof_stat_cnt2                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_3                   (volatile uint32_t *)0xff00b500
//Bit 31: 0,        ro_vbof_stat_cnt3                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_4                   (volatile uint32_t *)0xff00b504
//Bit 31: 0,        ro_vbof_stat_cnt4                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_5                   (volatile uint32_t *)0xff00b508
//Bit 31: 0,        ro_vbof_stat_cnt5                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_6                   (volatile uint32_t *)0xff00b50c
//Bit 31: 0,        ro_vbof_stat_cnt6                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_7                   (volatile uint32_t *)0xff00b510
//Bit 31: 0,        ro_vbof_stat_cnt7                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_8                   (volatile uint32_t *)0xff00b514
//Bit 31: 0,        ro_vbof_stat_cnt8                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_9                   (volatile uint32_t *)0xff00b518
//Bit 31: 0,        ro_vbof_stat_cnt9                                                         . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_10                  (volatile uint32_t *)0xff00b51c
//Bit 31: 0,        ro_vbof_stat_cnt10                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_11                  (volatile uint32_t *)0xff00b520
//Bit 31: 0,        ro_vbof_stat_cnt11                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_12                  (volatile uint32_t *)0xff00b524
//Bit 31: 0,        ro_vbof_stat_cnt12                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_13                  (volatile uint32_t *)0xff00b528
//Bit 31: 0,        ro_vbof_stat_cnt13                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_14                  (volatile uint32_t *)0xff00b52c
//Bit 31: 0,        ro_vbof_stat_cnt14                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_15                  (volatile uint32_t *)0xff00b530
//Bit 31: 0,        ro_vbof_stat_cnt15                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_16                  (volatile uint32_t *)0xff00b534
//Bit 31: 0,        ro_vbof_stat_cnt16                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_17                  (volatile uint32_t *)0xff00b538
//Bit 31: 0,        ro_vbof_stat_cnt17                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_18                  (volatile uint32_t *)0xff00b53c
//Bit 31: 0,        ro_vbof_stat_cnt18                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_19                  (volatile uint32_t *)0xff00b540
//Bit 31: 0,        ro_vbof_stat_cnt19                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_20                  (volatile uint32_t *)0xff00b544
//Bit 31: 0,        ro_vbof_stat_cnt20                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_21                  (volatile uint32_t *)0xff00b548
//Bit 31: 0,        ro_vbof_stat_cnt21                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_22                  (volatile uint32_t *)0xff00b54c
//Bit 31: 0,        ro_vbof_stat_cnt22                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_23                  (volatile uint32_t *)0xff00b550
//Bit 31: 0,        ro_vbof_stat_cnt23                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_24                  (volatile uint32_t *)0xff00b554
//Bit 31: 0,        ro_vbof_stat_cnt24                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_25                  (volatile uint32_t *)0xff00b558
//Bit 31: 0,        ro_vbof_stat_cnt25                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_26                  (volatile uint32_t *)0xff00b55c
//Bit 31: 0,        ro_vbof_stat_cnt26                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_27                  (volatile uint32_t *)0xff00b560
//Bit 31: 0,        ro_vbof_stat_cnt27                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_28                  (volatile uint32_t *)0xff00b564
//Bit 31: 0,        ro_vbof_stat_cnt28                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_29                  (volatile uint32_t *)0xff00b568
//Bit 31: 0,        ro_vbof_stat_cnt29                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_30                  (volatile uint32_t *)0xff00b56c
//Bit 31: 0,        ro_vbof_stat_cnt30                                                        . unsigned  , default = 0
#define P_DNR_RO_VBOF_STAT_CNT_31                  (volatile uint32_t *)0xff00b570
//Bit 31: 0,        ro_vbof_stat_cnt31                                                        . unsigned  , default = 0
#define P_DNR_DM_ADP_EN                            (volatile uint32_t *)0xff00b574
//Bit 31: 8        reserved
//Bit  7           reg_dnr_scene_change_flg    // unsigned , default = 1  , scence change flag for dnr(dm);
//Bit  6           reg_dnr_dm_lpf_en           // unsigned , default = 1  , enable lpf for demosquito filter
//Bit  5           reg_dnr_dm_adp_level_en     // unsigned , default = 1  , enable adaptive demosquito level
//Bit  4           reg_dnr_dm_flg2bdif_en      // unsigned , default = 1  , enable edge flg to blkdif calc.
//Bit  3: 2        reg_dnr_dm_edgeiir          // unsigned , default = 1  , edge flag iir mode, 0: cur, 1: max(pre, cur), 2: choice 0/1 by org mtn, 3: choice 0/1 by ref mtn
//Bit  1           reg_dnr_dm_dirdifmod        // unsigned , default = 1  , dif mode for direction calc, 0: abs(dif02), 1: (abs(dif01)+abs(dif21))/2
//Bit  0           reg_dnr_dm_sur_dir_mod      // unsigned , default = 0  , sure direction mode for cordif calc.
#define P_DNR_DM_EDGE_DIR                          (volatile uint32_t *)0xff00b578
//Bit 31:24        reserved
//Bit 23:16        reg_dnr_dm_dirdifcor        // unsigned , default = 2  , dif coring threshold for direction calc
//Bit 15: 8        reg_dnr_dm_edgecordifthd    // unsigned , default = 160  , edge flg down when cordif is large than threshold
//Bit  7: 0        reg_dnr_dm_mtnrt            // unsigned , default = 60  , motion ratio for mtn decision
#define P_DNR_DM_CTRL                              (volatile uint32_t *)0xff00b580
//Bit 31:13,        reserved
//Bit 12,            reg_dnr_dm_fedgeflg_en                      , enable edge flag calc. of each frame. unsigned  , default = 1
//Bit 11,            reg_dnr_dm_fedgeflg_cl                      , clear frame edge flag if needed. unsigned  , default = 1
//Bit 10,            reg_dnr_dm_fedgeflg_df                      , user defined edge when reg_dnr_dm_fedgeflg_en=0, default = 1
//Bit  9,            reg_dnr_dm_en                               , enable demosquito function  . unsigned  , default = 1
//Bit  8,            reg_dnr_dm_chrmen                           , enable chrome processing for demosquito. unsigned  , default = 1
//Bit  7: 6,        reg_dnr_dm_level                            , demosquito level            . unsigned  , default = 3
//Bit  5: 4,        reg_dnr_dm_leveldw0                         , level down when gbs is small. unsigned  , default = 1
//Bit  3: 2,        reg_dnr_dm_leveldw1                         , level down for no edge/flat blocks. unsigned  , default = 1
//Bit  1: 0,        reg_dnr_dm_gbsthd                           , small/large threshold for gbs (<=). unsigned  , default = 0
#define P_DNR_DM_NR_BLND                           (volatile uint32_t *)0xff00b584
//Bit 31:25,        reserved
//Bit 24,            reg_dnr_dm_defalpen                         , enable user define alpha for dm & nr blend. unsigned  , default = 0
//Bit 23:16,        reg_dnr_dm_defalp                           , user define alpha for dm & nr blend if enable. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_dm_alpgain                          , gain for nr/dm alpha, normalized 32 as "1". unsigned  , default = 32
//Bit  7: 0,        reg_dnr_dm_alpoffst                         , (-128, 127), offset for nr/dm alpha. signed    , default = 0
#define P_DNR_DM_RNG_THD                           (volatile uint32_t *)0xff00b588
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_dm_rngminthd                                                      . unsigned  , default = 2
//Bit 15: 8,        reg_dnr_dm_rngmaxthd                                                      . unsigned  , default = 64
//Bit  7: 0,        reg_dnr_dm_rngdifthd                                                      . unsigned  , default = 4
#define P_DNR_DM_RNG_GAIN_OFST                     (volatile uint32_t *)0xff00b58c
//Bit 31:14,        reserved
//Bit 13: 8,        reg_dnr_dm_rnggain                          , normalized 16 as "1"        . unsigned  , default = 16
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_dm_rngofst                                                        . unsigned  , default = 0
#define P_DNR_DM_DIR_MISC                          (volatile uint32_t *)0xff00b590
//Bit 31:30,        reserved
//Bit 29,            reg_dnr_dm_diralpen                                                       . unsigned  , default = 1
//Bit 28:24,        reg_dnr_dm_diralpgain                                                     . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_dnr_dm_diralpofst                                                     . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_diralpmin                                                      . unsigned  , default = 0
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_diralpmax                                                      . unsigned  , default = 31
#define P_DNR_DM_COR_DIF                           (volatile uint32_t *)0xff00b594
//Bit 31: 4,        reserved
//Bit  3: 1,        reg_dnr_dm_cordifshft                                                     . unsigned  , default = 3
//Bit  0,            reg_dnr_dm_cordifmod                        , 0:use max dir dif as cordif, 1: use max3x3 - min3x3 as cordif. unsigned  , default = 1
#define P_DNR_DM_FLT_THD                           (volatile uint32_t *)0xff00b598
//Bit 31:24,        reg_dnr_dm_fltthd00                         , block flat threshold0 for block average difference when gbs is small, for flat block detection. unsigned  , default = 4
//Bit 23:16,        reg_dnr_dm_fltthd01                         , block flat threshold1 for block average difference when gbs is small, for flat block detection. unsigned  , default = 6
//Bit 15: 8,        reg_dnr_dm_fltthd10                         , block flat threshold0 for block average difference when gbs is large, for flat block detection. unsigned  , default = 9
//Bit  7: 0,        reg_dnr_dm_fltthd11                         , block flat threshold1 for block average difference when gbs is large, for flat block detection. unsigned  , default = 12
#define P_DNR_DM_VAR_THD                           (volatile uint32_t *)0xff00b59c
//Bit 31:24,        reg_dnr_dm_varthd00                         , block variance threshold0 (>=) when gbs is small, for flat block detection. unsigned  , default = 2
//Bit 23:16,        reg_dnr_dm_varthd01                         , block variance threshold1 (<=) when gbs is small, for flat block detection. unsigned  , default = 15
//Bit 15: 8,        reg_dnr_dm_varthd10                         , block variance threshold0 (>=) when gbs is large, for flat block detection. unsigned  , default = 3
//Bit  7: 0,        reg_dnr_dm_varthd11                         , block variance threshold1 (<=) when gbs is large, for flat block detection. unsigned  , default = 24
#define P_DNR_DM_EDGE_DIF_THD                      (volatile uint32_t *)0xff00b5a0
//Bit 31:24,        reg_dnr_dm_edgethd0                         , block edge threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 32
//Bit 23:16,        reg_dnr_dm_edgethd1                         , block edge threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 48
//Bit 15: 8,        reg_dnr_dm_difthd0                          , block dif threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 48
//Bit  7: 0,        reg_dnr_dm_difthd1                          , block dif threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 64
#define P_DNR_DM_AVG_THD                           (volatile uint32_t *)0xff00b5a4
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_dm_avgthd0                          , block average threshold (>=), for flat block detection. unsigned  , default = 160
//Bit  7: 0,        reg_dnr_dm_avgthd1                          , block average threshold (<=), for flat block detection. unsigned  , default = 128
#define P_DNR_DM_AVG_VAR_DIF_THD                   (volatile uint32_t *)0xff00b5a8
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_dm_avgdifthd                        , block average dif threshold (<) between cur and up block, for flat block detection. unsigned  , default = 12
//Bit  7: 0,        reg_dnr_dm_vardifthd                        , block variance dif threshold (>=) between cur and up block, for flat block detection. unsigned  , default = 1
#define P_DNR_DM_VAR_EDGE_DIF_THD2                 (volatile uint32_t *)0xff00b5ac
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_dm_varthd2                          , block variance threshold (>=), for edge block detection. unsigned  , default = 24
//Bit 15: 8,        reg_dnr_dm_edgethd2                         , block edge threshold (>=), for edge block detection. unsigned  , default = 40
//Bit  7: 0,        reg_dnr_dm_difthd2                          , block dif threshold (>=), for edge block detection. unsigned  , default = 80
#define P_DNR_DM_DIF_FLT_MISC                      (volatile uint32_t *)0xff00b5b0
//Bit 31:28,        reg_dnr_dm_ldifoob                          , pre-defined large dif when pixel out of blocks. unsigned  , default = 0
//Bit 27:24,        reg_dnr_dm_bdifoob                          , pre-defined block dif when pixel out of blocks;. unsigned  , default = 0
//Bit 23:16,        reg_dnr_dm_fltalp                           , pre-defined alpha for dm and nr blending, when block is flat with mos.. unsigned  , default = 200
//Bit 15:12,        reserved
//Bit 11: 8,        reg_dnr_dm_fltminbdif                       , pre-defined min block dif for dm filter, when block is flat with mos.. unsigned  , default = 12
//Bit  7,            reserved
//Bit  6: 2,        reg_dnr_dm_difnormgain                      , gain for pixel dif normalization for dm filter, normalized 16 as "1". unsigned  , default = 16
//Bit  1,            reg_dnr_dm_difnormen                        , enable pixel dif normalization for dm filter. unsigned  , default = 1
//Bit  0,            reg_dnr_dm_difupden                         , enable block dif update using max of left, cur, right difs. unsigned  , default = 0
#define P_DNR_DM_SDIF_LUT0_2                       (volatile uint32_t *)0xff00b5b4
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut0                         , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut1                         , normally 0-16               . unsigned  , default = 14
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut2                         , normally 0-16               . unsigned  , default = 13
#define P_DNR_DM_SDIF_LUT3_5                       (volatile uint32_t *)0xff00b5b8
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut3                         , normally 0-16               . unsigned  , default = 10
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut4                         , normally 0-16               . unsigned  , default = 7
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut5                         , normally 0-16               . unsigned  , default = 5
#define P_DNR_DM_SDIF_LUT6_8                       (volatile uint32_t *)0xff00b5bc
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut6                         , normally 0-16               . unsigned  , default = 3
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut7                         , normally 0-16               . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut8                         , normally 0-16               . unsigned  , default = 0
#define P_DNR_DM_LDIF_LUT0_2                       (volatile uint32_t *)0xff00b5c0
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut0                         , normally 0-16               . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut1                         , normally 0-16               . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut2                         , normally 0-16               . unsigned  , default = 12
#define P_DNR_DM_LDIF_LUT3_5                       (volatile uint32_t *)0xff00b5c4
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut3                         , normally 0-16               . unsigned  , default = 14
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut4                         , normally 0-16               . unsigned  , default = 15
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut5                         , normally 0-16               . unsigned  , default = 16
#define P_DNR_DM_LDIF_LUT6_8                       (volatile uint32_t *)0xff00b5c8
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut6                         , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut7                         , normally 0-16               . unsigned  , default = 16
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut8                         , normally 0-16               . unsigned  , default = 16
#define P_DNR_DM_DIF2NORM_LUT0_2                   (volatile uint32_t *)0xff00b5cc
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut0                     , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut1                     , normally 0-16               . unsigned  , default = 5
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut2                     , normally 0-16               . unsigned  , default = 3
#define P_DNR_DM_DIF2NORM_LUT3_5                   (volatile uint32_t *)0xff00b5d0
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut3                     , normally 0-16               . unsigned  , default = 2
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut4                     , normally 0-16               . unsigned  , default = 2
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut5                     , normally 0-16               . unsigned  , default = 1
#define P_DNR_DM_DIF2NORM_LUT6_8                   (volatile uint32_t *)0xff00b5d4
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut6                     , normally 0-16               . unsigned  , default = 1
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut7                     , normally 0-16               . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut8                     , normally 0-16               . unsigned  , default = 1
#define P_DNR_DM_GMS_THD                           (volatile uint32_t *)0xff00b5d8
//Bit 31:16,        reserved
//Bit 15: 8,        reg_gms_stat_thd0                                                         . unsigned  , default = 0
//Bit  7: 0,        reg_gms_stat_thd1                                                         . unsigned  , default = 128
#define P_DNR_RO_DM_GMS_STAT_CNT                   (volatile uint32_t *)0xff00b5dc
//Bit 31: 0,        ro_dm_gms_stat_cnt                                                        . unsigned  , default = 0
#define P_DNR_RO_DM_GMS_STAT_MS                    (volatile uint32_t *)0xff00b5e0
//Bit 31: 0,        ro_dm_gms_stat_ms                                                        . unsigned  , default = 0
#define P_DNR_DM_EDGE_GAIN                         (volatile uint32_t *)0xff00b5e4
//Bit 31:24        reg_dnr_dm_alpedgegain0   // unsigned , default = 8  , edge based gain for alpha, normalized 16 as "1"
//Bit 23:16        reg_dnr_dm_alpedgegain1   // unsigned , default = 16  , edge based gain for alpha, normalized 16 as "1"
//Bit 15: 8        reg_dnr_dm_alpedgegain2   // unsigned , default = 24  , edge based gain for alpha, normalized 16 as "1"
//Bit  7: 0        reg_dnr_dm_alpedgegain3   // unsigned , default = 32  , edge based gain for alpha, normalized 16 as "1"
#define P_DNR_DM_FLG_BDIF                          (volatile uint32_t *)0xff00b5e8
//Bit 31:29        reserved
//Bit 28:24        reg_dnr_dm_flg2bdif0      // unsigned , default = 0  , (0-16), edge flg to blkdif calc.
//Bit 23:21        reserved
//Bit 20:16        reg_dnr_dm_flg2bdif1      // unsigned , default = 6  , (0-16), edge flg to blkdif calc.
//Bit 15:13        reserved
//Bit 12: 8        reg_dnr_dm_flg2bdif2      // unsigned , default = 10  , (0-16), edge flg to blkdif calc.
//Bit  7: 5        reserved
//Bit  4: 0        reg_dnr_dm_flg2bdif3      // unsigned , default = 12  , (0-16), edge flg to blkdif calc.
#define P_DNR_DM_GBS_RORM                          (volatile uint32_t *)0xff00b5ec
//Bit 31:16        reserved
//Bit 15:12        reg_dnr_dm_gbs4difnorm0   // unsigned , default = 0  , gbs=0 for dif norm calc.
//Bit 11: 8        reg_dnr_dm_gbs4difnorm1   // unsigned , default = 1  , gbs=1 for dif norm calc.
//Bit  7: 4        reg_dnr_dm_gbs4difnorm2   // unsigned , default = 4  , gbs=2 for dif norm calc.
//Bit  3: 0        reg_dnr_dm_gbs4difnorm3   // unsigned , default = 6  , gbs=3 for dif norm calc.
#define P_DNR_DM_FLG_LEV                           (volatile uint32_t *)0xff00b5f0
//Bit 31:14        reserved
//Bit 13:12        reg_dnr_dm_flg2lev0       // unsigned , default = 1  , edge flg to filter level calc.
//Bit 11:10        reserved
//Bit  9: 8        reg_dnr_dm_flg2lev1       // unsigned , default = 3  , edge flg to filter level calc.
//Bit  7: 6        reserved
//Bit  5: 4        reg_dnr_dm_flg2lev2       // unsigned , default = 3  , edge flg to filter level calc.
//Bit  3: 2        reserved
//Bit  1: 0        reg_dnr_dm_flg2lev3       // unsigned , default = 3  , edge flg to filter level calc.
#define P_DNR_DM_DIF_FLG_TH                        (volatile uint32_t *)0xff00b5f4
//Bit 31:16        reserved
//Bit 15: 8        reg_dnr_dm_dif2flgthd1    // unsigned , default = 128  , dif to edge flg threshold 1
//Bit  7: 0        reg_dnr_dm_dif2flgthd2    // unsigned , default = 192  , dif to edge flg threshold 2
#define P_DNR_DM_CALP_GAIN_OFST                    (volatile uint32_t *)0xff00b5f8
//Bit 31:22        reserved
//Bit 21:16        reg_dnr_dm_calpgain       // unsigned , default = 16  , chroma gain for nr/dm alpha, normalized 32 as "1"
//Bit 15: 9        reserved
//Bit  8: 0        reg_dnr_dm_calpoffst      // signed , default = -64  , (-255, 255), chroma offset for nr/dm alpha
// 0x80-0x90
//
// Reading file:  vpu_decomb_regs.h
//
    // defined registers
#define P_DECOMB_DET_VERT_CON0                     (volatile uint32_t *)0xff00b600
//Bit  31:24   reg_di_dcmb_det_vcon_thd0      default = 60  // u8
//Bit  23:16   reg_di_dcmb_det_vcon_thd1      default = 80  // u8
//Bit  15: 8   reg_di_dcmb_det_valp_lmt0      default = 63  // u8
//Bit   7: 0   reg_di_dcmb_det_valp_lmt1      default = 4   // u8
#define P_DECOMB_DET_VERT_CON1                     (volatile uint32_t *)0xff00b604
//Bit  23:16   reg_di_dcmb_det_valp_lmt2      default = 0   // u8
//Bit  15: 8   reg_di_dcmb_det_vrate0         default = 32  // u8
//Bit   7: 0   reg_di_dcmb_det_vrate1         default = 4   // u8
#define P_DECOMB_DET_EDGE_CON0                     (volatile uint32_t *)0xff00b608
//Bit  31:24   reg_di_dcmb_det_econ_thd0      default = 60  // u8
//Bit  23:16   reg_di_dcmb_det_econ_thd1      default = 80  // u8
//Bit  15: 8   reg_di_dcmb_det_ealp_lmt0      default = 63  // u8
//Bit   7: 0   reg_di_dcmb_det_ealp_lmt1      default = 4   // u8
#define P_DECOMB_DET_EDGE_CON1                     (volatile uint32_t *)0xff00b60c
//Bit  23:16   reg_di_dcmb_det_ealp_lmt2      default = 0   // u8
//Bit  15: 8   reg_di_dcmb_det_erate0         default = 32  // u8
//Bit   7: 0   reg_di_dcmb_det_erate1         default = 4  // u8
#define P_DECOMB_PARA                              (volatile uint32_t *)0xff00b610
//Bit  31:30   reserved
//Bit  29:28   reg_di_dcmb_cmb_lpf            default = 1  // u2, 0:no lpf, 1:[1 2 1], 2,3: [1 2 2 2 1]
//Bit  27:26   reg_di_dcmb_vedge_chk          default = 0  // u2, vertical edge check, 0: no check, 1: vrt!=0, 2: vrt==3
//Bit  25:24   reg_di_dcmb_nedge_chk          default = 0  // u2, no idea edge check, 0, no check, 1, check
//Bit  23:20   reg_di_dcmb_edge_min           default = 0   // u4, min edge for edge cmb
//Bit  19:16   reg_di_dcmb_edge_max           default = 15  // u4, min edge for edge cmb
//Bit   15:8   reg_di_dcmb_bld_alp            default = 255  // u8, user defined alpha for di & decmb blend
//Bit    7:0   reg_di_dcmb_bld_alp_beta       default = 40  // u8, beta for mtn & cmb blend, for bld alpha calc.
#define P_DECOMB_BLND_CON0                         (volatile uint32_t *)0xff00b614
//Bit  31:24   reg_di_dcmb_bld_con_thd0       default = 100  // u8
//Bit  23:16   reg_di_dcmb_bld_con_thd1       default = 120  // u8
//Bit  15: 8   reg_di_dcmb_bld_alp_lmt0       default = 0  // u8
//Bit   7: 0   reg_di_dcmb_bld_alp_lmt1       default = 128   // u8
#define P_DECOMB_BLND_CON1                         (volatile uint32_t *)0xff00b618
//Bit  23:16   reg_di_dcmb_bld_alp_lmt2       default = 255   // u8
//Bit  15: 8   reg_di_dcmb_bld_rate0          default = 32 // u8
//Bit   7: 0   reg_di_dcmb_bld_rate1          default = 32  // u8
#define P_DECOMB_YC_THRD                           (volatile uint32_t *)0xff00b61c
//Bit  31:16   reserved
//Bit  15: 8   reg_di_dcmb_ythd               default = 2 // u8, default = 2
//Bit   7: 0   reg_di_dcmb_cthd               default = 2 // u8, default = 2
#define P_DECOMB_MTN_GAIN_OFST                     (volatile uint32_t *)0xff00b620
//Bit  31:22   reserved
//Bit  21:16   reg_di_dcmb_mtn_alp_gain       default = 16  // u6, 16 is normalized to '1'
//Bit   15:9   reserved
//Bit    8:0   reg_di_dcmb_mtn_alp_ofst       default = 0  // s9, [-256, 255]
#define P_DECOMB_CMB_SEL_GAIN_OFST                 (volatile uint32_t *)0xff00b624
//Bit  31:22   reserved
//Bit  21:16   reg_di_dcmb_cmb_sel_gain       default = 48  // u6, 16 is normalized to '1'
//Bit   15:9   reserved
//Bit    8:0   reg_di_dcmb_cmb_sel_ofst       default = 0  // s9, [-256, 255]
#define P_DECOMB_WIND00                            (volatile uint32_t *)0xff00b628
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd00              default = 0 // u13, x0 for window 0, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd01              default = 719 // u13, x1 for window 0, HSIZE-1, software control
#define P_DECOMB_WIND01                            (volatile uint32_t *)0xff00b62c
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd02              default = 0 // u13, y0 for window 0, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd03              default = 39 // u13, y1 for window 0, software control
#define P_DECOMB_WIND10                            (volatile uint32_t *)0xff00b630
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd10              default = 0 // u13, x0 for window 1, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd11              default = 719 // u13, x1 for window 1, HSIZE-1, software control
#define P_DECOMB_WIND11                            (volatile uint32_t *)0xff00b634
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd12              default = 40 // u13, y0 for window 1, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd13              default = 239 // u13, y1 for window 1, VSIZE-1-40, software control
#define P_DECOMB_MODE                              (volatile uint32_t *)0xff00b638
//Bit  31:16   reserved
//Bit     15   reg_di_dcmb_is_cmb_bef         default = 1  // u1, 1: decide is_cmb before cmbing refine, 0: decide is_cmb after cmbing refine
//Bit     14   reg_di_dcmb_en0                default = 1 // u1, enable decmobing for wind0
//Bit     13   reg_di_dcmb_en1                default = 1 // u1, enable decmobing for wind1
//Bit     12   reg_di_dcmb_en2                default = 1 // u1, enable decmobing for wind2
//Bit  11:10   reg_di_dcmb_lpf_mod0           default = 2  // u2, get combing free pixels of wind0 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit    9:8   reg_di_dcmb_lpf_mod1           default = 2  // u2, get combing free pixels of wind1 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit    7:6   reg_di_dcmb_lpf_mod2           default = 0  // u2, get combing free pixels of wind2 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit      5   reg_di_dcmb_cmb_sel0           default = 1  // u1, wind0 decmb based on: 0, vertical cmb, 1, edge cmb
//Bit      4   reg_di_dcmb_cmb_sel1           default = 1  // u1, wind1 decmb based on: 0, vertical cmb, 1, edge cmb
//Bit      3   reg_di_dcmb_cmb_sel2           default = 0  // u1, wind2 decmb based on: 0, vertical cmb, 1, edge cmb
//Bit      2   reg_di_dcmb_alp_mod0           default = 1  // u1, wind0 decmb alpha based on: 0, user-defined, 1, motion adaptive
//Bit      1   reg_di_dcmb_alp_mod1           default = 1  // u1, wind1 decmb alpha based on: 0, user-defined, 1, motion adaptive
//Bit      0   reg_di_dcmb_alp_mod2           default = 1  // u1, wind2 decmb alpha based on: 0, user-defined, 1, motion adaptive
#define P_DECOMB_FRM_SIZE                          (volatile uint32_t *)0xff00b63c
//Bit  31:29   reserved
//Bit  28:16   hsize_in                       default = 1920  // u13, pic horizontal size in  unit: pixel
//Bit  15:13   reserved
//Bit   12:0   vsize_in                       default = 1080  // u13, pic vertical size in  unit: pixel
#define P_DECOMB_HV_BLANK                          (volatile uint32_t *)0xff00b640
//Bit  31:16   reserved
//Bit   15:8   hblank_num                     default = 20  // u8, horizontal blank time
//Bit    7:0   vblank_num                     default = 50  // u8, vertical blank time
//
// Closing file:  vpu_decomb_regs.h
//
// 0x98-0xa3
//
// Reading file:  vpu_nr2_dpolar_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR2_POLAR3_MODE                          (volatile uint32_t *)0xff00b660
//Bit 31:20        reserved
//Bit 19:18        reg_polar3_f02lpf_mod0    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vertical lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
//Bit 17:16        reg_polar3_f02lpf_mod1    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vertical lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
//Bit 15: 8        reg_polar3_dif02_thrd0    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
//Bit  7: 0        reg_polar3_dif02_thrd1    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
#define P_NR2_POLAR3_THRD                          (volatile uint32_t *)0xff00b664
//Bit 31:24        reg_polar3_txtf02_thrd0   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit 23:16        reg_polar3_txtf02_thrd1   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit 15: 8        reg_polar3_txtf1_thrd0    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit  7: 0        reg_polar3_txtf1_thrd1    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
#define P_NR2_POLAR3_PARA0                         (volatile uint32_t *)0xff00b668
//Bit 31:28        reg_polar3_rate00         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
//Bit 27:24        reg_polar3_rate01         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
//Bit 23:20        reg_polar3_rate10         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
//Bit 19:16        reg_polar3_rate11         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
//Bit 15:12        reg_polar3_rate20         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit 11: 8        reg_polar3_rate21         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit  7: 1        reserved
//Bit  0           reg_polar3_ro_reset       // unsigned , default = 0  reset signal of the polar3 read only registers
#define P_NR2_POLAR3_PARA1                         (volatile uint32_t *)0xff00b66c
//Bit 31:24        reg_polar3_rate30         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 23:16        reg_polar3_rate31         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 15:12        reg_polar3_ofst30         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 11: 8        reg_polar3_ofst31         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit  7: 4        reg_polar3_ofst20         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit  3: 0        reg_polar3_ofst21         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
#define P_NR2_POLAR3_CTRL                          (volatile uint32_t *)0xff00b670
//Bit 31:24        reg_polar3_ofst10         // signed , default = 1
//Bit 23:16        reg_polar3_ofst11         // signed , default = 1
//Bit 15: 8        reg_polar3_h_mute         // unsigned , default = 10  horizontal pixels to mute for left right sides for polar3 detection;
//Bit  7: 0        reg_polar3_v_mute         // unsigned , default = 10  vertical pixels to mute for top and bottom sides for polar3 detection;
#define P_NR2_RO_POLAR3_NUMOFPIX                   (volatile uint32_t *)0xff00b674
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_numofpix        // unsigned , default = 0  number of pixels detected as polar3
#define P_NR2_RO_POLAR3_SMOOTHMV                   (volatile uint32_t *)0xff00b678
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_smoothmv        // unsigned , default = 0  number of pixels with smooth mv, F(t) is close between avg of f(t-1) and f(t+1);
#define P_NR2_RO_POLAR3_M1                         (volatile uint32_t *)0xff00b67c
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_m1              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but in between [f(t-1), f(t+1)];
#define P_NR2_RO_POLAR3_P1                         (volatile uint32_t *)0xff00b680
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_p1              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but in between [f(t-1), f(t+1)];
#define P_NR2_RO_POLAR3_M2                         (volatile uint32_t *)0xff00b684
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_m2              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but out side of (f(t-1), f(t+1));
#define P_NR2_RO_POLAR3_P2                         (volatile uint32_t *)0xff00b688
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_p2              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but out side of (f(t-1), f(t+1));
#define P_NR2_RO_POLAR3_32                         (volatile uint32_t *)0xff00b68c
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_32              // unsigned , default = 0  number of pixels with F(t) far from [f(t-1),f(t+1)] and f(t-1) is close to f(t+1);
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_nr2_dpolar_regs.h
//
// 0xa4-0xf7 / 0xff
//
// Reading file:  vpu_nr4_regs.h
//
// synopsys translate_off
// synopsys translate_on
//========== nr4_drt_regs register begin ==========//
#define P_NR4_DRT_CTRL                             (volatile uint32_t *)0xff00b690
//Bit 31:24        reg_nr4_ydrt_3line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
//Bit 23:16        reg_nr4_ydrt_5line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
//Bit 15            reserved
//Bit 14:13        reg_nr4_drt_yhsad_mode         // unsigned , default = 1  mode for luma horizontal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
//Bit 12:11        reg_nr4_drt_chsad_mode         // unsigned , default = 1  mode for chroma horizontal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
//Bit 10           reg_nr4_drt_yhsad_hlpf         // unsigned , default = 1  hlpf for luma hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  9           reg_nr4_drt_yvsad_hlpf         // unsigned , default = 1  hlpf for luma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  8           reg_nr4_drt_ydsad_hlpf         // unsigned , default = 1  hlpf for luma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  7           reg_nr4_drt_chsad_hlpf         // unsigned , default = 1  hlpf for chrome hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  6           reg_nr4_drt_cvsad_hlpf         // unsigned , default = 1  hlpf for chroma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  5           reg_nr4_drt_cdsad_hlpf         // unsigned , default = 1  hlpf for chroma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  4           reg_nr4_ydrt_dif_mode          // unsigned , default = 1  0:y_dif, 1: y_dif + (u_dif + v_dif)/2
//Bit  3: 2        reg_nr4_cdrt_dif_mode          // unsigned , default = 2  0:(u_dif + v_dif), 1: y_dif/4 + (u_dif + v_dif)*3/4, 2:y_dif/2 + (u_dif + v_dif)/2, 3: y_dif (not recommended)
//Bit  1: 0        reserved
#define P_NR4_DRT_YSAD_GAIN                        (volatile uint32_t *)0xff00b694
//Bit 31:24        reg_nr4_ysad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
//Bit 23:16        reg_nr4_ysad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
//Bit 15: 8        reg_nr4_ysad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_drt_ysad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
#define P_NR4_DRT_CSAD_GAIN                        (volatile uint32_t *)0xff00b698
//Bit 31:24        reg_nr4_csad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
//Bit 23:16        reg_nr4_csad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
//Bit 15: 8        reg_nr4_csad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_drt_csad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
#define P_NR4_DRT_SAD_ALP_CORE                     (volatile uint32_t *)0xff00b69c
//Bit 31:24        reserved
//Bit 23:20        reg_nr4_ydrt_alp_core_rate     // unsigned , default = 0  luma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
//Bit 19:16        reg_nr4_cdrt_alp_core_rate     // unsigned , default = 0  chroma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_ydrt_alp_core_ofst     // unsigned , default = 10  luma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_cdrt_alp_core_ofst     // unsigned , default = 10  chroma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
#define P_NR4_DRT_ALP_MINMAX                       (volatile uint32_t *)0xff00b6a0
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_ydrt_alp_min           // unsigned , default = 0  luma min value of alpha, dft = 0
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_ydrt_alp_max           // unsigned , default = 63  luma max value of alpha, dft = 63
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_cdrt_alp_min           // unsigned , default = 0  chroma min value of alpha, dft = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_cdrt_alp_max           // unsigned , default = 63  chroma max value of alpha, dft = 63
//========== nr4_drt_regs register end ==========//
//========== nr4_snr_regs register begin ==========//
#define P_NR4_SNR_CTRL_REG                         (volatile uint32_t *)0xff00b6a4
//Bit 31:13        reserved
//Bit 12           reg_nr4_bet2_sel              // unsigned , default = 1
//Bit 11: 9        reg_nr4_snr2_sel_mode         // unsigned , default = 0  0: no filter, 1: adpgau, adp_drt_lpf blend; 2: adpgau, drt4_lpf blend; 3: adp_drt_lpf method, 4: drt4_lpf method, 5: adp_drt_                                                             //original image blend, 6: drt4_lpf, original image blend, 7: adpgau method; dft=1
//Bit  8           reg_nr4_snr2_gaulpf_mode      // unsigned , default = 1    0: 3*5 or 5*5 gaussian lpf;  1: 3*3 (window size) gaussian lpf;   dft=1
//Bit  7: 6        reg_nr4_snr2_alpha0_sad_mode  // unsigned , default = 3  0: max_sad*max_ssd;  1: max_sad*max_sad; 2: adp_max_sad*max_ssd; 3: adp_max_sad*adp_max_sad  dft=3
//Bit  5: 4        reg_nr4_snr2_alpha1_sad_mode  // unsigned , default = 2  0: max_sad;  1: cross_max_sad; 2 or 3: adp_sad  dft=2
//Bit  3: 2        reserved
//Bit  1: 0        reg_nr4_snr2_adp_drtlpf_mode  // unsigned , default = 3  0: adp_drtlpf [2 1 1]/4, 1: adp_drtlpf [4 2 1 1]/8; 2: adp_drtlpf [2 2 2 1 1]/8; 3: adp_drtlpf [7 7 7 6 5]/32;  dft=3;
#define P_NR4_SNR_ALPHA0_MAX_MIN                   (volatile uint32_t *)0xff00b6a8
//Bit 31:30        reserved
//Bit 29:23        reg_nr4_snr2_alp0_ymin    // unsigned , default = 127  normalized to 128 as '1'
//Bit 22:16        reg_nr4_snr2_alp0_ymax    // unsigned , default = 127  normalized to 128 as '1'
//Bit 15:14        reserved
//Bit 13: 7        reg_nr4_snr2_alp0_cmin    // unsigned , default = 127  normalized to 128 as '1'
//Bit  6: 0        reg_nr4_snr2_alp0_cmax    // unsigned , default = 127  normalized to 128 as '1'
#define P_NR4_ALP0C_ERR2CURV_LIMIT0                (volatile uint32_t *)0xff00b6ac
//Bit 31:24        reg_nr4_snr2_alp0_minerr_cpar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.
//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
#define P_NR4_ALP0C_ERR2CURV_LIMIT1                (volatile uint32_t *)0xff00b6b0
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel,   that we can do for texture region. 0~255.
#define P_NR4_ALP0Y_ERR2CURV_LIMIT0                (volatile uint32_t *)0xff00b6b4
//Bit 31:24        reg_nr4_snr2_alp0_minerr_ypar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.
//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
#define P_NR4_ALP0Y_ERR2CURV_LIMIT1                (volatile uint32_t *)0xff00b6b8
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel,  set to alp0 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for texture region. 0~255.
#define P_NR4_SNR_ALPA1_RATE_AND_OFST              (volatile uint32_t *)0xff00b6bc
//Bit 31:24        reserved
//Bit 23:18        reg_nr4_snr2_alp1_ycore_rate      // unsigned , default = 0    normalized 64 as "1"
//Bit 17:12        reg_nr4_snr2_alp1_ccore_rate      // unsigned , default = 0    normalized 64 as "1"
//Bit 11: 6        reg_nr4_snr2_alp1_ycore_ofst      // signed , default = 3    normalized 64 as "1"
//Bit  5: 0        reg_nr4_snr2_alp1_ccore_ofst      // signed , default = 3    normalized 64 as "1"
#define P_NR4_SNR_ALPHA1_MAX_MIN                   (volatile uint32_t *)0xff00b6c0
//Bit 31:24        reserved
//Bit 23:18        reg_nr4_snr2_alp1_ymin            // unsigned , default = 0    normalized to 64 as '1'
//Bit 17:12        reg_nr4_snr2_alp1_ymax            // unsigned , default = 63   normalized to 64 as '1'
//Bit 11: 6        reg_nr4_snr2_alp1_cmin            // unsigned , default = 0    normalized to 64 as '1'
//Bit  5: 0        reg_nr4_snr2_alp1_cmax            // unsigned , default = 63   normalized to 64 as '1'
#define P_NR4_ALP1C_ERR2CURV_LIMIT0                (volatile uint32_t *)0xff00b6c4
//Bit 31:24        reg_nr4_snr2_alp1_minerr_cpar0  // unsigned , default = 0    annel, this will be set value of flat region mierr that no need directional NR. 0~255.
//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar1  // unsigned , default = 24   hannel,this will be set value of texture region mierr that can not do directional NR. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar5  // unsigned , default = 0    a/chroma  channel. the larger of the value, the deep of the slope.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar6  // unsigned , default = 20   a/chroma  channel. the larger of the value, the deep of the slope. 0~255
#define P_NR4_ALP1C_ERR2CURV_LIMIT1                (volatile uint32_t *)0xff00b6c8
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar2  // unsigned , default = 0    will be set to alp1 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar3  // unsigned , default = 16   this will be set to alp1 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar4  // unsigned , default = 63   will be set to alp1 that we can do for texture region. 0~255.255 before
#define P_NR4_ALP1Y_ERR2CURV_LIMIT0                (volatile uint32_t *)0xff00b6cc
//Bit 31:24        reg_nr4_snr2_alp1_minerr_ypar0  // unsigned , default = 0    thra/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.
//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar1  // unsigned , default = 24   thra/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar5  // unsigned , default = 0    ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar6  // unsigned , default = 20   ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255
#define P_NR4_ALP1Y_ERR2CURV_LIMIT1                (volatile uint32_t *)0xff00b6d0
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar2  // unsigned , default = 0    lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar3  // unsigned , default = 16   levierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar4  // unsigned , default = 63   lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before
//========== nr4_snr_regs register end ==========//
//========== nr4_tnr_regs register begin ==========//
#define P_NR4_MTN_CTRL                             (volatile uint32_t *)0xff00b6d4
//Bit 31: 2        reserved
//Bit  1           reg_nr4_mtn_ref_en        // unsigned , default = 1  enable motion refinement, dft = 1
//Bit  0           reg_nr4_mtn_ref_bet_sel   // unsigned , default = 0  beta selection mode for motion refinement, 0: beta1, 1: beta2, dft = 0
#define P_NR4_MTN_REF_PAR0                         (volatile uint32_t *)0xff00b6d8
//Bit 31:24        reg_nr4_mtn_ref_par0      // unsigned , default = 24  par0 for beta to gain, dft =
//Bit 23:16        reg_nr4_mtn_ref_par1      // unsigned , default = 60  par1 for beta to gain, dft =
//Bit 15: 8        reg_nr4_mtn_ref_par2      // unsigned , default = 4  par2 for beta to gain, dft =
//Bit  7: 0        reg_nr4_mtn_ref_par3      // unsigned , default = 32  par3 for beta to gain, dft =
#define P_NR4_MTN_REF_PAR1                         (volatile uint32_t *)0xff00b6dc
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_mtn_ref_par4      // unsigned , default = 128  par4 for beta to gain, dft =
//Bit 15: 8        reg_nr4_mtn_ref_par5      // unsigned , default = 40  par5 for beta to gain, dft =
//Bit  7: 0        reg_nr4_mtn_ref_par6      // unsigned , default = 20  par6 for beta to gain, dft =
//========== nr4_tnr_regs register end ==========//
//========== nr4_mcnr_regs register begin ==========//
#define P_NR4_MCNR_LUMA_ENH_CTRL                   (volatile uint32_t *)0xff00b6e0
//Bit 31: 4        reserved
//Bit  3           reg_nr4_luma_plus_en           // unsigned , default = 1  enable luma enhancement, dft = 1
//Bit  2           reg_nr4_luma_plus_wt_mode      // unsigned , default = 1  luma weight calc mode, 0:sqrt(1+x^2), 1: 1+abs(x), dft = 0
//Bit  1: 0        reg_nr4_luma_plus_orient_mode  // unsigned , default = 1  0: only use previous orient for pre and cur luma plus, 1: 0: only use current orient for pre and cur luma plus
#define P_NR4_MCNR_LUMA_STAT_LIMTX                 (volatile uint32_t *)0xff00b6e4
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_luma_plus_xst        // unsigned , default = 8    start for luma plus statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_luma_plus_xed        // unsigned , default = 711  end for luma plus statistic, dft = HSIZE-8-1;
#define P_NR4_MCNR_LUMA_STAT_LIMTY                 (volatile uint32_t *)0xff00b6e8
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_luma_plus_yst          // unsigned , default = 8  start for luma plus statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_luma_plus_yed          // unsigned , default = 231  end for luma plus statistic, dft = VSIZE-8-1
#define P_NR4_MCNR_LUMA_DIF_CALC                   (volatile uint32_t *)0xff00b6ec
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_luma_plus_ugain        // unsigned , default = 8  U's gain for luma enhancement, 16 normalized as '1'
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_luma_plus_vgain        // unsigned , default = 8  V's gain for luma enhancement, 16 normalized as '1'
//Bit 15: 8        reg_nr4_luma_plus_ycor_thd     // unsigned , default = 2  Y coring threshold for difference calc., dft = 0
//Bit  7: 0        reg_nr4_luma_plus_ccor_thd     // unsigned , default = 0  C coring threshold for difference calc., dft = 0
#define P_NR4_MCNR_LUMAPRE_CAL_PRAM                (volatile uint32_t *)0xff00b6f0
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_pre_u_orient           // signed , default = 0  orientation of previous U, initial to 0, and will be updated by software
//Bit 23:18        reserved
//Bit 17:16        reg_nr4_pre_v_orient           // signed , default = 0  orientation of previous V, initial to 0, and will be updated by software
//Bit 15: 8        reg_nr4_pre_u_mean             // unsigned , default = 0  mean of previous U, initial to 0, and will be updated by software
//Bit  7: 0        reg_nr4_pre_v_mean             // unsigned , default = 0  mean of previousV, initial to 0, and will be updated by software
#define P_NR4_MCNR_LUMACUR_CAL_PRAM                (volatile uint32_t *)0xff00b6f4
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_cur_u_orient           // signed , default = 0  orientation of current U, initial to 0, and will be updated by software
//Bit 23:18        reserved
//Bit 17:16        reg_nr4_cur_v_orient           // signed , default = 0  orientation of current V, initial to 0, and will be updated by software
//Bit 15: 8        reg_nr4_cur_u_mean             // unsigned , default = 0  mean of current U, initial to 0, and will be updated by software
//Bit  7: 0        reg_nr4_cur_v_mean             // unsigned , default = 0  mean of current, initial to 0, and will be updated by software
#define P_NR4_MCNR_MV_CTRL_REG                     (volatile uint32_t *)0xff00b6f8
//Bit 31:14        reserved
//Bit 13:12        reg_nr4_sad_bitw          // unsigned , default = 2  sad bit width (8 + x) before clip to u8, dft = 1
//Bit 11: 4        reg_nr4_glb_gain          // unsigned , default = 64  global gain calc. by software, 64 is normalized as '1'
//Bit  3: 0        reg_nr4_mv_err_rsft       // unsigned , default = 8  right shift for mv err calc., dft = 9
#define P_NR4_MCNR_MV_GAIN0                        (volatile uint32_t *)0xff00b6fc
//Bit 31:28        reg_nr4_lftmvx_gain       // unsigned , default = 1  left mvx gain for err calc., dft = 1
//Bit 27:24        reg_nr4_lftmvy_gain       // unsigned , default = 1  left mvy gain for err calc., dft = 1
//Bit 23:20        reg_nr4_zmvx_gain         // unsigned , default = 5  zero mvx gain for err calc., dft = 2
//Bit 19:16        reg_nr4_zmvy_gain         // unsigned , default = 5  zero mvy gain for err calc., dft = 4
//Bit 15:12        reg_nr4_lmvx0_gain        // unsigned , default = 2  line mvx0 gain for err calc., dft = 1
//Bit 11: 8        reg_nr4_lmvx1_gain        // unsigned , default = 2  line mvx1 gain for err calc., dft = 1
//Bit  7: 4        reg_nr4_lmvy0_gain        // unsigned , default = 2  line mvy0 gain for err calc., dft = 1
//Bit  3: 0        reg_nr4_lmvy1_gain        // unsigned , default = 2  line mvy1 gain for err calc., dft = 1
#define P_NR4_MCNR_LMV_PARM                        (volatile uint32_t *)0xff00b700
//Bit 31:28        reg_nr4_lmv_rt0		         // unsigned , default = 3  ratio of max lmv
//Bit 27:24        reg_nr4_lmv_rt1		         // unsigned , default = 3  ratio of second max lmv
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_lmv_num_lmt0	     // unsigned , default = 16  lmv0 least/limit number of (total number - zero_bin)
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_lmv_num_lmt1	     // unsigned , default = 8  lmv1 least/limit number of (total number - zero_bin - max0)
//Bit  7: 2        reserved
//Bit  1: 0        reg_nr4_max_sad_rng       // unsigned , default = 1  search range of max2 sad in small region, dft = 1
#define P_NR4_MCNR_ALP0_REG                        (volatile uint32_t *)0xff00b704
//Bit 31:26        reserved
//Bit 25           reg_nr4_alp0_fail_chk     // unsigned , default = 1  enable check for alp0 fail status
//Bit 24           reg_nr4_bet0_coef_ref_en  // unsigned , default = 1  bet1 refinement by coef_blt
//Bit 23:16        reg_nr4_alp0_posad_gain   // unsigned , default = 255  the sad (norm) gain for pixel pointed by MV;
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_alp0_norm_mode    // unsigned , default = 0  alp0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_alp0_norm_gain    // unsigned , default = 16  alp0 gain for sad norm, '32' as '1', dft = 1
#define P_NR4_MCNR_ALP1_AND_BET0_REG               (volatile uint32_t *)0xff00b708
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_alp1_norm_mode    // unsigned , default = 3  alp1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_alp1_norm_gain    // unsigned , default = 3  alp1 gain for sad norm, '32' as '1', dft = 1
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_bet0_norm_mode    // unsigned , default = 3  bet0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bet0_norm_gain    // unsigned , default = 8  bet0 gain for sad norm, '32' as '1', dft = 1
#define P_NR4_MCNR_BET1_AND_BET2_REG               (volatile uint32_t *)0xff00b70c
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_bet1_norm_mode    // unsigned , default = 3  bet1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bet1_norm_gain    // unsigned , default = 8  bet1 gain for sad norm, '32' as '1', dft = 1
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_bet2_norm_mode    // unsigned , default = 0  bet2 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bet2_norm_gain    // unsigned , default = 16  bet2 gain for sad norm, '32' as '1', dft = 1
#define P_NR4_MCNR_AC_DC_CRTL                      (volatile uint32_t *)0xff00b710
//Bit 31:16        reserved
//Bit 15:12        reserved
//Bit 11           reg_nr4_dc_mode           // unsigned , default = 1  mode for dc selection,0: Y_lpf, 1: Y_lpf + (U_Lpf+V_lpf)/2,
//Bit 10           reg_nr4_ac_mode           // unsigned , default = 1  mode for ac selection, 0: Y_abs_dif, 1: Y_abs_dif + (U_abs_dif + V_abs_dif)/2
//Bit  9           reg_nr4_dc_sel            // unsigned , default = 0  selection mode for dc value, 0: 3x5, 1: 5x5, dft = 1
//Bit  8           reg_nr4_ac_sel            // unsigned , default = 0  selection mode for ac value, 0: 3x5, 1: 5x5, dft = 1
//Bit  7            reserved
//Bit  6: 4        reg_nr4_dc_shft           // unsigned , default = 2  right shift for dc value, dft = 2
//Bit  3            reserved
//Bit  2: 0        reg_nr4_ac_shft           // unsigned , default = 0  right shift for ac value, dft = 2
#define P_NR4_MCNR_CM_CTRL0                        (volatile uint32_t *)0xff00b714
//Bit 31:29        reserved
//Bit 28           reg_nr4_cm_skin_prc_bet0      // unsigned , default = 0  enable skin tone processing for mcnr bet0 calc., dft = 1
//Bit 27:26        reg_nr4_cm_chrm_sel           // unsigned , default = 1  chrome selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
//Bit 25:24        reg_nr4_cm_luma_sel           // unsigned , default = 1  luma selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
//Bit 23:21        reg_nr4_cm_skin_rshft_bet0    // unsigned , default = 3  right shift for bet0's skin color gains, dft = 3
//Bit 20           reg_nr4_cm_var_sel            // unsigned , default = 1  variation selection for color match, 0: 3x5, 1: 5x5 for 5lines, 3x5 for 3lines, dft = 1
//Bit 19           reg_nr4_cm_green_prc_bet0     // unsigned , default = 1  enable green processing for mcnr bet0 calc., dft = 1
//Bit 18:16        reg_nr4_cm_green_rshft_bet0   // unsigned , default = 4  right shift for bet0's green color gains, dft = 4
//Bit 15:14        reg_nr4_preflt_mod            // unsigned , default = 2  pre filter mode in mcnr, 0: mv pointed pixel, 1: bilater filter
//Bit 13:12        reg_nr4_alp1_mode             // unsigned , default = 1  mode for alpha1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad
//Bit 11:10        reserved
//Bit  9: 8        reg_nr4_bet0_mode             // unsigned , default = 0  mode for bet0's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
//Bit  7: 6        reserved
//Bit  5: 4        reg_nr4_bet1_mode             // unsigned , default = 2  mode for bet1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
//Bit  3: 2        reserved
//Bit  1: 0        reg_nr4_bet2_mode             // unsigned , default = 1  mode for bet2's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
#define P_NR4_MCNR_CM_PRAM                         (volatile uint32_t *)0xff00b718
//Bit 31:30        reserved
//Bit 29           reg_nr4_cm_blue_prc_alp0      // unsigned , default = 1  enable blue processing for mcnr alpha0 calc., dft = 1
//Bit 28           reg_nr4_cm_blue_prc_alp1      // unsigned , default = 1  enable blue processing for mcnr alpha1 calc., dft = 1
//Bit 27           reg_nr4_cm_skin_prc_alp0      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
//Bit 26           reg_nr4_cm_green_prc_alp0     // unsigned , default = 1  enable green processing for mcnr alpha0 clac., dft = 1
//Bit 25           reg_nr4_cm_skin_prc_alp1      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
//Bit 24           reg_nr4_cm_green_prc_alp1     // unsigned , default = 1  enable green processing for mcnr alpha1 clac., dft = 1
//Bit 23:20        reg_nr4_cm_blue_hue_st        // unsigned , default = 13  hue start of blue, dft =
//Bit 19:16        reg_nr4_cm_blue_hue_ed        // unsigned , default = 15  hue end  of blue, dft =
//Bit 15:12        reg_nr4_cm_green_hue_st       // unsigned , default = 7  hue start of green, dft =
//Bit 11: 8        reg_nr4_cm_green_hue_ed       // unsigned , default = 10  hue end  of green, dft =
//Bit  7: 4        reg_nr4_cm_skin_hue_st        // unsigned , default = 5  hue start of skin, dft =
//Bit  3: 0        reg_nr4_cm_skin_hue_ed        // unsigned , default = 6  hue end  of skin, dft =
#define P_NR4_MCNR_CM_RSHFT_ALP0                   (volatile uint32_t *)0xff00b71c
//Bit 31:28        reserved
//Bit 27:25        reg_nr4_cm_blue_rshft_bet0    // unsigned , default = 5  right shift for bet0's blue color gains, dft = 5
//Bit 24           reg_nr4_cm_blue_prc_bet0      // unsigned , default = 1  enable blue processing for mcnr bet0 calc., dft = 1
//Bit 23            reserved
//Bit 22:20        reg_nr4_cm_blue_rshft_alp0    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
//Bit 19            reserved
//Bit 18:16        reg_nr4_cm_blue_rshft_alp1    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
//Bit 15            reserved
//Bit 14:12        reg_nr4_cm_green_rshft_alp0   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
//Bit 11            reserved
//Bit 10: 8        reg_nr4_cm_green_rshft_alp1   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
//Bit  7            reserved
//Bit  6: 4        reg_nr4_cm_skin_rshft_alp0    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
//Bit  3            reserved
//Bit  2: 0        reg_nr4_cm_skin_rshft_alp1    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
#define P_NR4_MCNR_BLUE_CENT                       (volatile uint32_t *)0xff00b720
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_centx         // unsigned , default = 157  x coordinate of center of blue, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_blue_centy         // unsigned , default = 110  y coordinate of center of blue, dft =
#define P_NR4_MCNR_BLUE_GAIN_PAR0                  (volatile uint32_t *)0xff00b724
//Bit 31:24        reg_nr4_cm_blue_gain_par0   // unsigned , default = 32  par0 for blue gain, dft =
//Bit 23:16        reg_nr4_cm_blue_gain_par1   // unsigned , default = 255  par1 for blue gain, dft =
//Bit 15: 8        reg_nr4_cm_blue_gain_par2   // unsigned , default = 4  par2 for blue gain, dft =
//Bit  7: 0        reg_nr4_cm_blue_gain_par3   // unsigned , default = 32  par3 for blue gain, dft =
#define P_NR4_MCNR_BLUE_GAIN_PAR1                  (volatile uint32_t *)0xff00b728
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_gain_par4   // unsigned , default = 32  par4 for blue gain, dft =
//Bit 15: 8        reg_nr4_cm_blue_gain_par5   // unsigned , default = 32  par5 for blue gain, dft =
//Bit  7: 0        reg_nr4_cm_blue_gain_par6   // unsigned , default = 0  par6 for blue gain, dft =
#define P_NR4_MCNR_CM_BLUE_CLIP0                   (volatile uint32_t *)0xff00b72c
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_luma_min      // unsigned , default = 40  luma min for blue color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_blue_luma_max      // unsigned , default = 180  luma max for blue color matching, dft =
#define P_NR4_MCNR_CM_BLUE_CLIP1                   (volatile uint32_t *)0xff00b730
//Bit 31:24        reg_nr4_cm_blue_sat_min       // unsigned , default = 5  saturation min for blue color matching, dft =
//Bit 23:16        reg_nr4_cm_blue_sat_max       // unsigned , default = 255  saturation max for blue color matching, dft =
//Bit 15: 8        reg_nr4_cm_blue_var_min       // unsigned , default = 0  variation min for blue color matching, dft =
//Bit  7: 0        reg_nr4_cm_blue_var_max       // unsigned , default = 12  variation max for blue color matching, dft =
#define P_NR4_MCNR_GREEN_CENT                      (volatile uint32_t *)0xff00b734
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_centx         // unsigned , default = 114  x coordinate of center of green, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_green_centy         // unsigned , default = 126  y coordinate of center of green, dft =
#define P_NR4_MCNR_GREEN_GAIN_PAR0                 (volatile uint32_t *)0xff00b738
//Bit 31:24        reg_nr4_cm_green_gain_par0   // unsigned , default = 16  par0 for green gain, dft =
//Bit 23:16        reg_nr4_cm_green_gain_par1   // unsigned , default = 255  par1 for green gain, dft =
//Bit 15: 8        reg_nr4_cm_green_gain_par2   // unsigned , default = 255  par2 for green gain, dft =
//Bit  7: 0        reg_nr4_cm_green_gain_par3   // unsigned , default = 16  par3 for green gain, dft =
#define P_NR4_MCNR_GREEN_GAIN_PAR1                 (volatile uint32_t *)0xff00b73c
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_gain_par4   // unsigned , default = 16  par4 for green gain, dft =
//Bit 15: 8        reg_nr4_cm_green_gain_par5   // unsigned , default = 128  par5 for green gain, dft =
//Bit  7: 0        reg_nr4_cm_green_gain_par6   // unsigned , default = 0  par6 for green gain, dft =
#define P_NR4_MCNR_GREEN_CLIP0                     (volatile uint32_t *)0xff00b740
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_luma_min      // unsigned , default = 40  luma min for green color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_green_luma_max      // unsigned , default = 160  luma max for green color matching, dft =
#define P_NR4_MCNR_GREEN_CLIP2                     (volatile uint32_t *)0xff00b744
//Bit 31:24        reg_nr4_cm_green_sat_min       // unsigned , default = 4  saturation min for green color matching, dft =
//Bit 23:16        reg_nr4_cm_green_sat_max       // unsigned , default = 255  saturation max for green color matching, dft =
//Bit 15: 8        reg_nr4_cm_green_var_min       // unsigned , default = 0  variation min for green color matching, dft =
//Bit  7: 0        reg_nr4_cm_green_var_max       // unsigned , default = 12  variation max for green color matching, dft =
#define P_NR4_MCNR_SKIN_CENT                       (volatile uint32_t *)0xff00b748
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_centx         // unsigned , default = 112  x coordinate of center of skin tone, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_skin_centy         // unsigned , default = 149  y coordinate of center of skin tone, dft =
#define P_NR4_MCNR_SKIN_GAIN_PAR0                  (volatile uint32_t *)0xff00b74c
//Bit 31:24        reg_nr4_cm_skin_gain_par0   // unsigned , default = 20  par0 for skin gain, dft =
//Bit 23:16        reg_nr4_cm_skin_gain_par1   // unsigned , default = 255  par1 for skin gain, dft =
//Bit 15: 8        reg_nr4_cm_skin_gain_par2   // unsigned , default = 255  par2 for skin gain, dft =
//Bit  7: 0        reg_nr4_cm_skin_gain_par3   // unsigned , default = 8  par3 for skin gain, dft =
#define P_NR4_MCNR_SKIN_GAIN_PAR1                  (volatile uint32_t *)0xff00b750
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_gain_par4   // unsigned , default = 8  par4 for skin gain, dft =
//Bit 15: 8        reg_nr4_cm_skin_gain_par5   // unsigned , default = 128  par5 for skin gain, dft =
//Bit  7: 0        reg_nr4_cm_skin_gain_par6   // unsigned , default = 0  par6 for skin gain, dft =
#define P_NR4_MCNR_SKIN_CLIP0                      (volatile uint32_t *)0xff00b754
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_luma_min      // unsigned , default = 40  luma min for skin color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_skin_luma_max      // unsigned , default = 180  luma max for skin color matching, dft =
#define P_NR4_MCNR_SKIN_CLIP1                      (volatile uint32_t *)0xff00b758
//Bit 31:24        reg_nr4_cm_skin_sat_min       // unsigned , default = 5  saturation min for skin color matching, dft =
//Bit 23:16        reg_nr4_cm_skin_sat_max       // unsigned , default = 255  saturation max for skin color matching, dft =
//Bit 15: 8        reg_nr4_cm_skin_var_min       // unsigned , default = 0  variation min for skin color matching, dft =
//Bit  7: 0        reg_nr4_cm_skin_var_max       // unsigned , default = 12  variation max for skin color matching, dft =
#define P_NR4_MCNR_ALP1_GLB_CTRL                   (volatile uint32_t *)0xff00b75c
//Bit 31           reg_nr4_alp1_glb_gain_en     // unsigned , default = 0  alp1 adjust by global gain, dft = 1
//Bit 30:28        reg_nr4_alp1_glb_gain_lsft   // unsigned , default = 6  alp1 left shift before combine with global gain
//Bit 27           reg_nr4_bet0_glb_gain_en     // unsigned , default = 1  bet0 adjust by global gain, dft = 1
//Bit 26:24        reg_nr4_bet0_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
//Bit 23           reg_nr4_bet1_glb_gain_en     // unsigned , default = 0  bet1 adjust by global gain, dft = 0
//Bit 22:20        reg_nr4_bet1_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
//Bit 19           reg_nr4_bet2_glb_gain_en     // unsigned , default = 1  bet2 adjust by global gain, dft = 1
//Bit 18:16        reg_nr4_bet2_glb_gain_lsft   // unsigned , default = 6  bet2 left shift before combine with global gain
//Bit 15           reg_nr4_alp1_ac_en           // unsigned , default = 1  alp1 adjust by ac, dft = 1
//Bit 14:12        reg_nr4_alp1_ac_lsft         // unsigned , default = 5  alp1 left shift before combine with ac
//Bit 11           reg_nr4_bet0_ac_en           // unsigned , default = 0  bet0 adjust by ac, dft = 1
//Bit 10: 8        reg_nr4_bet0_ac_lsft         // unsigned , default = 5  bet0 left shift before combine with ac
//Bit  7           reg_nr4_bet1_ac_en           // unsigned , default = 0  bet1 adjust by ac, dft = 1
//Bit  6: 4        reg_nr4_bet1_ac_lsft         // unsigned , default = 5  bet1 left shift before combine with ac
//Bit  3           reg_nr4_bet2_ac_en           // unsigned , default = 0  bet2 adjust by ac, dft = 1
//Bit  2: 0        reg_nr4_bet2_ac_lsft         // unsigned , default = 5  bet2 left shift before combine with ac
#define P_NR4_MCNR_DC2NORM_LUT0                    (volatile uint32_t *)0xff00b760
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_dc2norm_lut0         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_dc2norm_lut1         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_dc2norm_lut2         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut3         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
#define P_NR4_MCNR_DC2NORM_LUT1                    (volatile uint32_t *)0xff00b764
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_dc2norm_lut4         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_dc2norm_lut5         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_dc2norm_lut6         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut7         // unsigned , default = 12  normal 0~16, dc to norm for alpha adjust, dft =
#define P_NR4_MCNR_DC2NORM_LUT2                    (volatile uint32_t *)0xff00b768
//Bit 31: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut8        // unsigned , default = 8   normal 0~16, dc to norm for alpha adjust, dft =
#define P_NR4_MCNR_AC2NORM_LUT0                    (volatile uint32_t *)0xff00b76c
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_ac2norm_lut0         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_ac2norm_lut1         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_ac2norm_lut2         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut3         // unsigned , default = 12  normal 0~16, ac to norm for alpha adjust, dft =
#define P_NR4_MCNR_AC2NORM_LUT1                    (volatile uint32_t *)0xff00b770
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_ac2norm_lut4         // unsigned , default = 4  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_ac2norm_lut5         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_ac2norm_lut6         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut7         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
#define P_NR4_MCNR_AC2NORM_LUT2                    (volatile uint32_t *)0xff00b774
//Bit 31: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut8         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
#define P_NR4_MCNR_SAD2ALP0_LUT0                   (volatile uint32_t *)0xff00b778
//Bit 31:24        reg_nr4_sad2alp0_lut0        // unsigned , default = 255  sad to alpha0 for temporal pixel value, dft = 255
//Bit 23:16        reg_nr4_sad2alp0_lut1        // unsigned , default = 252  sad to alpha0 for temporal pixel value, dft = 252
//Bit 15: 8        reg_nr4_sad2alp0_lut2        // unsigned , default = 249  sad to alpha0 for temporal pixel value, dft = 249
//Bit  7: 0        reg_nr4_sad2alp0_lut3        // unsigned , default = 235  sad to alpha0 for temporal pixel value, dft = 70
#define P_NR4_MCNR_SAD2ALP0_LUT1                   (volatile uint32_t *)0xff00b77c
//Bit 31:24        reg_nr4_sad2alp0_lut4        // unsigned , default = 185  sad to alpha0 for temporal pixel value, dft = 12
//Bit 23:16        reg_nr4_sad2alp0_lut5        // unsigned , default = 70  sad to alpha0 for temporal pixel value, dft = 1
//Bit 15: 8        reg_nr4_sad2alp0_lut6        // unsigned , default = 14  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut7        // unsigned , default = 1  sad to alpha0 for temporal pixel value, dft = 0
#define P_NR4_MCNR_SAD2ALP0_LUT2                   (volatile uint32_t *)0xff00b780
//Bit 31:24        reg_nr4_sad2alp0_lut8        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 23:16        reg_nr4_sad2alp0_lut9        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 15: 8        reg_nr4_sad2alp0_lut10       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut11       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
#define P_NR4_MCNR_SAD2ALP0_LUT3                   (volatile uint32_t *)0xff00b784
//Bit 31:24        reg_nr4_sad2alp0_lut12       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 23:16        reg_nr4_sad2alp0_lut13       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 15: 8        reg_nr4_sad2alp0_lut14       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut15       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
#define P_NR4_MCNR_SAD2ALP1_LUT0                   (volatile uint32_t *)0xff00b788
//Bit 31:24        reg_nr4_sad2alp1_lut0        // unsigned , default = 192  sad to alpha1 for temporal blending, dft = 128
//Bit 23:16        reg_nr4_sad2alp1_lut1        // unsigned , default = 160  sad to alpha1 for temporal blending, dft = 128
//Bit 15: 8        reg_nr4_sad2alp1_lut2        // unsigned , default = 128  sad to alpha1 for temporal blending, dft = 128
//Bit  7: 0        reg_nr4_sad2alp1_lut3        // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 64
#define P_NR4_MCNR_SAD2ALP1_LUT1                   (volatile uint32_t *)0xff00b78c
//Bit 31:24        reg_nr4_sad2alp1_lut4        // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 64
//Bit 23:16        reg_nr4_sad2alp1_lut5        // unsigned , default = 32  sad to alpha1 for temporal blending, dft = 128
//Bit 15: 8        reg_nr4_sad2alp1_lut6        // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut7        // unsigned , default = 8  sad to alpha1 for temporal blending, dft = 255
#define P_NR4_MCNR_SAD2ALP1_LUT2                   (volatile uint32_t *)0xff00b790
//Bit 31:24        reg_nr4_sad2alp1_lut8        // unsigned , default = 4  sad to alpha1 for temporal blending, dft = 255
//Bit 23:16        reg_nr4_sad2alp1_lut9        // unsigned , default = 0  sad to alpha1 for temporal blending, dft = 255
//Bit 15: 8        reg_nr4_sad2alp1_lut10       // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut11       // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 255
#define P_NR4_MCNR_SAD2ALP1_LUT3                   (volatile uint32_t *)0xff00b794
//Bit 31:24        reg_nr4_sad2alp1_lut12       // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 255
//Bit 23:16        reg_nr4_sad2alp1_lut13       // unsigned , default = 224  sad to alpha1 for temporal blending, dft = 255
//Bit 15: 8        reg_nr4_sad2alp1_lut14       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut15       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
#define P_NR4_MCNR_SAD2BET0_LUT0                   (volatile uint32_t *)0xff00b798
//Bit 31:24        reg_nr4_sad2bet0_lut0        // unsigned , default = 0  sad to beta0 for tnr and mcnr blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet0_lut1        // unsigned , default = 2  sad to beta0 for tnr and mcnr blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet0_lut2        // unsigned , default = 4  sad to beta0 for tnr and mcnr blending, dft = 4
//Bit  7: 0        reg_nr4_sad2bet0_lut3        // unsigned , default = 8  sad to beta0 for tnr and mcnr blending, dft = 8
#define P_NR4_MCNR_SAD2BET0_LUT1                   (volatile uint32_t *)0xff00b79c
//Bit 31:24        reg_nr4_sad2bet0_lut4        // unsigned , default = 16  sad to beta0 for tnr and mcnr blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet0_lut5        // unsigned , default = 32  sad to beta0 for tnr and mcnr blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet0_lut6        // unsigned , default = 48  sad to beta0 for tnr and mcnr blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet0_lut7        // unsigned , default = 64  sad to beta0 for tnr and mcnr blending, dft = 64
#define P_NR4_MCNR_SAD2BET0_LUT2                   (volatile uint32_t *)0xff00b7a0
//Bit 31:24        reg_nr4_sad2bet0_lut8        // unsigned , default = 80  sad to beta0 for tnr and mcnr blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet0_lut9        // unsigned , default = 96  sad to beta0 for tnr and mcnr blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet0_lut10       // unsigned , default = 112  sad to beta0 for tnr and mcnr blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet0_lut11       // unsigned , default = 128  sad to beta0 for tnr and mcnr blending, dft = 128
#define P_NR4_MCNR_SAD2BET0_LUT3                   (volatile uint32_t *)0xff00b7a4
//Bit 31:24        reg_nr4_sad2bet0_lut12       // unsigned , default = 196  sad to beta0 for tnr and mcnr blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet0_lut13       // unsigned , default = 224  sad to beta0 for tnr and mcnr blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet0_lut14       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet0_lut15       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 255
#define P_NR4_MCNR_SAD2BET1_LUT0                   (volatile uint32_t *)0xff00b7a8
//Bit 31:24        reg_nr4_sad2bet1_lut0        // unsigned , default = 0  sad to beta1 for deghost blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet1_lut1        // unsigned , default = 2  sad to beta1 for deghost blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet1_lut2        // unsigned , default = 4  sad to beta1 for deghost blending, dft = 4
//Bit  7: 0        reg_nr4_sad2bet1_lut3        // unsigned , default = 8  sad to beta1 for deghost blending, dft = 8
#define P_NR4_MCNR_SAD2BET1_LUT1                   (volatile uint32_t *)0xff00b7ac
//Bit 31:24        reg_nr4_sad2bet1_lut4        // unsigned , default = 16  sad to beta1 for deghost blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet1_lut5        // unsigned , default = 32  sad to beta1 for deghost blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet1_lut6        // unsigned , default = 48  sad to beta1 for deghost blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet1_lut7        // unsigned , default = 64  sad to beta1 for deghost blending, dft = 64
#define P_NR4_MCNR_SAD2BET1_LUT2                   (volatile uint32_t *)0xff00b7b0
//Bit 31:24        reg_nr4_sad2bet1_lut8        // unsigned , default = 80  sad to beta1 for deghost blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet1_lut9        // unsigned , default = 96  sad to beta1 for deghost blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet1_lut10       // unsigned , default = 112  sad to beta1 for deghost blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet1_lut11       // unsigned , default = 128  sad to beta1 for deghost blending, dft = 128
#define P_NR4_MCNR_SAD2BET1_LUT3                   (volatile uint32_t *)0xff00b7b4
//Bit 31:24        reg_nr4_sad2bet1_lut12       // unsigned , default = 160  sad to beta1 for deghost blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet1_lut13       // unsigned , default = 192  sad to beta1 for deghost blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet1_lut14       // unsigned , default = 224  sad to beta1 for deghost blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet1_lut15       // unsigned , default = 255  sad to beta1 for deghost blending, dft = 255
#define P_NR4_MCNR_SAD2BET2_LUT0                   (volatile uint32_t *)0xff00b7b8
//Bit 31:24        reg_nr4_sad2bet2_lut0        // unsigned , default = 0  sad to beta2 for snr and mcnr blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet2_lut1        // unsigned , default = 1  sad to beta2 for snr and mcnr blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet2_lut2        // unsigned , default = 2  sad to beta2 for snr and mcnr blending, dft  = 4
//Bit  7: 0        reg_nr4_sad2bet2_lut3        // unsigned , default = 4  sad to beta2 for snr and mcnr blending, dft = 8
#define P_NR4_MCNR_SAD2BET2_LUT1                   (volatile uint32_t *)0xff00b7bc
//Bit 31:24        reg_nr4_sad2bet2_lut4        // unsigned , default = 8  sad to beta2 for snr and mcnr blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet2_lut5        // unsigned , default = 16  sad to beta2 for snr and mcnr blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet2_lut6        // unsigned , default = 32  sad to beta2 for snr and mcnr blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet2_lut7        // unsigned , default = 48  sad to beta2 for snr and mcnr blending, dft = 64
#define P_NR4_MCNR_SAD2BET2_LUT2                   (volatile uint32_t *)0xff00b7c0
//Bit 31:24        reg_nr4_sad2bet2_lut8        // unsigned , default = 64  sad to beta2 for snr and mcnr blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet2_lut9        // unsigned , default = 80  sad to beta2 for snr and mcnr blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet2_lut10       // unsigned , default = 96  sad to beta2 for snr and mcnr blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet2_lut11       // unsigned , default = 112  sad to beta2 for snr and mcnr blending, dft = 128
#define P_NR4_MCNR_SAD2BET2_LUT3                   (volatile uint32_t *)0xff00b7c4
//Bit 31:24        reg_nr4_sad2bet2_lut12       // unsigned , default = 128  sad to beta2 for snr and mcnr blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet2_lut13       // unsigned , default = 160  sad to beta2 for snr and mcnr blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet2_lut14       // unsigned , default = 224  sad to beta2 for snr and mcnr blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet2_lut15       // unsigned , default = 255  sad to beta2 for snr and mcnr blending, dft = 255
#define P_NR4_MCNR_RO_U_SUM                        (volatile uint32_t *)0xff00b7c8
//Bit 31: 0        ro_nr4_u_sum                // unsigned , default = 0  sum of U of current field/frame
#define P_NR4_MCNR_RO_V_SUM                        (volatile uint32_t *)0xff00b7cc
//Bit 31: 0        ro_nr4_v_sum                // unsigned , default = 0  sum of V of current field/frame
#define P_NR4_MCNR_RO_GRDU_SUM                     (volatile uint32_t *)0xff00b7d0
//Bit 31: 0        ro_nr4_grdu_sum             // unsigned , default = 0  sum of gradient U of current field/frame
#define P_NR4_MCNR_RO_GRDV_SUM                     (volatile uint32_t *)0xff00b7d4
//Bit 31: 0        ro_nr4_grdv_sum             // unsigned , default = 0  sum of gradient V of current field/frame
#define P_NR4_TOP_CTRL                             (volatile uint32_t *)0xff00b7fc
//Bit 31:20        reg_gclk_ctrl                 // unsigned , default = 0
//Bit 19           reserved
//Bit 18           reg_nr4_mcnr_en              // unsigned , default = 1  ncnr enable or bypass, dft = 1
//Bit 17           reg_nr2_en                 // unsigned , default = 1  nr2 enable, dft = 1
//Bit 16           reg_nr4_en                   // unsigned , default = 1  nr4 enable, dft = 1
//Bit 15           reg_nr2_proc_en            // unsigned , default = 1
//Bit 14           reg_det3d_en               // unsigned , default = 1
//Bit 13           di_polar_en                   // unsigned , default = 1  do does not have in C
//Bit 12           reg_cfr_enable             // unsigned , default = 0  0-disable;  1:enable
//Bit 11: 9        reg_3dnr_enable_l          // unsigned , default = 7  b0: Y b1:U b2:V
//Bit  8: 6        reg_3dnr_enable_r          // unsigned , default = 7  b0: Y b1:U b2:V
//Bit  5           reg_nr4_lnbuf_ctrl           // unsigned , default = 1  line buf ctrl for nr4: 0, 3lines, 1, 5lines, dft = 1
//Bit  4           reg_nr4_snr2_en              // unsigned , default = 0  snr2 enable, 0: use old snr, 1: use new snr2,   dft = 1
//Bit  3           reg_nr4_scene_change_en      // unsigned , default = 1  enable scene change proc. dft = 1
//Bit  2           nr2_sw_en                     // unsigned , default = 1  do does not have in C
//Bit  1            reserved
//Bit  0           reg_nr4_scene_change_flg     // unsigned , default = 0  flags for scene change, dft = 0
//========== nr4_mcnr_regs register end ==========//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_nr4_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_dnr_regs.h
//
//========================================================================
//  VI_HIST_SPL register    (16'h2e00 - 16'h2eff)
//========================================================================
//
// Reading file:  vi_hist_spl_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VI_HIST_SPL 0x2e
// ----------------------------
// -----------------------------------------------
// REG_BASE:  VI_HIST_SPL_VCBUS_BASE = 0x2e
// -----------------------------------------------
//BIT 14: 34bin only, 0&255 and other 32bins
//Bit 13:11 hist_din_sel, 00: from vdin0 dout,  1: from vdin1, 2: from nr dout, 3: di output, 4: vpp output, 5: vd1_din, 6: vd2_din, 7:osd1_dout
//Bit 10:8   hist_din_comp_mux, mux of [29:22], [19:12], [9:2] for hist detect
//Bit 7:5   hist_dnlp_low   the real pixels in each bins got by VI_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define P_VI_HIST_CTRL                             (volatile uint32_t *)0xff00b800
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define P_VI_HIST_H_START_END                      (volatile uint32_t *)0xff00b804
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define P_VI_HIST_V_START_END                      (volatile uint32_t *)0xff00b808
//Bit 15:8  hist_max    maximum value
//Bit 7:0   hist_min    minimum value
//read only
#define P_VI_HIST_MAX_MIN                          (volatile uint32_t *)0xff00b80c
//Bit 31:0  hist_spl_rd
//counts for the total luma value
//read only
#define P_VI_HIST_SPL_VAL                          (volatile uint32_t *)0xff00b810
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define P_VI_HIST_SPL_PIX_CNT                      (volatile uint32_t *)0xff00b814
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value
//read only
#define P_VI_HIST_CHROMA_SUM                       (volatile uint32_t *)0xff00b818
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VI_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VI_DNLP_HIST00[15:0]  counts for the first  bin
//VI_DNLP_HIST00[31:16] counts for the second bin
//VI_DNLP_HIST01[15:0]  counts for the third  bin
//VI_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define P_VI_DNLP_HIST00                           (volatile uint32_t *)0xff00b81c
#define P_VI_DNLP_HIST01                           (volatile uint32_t *)0xff00b820
#define P_VI_DNLP_HIST02                           (volatile uint32_t *)0xff00b824
#define P_VI_DNLP_HIST03                           (volatile uint32_t *)0xff00b828
#define P_VI_DNLP_HIST04                           (volatile uint32_t *)0xff00b82c
#define P_VI_DNLP_HIST05                           (volatile uint32_t *)0xff00b830
#define P_VI_DNLP_HIST06                           (volatile uint32_t *)0xff00b834
#define P_VI_DNLP_HIST07                           (volatile uint32_t *)0xff00b838
#define P_VI_DNLP_HIST08                           (volatile uint32_t *)0xff00b83c
#define P_VI_DNLP_HIST09                           (volatile uint32_t *)0xff00b840
#define P_VI_DNLP_HIST10                           (volatile uint32_t *)0xff00b844
#define P_VI_DNLP_HIST11                           (volatile uint32_t *)0xff00b848
#define P_VI_DNLP_HIST12                           (volatile uint32_t *)0xff00b84c
#define P_VI_DNLP_HIST13                           (volatile uint32_t *)0xff00b850
#define P_VI_DNLP_HIST14                           (volatile uint32_t *)0xff00b854
#define P_VI_DNLP_HIST15                           (volatile uint32_t *)0xff00b858
#define P_VI_DNLP_HIST16                           (volatile uint32_t *)0xff00b85c
#define P_VI_DNLP_HIST17                           (volatile uint32_t *)0xff00b860
#define P_VI_DNLP_HIST18                           (volatile uint32_t *)0xff00b864
#define P_VI_DNLP_HIST19                           (volatile uint32_t *)0xff00b868
#define P_VI_DNLP_HIST20                           (volatile uint32_t *)0xff00b86c
#define P_VI_DNLP_HIST21                           (volatile uint32_t *)0xff00b870
#define P_VI_DNLP_HIST22                           (volatile uint32_t *)0xff00b874
#define P_VI_DNLP_HIST23                           (volatile uint32_t *)0xff00b878
#define P_VI_DNLP_HIST24                           (volatile uint32_t *)0xff00b87c
#define P_VI_DNLP_HIST25                           (volatile uint32_t *)0xff00b880
#define P_VI_DNLP_HIST26                           (volatile uint32_t *)0xff00b884
#define P_VI_DNLP_HIST27                           (volatile uint32_t *)0xff00b888
#define P_VI_DNLP_HIST28                           (volatile uint32_t *)0xff00b88c
#define P_VI_DNLP_HIST29                           (volatile uint32_t *)0xff00b890
#define P_VI_DNLP_HIST30                           (volatile uint32_t *)0xff00b894
#define P_VI_DNLP_HIST31                           (volatile uint32_t *)0xff00b898
#define P_VI_DNLP_HIST32                           (volatile uint32_t *)0xff00b89c
//Bit 28:16 hist_pic_height  active input data window height
//Bit 12:0  hist_pic_width   active input data window width
#define P_VI_HIST_PIC_SIZE                         (volatile uint32_t *)0xff00b8a0
//Bit 15:8 hist_pix_white_value: >= this value will be white pixel
//Bit 7:0 hist_pix_black_value: <= this value will be black pixel
#define P_VI_HIST_BLACK_WHITE_VALUE                (volatile uint32_t *)0xff00b8a4
#define P_VI_HIST_GCLK_CTRL                        (volatile uint32_t *)0xff00b8a8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vi_hist_spl_reg.h
//
//
// Reading file:  mcdi_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MCDI_VCBUS_BASE = 0x2f
// -----------------------------------------------
////=================================================================////
//// memc di core 0
////=================================================================////
#define P_MCDI_HV_SIZEIN                           (volatile uint32_t *)0xff00bc00
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_hsize               image horizontal size (number of cols)   default=1024
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_vsize               image vertical size   (number of rows)   default=1024
#define P_MCDI_HV_BLKSIZEIN                        (volatile uint32_t *)0xff00bc04
//Bit    31, reg_mcdi_vrev					 default = 0
//Bit    30, reg_mcdi_hrev					 default = 0
//Bit 29:28, reserved
//Bit 27:16, reg_mcdi_blkhsize               image horizontal blk size (number of cols)   default=1024
//Bit 15:13, reserved
//Bit 11: 0, reg_mcdi_blkvsize               image vertical blk size   (number of rows)   default=1024
#define P_MCDI_BLKTOTAL                            (volatile uint32_t *)0xff00bc08
//Bit 31:24, reserved
//Bit 23: 0, reg_mcdi_blktotal
#define P_MCDI_MOTINEN                             (volatile uint32_t *)0xff00bc0c
//Bit 31: 2, reserved
//Bit     1, reg_mcdi_motionrefen.           enable motion refinement of MA, default = 1
//Bit     0, reg_mcdi_motionparadoxen.       enable motion paradox detection, default = 1
#define P_MCDI_CTRL_MODE                           (volatile uint32_t *)0xff00bc10
//Bit 31:28, reserved
//Bit 27:26, reg_mcdi_lmvlocken	             0:disable, 1: use max Lmv, 2: use no-zero Lmv, lmv lock enable mode, default = 2			
//Bit 25,    reg_mcdi_reldetrptchken
//                                           0: unable; 1: enable, enable repeat pattern check (not repeat mv detection) in rel det part, default = 1
//Bit 24,    reg_mcdi_reldetgmvpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check in gmv lock mode for rel det, default = 1
//Bit 23,    reg_mcdi_pd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check (lock) function, default = 1
//Bit 22,    reg_mcdi_reldetlpfen
//                                           0: unable; 1: enable, enable det value lpf, default = 1
//Bit 21,    reg_mcdi_reldetlmvpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check in lmv lock mode for rel det, default = 1
//Bit 20,    reg_mcdi_reldetlmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
//Bit 19,    reg_mcdi_reldetgmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
//Bit 18,    reg_mcdi_reldetpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check for rel det refinement, default = 1
//Bit 17,    reg_mcdi_reldetfrqchken
//                                           0: unable; 1: enable, enable mv frequency check in rel det, default = 1
//Bit 16,    reg_mcdi_qmeen
//                                           0: unable; 1: enable, enable quarter motion estimation, default = 1
//Bit 15,    reg_mcdi_refrptmven
//                                           0: unable; 1: enable, use repeat mv in refinement, default = 1
//Bit 14,    reg_mcdi_refgmven
//                                           0: unable; 1: enable, use gmv in refinement, default = 1
//Bit 13,    reg_mcdi_reflmven
//                                           0: unable; 1: enable, use lmvs in refinement, default = 1
//Bit 12,    reg_mcdi_refnmven
//                                           0: unable; 1: enable, use neighoring mvs in refinement, default = 1
//Bit 11,    reserved
//Bit 10,    reg_mcdi_referrfrqchken		
//                                           0: unable; 1: enable, enable mv frequency check while finding min err in ref, default = 1
//Bit 9,     reg_mcdi_refen					
//                                           0: unable; 1: enable, enable mv refinement, default = 1
//Bit 8,     reg_mcdi_horlineen				
//                                           0: unable; 1: enable,enable horizontal lines detection by sad map, default = 1
//Bit 7,     reg_mcdi_highvertfrqdeten		
//                                           0: unable; 1: enable, enable high vertical frequency pattern detection, default = 1
//Bit 6,     reg_mcdi_gmvlocken				
//                                           0: unable; 1: enable, enable gmv lock mode, default = 1
//Bit 5,     reg_mcdi_rptmven	
//                                           0: unable; 1: enable, enable repeat pattern detection, default = 1
//Bit 4,     reg_mcdi_gmven
//                                           0: unable; 1: enable, enable global motion estimation, default = 1
//Bit 3,     reg_mcdi_lmven
//                                           0: unable; 1: enable, enable line mv estimation for hme, default = 1
//Bit 2,     reg_mcdi_chkedgeen		
//                                           0: unable; 1: enable, enable check edge function, default = 1
//Bit 1,     reg_mcdi_txtdeten			
//                                           0: unable; 1: enable, enable texture detection, default = 1
//Bit 0,     reg_mcdi_memcen
//                                           0: unable; 1: enable, enable of memc di, default = 1
#define P_MCDI_UNI_MVDST                           (volatile uint32_t *)0xff00bc14
//Bit 31:20, reserved
//Bit 19:17, reg_mcdi_unimvdstabsseg0                     segment0 for uni-mv abs, default = 1
//Bit 16:12, reg_mcdi_unimvdstabsseg1                     segment1 for uni-mv abs, default = 15
//Bit 11: 8, reg_mcdi_unimvdstabsdifgain0	          2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2
//Bit  7: 5, reg_mcdi_unimvdstabsdifgain1                 2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2
//Bit  4: 2, reg_mcdi_unimvdstabsdifgain2                 2/2, gain2 of uni-mv abs dif beyond segment1, normalized 2 to '1', default = 2
//Bit  1: 0, reg_mcdi_unimvdstsgnshft		          shift for neighboring distance of uni-mv, default = 0
#define P_MCDI_BI_MVDST                            (volatile uint32_t *)0xff00bc18
//Bit 31:20, reserved
//Bit 19:17, reg_mcdi_bimvdstabsseg0                      segment0 for bi-mv abs, default = 1
//Bit 16:12, reg_mcdi_bimvdstabsseg1                      segment1 for bi-mv abs, default = 9
//Bit 11: 8, reg_mcdi_bimvdstabsdifgain0	          6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6
//Bit  7: 5, reg_mcdi_bimvdstabsdifgain1                  3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3
//Bit  4: 2, reg_mcdi_bimvdstabsdifgain2                  2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2
//Bit  1: 0, reg_mcdi_bimvdstsgnshft	                  shift for neighboring distance of bi-mv, default = 0
#define P_MCDI_SAD_GAIN                            (volatile uint32_t *)0xff00bc1c
//Bit 31:19, reserved
//Bit 18:17, reg_mcdi_unisadcorepxlgain                   uni-sad core pixels gain, default = 3
//Bit 16,    reg_mcdi_unisadcorepxlnormen                 enable uni-sad core pixels normalization, default = 0
//Bit 15:11, reserved
//Bit 10: 9, reg_mcdi_bisadcorepxlgain                    bi-sad core pixels gain, default = 3
//Bit  8,    reg_mcdi_bisadcorepxlnormen                  enable bi-sad core pixels normalization, default = 1
//Bit  7: 3, reserved
//Bit  2: 1, reg_mcdi_biqsadcorepxlgain                   bi-qsad core pixels gain, default = 3
//Bit  0,    reg_mcdi_biqsadcorepxlnormen                 enable bi-qsad core pixels normalization, default = 1
#define P_MCDI_TXT_THD                             (volatile uint32_t *)0xff00bc20
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_txtminmaxdifthd,                    min max dif threshold (>=) for texture detection, default = 24
//Bit 15: 8, reg_mcdi_txtmeandifthd,                      mean dif threshold (<) for texture detection, default = 9
//Bit  7: 3, reserved
//Bit  2: 0, reg_mcdi_txtdetthd,                          texture detecting threshold, 0~4, default = 2
#define P_MCDI_FLT_MODESEL                         (volatile uint32_t *)0xff00bc24
//Bit 31	 reserved
//Bit 30:28, reg_mcdi_flthorlineselmode                   mode for horizontal line detecting flat calculation, default = 1, same as below
//Bit 27	 reserved
//Bit 26:24, reg_mcdi_fltgmvselmode                       mode for gmv flat calculation, default = 4, same as below
//Bit 23,	 reserved
//Bit 22:20, reg_mcdi_fltsadselmode                       mode for sad flat calculation, default = 2, same as below
//Bit 19,	 reserved
//Bit 18:16, reg_mcdi_fltbadwselmode                      mode for badw flat calculation, default = 3, same as below
//Bit 15,	 reserved
//Bit 14:12, reg_mcdi_fltrptmvselmode                     mode for repeat mv flat calculation, default = 4, same as below
//Bit 11,	 reserved
//Bit 10: 8, reg_mcdi_fltbadrelselmode                    mode for bad rel flat calculation, default = 4, same as below
//Bit  7,	 reserved
//Bit  6: 4, reg_mcdi_fltcolcfdselmode                    mode for col cfd flat calculation, default = 2, same as below
//Bit  3,	 reserved
//Bit  2: 0, reg_mcdi_fltpd22chkselmode                   mode for pd22 check flat calculation, default = 2, # 0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v, 4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre)
#define P_MCDI_CHK_EDGE_THD                        (volatile uint32_t *)0xff00bc28
//Bit 23:28, reserved.
//Bit 27:24, reg_mcdi_chkedgedifsadthd.                   thd (<=) for sad dif check, 0~8, default = 1
//Bit 23:16, reserved.
//Bit 15:12, reg_mcdi_chkedgemaxedgethd.                  max drt of edge, default = 15
//Bit 11: 8, reg_mcdi_chkedgeminedgethd.                  min drt of edge, default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_chkedgevdifthd.                     thd for vertical dif in check edge, default = 14
#define P_MCDI_CHK_EDGE_GAIN_OFFST                 (volatile uint32_t *)0xff00bc2c
//Bit 31:24, reserved.
//Bit 23:20, reg_mcdi_chkedgedifthd1.                     thd1 for edge dif check (<=), default = 4
//Bit 19:16, reg_mcdi_chkedgedifthd0.                     thd0 for edge dif check (>=), default = 15
//Bit   :15, reserved.
//Bit 14:10, reg_mcdi_chkedgechklen.                      total check length for edge check, 1~24 (>0), default = 24
//Bit  9: 8, reg_mcdi_chkedgeedgesel.                     final edge select mode, 0: original start edge, 1: lpf start edge, 2: original start+end edge, 3: lpf start+end edge, default = 1
//Bit  7: 3, reg_mcdi_chkedgesaddstgain.                  distance gain for sad calc while getting edges, default = 4
//Bit     2, reg_mcdi_chkedgechkmode.                     edge used in check mode, 0: original edge, 1: lpf edge, default = 1
//Bit     1, reg_mcdi_chkedgestartedge.                   edge mode for start edge, 0: original edge, 1: lpf edge, default = 0
//Bit     0, reg_mcdi_chkedgeedgelpf.                     edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0
#define P_MCDI_LMV_RT                              (volatile uint32_t *)0xff00bc30
//BIt 31:15, reserved
//Bit 14:12, reg_mcdi_lmvvalidmode                        valid mode for lmv calc., 100b: use char det, 010b: use flt, 001b: use hori flg
//Bit 11:10, reg_mcdi_lmvgainmvmode                       four modes of mv selection for lmv weight calculation, default = 1
//                                                        0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1); 2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3); 3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2);
//Bit  9,    reg_mcdi_lmvinitmode                         initial lmvs at first row of input field, 0: initial value = 0; 1: initial = 32 (invalid), default = 0
//Bit  8,    reserved
//Bit  7: 4, reg_mcdi_lmvrt0                              ratio of max mv, default = 5
//Bit  3: 0, reg_mcdi_lmvrt1                              ratio of second max mv, default = 5
#define P_MCDI_LMV_GAINTHD                         (volatile uint32_t *)0xff00bc34
//Bit 31:24, reg_mcdi_lmvvxmaxgain                        max gain of lmv weight, default = 96
//Bit 23,    reserved
//Bit 22:20, reg_mcdi_lmvdifthd0                          dif threshold 0 (<) for small lmv, default = 1
//Bit 19:17, reg_mcdi_lmvdifthd1                          dif threshold 1 (<) for median lmv, default = 2
//Bit 16:14, reg_mcdi_lmvdifthd2                          dif threshold 2 (<) for large lmv, default = 3
//Bit 13: 8, reg_mcdi_lmvnumlmt                           least/limit number of (total number - max0), default = 20
//Bit  7: 0, reg_mcdi_lmvfltthd                           flt cnt thd (<) for lmv, default = 9
#define P_MCDI_RPTMV_THD0                          (volatile uint32_t *)0xff00bc38
//Bit 31:25, reg_mcdi_rptmvslpthd2			  slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64
//Bit 24:20, reg_mcdi_rptmvslpthd1                        slope thd (>=) between i and i+2/i-2, default = 4
//Bit 19:10, reg_mcdi_rptmvampthd2                        amplitude thd (>=) between max and min, when count cycles, default = 300
//Bit  9: 0, reg_mcdi_rptmvampthd1                        amplitude thd (>=) between average of max and min, default = 400
#define P_MCDI_RPTMV_THD1                          (volatile uint32_t *)0xff00bc3c
//Bit 31:28, reserved
//Bit 27:25, reg_mcdi_rptmvcyccntthd                      thd (>=) of total cycles count, default = 2
//Bit 24:21, reg_mcdi_rptmvcycdifthd                      dif thd (<) of cycles length, default = 3
//Bit 20:18, reg_mcdi_rptmvcycvldthd                      thd (>) of valid cycles number, default = 1
//Bit 17:15, reg_mcdi_rptmvhalfcycminthd                  min length thd (>=) of half cycle, default = 2
//Bit 14:11, reg_mcdi_rptmvhalfcycdifthd                  neighboring half cycle length dif thd (<), default = 5
//Bit 10: 8, reg_mcdi_rptmvminmaxcntthd                   least number of valid max and min, default = 2
//Bit  7: 5, reg_mcdi_rptmvcycminthd                      min length thd (>=) of cycles, default = 2
//Bit  4: 0, reg_mcdi_rptmvcycmaxthd                      max length thd (<) of cycles, default = 17
#define P_MCDI_RPTMV_THD2                          (volatile uint32_t *)0xff00bc40
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_rptmvhdifthd0                       higher hdif thd (>=) (vertical edge) for rpt detection, default = 8
//Bit 15: 8, reg_mcdi_rptmvhdifthd1                       hdif thd (>=) (slope edge) for rpt detection, default = 4
//Bit  7: 0, reg_mcdi_rptmvvdifthd                        vdif thd (>=) (slope edge) for rpt detection, default = 1
#define P_MCDI_RPTMV_SAD                           (volatile uint32_t *)0xff00bc44
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_rptmvsaddifthdgain                  7x3x(16/16), gain for sad dif thd in rpt mv detection, 0~672, normalized 16 as '1', default = 336
//Bit 15:10, reserved
//Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst                 offset for sad dif thd in rpt mv detection, -512~511, default = 16
#define P_MCDI_RPTMV_FLG                           (volatile uint32_t *)0xff00bc48
//Bit 31:18,  reserved
//Bit 17:16,  reg_mcdi_rptmvmode                          select mode of mvs for repeat motion estimation, 0: hmv, 1: qmv/2, 2 or 3: qmv/4, default = 2
//Bit 15: 8,  reg_mcdi_rptmvflgcntthd                     thd (>=) of min count number for rptmv of whole field, for rptmv estimation, default = 64
//Bit  7: 5,  reserved
//Bit  4: 0,  reg_mcdi_rptmvflgcntrt                      4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32,
#define P_MCDI_RPTMV_GAIN                          (volatile uint32_t *)0xff00bc4c
//Bit 31:24, reg_mcdi_rptmvlftgain                        up repeat mv gain for hme, default = 96
//Bit 23:16, reg_mcdi_rptmvuplftgain                      up left repeat mv gain for hme, default = 32
//Bit 15: 8, reg_mcdi_rptmvupgain                         up repeat mv gain for hme, default = 64
//Bit  7: 0, reg_mcdi_rptmvuprightgain                    up right repeat mv gain for hme, default = 32
#define P_MCDI_GMV_RT                              (volatile uint32_t *)0xff00bc50
//Bit 31,    reserved
//Bit 30:24, reg_mcdi_gmvmtnrt0                           ratio 0 for motion senario, set 127 to 128, normalized 128 as '1', default =32
//Bit 23,    reserved
//Bit 22:16, reg_mcdi_gmvmtnrt1                           ratio 1 for motion senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit 15,    reserved
//Bit 14: 8, reg_mcdi_gmvstlrt0                           ratio 0 for still senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit  7,    reserved
//Bit  6: 0, reg_mcdi_gmvstlrt1                           ratio 1 for still senario, set 127 to 128, normalized 128 as '1', default = 80
#define P_MCDI_GMV_GAIN                            (volatile uint32_t *)0xff00bc54
//Bit 31:25, reg_mcdi_gmvzeromvlockrt0                    ratio 0 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 100
//Bit 24:18, reg_mcdi_gmvzeromvlockrt1                    ratio 1 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 112
//Bit 17:16, reg_mcdi_gmvvalidmode                        valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3
//Bit 15: 8, reg_mcdi_gmvvxgain                           gmv's vx gain when gmv locked for hme, default = 0
//Bit  7: 0, reg_mcdi_gmvfltthd                           flat thd (<) for gmv calc. default = 3
#define P_MCDI_HOR_SADOFST                         (volatile uint32_t *)0xff00bc58
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_horsaddifthdgain                    21*1/8, gain/divisor for sad dif threshold in hor line detection, normalized 8 as '1', default = 21
//Bit 15: 8, reg_mcdi_horsaddifthdoffst                   offset for sad dif threshold in hor line detection, -128~127, default = 0
//Bit  7: 0, reg_mcdi_horvdifthd                          threshold (>=) of vertical dif of next block for horizontal line detection, default = 24
#define P_MCDI_REF_MV_NUM                          (volatile uint32_t *)0xff00bc5c
//Bit 31: 2, reserved
//Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0
#define P_MCDI_REF_BADW_THD_GAIN                   (volatile uint32_t *)0xff00bc60
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_refbadwcnt2gain.   gain for badwv count num==3, default = 6
//Bit 23:20, reg_mcdi_refbadwcnt1gain.   gain for badwv count num==2, default = 3
//Bit 19:16, reg_mcdi_refbadwcnt0gain.   gain for badwv count num==1, default = 1
//Bit 15:12, reg_mcdi_refbadwthd3.       threshold 3 for detect badweave with largest average luma, default = 4
//Bit 11: 8, reg_mcdi_refbadwthd2.       threshold 2 for detect badweave with third smallest average luma, default = 3
//Bit  7: 4, reg_mcdi_refbadwthd1.       threshold 1 for detect badweave with second smallest average luma, default = 2
//Bit  3: 0, reg_mcdi_refbadwthd0.       threshold 0 for detect badweave with smallest average luma, default = 1
#define P_MCDI_REF_BADW_SUM_GAIN                   (volatile uint32_t *)0xff00bc64
//Bit 31:13, reserved
//Bit 12: 8, reg_mcdi_refbadwsumgain0.   sum gain for r channel, 0~16, default = 8
//Bit  7: 5, reserved
//Bit     4, reg_mcdi_refbadwcalcmode.   mode for badw calculation, 0:sum, 1:max, default = 0
//Bit  3: 0, reserved
#define P_MCDI_REF_BS_THD_GAIN                     (volatile uint32_t *)0xff00bc68
//Bit 31:28, reg_mcdi_refbsudgain1.      up & down block strength gain1, normalized to 8 as '1', default = 2
//Bit 27:24, reg_mcdi_refbsudgain0.      up & down block strength gain0, normalized to 8 as '1', default = 4
//Bit 23:19, reserved
//Bit 18:16, reg_mcdi_refbslftgain.      left block strength gain, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_refbsthd1.         threshold 1 for detect block strength in refinment, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_refbsthd0.         threshold 0 for detect block strength in refinment, default = 8
#define P_MCDI_REF_ERR_GAIN0                       (volatile uint32_t *)0xff00bc6c
//Bit    31, reserved
//Bit 30:24, reg_mcdi_referrnbrdstgain.            neighoring mv distances gain for err calc. in ref, normalized to 8 as '1', default = 48
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_referrbsgain.                bs gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit    15, reserved
//Bit 14: 8, reg_mcdi_referrbadwgain.              badw gain for err calc. in ref, normalized to 8 as '1', default = 64
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrsadgain.               sad gain for err calc. in ref, normalized to 8 as '1', default = 4
#define P_MCDI_REF_ERR_GAIN1                       (volatile uint32_t *)0xff00bc70
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_referrchkedgegain.           check edge gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_referrlmvgain.               (locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrgmvgain.               (locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0
#define P_MCDI_REF_ERR_FRQ_CHK                     (volatile uint32_t *)0xff00bc74
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_referrfrqgain.               gain for mv frequency, normalized to 4 as '1', default = 10
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_referrfrqmax.                max gain for mv frequency check, default = 31
//Bit    15, reserved
//Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.         mv dif threshold 2 (<) for mv frequency check, default = 3
//Bit    11, reserved
//Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.         mv dif threshold 1 (<) for mv frequency check, default = 2
//Bit     7, reserved
//Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.         mv dif threshold 0 (<) for mv frequency check, default = 1
//Bit  3: 0, reserved
#define P_MCDI_QME_LPF_MSK                         (volatile uint32_t *)0xff00bc78
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.           lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_qmebslpfmsk0.                lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.              lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_qmesadlpfmsk0.               lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
#define P_MCDI_REL_DIF_THD_02                      (volatile uint32_t *)0xff00bc7c
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldifthd2.                  thd (<) for (hdif+vdif), default = 9
//Bit 15: 8, reg_mcdi_reldifthd1.                  thd (<) for (vdif), default = 5
//Bit  7: 0, reg_mcdi_reldifthd0.                  thd (>=) for (hdif-vdif), default = 48
#define P_MCDI_REL_DIF_THD_34                      (volatile uint32_t *)0xff00bc80
//Bit 31:16, reserved.
//Bit 15: 8, reg_mcdi_reldifthd4.                  thd (<) for (hdif), default = 255
//Bit  7: 0, reg_mcdi_reldifthd3.                  thd (>=) for (vdif-hdif), default = 48
#define P_MCDI_REL_BADW_GAIN_OFFST_01              (volatile uint32_t *)0xff00bc84
//Bit 31:24, reg_mcdi_relbadwoffst1.               offset for badw adj, for flat block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain1.                gain for badw adj, for flat block, default = 128
//Bit 15: 8, reg_mcdi_relbadwoffst0.               offset for badw adj, for vertical block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain0.                gain for badw adj, for vertical block, default = 160
#define P_MCDI_REL_BADW_GAIN_OFFST_23              (volatile uint32_t *)0xff00bc88
//Bit 31:24, reg_mcdi_relbadwoffst3.               offset for badw adj, for other block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain3.                gain for badw adj, for other block, default = 48
//Bit 15: 8, reg_mcdi_relbadwoffst2.               offset for badw adj, for horizontal block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain2.                gain for badw adj, for horizontal block, default = 48
#define P_MCDI_REL_BADW_THD_GAIN_OFFST             (volatile uint32_t *)0xff00bc8c
//Bit 31:23, reserved.
//Bit 22:16, reg_mcdi_relbadwoffst.                offset for badw thd adj, -64~63, default = 0
//Bit 15: 8, reserved.
//Bit  7: 0, reg_mcdi_relbadwthdgain.              gain0 for badw thd adj, normalized to 16 as '1', default = 16
#define P_MCDI_REL_BADW_THD_MIN_MAX                (volatile uint32_t *)0xff00bc90
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_relbadwthdmax.               max for badw thd adj, default = 256
//Bit  7: 0, reg_mcdi_relbadwthdmin.               min for badw thd adj, default = 16
#define P_MCDI_REL_SAD_GAIN_OFFST_01               (volatile uint32_t *)0xff00bc94
//Bit 31:24, reg_mcdi_relsadoffst1.                offset for sad adj, for flat block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain1.                 gain for sad adj, for flat block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst0.                offset for sad adj, for vertical block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain0.                 gain for sad adj, for vertical block, normalized to 8 as '1', default = 6
#define P_MCDI_REL_SAD_GAIN_OFFST_23               (volatile uint32_t *)0xff00bc98
//Bit 31:24, reg_mcdi_relsadoffst3.                offset for sad adj, for other block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain3.                 gain for sad adj, for other block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst2.                offset for sad adj, for horizontal block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain2.                 gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12
#define P_MCDI_REL_SAD_THD_GAIN_OFFST              (volatile uint32_t *)0xff00bc9c
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_relsadoffst.                 offset for sad thd adj, -128~127, default = 0
//Bit 15:10, reserved.
//Bit  9: 0, reg_mcdi_relsadthdgain.               gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42
#define P_MCDI_REL_SAD_THD_MIN_MAX                 (volatile uint32_t *)0xff00bca0
//Bit 31:27, reserved.
//Bit 26:16, reg_mcdi_relsadthdmax.                max for sad thd adj, 21*32, default = 672
//Bit 15: 9, reserved.
//Bit  8: 0, reg_mcdi_relsadthdmin.                min for sad thd adj, 21*2, default = 42
#define P_MCDI_REL_DET_GAIN_00                     (volatile uint32_t *)0xff00bca4
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain0.               gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1', default = 8
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain0.             gain0 (gmv locked) for badw, for det. calc. normalized to 16 as '1', default = 12
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain0.              gain0 (gmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define P_MCDI_REL_DET_GAIN_01                     (volatile uint32_t *)0xff00bca8
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain0.          gain0 (gmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain0.           gain0 (gmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
#define P_MCDI_REL_DET_GAIN_10                     (volatile uint32_t *)0xff00bcac
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain1.               gain1 (lmv locked) for bs, for det. calc. normalized to 16 as '1', default = 0
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain1.             gain1 (lmv locked) for badw, for det. calc. normalized to 16 as '1', default = 8
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain1.              gain1 (lmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define P_MCDI_REL_DET_GAIN_11                     (volatile uint32_t *)0xff00bcb0
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain1.          gain1 (lmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 0
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain1.           gain1 (lmv locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 24
#define P_MCDI_REL_DET_GAIN_20                     (volatile uint32_t *)0xff00bcb4
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain2.               gain2 (no locked) for bs, for det. calc. normalized to 16 as '1', default = 12
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain2.             gain2 (no locked) for badw, for det. calc. normalized to 16 as '1', default = 32
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain2.              gain2 (no locked) for qsad, for det. calc. normalized to 16 as '1', default = 16
#define P_MCDI_REL_DET_GAIN_21                     (volatile uint32_t *)0xff00bcb8
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_reldetoffst.                 offset for rel calculation, for det. calc. -512~511,  default = 0
//Bit 15:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain2.          gain2 (no locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 10
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain2.           gain2 (no locked) for neighoring dist, for det. calc. normalized to 16 as '1', default = 32
#define P_MCDI_REL_DET_GMV_DIF_CHK                 (volatile uint32_t *)0xff00bcbc
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetgmvfltthd.             flat thd (>=) for gmv lock decision, default = 0
//Bit    15, reserved.
//Bit 14:12, reg_mcdi_reldetgmvdifthd.             dif thd (>=) for current mv different from gmv for gmv dif check, actually used in Lmv lock check, default = 3
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetgmvdifmin.             min mv dif for gmv dif check, default = 1, note: dif between reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min should be; 0,1,3,7, not work for others
//Bit  7: 4, reg_mcdi_reldetgmvdifmax.             max mv dif for gmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetgmvdifmvmode.          mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0
#define P_MCDI_REL_DET_LMV_DIF_CHK                 (volatile uint32_t *)0xff00bcc0
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetlmvfltthd.             flat thd (>=) for lmv lock decision, default = 12
//Bit 15:14, reserved.
//Bit 13:12, reg_mcdi_reldetlmvlockchkmode.        lmv lock check mode, 0:cur Lmv, 1: cur & (last | next), 2: last & cur & next Lmv, default = 1
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetlmvdifmin.             min mv dif for lmv dif check, default = 1, note: dif between reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be; 0,1,3,7, not work for others
//Bit  7: 4, reg_mcdi_reldetlmvdifmax.             max mv dif for lmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetlmvdifmvmode.          mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0
#define P_MCDI_REL_DET_FRQ_CHK                     (volatile uint32_t *)0xff00bcc4
//Bit 31:12, reserved.
//Bit 11: 8, reg_mcdi_reldetfrqgain.               gain for frequency check, normalized to 4 as '1', default = 10
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetfrqmax.                max value for frequency check, default = 31
#define P_MCDI_REL_DET_PD22_CHK                    (volatile uint32_t *)0xff00bcc8
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_reldetpd22chkoffst.          offset for pd22 check happened, default = 512
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetpd22chkgain.           gain for pd22 check happened, normalized to 8 as '1', default = 12
#define P_MCDI_REL_DET_RPT_CHK_ROW                 (volatile uint32_t *)0xff00bccc
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_reldetrptchkendrow.          end row (<) number for repeat check, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_reldetrptchkstartrow.        start row (>=) number for repeat check, default = 0
#define P_MCDI_REL_DET_RPT_CHK_GAIN_QMV            (volatile uint32_t *)0xff00bcd0
//Bit 31:30, reserved
//Bit 29:24, reg_mcdi_reldetrptchkqmvmax.          max thd (<) of abs qmv for repeat check, default = 15, note that quarter mv's range is -63~63
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_reldetrptchkqmvmin.          min thd (>=) of abs qmv for repeat check, default = 10, note that quarter mv's range is -63~63
//Bit    15, reserved/
//Bit 14: 4, reg_mcdi_reldetrptchkoffst.           offset for repeat check, default = 512
//Bit  3: 0, reg_mcdi_reldetrptchkgain.            gain for repeat check, normalized to 8 as '1', default = 4
#define P_MCDI_REL_DET_RPT_CHK_THD_0               (volatile uint32_t *)0xff00bcd4
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.      zero sad thd (<) for repeat check, default = 255
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.     zero badw thd (>=) for repeat check, default = 16
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.       frequency dif thd (<) for repeat check, 0~10, default = 5
#define P_MCDI_REL_DET_RPT_CHK_THD_1               (volatile uint32_t *)0xff00bcd8
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.         vertical dif thd (<) for repeat check, default = 16
//Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.         horizontal dif thd (>=) for repeat check, default = 16
#define P_MCDI_REL_DET_LPF_DIF_THD                 (volatile uint32_t *)0xff00bcdc
//Bit 31:24, reg_mcdi_reldetlpfdifthd3.            hdif thd (<) for lpf selection of horizontal block, default = 9
//Bit 23:16, reg_mcdi_reldetlpfdifthd2.            vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48
//Bit 15: 8, reg_mcdi_reldetlpfdifthd1.            vdif thd (<) for lpf selection of vertical block, default = 9
//Bit  7: 0, reg_mcdi_reldetlpfdifthd0.            hdif-vdif thd (>=) for lpf selection of vertical block, default = 48
#define P_MCDI_REL_DET_LPF_MSK_00_03               (volatile uint32_t *)0xff00bce0
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk03.              det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk02.              det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk01.              det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk00.              det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8
#define P_MCDI_REL_DET_LPF_MSK_04_12               (volatile uint32_t *)0xff00bce4
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk12.              det lpf mask12 for vertical blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk11.              det lpf mask11 for vertical blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk10.              det lpf mask10 for vertical blocks, 0~16, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk04.              det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1
#define P_MCDI_REL_DET_LPF_MSK_13_21               (volatile uint32_t *)0xff00bce8
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk21.              det lpf mask21 for horizontal blocks, 0~16, default = 6
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk20.              det lpf mask20 for horizontal blocks, 0~16, default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk14.              det lpf mask14 for vertical blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk13.              det lpf mask13 for vertical blocks, 0~16, default = 0
#define P_MCDI_REL_DET_LPF_MSK_22_30               (volatile uint32_t *)0xff00bcec
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk30.              det lpf mask30 for other blocks, 0~16, default = 16
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk24.              det lpf mask24 for horizontal blocks, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk23.              det lpf mask23 for horizontal blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk22.              det lpf mask22 for horizontal blocks, 0~16, default = 1
#define P_MCDI_REL_DET_LPF_MSK_31_34               (volatile uint32_t *)0xff00bcf0
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk34.              det lpf mask34 for other blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk33.              det lpf mask33 for other blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk32.              det lpf mask32 for other blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk31.              det lpf mask31 for other blocks, 0~16, default = 0
//Note: there are four group lpf masks from addr 37~3b, each group sum equal to 16.
#define P_MCDI_REL_DET_MIN                         (volatile uint32_t *)0xff00bcf4
//Bit 31: 7, reserved
//Bit  6: 0, reg_mcdi_reldetmin.                   min of detected value, default = 16
#define P_MCDI_REL_DET_LUT_0_3                     (volatile uint32_t *)0xff00bcf8
//Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8
//Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4
//Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2
//Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0
#define P_MCDI_REL_DET_LUT_4_7                     (volatile uint32_t *)0xff00bcfc
//Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64
//Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48
//Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32
//Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16
#define P_MCDI_REL_DET_LUT_8_11                    (volatile uint32_t *)0xff00bd00
//Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160
//Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128
//Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96
//Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80
#define P_MCDI_REL_DET_LUT_12_15                   (volatile uint32_t *)0xff00bd04
//Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255
//Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240
//Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224
//Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192
#define P_MCDI_REL_DET_COL_CFD_THD                 (volatile uint32_t *)0xff00bd08
//Bit 31:24, reg_mcdi_reldetcolcfdfltthd.          thd for flat smaller than (<) of column confidence, default = 5
//Bit 23:16, reg_mcdi_reldetcolcfdthd1.            thd for rel larger than (>=) in rel calc. mode col confidence without gmv locking, default = 160
//Bit 15: 8, reg_mcdi_reldetcolcfdthd0.            thd for rel larger than (>=) in rel calc. mode col confidence when gmv locked, default = 100
//Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.         thd for badw larger than (>=) in qbadw calc. mode of column confidence, default = 16
//Bit     1, reserved
//Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc. mode for column confidence, 0: use rel, 1: use qbadw, default = 0
#define P_MCDI_REL_DET_COL_CFD_AVG_LUMA            (volatile uint32_t *)0xff00bd0c
//Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.         avg luma min1 (>=) for column confidence, valid between 16~235, default = 235
//Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.         avg luma max1 (<)  for column confidence, valid between 16~235, default = 235
//Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.         avg luma min0 (>=) for column confidence, valid between 16~235, default = 16
//Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.         avg luma max0 (<)  for column confidence, valid between 16~235, default = 21
#define P_MCDI_REL_DET_BAD_THD_0                   (volatile uint32_t *)0xff00bd10
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetbadsadthd.             thd (>=) for bad sad, default = 120 (480/4)
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_reldetbadbadwthd.            thd (>=) for bad badw, 0~42, default = 12
#define P_MCDI_REL_DET_BAD_THD_1                   (volatile uint32_t *)0xff00bd14
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetbadrelfltthd.          thd (>=) of flat for bad rel detection, default = 4
//Bit 15: 8, reg_mcdi_reldetbadrelthd1.            thd (>=) for bad rel without gmv/lmv locked, default = 160
//Bit  7: 0, reg_mcdi_reldetbadrelthd0.            thd (>=) for bad rel with gmv/lmv locked, default = 120
#define P_MCDI_PD22_CHK_THD                        (volatile uint32_t *)0xff00bd18
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_pd22chksaddifthd.            sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64
//Bit 15:14, reserved
//Bit 13: 8, reg_mcdi_pd22chkqmvthd.               thd (>=) of abs qmv for pd22 check, default = 2
//Bit  7: 0, reg_mcdi_pd22chkfltthd.               thd (>=) of flat for pd22 check, default = 4
#define P_MCDI_PD22_CHK_GAIN_OFFST_0               (volatile uint32_t *)0xff00bd1c
//Bit 31:24, reg_mcdi_pd22chkedgeoffst0.           offset0 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain0.            gain0 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.           offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain0.            gain0 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 8
#define P_MCDI_PD22_CHK_GAIN_OFFST_1               (volatile uint32_t *)0xff00bd20
//Bit 31:24, reg_mcdi_pd22chkedgeoffst1.           offset1 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain1.            gain1 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.           offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain1.            gain1 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 12
#define P_MCDI_LMV_LOCK_CNT_THD_GAIN               (volatile uint32_t *)0xff00bd24
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_lmvlockcntmax.               max lmv lock count number, default = 6
//Bit 15:12, reg_mcdi_lmvlockcntoffst.             offset for lmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_lmvlockcntgain.              gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockcntthd.               lmv count thd (>=) before be locked, 1~31, default = 4
#define P_MCDI_LMV_LOCK_ABS_DIF_THD                (volatile uint32_t *)0xff00bd28
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockdifthd2.              lmv dif thd for third part, before locked, default = 1
//Bit    23, reserved
//Bit 22:20, reg_mcdi_lmvlockdifthd1.              lmv dif thd for second part, before locked, default = 1
//Bit    19, reserved
//Bit 18:16, reg_mcdi_lmvlockdifthd0.              lmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_lmvlockabsmax.               max abs (<) of lmv to be locked, default = 24
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockabsmin.               min abs (>=) of lmv to be locked, default = 1
#define P_MCDI_LMV_LOCK_ROW                        (volatile uint32_t *)0xff00bd2c
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_lmvlockendrow.               end row (<) for lmv lock, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_lmvlockstartrow.             start row (>=) for lmv lock, default = 0
#define P_MCDI_LMV_LOCK_RT_MODE                    (volatile uint32_t *)0xff00bd30
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockextmode.              extend lines for lmv lock check, check how many lines for lmv locking, default = 2
//Bit 23:16, reg_mcdi_lmvlockfltcntrt.             ratio of flt cnt for lock check, normalized 256 as '1', 255 is set to 256, default = 32
//Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.            ratio when use non-zero lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 48
//Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.            ratio when use max lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 106
#define P_MCDI_GMV_LOCK_CNT_THD_GAIN               (volatile uint32_t *)0xff00bd34
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_gmvlockcntmax.               max gmv lock count number, default = 6
//Bit 15:12, reg_mcdi_gmvlockcntoffst.             offset for gmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_gmvlockcntgain.              gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockcntthd.               gmv count thd (>=) before be locked, 1~31, default = 4
#define P_MCDI_GMV_LOCK_ABS_DIF_THD                (volatile uint32_t *)0xff00bd38
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_gmvlockdifthd2.              gmv dif thd for third part, before locked, default = 3
//Bit    23, reserved
//Bit 22:20, reg_mcdi_gmvlockdifthd1.              gmv dif thd for second part, before locked, default = 2
//Bit    19, reserved
//Bit 18:16, reg_mcdi_gmvlockdifthd0.              gmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_gmvlockabsmax.               max abs of gmv to be locked, default = 15
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockabsmin.               min abs of gmv to be locked, default = 1
#define P_MCDI_HIGH_VERT_FRQ_DIF_THD               (volatile uint32_t *)0xff00bd3c
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.     high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define P_MCDI_HIGH_VERT_FRQ_DIF_DIF_THD           (volatile uint32_t *)0xff00bd40
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.  high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define P_MCDI_HIGH_VERT_FRQ_RT_GAIN               (volatile uint32_t *)0xff00bd44
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_highvertfrqcntthd.           high_vert_frq count thd (>=) before locked, 1~31, default = 4
//Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.         ratio for high_vert_frq bad sad count, normalized 256 as '1', 255 is set to 256, default = 24
//Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.        ratio for high_vert_frq badw count, normalized 256 as '1', 255 is set to 256, default = 130
#define P_MCDI_MOTION_PARADOX_THD                  (volatile uint32_t *)0xff00bd48
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_motionparadoxcntthd.         motion paradox count thd (>=) before locked, 1~31, default = 4
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_motionparadoxgmvthd.         abs gmv thd (<) of motion paradox, 0~32, note that 32 means invalid gmv, be careful, default = 32
//Bit 15: 0, reserved
#define P_MCDI_MOTION_PARADOX_RT                   (volatile uint32_t *)0xff00bd4c
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_motionparadoxbadsadrt.       ratio for field bad sad count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 24
//Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.       ratio for field bad reliability count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 120
//Bit  7: 0, reg_mcdi_motionparadoxmtnrt.          ratio for field motion count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 218
#define P_MCDI_MOTION_REF_THD                      (volatile uint32_t *)0xff00bd50
//Bit 31:24, reserved
//Bit 23:20, reg_mcdi_motionrefoffst.              motion ref additive offset, default = 15
//Bit 19:16, reg_mcdi_motionrefgain.               motion ref gain, normalized 8 as '1', default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_motionrefrptmvthd.           abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1
//Bit  7: 2, reg_mcdi_motionrefqmvthd.             min thd (>=) of abs qmv for motion ref, note that quarter mv's range is -63~63, default = 2
//Bit  1: 0, reg_mcdi_motionreflpfmode.            Mv and (8 x repeat flg) 's lpf mode of motion refinement, 0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1
#define P_MCDI_REL_COL_REF_RT                      (volatile uint32_t *)0xff00bd54
//Bit 31: 8, reserved
//Bit  7: 0, reg_mcdi_relcolrefrt.                 ratio for column confidence level against column number, for refinement, default = 135
#define P_MCDI_PD22_CHK_THD_RT                     (volatile uint32_t *)0xff00bd58
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_pd22chkfltcntrt.             ratio for flat count of field pulldown 22 check, normalized 2048 as '1', 2047 is set to 2048, default = 1
//Bit 15: 8, reg_mcdi_pd22chkcntrt.                ratio of pulldown 22 check count, normalized 256 as '1', 255 is set to 256, default = 100
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkcntthd.               thd (>=) for pd22 count before locked, 1~31, default = 4
#define P_MCDI_CHAR_DET_DIF_THD                    (volatile uint32_t *)0xff00bd5c
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_chardetminmaxdifthd.         thd (>=) for dif between min and max value, default = 64
//Bit 15: 8, reg_mcdi_chardetmaxdifthd.            thd (<) for dif between max value, default = 17
//Bit  7: 0, reg_mcdi_chardetmindifthd.            thd (<) for dif between min value, default = 17
#define P_MCDI_CHAR_DET_CNT_THD                    (volatile uint32_t *)0xff00bd60
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_chardettotcntthd.            thd (>=) for total count, 0~21, default = 18
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_chardetmaxcntthd.            thd (>=) for max count, 0~21, default = 1
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_chardetmincntthd.            thd (>=) for min count, 0~21, default = 1
//new add
#define P_MCDI_PD_22_CHK_WND0_X                    (volatile uint32_t *)0xff00bd64
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd0_x1                 u13, x1 for window 0, HSIZE-1, software control, default = 719
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd0_x0                 u13, x0 for window 0, software control, default = 0
#define P_MCDI_PD_22_CHK_WND0_Y                    (volatile uint32_t *)0xff00bd68
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd0_y1                 u13, y1 for window 0  software control, default = 39
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd0_y0                 u13, y0 for window 0, software control, default = 0
#define P_MCDI_PD_22_CHK_WND1_X                    (volatile uint32_t *)0xff00bd6c
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd1_x1                 u13, x1 for window 1, HSIZE-1, software control, default = 719
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd1_x0                 u13, x0 for window 1, software control, default = 0
#define P_MCDI_PD_22_CHK_WND1_Y                    (volatile uint32_t *)0xff00bd70
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd1_y1                 u13, y1 for window 1  software control, default = 199
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd1_y0                 u13, y0 for window 1, software control, default = 40
#define P_MCDI_PD_22_CHK_FRC_LMV                   (volatile uint32_t *)0xff00bd74
//Bit 31:11, reserved
//Bit    10, reg_mcdi_pd22chklmvchk2               u1, lmv lock check while force vof for each windows, default = 1
//Bit     9, reg_mcdi_pd22chklmvchk1               u1, lmv lock check while force vof for each windows, default = 0
//Bit     8, reg_mcdi_pd22chklmvchk0               u1, lmv lock check while force vof for each windows, default = 0
//Bit     7, reserved
//Bit     6, reg_mcdi_pd22chkfrcpd2                u1, force pd flags for each windows, default = 0
//Bit     5, reg_mcdi_pd22chkfrcpd1                u1, force pd flags for each windows, default = 0
//Bit     4, reg_mcdi_pd22chkfrcpd0                u1, force pd flags for each windows, default = 0
//Bit     3, reserved
//Bit     2, reg_mcdi_pd22chkfrcvof2               u1, force vof flags for each windows, default = 1
//Bit     1, reg_mcdi_pd22chkfrcvof1               u1, force vof flags for each windows, default = 0
//Bit     0, reg_mcdi_pd22chkfrcvof0               u1, force vof flags for each windows, default = 0
#define P_MCDI_PD_22_CHK_FLG_CNT                   (volatile uint32_t *)0xff00bd78
//Bit 31:27, reserved.
//Bit    26, reg_mcdi_pd22chkflg2.                     pull down 22 flag of previous one field. initial = 0
//Bit    25, reg_mcdi_pd22chkflg1.                     pull down 22 flag of previous one field. initial = 0
//Bit    24, reg_mcdi_pd22chkflg.                      pull down 22 flag of previous one field. initial = 0
//Bit 23:16, reg_mcdi_pd22chkcnt2.                     pull down 22 count till previous one field. initial = 0
//Bit 15: 8, reg_mcdi_pd22chkcnt1.                     pull down 22 count till previous one field. initial = 0
//Bit  7: 0, reg_mcdi_pd22chkcnt.                      pull down 22 count till previous one field. initial = 0
#define P_MCDI_RO_FLD_PD_22_PRE_CNT1               (volatile uint32_t *)0xff00bf28
//Bit 31: 0, ro_mcdi_fldpd22precnt1.              previous pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FOR_CNT1               (volatile uint32_t *)0xff00bf2c
//Bit 31: 0, ro_mcdi_fldpd22forcnt1.              forward pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FLT_CNT1               (volatile uint32_t *)0xff00bf30
//Bit 31: 0, ro_mcdi_fldpd22fltcnt1.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_PRE_CNT2               (volatile uint32_t *)0xff00bf34
//Bit 31: 0, ro_mcdi_fldpd22precnt2.              previous pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FOR_CNT2               (volatile uint32_t *)0xff00bf38
//Bit 31: 0, ro_mcdi_fldpd22forcnt2.              forward pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FLT_CNT2               (volatile uint32_t *)0xff00bf3c
//Bit 31: 0, ro_mcdi_fldpd22fltcnt2.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define P_MCDI_FIELD_MV                            (volatile uint32_t *)0xff00bd80
//Bit 31:24, reg_mcdi_pd22chkcnt
//Bit 23:16, reg_mcdi_fieldgmvcnt
//Bit    15, reg_mcdi_pd22chkflg
//Bit    14, reg_mcdi_fieldgmvlock
//Bit 13: 8, reg_mcdi_fieldrptmv.    	           last field rpt mv
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv
#define P_MCDI_FIELD_HVF_PRDX_CNT                  (volatile uint32_t *)0xff00bd84
//Bit 31:24, reg_mcdi_motionparadoxcnt.
//Bit 23:17, reserved
//Bit    16, reg_mcdi_motionparadoxflg.
//Bit 15: 8, reg_mcdi_highvertfrqcnt.
//Bit  7: 4, reserved	
//Bit  3: 2, reg_mcdi_highvertfrqphase.
//Bit     1, reserved
//Bit     0, reg_mcdi_highvertfrqflg.
#define P_MCDI_FIELD_LUMA_AVG_SUM_0                (volatile uint32_t *)0xff00bd88
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum0.
#define P_MCDI_FIELD_LUMA_AVG_SUM_1                (volatile uint32_t *)0xff00bd8c
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum1.
#define P_MCDI_YCBCR_BLEND_CRTL                    (volatile uint32_t *)0xff00bd90
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_ycbcrblendgain.              ycbcr blending gain for cbcr in ycbcr. default = 0
//Bit  7: 2, reserved.
//Bit  1: 0, reg_mcdi_ycbcrblendmode.              0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2
#define P_MCDI_MCVECWR_CANVAS_SIZE                 (volatile uint32_t *)0xff00bd94
#define P_MCDI_MCVECRD_CANVAS_SIZE                 (volatile uint32_t *)0xff00bd98
#define P_MCDI_MCINFOWR_CANVAS_SIZE                (volatile uint32_t *)0xff00bd9c
#define P_MCDI_MCINFORD_CANVAS_SIZE                (volatile uint32_t *)0xff00bda0
#define P_MCDI_MCVECWR_X                           (volatile uint32_t *)0xff00be48
#define P_MCDI_MCVECWR_Y                           (volatile uint32_t *)0xff00be4c
#define P_MCDI_MCVECWR_CTRL                        (volatile uint32_t *)0xff00be50
#define P_MCDI_MCVECRD_X                           (volatile uint32_t *)0xff00be54
#define P_MCDI_MCVECRD_Y                           (volatile uint32_t *)0xff00be58
#define P_MCDI_MCVECRD_CTRL                        (volatile uint32_t *)0xff00be5c
#define P_MCDI_MCINFOWR_X                          (volatile uint32_t *)0xff00be60
#define P_MCDI_MCINFOWR_Y                          (volatile uint32_t *)0xff00be64
#define P_MCDI_MCINFOWR_CTRL                       (volatile uint32_t *)0xff00be68
#define P_MCDI_MCINFORD_X                          (volatile uint32_t *)0xff00be6c
#define P_MCDI_MCINFORD_Y                          (volatile uint32_t *)0xff00be70
#define P_MCDI_MCINFORD_CTRL                       (volatile uint32_t *)0xff00be74
#define P_MCDI_LMVLCKSTEXT_0                       (volatile uint32_t *)0xff00bda4
//Bit 31:28, reserved
//Bit 27:16, mcdi_lmvlckstext_1                    lmv lck blog 1 line start
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckstext_0                    lmv lck blog 0 line start
#define P_MCDI_LMVLCKSTEXT_1                       (volatile uint32_t *)0xff00bda8
//Bit 31   , mcdi_refnewmode                       new ref me mv array order
//Bit 30   , mcdi_ref_lmv_lck_en                   use locked line mvs for ref
//Bit 29:28, mcdi_lmvlckupdw_ext                   up/down extend lines for locked lmv line's
//Bit 27:12, mcdi_lmvlckmin                        lmv lck blog height limit
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckstext_2                    lmv lck blog 2 line start
#define P_MCDI_LMVLCKEDEXT_0                       (volatile uint32_t *)0xff00bdac
//Bit 31:28, reserved
//Bit 27:16, mcdi_lmvlckedext_1                    lmv lck blog 1 line end
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckedext_0                    lmv lck blog 0 line end
#define P_MCDI_LMVLCKEDEXT_1                       (volatile uint32_t *)0xff00bdb0
//Bit 31:12, reserved
//Bit 11: 0, mcdi_lmvlckedext_2                    lmv lck blog 2 line end
// ================================================================== MC registers ========================================================================================================
#define P_MCDI_MC_CRTL                             (volatile uint32_t *)0xff00bdc0
//Bit 31: 9, reserved
//Bit     8, reg_mcdi_mcpreflg.                    flag to use previous field for MC, 0:forward field, 1: previous field, default = 1
//Bit     7, reg_mcdi_mcrelrefbycolcfden.          enable rel refinement by column confidence in mc blending, default = 1
//Bit  6: 5, reg_mcdi_mclpfen.                     enable mc pixles/rel lpf, 0:disable, 1: lpf rel, 2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0
//Bit  4: 2, reg_mcdi_mcdebugmode.                 enable mc debug mode, 0:disable, 1: split left/right, 2: split top/bottom, 3: debug mv, 4: debug rel, default = 0
//Bit  1: 0, reg_mcdi_mcen.                        mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1
#define P_MCDI_MC_LPF_MSK_0                        (volatile uint32_t *)0xff00bdc4
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk02.                  mc lpf coef. 2 for pixel 0 of current block, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk01.                  mc lpf coef. 1 for pixel 0 of current block, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk00.                  mc lpf coef. 0 for pixel 0 of current block, normalized 16 as '1', default = 7
#define P_MCDI_MC_LPF_MSK_1                        (volatile uint32_t *)0xff00bdc8
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk12.                  mc lpf coef. 2 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk11.                  mc lpf coef. 1 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk10.                  mc lpf coef. 0 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 5
#define P_MCDI_MC_LPF_MSK_2                        (volatile uint32_t *)0xff00bdcc
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk22.                  mc lpf coef. 2 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk21.                  mc lpf coef. 1 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 14
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk20.                  mc lpf coef. 0 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
#define P_MCDI_MC_LPF_MSK_3                        (volatile uint32_t *)0xff00bdd0
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk32.                  mc lpf coef. 2 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 5
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk31.                  mc lpf coef. 1 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk30.                  mc lpf coef. 0 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 0
#define P_MCDI_MC_LPF_MSK_4                        (volatile uint32_t *)0xff00bdd4
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk42.                  mc lpf coef. 2 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 7
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk41.                  mc lpf coef. 1 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk40.                  mc lpf coef. 0 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 0
#define P_MCDI_MC_REL_GAIN_OFFST_0                 (volatile uint32_t *)0xff00bdd8
//Bit 31:26, reserved
//Bit    25, reg_mcdi_mcmotionparadoxflg.          flag of motion paradox, initial with 0 and read from software, default = 0
//Bit    24, reg_mcdi_mchighvertfrqflg.            flag of high vertical frq, initial with 0 and read from software, default = 0
//Bit 23:16, reg_mcdi_mcmotionparadoxoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 128
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_mcmotionparadoxgain.         gain for rel (MC blending coef.) refinement if motion paradox detected before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset (alpha - offset) for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, default = 15
//Bit  3: 0, reg_mcdi_mchighvertfrqgain.           gain for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8
#define P_MCDI_MC_REL_GAIN_OFFST_1                 (volatile uint32_t *)0xff00bddc
//Bit 31:24, reg_mcdi_mcoutofboundrayoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending before MC blending, default = 255
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_mcoutofboundraygain.         gain for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.       offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 255
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.        gain for rel (MC blending coef.) refinement if column confidence failed before MC blending, normalized 8 as '1', set 15 to 16, default = 8
#define P_MCDI_MC_COL_CFD_0                        (volatile uint32_t *)0xff00bde0
//Bit 31: 0, mcdi_mc_col_cfd_0.                    column confidence value 0 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_1                        (volatile uint32_t *)0xff00bde4
//Bit 31: 0, mcdi_mc_col_cfd_1.                    column confidence value 1 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_2                        (volatile uint32_t *)0xff00bde8
//Bit 31: 0, mcdi_mc_col_cfd_2.                    column confidence value 2 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_3                        (volatile uint32_t *)0xff00bdec
//Bit 31: 0, mcdi_mc_col_cfd_3.                    column confidence value 3 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_4                        (volatile uint32_t *)0xff00bdf0
//Bit 31: 0, mcdi_mc_col_cfd_4.                    column confidence value 4 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_5                        (volatile uint32_t *)0xff00bdf4
//Bit 31: 0, mcdi_mc_col_cfd_5.                    column confidence value 5 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_6                        (volatile uint32_t *)0xff00bdf8
//Bit 31: 0, mcdi_mc_col_cfd_6.                    column confidence value 6 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_7                        (volatile uint32_t *)0xff00bdfc
//Bit 31: 0, mcdi_mc_col_cfd_7.                    column confidence value 7 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_8                        (volatile uint32_t *)0xff00be00
//Bit 31: 0, mcdi_mc_col_cfd_8.                    column confidence value 8 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_9                        (volatile uint32_t *)0xff00be04
//Bit 31: 0, mcdi_mc_col_cfd_9.                    column confidence value 9 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_10                       (volatile uint32_t *)0xff00be08
//Bit 31: 0, mcdi_mc_col_cfd_10.                   column confidence value 10 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_11                       (volatile uint32_t *)0xff00be0c
//Bit 31: 0, mcdi_mc_col_cfd_11.                   column confidence value 11 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_12                       (volatile uint32_t *)0xff00be10
//Bit 31: 0, mcdi_mc_col_cfd_12.                   column confidence value 12 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_13                       (volatile uint32_t *)0xff00be14
//Bit 31: 0, mcdi_mc_col_cfd_13.                   column confidence value 13 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_14                       (volatile uint32_t *)0xff00be18
//Bit 31: 0, mcdi_mc_col_cfd_14.                   column confidence value 14 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_15                       (volatile uint32_t *)0xff00be1c
//Bit 31: 0, mcdi_mc_col_cfd_15.                   column confidence value 15 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_16                       (volatile uint32_t *)0xff00be20
//Bit 31: 0, mcdi_mc_col_cfd_16.                   column confidence value 16 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_17                       (volatile uint32_t *)0xff00be24
//Bit 31: 0, mcdi_mc_col_cfd_17.                   column confidence value 17 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_18                       (volatile uint32_t *)0xff00be28
//Bit 31: 0, mcdi_mc_col_cfd_18.                   column confidence value 18 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_19                       (volatile uint32_t *)0xff00be2c
//Bit 31: 0, mcdi_mc_col_cfd_19.                   column confidence value 19 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_20                       (volatile uint32_t *)0xff00be30
//Bit 31: 0, mcdi_mc_col_cfd_20.                   column confidence value 20 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_21                       (volatile uint32_t *)0xff00be34
//Bit 31: 0, mcdi_mc_col_cfd_21.                   column confidence value 21 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_22                       (volatile uint32_t *)0xff00be38
//Bit 31: 0, mcdi_mc_col_cfd_22.                   column confidence value 22 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_23                       (volatile uint32_t *)0xff00be3c
//Bit 31: 0, mcdi_mc_col_cfd_23.                   column confidence value 23 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_24                       (volatile uint32_t *)0xff00be40
//Bit 31: 0, mcdi_mc_col_cfd_24.                   column confidence value 24 read from software. initial = 0
#define P_MCDI_MC_COL_CFD_25                       (volatile uint32_t *)0xff00be44
//Bit 31: 0, mcdi_mc_col_cfd_25.                   column confidence value 25 read from software. initial = 0
// ===================================================================================== PRE RO Registers ==========================================================================================
#define P_MCDI_RO_FLD_LUMA_AVG_SUM                 (volatile uint32_t *)0xff00be80
//Bit 31: 0, ro_mcdi_fldlumaavgsum.                block's luma avg sum of current filed (block based). initial = 0
#define P_MCDI_RO_GMV_VLD_CNT                      (volatile uint32_t *)0xff00be84
//Bit 31: 0, ro_mcdi_gmvvldcnt.                    valid gmv's count of pre one filed (block based). initial = 0
#define P_MCDI_RO_RPT_FLG_CNT                      (volatile uint32_t *)0xff00be88
//Bit 31: 0, ro_mcdi_rptflgcnt.                    repeat mv's count of pre one filed (block based). initial = 0
#define P_MCDI_RO_FLD_BAD_SAD_CNT                  (volatile uint32_t *)0xff00be8c
//Bit 31: 0, ro_mcdi_fldbadsadcnt.                 bad sad count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_BAD_BADW_CNT                 (volatile uint32_t *)0xff00be90
//Bit 31: 0, ro_mcdi_fldbadbadwcnt.                bad badw count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_BAD_REL_CNT                  (volatile uint32_t *)0xff00be94
//Bit 31: 0, ro_mcdi_fldbadrelcnt.                 bad rel count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_MTN_CNT                      (volatile uint32_t *)0xff00be98
//Bit 31: 0, ro_mcdi_fldmtncnt.                    motion count of whole pre one field (pixel based). initial = 0
#define P_MCDI_RO_FLD_VLD_CNT                      (volatile uint32_t *)0xff00be9c
//Bit 31: 0, ro_mcdi_fldvldcnt.                    valid motion count of whole pre one field (pixel based). initial = 0
#define P_MCDI_RO_FLD_PD_22_PRE_CNT                (volatile uint32_t *)0xff00bea0
//Bit 31: 0, ro_mcdi_fldpd22precnt.                previous pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FOR_CNT                (volatile uint32_t *)0xff00bea4
//Bit 31: 0, ro_mcdi_fldpd22forcnt.                forward pd22 check count of whole pre one field (block based). initial = 0
#define P_MCDI_RO_FLD_PD_22_FLT_CNT                (volatile uint32_t *)0xff00bea8
//Bit 31: 0, ro_mcdi_fldpd22fltcnt.                flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define P_MCDI_RO_HIGH_VERT_FRQ_FLG                (volatile uint32_t *)0xff00beac
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_highvertfrqcnt.               high vertical frequency count till previous one field. initial = 0
//Bit  7: 3, reserved.
//Bit  2: 1, ro_mcdi_highvertfrqphase.             high vertical frequency phase of previous one field. initial = 2
//Bit     0, ro_mcdi_highvertfrqflg.               high vertical frequency flag of previous one field. initial = 0
#define P_MCDI_RO_GMV_LOCK_FLG                     (volatile uint32_t *)0xff00beb0
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_gmvlckcnt.                    global mv lock count till previous one field. initial = 0
//Bit  7: 2, ro_mcdi_gmv.                          global mv of previous one field. -31~31, initial = 32 (invalid value)
//Bit     1, ro_mcdi_zerogmvlckflg.                zero global mv lock flag of previous one field. initial = 0
//Bit     0, ro_mcdi_gmvlckflg.                    global mv lock flag of previous one field. initial = 0
#define P_MCDI_RO_RPT_MV                           (volatile uint32_t *)0xff00beb4
//Bit 5: 0, ro_mcdi_rptmv.                         repeate mv of previous one field. -31~31, initial = 32 (invalid value)
#define P_MCDI_RO_MOTION_PARADOX_FLG               (volatile uint32_t *)0xff00beb8
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_motionparadoxcnt.             motion paradox count till previous one field. initial = 0
//Bit  7: 1, reserved.
//Bit     0, ro_mcdi_motionparadoxflg.             motion paradox flag of previous one field. initial = 0
#define P_MCDI_RO_PD_22_FLG                        (volatile uint32_t *)0xff00bebc
//Bit 31:27, reserved.
//Bit    26, ro_mcdi_pd22flg2.                     pull down 22 flag of previous one field. initial = 0
//Bit    25, ro_mcdi_pd22flg1.                     pull down 22 flag of previous one field. initial = 0
//Bit    24, ro_mcdi_pd22flg.                      pull down 22 flag of previous one field. initial = 0
//Bit 23:16, ro_mcdi_pd22cnt2.                     pull down 22 count till previous one field. initial = 0
//Bit 15: 8, ro_mcdi_pd22cnt1.                     pull down 22 count till previous one field. initial = 0
//Bit  7: 0, ro_mcdi_pd22cnt.                      pull down 22 count till previous one field. initial = 0
#define P_MCDI_RO_COL_CFD_0                        (volatile uint32_t *)0xff00bec0
//Bit 31: 0, ro_mcdi_col_cfd_0.                    column confidence value 0. initial = 0
#define P_MCDI_RO_COL_CFD_1                        (volatile uint32_t *)0xff00bec4
//Bit 31: 0, ro_mcdi_col_cfd_1.                    column confidence value 1. initial = 0
#define P_MCDI_RO_COL_CFD_2                        (volatile uint32_t *)0xff00bec8
//Bit 31: 0, ro_mcdi_col_cfd_2.                    column confidence value 2. initial = 0
#define P_MCDI_RO_COL_CFD_3                        (volatile uint32_t *)0xff00becc
//Bit 31: 0, ro_mcdi_col_cfd_3.                    column confidence value 3. initial = 0
#define P_MCDI_RO_COL_CFD_4                        (volatile uint32_t *)0xff00bed0
//Bit 31: 0, ro_mcdi_col_cfd_4.                    column confidence value 4. initial = 0
#define P_MCDI_RO_COL_CFD_5                        (volatile uint32_t *)0xff00bed4
//Bit 31: 0, ro_mcdi_col_cfd_5.                    column confidence value 5. initial = 0
#define P_MCDI_RO_COL_CFD_6                        (volatile uint32_t *)0xff00bed8
//Bit 31: 0, ro_mcdi_col_cfd_6.                    column confidence value 6. initial = 0
#define P_MCDI_RO_COL_CFD_7                        (volatile uint32_t *)0xff00bedc
//Bit 31: 0, ro_mcdi_col_cfd_7.                    column confidence value 7. initial = 0
#define P_MCDI_RO_COL_CFD_8                        (volatile uint32_t *)0xff00bee0
//Bit 31: 0, ro_mcdi_col_cfd_8.                    column confidence value 8. initial = 0
#define P_MCDI_RO_COL_CFD_9                        (volatile uint32_t *)0xff00bee4
//Bit 31: 0, ro_mcdi_col_cfd_9.                    column confidence value 9. initial = 0
#define P_MCDI_RO_COL_CFD_10                       (volatile uint32_t *)0xff00bee8
//Bit 31: 0, ro_mcdi_col_cfd_10.                   column confidence value 10. initial = 0
#define P_MCDI_RO_COL_CFD_11                       (volatile uint32_t *)0xff00beec
//Bit 31: 0, ro_mcdi_col_cfd_11.                   column confidence value 11. initial = 0
#define P_MCDI_RO_COL_CFD_12                       (volatile uint32_t *)0xff00bef0
//Bit 31: 0, ro_mcdi_col_cfd_12.                   column confidence value 12. initial = 0
#define P_MCDI_RO_COL_CFD_13                       (volatile uint32_t *)0xff00bef4
//Bit 31: 0, ro_mcdi_col_cfd_13.                   column confidence value 13. initial = 0
#define P_MCDI_RO_COL_CFD_14                       (volatile uint32_t *)0xff00bef8
//Bit 31: 0, ro_mcdi_col_cfd_14.                   column confidence value 14. initial = 0
#define P_MCDI_RO_COL_CFD_15                       (volatile uint32_t *)0xff00befc
//Bit 31: 0, ro_mcdi_col_cfd_15.                   column confidence value 15. initial = 0
#define P_MCDI_RO_COL_CFD_16                       (volatile uint32_t *)0xff00bf00
//Bit 31: 0, ro_mcdi_col_cfd_16.                   column confidence value 16. initial = 0
#define P_MCDI_RO_COL_CFD_17                       (volatile uint32_t *)0xff00bf04
//Bit 31: 0, ro_mcdi_col_cfd_17.                   column confidence value 17. initial = 0
#define P_MCDI_RO_COL_CFD_18                       (volatile uint32_t *)0xff00bf08
//Bit 31: 0, ro_mcdi_col_cfd_18.                   column confidence value 18. initial = 0
#define P_MCDI_RO_COL_CFD_19                       (volatile uint32_t *)0xff00bf0c
//Bit 31: 0, ro_mcdi_col_cfd_19.                   column confidence value 19. initial = 0
#define P_MCDI_RO_COL_CFD_20                       (volatile uint32_t *)0xff00bf10
//Bit 31: 0, ro_mcdi_col_cfd_20.                   column confidence value 20. initial = 0
#define P_MCDI_RO_COL_CFD_21                       (volatile uint32_t *)0xff00bf14
//Bit 31: 0, ro_mcdi_col_cfd_21.                   column confidence value 21. initial = 0
#define P_MCDI_RO_COL_CFD_22                       (volatile uint32_t *)0xff00bf18
//Bit 31: 0, ro_mcdi_col_cfd_22.                   column confidence value 22. initial = 0
#define P_MCDI_RO_COL_CFD_23                       (volatile uint32_t *)0xff00bf1c
//Bit 31: 0, ro_mcdi_col_cfd_23.                   column confidence value 23. initial = 0
#define P_MCDI_RO_COL_CFD_24                       (volatile uint32_t *)0xff00bf20
//Bit 31: 0, ro_mcdi_col_cfd_24.                   column confidence value 24. initial = 0
#define P_MCDI_RO_COL_CFD_25                       (volatile uint32_t *)0xff00bf24
//Bit 31: 0, ro_mcdi_col_cfd_25.                   column confidence value 25. initial = 0
// add space 8'hd0-8'hef
//
// Reading file:  dipd_regs.h
//
// synopsys translate_off
// synopsys translate_on
// using 8'he0-8'hef
#define P_DIPD_COMB_CTRL0                          (volatile uint32_t *)0xff00bf40
//Bit 31:0,								reg_pd_comb_ctrl0
#define P_DIPD_COMB_CTRL1                          (volatile uint32_t *)0xff00bf44
//Bit 31:0,								reg_pd_comb_ctrl1
#define P_DIPD_COMB_CTRL2                          (volatile uint32_t *)0xff00bf48
//Bit 31:0,								reg_pd_comb_ctrl2
#define P_DIPD_COMB_CTRL3                          (volatile uint32_t *)0xff00bf4c
//Bit 31:0,								reg_pd_comb_ctrl3
#define P_DIPD_COMB_CTRL4                          (volatile uint32_t *)0xff00bf50
//Bit 31:0,								reg_pd_comb_ctrl4
#define P_DIPD_COMB_CTRL5                          (volatile uint32_t *)0xff00bf54
//Bit 31:0,								reg_pd_comb_ctrl5
#define P_DIPD_RO_COMB_0                           (volatile uint32_t *)0xff00bf58
//Bit 31:0,								ro_pd_comb_0
#define P_DIPD_RO_COMB_1                           (volatile uint32_t *)0xff00bf5c
//Bit 31:0,								ro_pd_comb_1
#define P_DIPD_RO_COMB_2                           (volatile uint32_t *)0xff00bf60
//Bit 31:0,								ro_pd_comb_2
#define P_DIPD_RO_COMB_3                           (volatile uint32_t *)0xff00bf64
//Bit 31:0,								ro_pd_comb_3
#define P_DIPD_RO_COMB_4                           (volatile uint32_t *)0xff00bf68
//Bit 31:0,								ro_pd_comb_4
#define P_DIPD_RO_COMB_5                           (volatile uint32_t *)0xff00bf6c
//Bit 31:0,								ro_pd_comb_5
#define P_DIPD_RO_COMB_6                           (volatile uint32_t *)0xff00bf70
//Bit 31:0,								ro_pd_comb_6
#define P_DIPD_RO_COMB_7                           (volatile uint32_t *)0xff00bf74
//Bit 31:0,								ro_pd_comb_7
#define P_DIPD_RO_COMB_8                           (volatile uint32_t *)0xff00bf78
//Bit 31:0,								ro_pd_comb_8
#define P_DIPD_RO_COMB_9                           (volatile uint32_t *)0xff00bf7c
//Bit 31:0,								ro_pd_comb_9
#define P_DIPD_RO_COMB_10                          (volatile uint32_t *)0xff00bf80
//Bit 31:0,								ro_pd_comb_10
#define P_DIPD_RO_COMB_11                          (volatile uint32_t *)0xff00bf84
//Bit 31:0,								ro_pd_comb_11
#define P_DIPD_RO_COMB_12                          (volatile uint32_t *)0xff00bf88
//Bit 31:0,								ro_pd_comb_12
#define P_DIPD_RO_COMB_13                          (volatile uint32_t *)0xff00bf8c
//Bit 31:0,								ro_pd_comb_13
#define P_DIPD_RO_COMB_14                          (volatile uint32_t *)0xff00bf90
//Bit 31:0,								ro_pd_comb_14
#define P_DIPD_RO_COMB_15                          (volatile uint32_t *)0xff00bf94
//Bit 31:0,								ro_pd_comb_15
#define P_DIPD_RO_COMB_16                          (volatile uint32_t *)0xff00bf98
//Bit 31:0,								ro_pd_comb_16
#define P_DIPD_RO_COMB_17                          (volatile uint32_t *)0xff00bf9c
//Bit 31:0,								ro_pd_comb_17
#define P_DIPD_RO_COMB_18                          (volatile uint32_t *)0xff00bfa0
//Bit 31:0,								ro_pd_comb_18
#define P_DIPD_RO_COMB_19                          (volatile uint32_t *)0xff00bfa4
//Bit 31:0,								ro_pd_comb_19
#define P_DIPD_RO_COMB_20                          (volatile uint32_t *)0xff00bfa8
//Bit 31:0,								ro_pd_comb_20
#define P_DIPD_COMB_CTRL6                          (volatile uint32_t *)0xff00bfac
//Bit 31:0,								reg_pd_comb_ctrl6
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dipd_regs.h
//
// addr space 8'hf0-8'hff
//
// Reading file:  nr3_tnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR3_MODE                                 (volatile uint32_t *)0xff00bfc0
//Bit 31: 6        reserved
//Bit  5           reg_nr3_vtxt_mode         // unsigned , default = 0  0: avg; 1:MAX
//Bit  4           reg_3dnr_nr3_cbyy_ignor_coop    // unsigned , default = 0  ignore coop condition for cbyy motion decision
//Bit  3           reg_3dnr_nr3_ybyc_ignor_cnoop   // unsigned , default = 0  ignore cnoop condition for ybyc motion decision
//Bit  2: 0        reg_3dnr_nr3_suremot_txt_mode   // unsigned , default = 3  0: cur, 1:p2; 2: (cur+p2)/2; 3/up: min(cur,p2)
#define P_NR3_COOP_PARA                            (volatile uint32_t *)0xff00bfc4
//Bit 31:22        reserved
//Bit 21:20        reg_3dnr_nr3_coop_mode    // unsigned , default = 2  0 original pixel 1: [1 2 1]/4 lpf; 2: [1 2 2 2 1]/8; 3: 3x3 lpf
//Bit 19:16        reg_3dnr_nr3_coop_ratio    // unsigned , default = 8  cur and p2 color oop decision ratio:  (avg1<(dif1*ratio/8 + ofst));
//Bit 15: 8        reg_3dnr_nr3_coop_ofset    // signed , default = -1  cur and p2 color oop decision ofst:  (avg1<(dif1*ratio/8 + ofst));
//Bit  7: 0        reg_3dnr_nr3_coop_sat_thrd // unsigned , default = 0  cur and p2 color oop decision min(sat0,sat1) threshold;
#define P_NR3_CNOOP_GAIN                           (volatile uint32_t *)0xff00bfc8
//Bit 31:24        reserved
//Bit 23:20        reg_3dnr_nr3_cnoop_ratio0   // unsigned , default = 8  cur and p2 color noop decision ratio0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
//Bit 19:16        reg_3dnr_nr3_cnoop_ratio1   // unsigned , default = 8  cur and p2 color noop decision ratio1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
//Bit 15: 8        reg_3dnr_nr3_cnoop_ofset0   // signed , default = 25  cur and p2 color noop decision ofset0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
//Bit  7: 0        reg_3dnr_nr3_cnoop_ofset1   // signed , default = 0  cur and p2 color noop decision ofset1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
#define P_NR3_YMOT_PARA                            (volatile uint32_t *)0xff00bfcc
//Bit 31:20        reserved
//Bit 19           reg_3dnr_nr3_ymot_only_en  // unsigned , default = 1  enable signal for ignor chroma motion: (ytxt &coop)
//Bit 18           reg_3dnr_nr3_ymot_only_cmtmode  // unsigned , default = 1  0: cmot=ymot; 1: cmot = MIN(ymot, cmot)
//Bit 17:16        reg_3dnr_nr3_ymot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15: 8        reg_3dnr_nr3_ymot_only_txtthrd  // unsigned , default = 10  threshold to luma texture to decide use ymot only
//Bit  7: 0        reg_3dnr_nr3_ymot_only_motthrd  // unsigned , default = 30  threshold to luma motion to decide use ymot only
#define P_NR3_CMOT_PARA                            (volatile uint32_t *)0xff00bfd0
//Bit 31:20        reserved
//Bit 19           reg_3dnr_nr3_cmot_only_en  // unsigned , default = 1  enable signal for ignor luma motion: (ctxt &cnoop)
//Bit 18           reg_3dnr_nr3_cmot_only_ymtmode  // unsigned , default = 0  0: ymot=cmot+ymot/4; 1: ymot = MIN(ymot, cmot)
//Bit 17:16        reg_3dnr_nr3_cmot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15: 8        reg_3dnr_nr3_cmot_only_txtthrd  // unsigned , default = 20  threshold to chroma texture to decide use cmot only
//Bit  7: 0        reg_3dnr_nr3_cmot_only_motthrd  // unsigned , default = 15  threshold to chroma motion to decide use cmot only
#define P_NR3_SUREMOT_YGAIN                        (volatile uint32_t *)0xff00bfd4
//Bit 31:24        reg_3dnr_nr3_suremot_dec_yrate  // unsigned , default = 16  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16        reg_3dnr_nr3_suremot_dec_yofst  // unsigned , default = 12   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15: 8        reg_3dnr_nr3_suremot_frc_ygain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7: 0        reg_3dnr_nr3_suremot_frc_yofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
#define P_NR3_SUREMOT_CGAIN                        (volatile uint32_t *)0xff00bfd8
//Bit 31:24        reg_3dnr_nr3_suremot_dec_crate  // unsigned , default = 34  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16        reg_3dnr_nr3_suremot_dec_cofst  // unsigned , default = 38   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15: 8        reg_3dnr_nr3_suremot_frc_cgain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7: 0        reg_3dnr_nr3_suremot_frc_cofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr3_tnr_regs.h
//
#define P_LBUF_TOP_CTRL                            (volatile uint32_t *)0xff00bffc
//bit 23:22   mode_444c422
//bit 21:20   mode_422c444
//bit 17      lbuf_fmt444_mode
//bit 16      lbuf_line5_mode
//bit 12:0    pre_lbuf_size
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  mcdi_regs.h
//
//  VPU_VLOCK register    (16'h3000 - 16'h30ff)
//========================================================================
//
// Reading file:  vpu_vlock_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VPU_VLOCK 0x30
// ----------------------------
// -----------------------------------------------
// REG_BASE:  VPU_VLOCK_VCBUS_BASE = 0x30
// -----------------------------------------------
#define P_VPU_VLOCK_CTRL                           (volatile uint32_t *)0xff00c000
#define P_VPU_VLOCK_MISC_CTRL                      (volatile uint32_t *)0xff00c004
#define P_VPU_VLOCK_LOOP0_ACCUM_LMT                (volatile uint32_t *)0xff00c008
#define P_VPU_VLOCK_LOOP0_CTRL0                    (volatile uint32_t *)0xff00c00c
#define P_VPU_VLOCK_LOOP1_CTRL0                    (volatile uint32_t *)0xff00c010
#define P_VPU_VLOCK_LOOP1_IMISSYNC_MAX             (volatile uint32_t *)0xff00c014
#define P_VPU_VLOCK_LOOP1_IMISSYNC_MIN             (volatile uint32_t *)0xff00c018
#define P_VPU_VLOCK_OVWRITE_ACCUM0                 (volatile uint32_t *)0xff00c01c
#define P_VPU_VLOCK_OVWRITE_ACCUM1                 (volatile uint32_t *)0xff00c020
#define P_VPU_VLOCK_OUTPUT0_CAPT_LMT               (volatile uint32_t *)0xff00c024
#define P_VPU_VLOCK_OUTPUT0_PLL_LMT                (volatile uint32_t *)0xff00c028
#define P_VPU_VLOCK_OUTPUT1_CAPT_LMT               (volatile uint32_t *)0xff00c02c
#define P_VPU_VLOCK_OUTPUT1_PLL_LMT                (volatile uint32_t *)0xff00c030
#define P_VPU_VLOCK_LOOP1_PHSDIF_TGT               (volatile uint32_t *)0xff00c034
#define P_VPU_VLOCK_RO_LOOP0_ACCUM                 (volatile uint32_t *)0xff00c038
#define P_VPU_VLOCK_RO_LOOP1_ACCUM                 (volatile uint32_t *)0xff00c03c
#define P_VPU_VLOCK_OROW_OCOL_MAX                  (volatile uint32_t *)0xff00c040
#define P_VPU_VLOCK_RO_VS_I_DIST                   (volatile uint32_t *)0xff00c044
#define P_VPU_VLOCK_RO_VS_O_DIST                   (volatile uint32_t *)0xff00c048
#define P_VPU_VLOCK_RO_LINE_PIX_ADJ                (volatile uint32_t *)0xff00c04c
#define P_VPU_VLOCK_RO_OUTPUT_00_01                (volatile uint32_t *)0xff00c050
#define P_VPU_VLOCK_RO_OUTPUT_10_11                (volatile uint32_t *)0xff00c054
#define P_VPU_VLOCK_MX4096                         (volatile uint32_t *)0xff00c058
#define P_VPU_VLOCK_STBDET_WIN0_WIN1               (volatile uint32_t *)0xff00c05c
#define P_VPU_VLOCK_STBDET_CLP                     (volatile uint32_t *)0xff00c060
#define P_VPU_VLOCK_STBDET_ABS_WIN0                (volatile uint32_t *)0xff00c064
#define P_VPU_VLOCK_STBDET_ABS_WIN1                (volatile uint32_t *)0xff00c068
#define P_VPU_VLOCK_STBDET_SGN_WIN0                (volatile uint32_t *)0xff00c06c
#define P_VPU_VLOCK_STBDET_SGN_WIN1                (volatile uint32_t *)0xff00c070
#define P_VPU_VLOCK_ADJ_EN_SYNC_CTRL               (volatile uint32_t *)0xff00c074
#define P_VPU_VLOCK_GCLK_EN                        (volatile uint32_t *)0xff00c078
#define P_VPU_VLOCK_LOOP1_ACCUM_LMT                (volatile uint32_t *)0xff00c07c
#define P_VPU_VLOCK_RO_M_INT_FRAC                  (volatile uint32_t *)0xff00c080
#define P_VPU_VLOCK_RO_PH_DIS                      (volatile uint32_t *)0xff00c084
#define P_VPU_VLOCK_RO_PH_ERR                      (volatile uint32_t *)0xff00c088
#define P_VPU_VLOCK_LOCK_TH                        (volatile uint32_t *)0xff00c08c
#define P_VPU_VLOCK_RO_LCK_FRM                     (volatile uint32_t *)0xff00c090
#define P_VPU_VLOCK_WIN0_TH                        (volatile uint32_t *)0xff00c094
#define P_VPU_VLOCK_WIN0_RATIO                     (volatile uint32_t *)0xff00c098
#define P_VPU_VLOCK_WIN0_FILTER_CNTL               (volatile uint32_t *)0xff00c09c
#define P_VPU_VLOCK_WIN1_TH                        (volatile uint32_t *)0xff00c0a0
#define P_VPU_VLOCK_WIN1_RATIO                     (volatile uint32_t *)0xff00c0a4
#define P_VPU_VLOCK_WIN1_FILTER_CNTL               (volatile uint32_t *)0xff00c0a8
#define P_VPU_VLOCK_LOCK_TH1                       (volatile uint32_t *)0xff00c0ac
#define P_VPU_VLOCK_LOOP0_ERR_LMT                  (volatile uint32_t *)0xff00c0b0
#define P_VPU_VLOCK_LOOP1_ERR_LMT                  (volatile uint32_t *)0xff00c0b4
#define P_VPU_VLOCK_ERR_CTRL0                      (volatile uint32_t *)0xff00c0b8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_vlock_reg.h
//
//
// Reading file:  vpp_partb_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPPB_VCBUS_BASE = 0x31
// -----------------------------------------------
////=================================================================////
//// vkeystone
////=================================================================////
// 8'h00-8'h17
//
// Reading file:  vkstone_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VKS_CTRL                                 (volatile uint32_t *)0xff00c400
//Bit 31           reg_vks_en                // unsigned , default = 1  enable signal of the vks function
//Bit 30           reg_vks_scl_mode0         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
//Bit 29           reg_vks_scl_mode1         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
//Bit 28           reg_vks_fill_mode         // unsigned , default = 1  mode of out-of-boundary fill, 0 extension, 1: fill with the fill_value
//Bit 27:26        reg_vks_row_inp_mode      // unsigned , default = 1  , interpolation mode from 16pieces ofset/step to each line ofset and step; 0: linear interpolation; 1: cubic interpolation (using ccoef)
//Bit 25           reg_vks_border_ext_mode0  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extropolate the border one
//Bit 24           reg_vks_border_ext_mode1  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extropolate the border one
//Bit 23           reg_vks_obuf_mode0        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
//Bit 22           reg_vks_obuf_mode1        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
//Bit 21:20        reg_vks_obuf_mrgn0        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
//Bit 19:18        reg_vks_obuf_mrgn1        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
//Bit 17:16        reg_vks_phs_qmode         // unsigned , default = 2  , interpolation mode of the phase, 0: floor to 1/64 phase; 1: round to 1/64 phase; 2/3 linear intp
//Bit 15: 0        reg_vks_row_scl           // unsigned , default = 11651  , scale of row to make it fit to the 16 pieces, scl = (2^23)/RowMax
#define P_VKS_OUT_WIN_SIZE                         (volatile uint32_t *)0xff00c404
//Bit 31:30        reserved
//Bit 29:16        reg_vks_ocolmax           // unsigned , default = 1280  output outer window col number, decided by the projector
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_orowmax           // unsigned , default = 720  output outer window row number, decided by the projector
#define P_VKS_PRELPF_YCOEF0                        (volatile uint32_t *)0xff00c408
//Bit 31:24        reg_vks_prelpf_ycoef0     // signed , default = -128  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit 23:16        reg_vks_prelpf_ycoef1     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit 15: 8        reg_vks_prelpf_ycoef2     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ycoef3     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
#define P_VKS_PRELPF_YCOEF1                        (volatile uint32_t *)0xff00c40c
//Bit 31:16        reserved
//Bit 15: 8        reg_vks_prelpf_ycoef4     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ycoef5     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
#define P_VKS_PRELPF_CCOEF0                        (volatile uint32_t *)0xff00c410
//Bit 31:24        reg_vks_prelpf_ccoef0     // signed , default = -128  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit 23:16        reg_vks_prelpf_ccoef1     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit 15: 8        reg_vks_prelpf_ccoef2     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ccoef3     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
#define P_VKS_PRELPF_CCOEF1                        (volatile uint32_t *)0xff00c414
//Bit 31:16        reserved
//Bit 15: 8        reg_vks_prelpf_ccoef4     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ccoef5     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
#define P_VKS_FILL_VAL                             (volatile uint32_t *)0xff00c418
//Bit 31:24        reserved
//Bit 23:16        reg_vks_fill_value0       // unsigned , default = 0  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
//Bit 15: 8        reg_vks_fill_value1       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
//Bit  7: 0        reg_vks_fill_value2       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
#define P_VKS_IWIN_HSIZE                           (volatile uint32_t *)0xff00c41c
//Bit 31:30        reserved
//Bit 29:16        reg_vks_iwinx0            // unsigned , default = 160  , input start-col and end-col;
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_iwinx1            // unsigned , default = 1279  , input start-col and end-col;
#define P_VKS_IWIN_VSIZE                           (volatile uint32_t *)0xff00c420
//Bit 31:30        reserved
//Bit 29:16        reg_vks_iwiny0            // unsigned , default = 0  , input start-row and end-row;
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_iwiny1            // unsigned , default = 719  , input start-row and end-row;
#define P_VKS_TOP_MISC                             (volatile uint32_t *)0xff00c424
//Bit 31:19        reserved
//Bit 18           reg_flt_en                // unsigned , default = 1
//Bit 17           reg_frm_rst               // unsigned , default = 0
//Bit 16           reg_ctrl_sync             // unsigned , default = 0
//Bit 15: 8        blank_num                 // unsigned , default = 4
//Bit  7: 0        flt_blank_num             // unsigned , default = 9
#define P_VKS_START_CTRL                           (volatile uint32_t *)0xff00c428
//Bit 31:17        reserved
//Bit 16           reg_vks_en_mode           // unsigned , default = 0
//Bit 15: 0        reg_hold_phnum            // unsigned , default = 5
#define P_VKS_LBUF_SIZE                            (volatile uint32_t *)0xff00c42c
//Bit 31:12        reserved
//Bit 11: 0        reg_lbuf_depth            // unsigned , default = 1024
#define P_VKS_PARA_ADDR_PORT                       (volatile uint32_t *)0xff00c438
#define P_VKS_PARA_DATA_PORT                       (volatile uint32_t *)0xff00c43c

    #define VKS_SCL_OFSET00                        0x9  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset0        // unsigned , default = 118534  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET01                        0xa  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset1        // unsigned , default = 111450  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET02                        0xb  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset2        // unsigned , default = 104366  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET03                        0xc  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset3        // unsigned , default = 97283  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET04                        0xd  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset4        // unsigned , default = 90199  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET05                        0xe  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset5        // unsigned , default = 83115  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET06                        0xf  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset6        // unsigned , default = 76031  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET07                       0x10  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset7        // unsigned , default = 68947  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET08                       0x11  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset8        // unsigned , default = 61864  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET09                       0x12  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset9        // unsigned , default = 54780  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET10                       0x13  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset10       // unsigned , default = 47696  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET11                       0x14  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset11       // unsigned , default = 40612  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET12                       0x15  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset12       // unsigned , default = 33528  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET13                       0x16  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset13       // unsigned , default = 26444  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET14                       0x17  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset14       // unsigned , default = 19361  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET15                       0x18  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset15       // unsigned , default = 12277  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET16                       0x19  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset16       // unsigned , default = 5193  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_STEP00                        0x1a  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step0         // unsigned , default = 331378  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP01                        0x1b  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step1         // unsigned , default = 383191  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP02                        0x1c  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step2         // unsigned , default = 435004  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP03                        0x1d  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step3         // unsigned , default = 486818  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP04                        0x1e  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step4         // unsigned , default = 538631  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP05                        0x1f  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step5         // unsigned , default = 590444  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP06                        0x20  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step6         // unsigned , default = 642257  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP07                        0x21  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step7         // unsigned , default = 694070  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP08                        0x22  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step8         // unsigned , default = 745884  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP09                        0x23  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step9         // unsigned , default = 797697  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP10                        0x24  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step10        // unsigned , default = 849510  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP11                        0x25  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step11        // unsigned , default = 901323  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP12                        0x26  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step12        // unsigned , default = 953136  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP13                        0x27  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step13        // unsigned , default = 1004949  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP14                        0x28  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step14        // unsigned , default = 1056763  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP15                        0x29  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step15        // unsigned , default = 1108576  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP16                        0x2a  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step16        // unsigned , default = 1160389  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_PPS_YCOEF00                       0x2b  //
//Bit 31:24        reg_vks_ycoef0            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef1            // signed , default = 128  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef2            // signed , default = 0  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef3            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF01                       0x2c  //
//Bit 31:24        reg_vks_ycoef4            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef5            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef6            // signed , default = 1  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef7            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF02                       0x2d  //
//Bit 31:24        reg_vks_ycoef8            // signed , default = -1  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef9            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef10           // signed , default = 2  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef11           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF03                       0x2e  //
//Bit 31:24        reg_vks_ycoef12           // signed , default = -2  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef13           // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef14           // signed , default = 3  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef15           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF04                       0x2f  //
//Bit 31:24        reg_vks_ycoef16           // signed , default = -3  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef17           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef18           // signed , default = 5  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef19           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF05                       0x30  //
//Bit 31:24        reg_vks_ycoef20           // signed , default = -4  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef21           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef22           // signed , default = 6  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef23           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF06                       0x31  //
//Bit 31:24        reg_vks_ycoef24           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef25           // signed , default = 125  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef26           // signed , default = 8  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef27           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF07                       0x32  //
//Bit 31:24        reg_vks_ycoef28           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef29           // signed , default = 124  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef30           // signed , default = 9  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef31           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF08                       0x33  //
//Bit 31:24        reg_vks_ycoef32           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef33           // signed , default = 123  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef34           // signed , default = 11  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef35           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF09                       0x34  //
//Bit 31:24        reg_vks_ycoef36           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef37           // signed , default = 122  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef38           // signed , default = 13  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef39           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF10                       0x35  //
//Bit 31:24        reg_vks_ycoef40           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef41           // signed , default = 121  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef42           // signed , default = 15  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef43           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF11                       0x36  //
//Bit 31:24        reg_vks_ycoef44           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef45           // signed , default = 119  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef46           // signed , default = 17  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef47           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF12                       0x37  //
//Bit 31:24        reg_vks_ycoef48           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef49           // signed , default = 118  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef50           // signed , default = 19  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef51           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF13                       0x38  //
//Bit 31:24        reg_vks_ycoef52           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef53           // signed , default = 116  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef54           // signed , default = 22  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef55           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF14                       0x39  //
//Bit 31:24        reg_vks_ycoef56           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef57           // signed , default = 114  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef58           // signed , default = 24  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef59           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF15                       0x3a  //
//Bit 31:24        reg_vks_ycoef60           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef61           // signed , default = 112  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef62           // signed , default = 26  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef63           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF16                       0x3b  //
//Bit 31:24        reg_vks_ycoef64           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef65           // signed , default = 111  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef66           // signed , default = 29  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef67           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF17                       0x3c  //
//Bit 31:24        reg_vks_ycoef68           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef69           // signed , default = 109  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef70           // signed , default = 31  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef71           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF18                       0x3d  //
//Bit 31:24        reg_vks_ycoef72           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef73           // signed , default = 107  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef74           // signed , default = 33  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef75           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF19                       0x3e  //
//Bit 31:24        reg_vks_ycoef76           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef77           // signed , default = 104  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef78           // signed , default = 36  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef79           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF20                       0x3f  //
//Bit 31:24        reg_vks_ycoef80           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef81           // signed , default = 102  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef82           // signed , default = 39  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef83           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF21                       0x40  //
//Bit 31:24        reg_vks_ycoef84           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef85           // signed , default = 100  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef86           // signed , default = 41  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef87           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF22                       0x41  //
//Bit 31:24        reg_vks_ycoef88           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef89           // signed , default = 97  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef90           // signed , default = 44  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef91           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF23                       0x42  //
//Bit 31:24        reg_vks_ycoef92           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef93           // signed , default = 95  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef94           // signed , default = 47  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef95           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF24                       0x43  //
//Bit 31:24        reg_vks_ycoef96           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef97           // signed , default = 93  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef98           // signed , default = 49  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef99           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF25                       0x44  //
//Bit 31:24        reg_vks_ycoef100          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef101          // signed , default = 90  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef102          // signed , default = 52  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef103          // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF26                       0x45  //
//Bit 31:24        reg_vks_ycoef104          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef105          // signed , default = 88  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef106          // signed , default = 55  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef107          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF27                       0x46  //
//Bit 31:24        reg_vks_ycoef108          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef109          // signed , default = 85  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef110          // signed , default = 58  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef111          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF28                       0x47  //
//Bit 31:24        reg_vks_ycoef112          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef113          // signed , default = 82  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef114          // signed , default = 60  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef115          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF29                       0x48  //
//Bit 31:24        reg_vks_ycoef116          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef117          // signed , default = 80  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef118          // signed , default = 63  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef119          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF30                       0x49  //
//Bit 31:24        reg_vks_ycoef120          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef121          // signed , default = 77  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef122          // signed , default = 66  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef123          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF31                       0x4a  //
//Bit 31:24        reg_vks_ycoef124          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef125          // signed , default = 74  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef126          // signed , default = 69  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef127          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF32                       0x4b  //
//Bit 31:24        reg_vks_ycoef128          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef129          // signed , default = 72  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef130          // signed , default = 72  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef131          // signed , default = -8  poly-phase scalar coefs
    #define VKS_PPS_CCOEF00                       0x4c  //
//Bit 31:24        reg_vks_ccoef0            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef1            // signed , default = 128  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef2            // signed , default = 0  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef3            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF01                       0x4d  //
//Bit 31:24        reg_vks_ccoef4            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef5            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef6            // signed , default = 1  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef7            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF02                       0x4e  //
//Bit 31:24        reg_vks_ccoef8            // signed , default = -1  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef9            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef10           // signed , default = 2  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef11           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF03                       0x4f  //
//Bit 31:24        reg_vks_ccoef12           // signed , default = -2  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef13           // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef14           // signed , default = 3  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef15           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF04                       0x50  //
//Bit 31:24        reg_vks_ccoef16           // signed , default = -3  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef17           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef18           // signed , default = 5  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef19           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF05                       0x51  //
//Bit 31:24        reg_vks_ccoef20           // signed , default = -4  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef21           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef22           // signed , default = 6  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef23           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF06                       0x52  //
//Bit 31:24        reg_vks_ccoef24           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef25           // signed , default = 125  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef26           // signed , default = 8  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef27           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF07                       0x53  //
//Bit 31:24        reg_vks_ccoef28           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef29           // signed , default = 124  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef30           // signed , default = 9  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef31           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF08                       0x54  //
//Bit 31:24        reg_vks_ccoef32           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef33           // signed , default = 123  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef34           // signed , default = 11  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef35           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF09                       0x55  //
//Bit 31:24        reg_vks_ccoef36           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef37           // signed , default = 122  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef38           // signed , default = 13  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef39           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF10                       0x56  //
//Bit 31:24        reg_vks_ccoef40           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef41           // signed , default = 121  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef42           // signed , default = 15  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef43           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF11                       0x57  //
//Bit 31:24        reg_vks_ccoef44           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef45           // signed , default = 119  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef46           // signed , default = 17  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef47           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF12                       0x58  //
//Bit 31:24        reg_vks_ccoef48           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef49           // signed , default = 118  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef50           // signed , default = 19  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef51           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF13                       0x59  //
//Bit 31:24        reg_vks_ccoef52           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef53           // signed , default = 116  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef54           // signed , default = 22  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef55           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF14                       0x5a  //
//Bit 31:24        reg_vks_ccoef56           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef57           // signed , default = 114  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef58           // signed , default = 24  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef59           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF15                       0x5b  //
//Bit 31:24        reg_vks_ccoef60           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef61           // signed , default = 112  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef62           // signed , default = 26  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef63           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF16                       0x5c  //
//Bit 31:24        reg_vks_ccoef64           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef65           // signed , default = 111  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef66           // signed , default = 29  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef67           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF17                       0x5d  //
//Bit 31:24        reg_vks_ccoef68           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef69           // signed , default = 109  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef70           // signed , default = 31  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef71           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF18                       0x5e  //
//Bit 31:24        reg_vks_ccoef72           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef73           // signed , default = 107  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef74           // signed , default = 33  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef75           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF19                       0x5f  //
//Bit 31:24        reg_vks_ccoef76           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef77           // signed , default = 104  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef78           // signed , default = 36  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef79           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF20                       0x60  //
//Bit 31:24        reg_vks_ccoef80           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef81           // signed , default = 102  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef82           // signed , default = 39  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef83           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF21                       0x61  //
//Bit 31:24        reg_vks_ccoef84           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef85           // signed , default = 100  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef86           // signed , default = 41  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef87           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF22                       0x62  //
//Bit 31:24        reg_vks_ccoef88           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef89           // signed , default = 97  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef90           // signed , default = 44  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef91           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF23                       0x63  //
//Bit 31:24        reg_vks_ccoef92           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef93           // signed , default = 95  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef94           // signed , default = 47  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef95           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF24                       0x64  //
//Bit 31:24        reg_vks_ccoef96           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef97           // signed , default = 93  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef98           // signed , default = 49  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef99           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF25                       0x65  //
//Bit 31:24        reg_vks_ccoef100          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef101          // signed , default = 90  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef102          // signed , default = 52  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef103          // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF26                       0x66  //
//Bit 31:24        reg_vks_ccoef104          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef105          // signed , default = 88  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef106          // signed , default = 55  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef107          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF27                       0x67  //
//Bit 31:24        reg_vks_ccoef108          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef109          // signed , default = 85  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef110          // signed , default = 58  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef111          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF28                       0x68  //
//Bit 31:24        reg_vks_ccoef112          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef113          // signed , default = 82  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef114          // signed , default = 60  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef115          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF29                       0x69  //
//Bit 31:24        reg_vks_ccoef116          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef117          // signed , default = 80  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef118          // signed , default = 63  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef119          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF30                       0x6a  //
//Bit 31:24        reg_vks_ccoef120          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef121          // signed , default = 77  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef122          // signed , default = 66  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef123          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF31                       0x6b  //
//Bit 31:24        reg_vks_ccoef124          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef125          // signed , default = 74  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef126          // signed , default = 69  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef127          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF32                       0x6c  //
//Bit 31:24        reg_vks_ccoef128          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef129          // signed , default = 72  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef130          // signed , default = 72  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef131          // signed , default = -8  poly-phase scalar coefs


// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vkstone_regs.h
//
////=================================================================////
//// vpp dither
////=================================================================////
// 8'h20-8'h3f
//
// Reading file:  vpp_dither_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VPP_VE_DITHER_CTRL                       (volatile uint32_t *)0xff00c480
#define P_VPP_VE_DITHER_LUT_1                      (volatile uint32_t *)0xff00c484
#define P_VPP_VE_DITHER_LUT_2                      (volatile uint32_t *)0xff00c488
#define P_VPP_VE_DITHER_LUT_3                      (volatile uint32_t *)0xff00c48c
#define P_VPP_VE_DITHER_LUT_4                      (volatile uint32_t *)0xff00c490
#define P_VPP_VE_DITHER_LUT_5                      (volatile uint32_t *)0xff00c494
#define P_VPP_VE_DITHER_LUT_6                      (volatile uint32_t *)0xff00c498
#define P_VPP_VE_DITHER_LUT_7                      (volatile uint32_t *)0xff00c49c
#define P_VPP_VE_DITHER_LUT_8                      (volatile uint32_t *)0xff00c4a0
#define P_VPP_VE_DITHER_LUT_9                      (volatile uint32_t *)0xff00c4a4
#define P_VPP_VE_DITHER_LUT_10                     (volatile uint32_t *)0xff00c4a8
#define P_VPP_VE_DITHER_LUT_11                     (volatile uint32_t *)0xff00c4ac
#define P_VPP_VE_DITHER_LUT_12                     (volatile uint32_t *)0xff00c4b0
#define P_VPP_OSDSC_DITHER_CTRL                    (volatile uint32_t *)0xff00c4c0
#define P_VPP_OSDSC_DITHER_LUT_1                   (volatile uint32_t *)0xff00c4c4
#define P_VPP_OSDSC_DITHER_LUT_2                   (volatile uint32_t *)0xff00c4c8
#define P_VPP_OSDSC_DITHER_LUT_3                   (volatile uint32_t *)0xff00c4cc
#define P_VPP_OSDSC_DITHER_LUT_4                   (volatile uint32_t *)0xff00c4d0
#define P_VPP_OSDSC_DITHER_LUT_5                   (volatile uint32_t *)0xff00c4d4
#define P_VPP_OSDSC_DITHER_LUT_6                   (volatile uint32_t *)0xff00c4d8
#define P_VPP_OSDSC_DITHER_LUT_7                   (volatile uint32_t *)0xff00c4dc
#define P_VPP_OSDSC_DITHER_LUT_8                   (volatile uint32_t *)0xff00c4e0
#define P_VPP_OSDSC_DITHER_LUT_9                   (volatile uint32_t *)0xff00c4e4
#define P_VPP_OSDSC_DITHER_LUT_10                  (volatile uint32_t *)0xff00c4e8
#define P_VPP_OSDSC_DITHER_LUT_11                  (volatile uint32_t *)0xff00c4ec
#define P_VPP_OSDSC_DITHER_LUT_12                  (volatile uint32_t *)0xff00c4f0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_dither_regs.h
//
// 8'h40-8'h4f
//
// Reading file:  osdsc_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_OSD_DB_FLT_CTRL                          (volatile uint32_t *)0xff00c500
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strength of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define P_OSD_DB_FLT_CTRL1                         (volatile uint32_t *)0xff00c504
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define P_OSD_DB_FLT_LUMA_THRD                     (volatile uint32_t *)0xff00c508
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define P_OSD_DB_FLT_CHRM_THRD                     (volatile uint32_t *)0xff00c50c
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define P_OSD_DB_FLT_RANDLUT                       (volatile uint32_t *)0xff00c510
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define P_OSD_DB_FLT_PXI_THRD                      (volatile uint32_t *)0xff00c514
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define P_OSD_DB_FLT_SEED_Y                        (volatile uint32_t *)0xff00c518
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define P_OSD_DB_FLT_SEED_U                        (volatile uint32_t *)0xff00c51c
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define P_OSD_DB_FLT_SEED_V                        (volatile uint32_t *)0xff00c520
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD_DB_FLT_SEED3                         (volatile uint32_t *)0xff00c524
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD_DB_FLT_SEED4                         (volatile uint32_t *)0xff00c528
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD_DB_FLT_SEED5                         (volatile uint32_t *)0xff00c52c
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  osdsc_deband_regs.h
//
//register definition for xvycc
// 8'h50-8'h7f
//
// Reading file:  xvycc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_XVYCC_INV_LUT_Y_ADDR_PORT                (volatile uint32_t *)0xff00c560
//Bit 31:7, reserved
//Bit  6:0,  xvycc_inv_lut_y_addr;
#define P_XVYCC_INV_LUT_Y_DATA_PORT                (volatile uint32_t *)0xff00c564
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_y_data;
#define P_XVYCC_INV_LUT_U_ADDR_PORT                (volatile uint32_t *)0xff00c568
//Bit 31:6, reserved
//Bit  5:0,  xvycc_inv_lut_u_addr;
#define P_XVYCC_INV_LUT_U_DATA_PORT                (volatile uint32_t *)0xff00c56c
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_u_data;
#define P_XVYCC_INV_LUT_V_ADDR_PORT                (volatile uint32_t *)0xff00c570
//Bit 31:6, reserved
//Bit  5:0,  xvycc_inv_lut_v_addr;
#define P_XVYCC_INV_LUT_V_DATA_PORT                (volatile uint32_t *)0xff00c574
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_v_data;
#define P_XVYCC_LUT_R_ADDR_PORT                    (volatile uint32_t *)0xff00c578
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_r_addr;
#define P_XVYCC_LUT_R_DATA_PORT                    (volatile uint32_t *)0xff00c57c
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_r_data;
#define P_XVYCC_LUT_G_ADDR_PORT                    (volatile uint32_t *)0xff00c580
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_g_addr;
#define P_XVYCC_LUT_G_DATA_PORT                    (volatile uint32_t *)0xff00c584
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_g_data;
#define P_XVYCC_LUT_B_ADDR_PORT                    (volatile uint32_t *)0xff00c588
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_b_addr;
#define P_XVYCC_LUT_B_DATA_PORT                    (volatile uint32_t *)0xff00c58c
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_b_data;
#define P_XVYCC_INV_LUT_CTL                        (volatile uint32_t *)0xff00c590
//Bit 31:15, reserved
//Bit 14:12, reg_xvycc_cmpr_invlut_enable    enable for xvycc compression inverse-lut [2] for Y, [1] for U, [0] for V default=0
//Bit 11:10, reg_xvycc_cmpr_invlut_vscl_1   v LUT input scale for positive portion   default=0
//Bit  9: 8, reg_xvycc_cmpr_invlut_vscl_0   v LUT input scale for negative portion   default=0
//Bit  7: 6, reg_xvycc_cmpr_invlut_uscl_1   u LUT input scale for positive portion   default=0
//Bit  5: 4, reg_xvycc_cmpr_invlut_uscl_0   u LUT input scale for negative portion   default=0
//Bit  3: 2, reg_xvycc_cmpr_invlut_yscl_1   y LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_cmpr_invlut_yscl_0   y LUT input scale for negative portion   default=0
#define P_XVYCC_LUT_CTL                            (volatile uint32_t *)0xff00c594
//Bit 31: 7, reserved
//Bit  6: 4, reg_xvycc_lut_enable  LUT enable [6] for R, [5] for G, [4] for B  default=0
//Bit  3: 2, reg_xvycc_lut_scl_1   LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_lut_scl_0   LUT input scale for negative portion   default=0
#define P_XVYCC_VADJ1_CURV_0                       (volatile uint32_t *)0xff00c598
//Bit 31:24, vadj1_softcon_curv0_ci                         default=0
//Bit 23:12, vadj1_softcon_curv0_b                          default=0
//Bit 11: 0, vadj1_softcon_curv0_a                          default=0
#define P_XVYCC_VADJ1_CURV_1                       (volatile uint32_t *)0xff00c59c
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv0_cs                         default=0
#define P_XVYCC_VADJ1_CURV_2                       (volatile uint32_t *)0xff00c5a0
//Bit 31:24, vadj1_softcon_curv1_ci                         default=0
//Bit 23:12, vadj1_softcon_curv1_b                          default=0
//Bit 11: 0, vadj1_softcon_curv1_a                          default=0
#define P_XVYCC_VADJ1_CURV_3                       (volatile uint32_t *)0xff00c5a4
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv1_cs                         default=0
#define P_XVYCC_VADJ2_CURV_0                       (volatile uint32_t *)0xff00c5a8
//Bit 31:24, vadj2_softcon_curv0_ci                         default=0
//Bit 23:12, vadj2_softcon_curv0_b                          default=0
//Bit 11: 0, vadj2_softcon_curv0_a                          default=0
#define P_XVYCC_VADJ2_CURV_1                       (volatile uint32_t *)0xff00c5ac
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv0_cs                         default=0
#define P_XVYCC_VADJ2_CURV_2                       (volatile uint32_t *)0xff00c5b0
//Bit 31:24, vadj2_softcon_curv1_ci                         default=0
//Bit 23:12, vadj2_softcon_curv1_b                          default=0
//Bit 11: 0, vadj2_softcon_curv1_a                          default=0
#define P_XVYCC_VADJ2_CURV_3                       (volatile uint32_t *)0xff00c5b4
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv1_cs                         default=0
#define P_XVYCC_VD1_RGB_CTRST                      (volatile uint32_t *)0xff00c5c0
//Bit 31:28, reserved
//Bit 27:16, reg_vd1_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved
//Bit 13: 4, reg_vd1_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
//Bit  3: 2, reserved
//Bit     1, reg_vd1_rgbbst_en         u1, enable rgbbst         default=0
//Bit     0, reg_vd1_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
#define P_XVYCC_VD1_RGB_BRGHT                      (volatile uint32_t *)0xff00c5c4
//Bit 31:16, reserved
//Bit 15: 4, reg_vd1_rgb_brght        s12, brightness level in rgb domain                              default=0
//Bit  3: 2, reserved
//Bit     1, reg_vd1_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_vd1_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define P_XVYCC_VD1_RGB_DLUT_0_3                   (volatile uint32_t *)0xff00c5c8
//Bit 31:24, reg_vd1_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_vd1_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_vd1_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_vd1_rgbbst_dlut3      u8,   default = 147
#define P_XVYCC_VD1_RGB_DLUT_4_7                   (volatile uint32_t *)0xff00c5cc
//Bit 31:24, reg_vd1_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_vd1_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_vd1_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_vd1_rgbbst_dlut7      u8,   default = 93
#define P_XVYCC_VD1_RGB_DLUT_8_11                  (volatile uint32_t *)0xff00c5d0
//Bit 31:24, reg_vd1_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_vd1_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_vd1_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_vd1_rgbbst_dlut11     u8,   default = 68
#define P_XVYCC_POST_RGB_CTRST                     (volatile uint32_t *)0xff00c5d4
//Bit 31:28, reserved
//Bit 27:16, reg_post_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved
//Bit 13: 4, reg_post_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
//Bit  3: 2, reserved
//Bit     1, reg_post_rgbbst_en         u1, enable rgbbst         default=0
//Bit     0, reg_post_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
#define P_XVYCC_POST_RGB_BRGHT                     (volatile uint32_t *)0xff00c5d8
//Bit 31:16, reserved
//Bit 15: 4, reg_post_rgb_brght        s12, brightness level in rgb domain                              default=0
//Bit  3: 2, reserved
//Bit     1, reg_post_rgb_brght_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_post_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define P_XVYCC_POST_RGB_DLUT_0_3                  (volatile uint32_t *)0xff00c5dc
//Bit 31:24, reg_post_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_post_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_post_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_post_rgbbst_dlut3      u8,   default = 147
#define P_XVYCC_POST_RGB_DLUT_4_7                  (volatile uint32_t *)0xff00c5e0
//Bit 31:24, reg_post_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_post_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_post_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_post_rgbbst_dlut7      u8,   default = 93
#define P_XVYCC_POST_RGB_DLUT_8_11                 (volatile uint32_t *)0xff00c5e4
//Bit 31:24, reg_post_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_post_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_post_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_post_rgbbst_dlut11     u8,   default = 68
#define P_ADAPTIVE_SCALE_REG0                      (volatile uint32_t *)0xff00c540
//Bit 31,    reg_adaptive_scale_enable    u1,  default = 1
//Bit 27:16, reg_adpscl_ys_coef_0        u12,  default = 538
//Bit 11: 0, reg_adpscl_ys_coef_1        u12,  default = 1389
#define P_ADAPTIVE_SCALE_REG1                      (volatile uint32_t *)0xff00c544
//Bit 27:16, reg_adpscl_ys_coef_2        u12,  default = 121
//Bit 11: 0, reg_adpscl_alpha_0          u12,  default = 1024
#define P_ADAPTIVE_SCALE_REG2                      (volatile uint32_t *)0xff00c548
//Bit 27:16, reg_adpscl_alpha_1          u12,  default = 1024
//Bit 11: 0, reg_adpscl_alpha_2          u12,  default = 1024
#define P_ADAPTIVE_SCALE_REG3                      (volatile uint32_t *)0xff00c54c
//Bit 31:16, reg_adpscl_beta_0          u16,  default = 0
//Bit 15: 0, reg_adpscl_beta_1          u16,  default = 0
#define P_ADAPTIVE_SCALE_REG4                      (volatile uint32_t *)0xff00c550
//Bit 31:16, reg_adpscl_beta_2          u16,  default = 0
#define P_ADAPTIVE_SCALE_ADDR                      (volatile uint32_t *)0xff00c554
//Bit 6:0,   reg_lut_addr               u7,  default = 0
#define P_ADAPTIVE_SCALE_DATA                      (volatile uint32_t *)0xff00c558
//Bit 11:0,  reg_lut_data               u12,  default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  xvycc_regs.h
//
//register definition for vd2 afbc dec
// 8'h80-8'h9f
//
// Reading file:  vd2_afbc_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define P_VD2_AFBC_ENABLE                          (volatile uint32_t *)0xff00c600
//Bit   31:29,    reserved
//Bit   28:23,    reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22,       reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21,       reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20,       reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19,       reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16,    soft_rst          unsigned  , default = 4
//Bit   15:14,    reserved
//Bit   13:12,    ddr_blk_size      unsigned  , default = 1
//Bit   11:9,     cmd_blk_size      unsigned  , default = 3
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:2,      reserved
//Bit   1,        head_len_sel      unsigned  , default = 1
//Bit   0,        dec_frm_start     unsigned  , default = 0
#define P_VD2_AFBC_MODE                            (volatile uint32_t *)0xff00c604
//Bit   31:30,    reserved
//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num     uns, default = 4 ,
//Bit   15:14,    burst_len         uns, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8,     compbits_yuv      uns, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horizontal skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horizontal skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define P_VD2_AFBC_SIZE_IN                         (volatile uint32_t *)0xff00c608
//Bit   31:29,    reserved
//Bit   28:16     hsize_in          uns, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in          uns, default = 1080 , pic vertical size in  unit: pixel
#define P_VD2_AFBC_DEC_DEF_COLOR                   (volatile uint32_t *)0xff00c60c
//Bit   31:30,   reserved
//Bit   29:20,   def_color_y        uns, default = 255, afbc dec y default setting value
//Bit   19:10,   def_color_u        uns, default = 128, afbc dec u default setting value
//Bit    9: 0,   def_color_v        uns, default = 128, afbc dec v default setting value
#define P_VD2_AFBC_CONV_CTRL                       (volatile uint32_t *)0xff00c610
//Bit   31:14,   reserved
//Bit   13:12,   fmt_mode            uns, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
#define P_VD2_AFBC_LBUF_DEPTH                      (volatile uint32_t *)0xff00c614
//Bit   31:28,   reserved
//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
//Bit   15:12,   reserved
//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
#define P_VD2_AFBC_HEAD_BADDR                      (volatile uint32_t *)0xff00c618
//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
#define P_VD2_AFBC_BODY_BADDR                      (volatile uint32_t *)0xff00c61c
//Bit   31:0,   mif_data_baddr      uns, default = 32'h00010000;
#define P_VD2_AFBC_SIZE_OUT                        (volatile uint32_t *)0xff00c620
//Bit   31:29,   reserved
//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
#define P_VD2_AFBC_OUT_YSCOPE                      (volatile uint32_t *)0xff00c624
//Bit   31:29,   reserved
//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
#define P_VD2_AFBC_STAT                            (volatile uint32_t *)0xff00c628
//Bit   31:0,   ro_dbg_top_info      uns
#define P_VD2_AFBC_VD_CFMT_CTRL                    (volatile uint32_t *)0xff00c62c
//Bit 31    cfmt_gclk_bit_dis      uns, default = 0    ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      uns, default = 0    ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         uns, default = 0    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               uns, default = 0    ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en uns, default = 0    ; //if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     uns, default = 0    ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   uns, default = 0    ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     uns, default = 0    ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    uns, default = 0    ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        uns, default = 0    ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       uns, default = 0    ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               uns, default = 0    ; //vertical formatter enable
#define P_VD2_AFBC_VD_CFMT_W                       (volatile uint32_t *)0xff00c630
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                uns, default = 0    ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                uns, default = 0    ;vertical formatter width
#define P_VD2_AFBC_MIF_HOR_SCOPE                   (volatile uint32_t *)0xff00c634
//Bit   31:26,   reserved
//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10,   reserved
//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
#define P_VD2_AFBC_MIF_VER_SCOPE                   (volatile uint32_t *)0xff00c638
//Bit   31:28,   reserved
//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12,   reserved
//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
#define P_VD2_AFBC_PIXEL_HOR_SCOPE                 (volatile uint32_t *)0xff00c63c
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
#define P_VD2_AFBC_PIXEL_VER_SCOPE                 (volatile uint32_t *)0xff00c640
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
#define P_VD2_AFBC_VD_CFMT_H                       (volatile uint32_t *)0xff00c644
//Bit 31:13,    reserved
//Bit 12:0      cfmt_h  uns, default = 142  ; //vertical formatter height
#define P_VD2_AFBCDEC_IQUANT_ENABLE                (volatile uint32_t *)0xff00c648
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1  //unsigned, RW, enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0  //unsigned, RW, enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_VD2_AFBCDEC_IQUANT_LUT_1                 (volatile uint32_t *)0xff00c64c
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_VD2_AFBCDEC_IQUANT_LUT_2                 (volatile uint32_t *)0xff00c650
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_VD2_AFBCDEC_IQUANT_LUT_3                 (volatile uint32_t *)0xff00c654
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_VD2_AFBCDEC_IQUANT_LUT_4                 (volatile uint32_t *)0xff00c658
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vd2_afbc_dec_regs.h
//
//register definition for osd1 afbcd dec
// 8'ha0-8'haf
//
// Reading file:  osd1_afbcd_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define P_OSD1_AFBCD_ENABLE                        (volatile uint32_t *)0xff00c680
//Bit   31:16,    reserved
//Bit   15:9,     id_fifo_thrd      unsigned  , default = 64, axi id fifo threshold
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:1,      reserved
//Bit   0,        frm_start         unsigned  , default = 0
#define P_OSD1_AFBCD_MODE                          (volatile uint32_t *)0xff00c684
//Bit   31,       soft_reset              the use as go_field
//Bit   30:29,    reserved
//Bit   28,       axi_reorder_mode        default=0, the axi reorder mode, note : don't seting
//Bit   27:26,    reserved
//Bit   25:24,    mif_urgent              uns, default = 3 , info mif and data mif urgent
//Bit   22:16,    hold_line_num
//Bit   15:8,     rgba_exchan_ctrl
//Bit   7,        reserved
//Bit   6,        hreg_block_split        uns, default = 1 , Enable/disable block split mode in sparse allocation
//Bit   5,        hreg_half_block         uns, default = 1 , Enable/disable half block decoding. 1=half block, 0=full block
//Bit   4:0,      hreg_pixel_packing_fmt  uns, default = 5 , Pixel format
#define P_OSD1_AFBCD_SIZE_IN                       (volatile uint32_t *)0xff00c688
//Bit   31:16     hreg_hsize_in          uns, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:0,     hreg_vsize_in          uns, default = 1080 , pic vertical size in  unit: pixel
#define P_OSD1_AFBCD_HDR_PTR                       (volatile uint32_t *)0xff00c68c
//Bit   31:0      hreg_hdr_ptr           uns, default = 0 ,
#define P_OSD1_AFBCD_FRAME_PTR                     (volatile uint32_t *)0xff00c690
//Bit   31:0      hreg_frame_ptr         uns, default = 0 , The start address of the target frame buffer.
//                                       For YUV format, this pointer specifies the luma buffer.
#define P_OSD1_AFBCD_CHROMA_PTR                    (volatile uint32_t *)0xff00c694
//Bit   31:0      hreg_chroma_ptr        uns, default = 0 , Only valid in YUV format, to specify the target chroma buffer.
#define P_OSD1_AFBCD_CONV_CTRL                     (volatile uint32_t *)0xff00c698
//Bit   31:15,   reserved
//Bit   15: 0,   conv_lbuf_len           uns, default = 1024, unit=16 pixel need to set = 2^n
#define P_OSD1_AFBCD_STATUS                        (volatile uint32_t *)0xff00c6a0
//Bit   30:4,     reserved
//Bit   3,        hreg_dec_resp          uns, default = 0 , Decoder error flage from the dec4x4 core
//Bit   2,        hreg_axi_bresp         uns, default = 0 , Bus error flag for AXI write error
//Bit   1,        hreg_axi_rresp         uns, default = 0 , Bus error flag for AXI read error
//Bit   0,        hreg_idle_n            uns, default = 0 , Idle output, value 0 indicates the standalone decoder is free now and can start the next frame.
#define P_OSD1_AFBCD_PIXEL_HSCOPE                  (volatile uint32_t *)0xff00c6a4
//Bit   31:16,   dec_pixel_bgn_h         uns, default = 0  ; // unit: pixel
//Bit   15: 0,   dec_pixel_end_h         uns, default = 1919 ; // unit: pixel
#define P_OSD1_AFBCD_PIXEL_VSCOPE                  (volatile uint32_t *)0xff00c6a8
//Bit   31:16,   dec_pixel_bgn_v         uns, default = 0  ; // unit: pixel
//Bit   15: 0,   dec_pixel_end_v         uns, default = 1079 ; // unit: pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  osd1_afbcd_regs.h
//
//register definition for osd1 afbcd dec
// 8'hb0-8'hca
//
// Reading file:  vpp_vmx_wm_regs.h
//
//// synopsys translate_off
//`ifdef VPP_WM_REGS_H
//`else
//    `define VPP_WM_REGS_H
//// synopsys translate_on
#define P_WM_CTRL                                  (volatile uint32_t *)0xff00c6c0
//Bit  31,      int_mask					default = 0
//Bit  30:16,	reserved
//Bit  15:8,	strength_multiply			default =1
//Bit  7:6,		reserved
//Bit  5,       shift_en                      default = 0
//Bit  4,		background_embedding_on			default =0
//Bit  3,		mark_en			default =0
//Bit  2,		noise_en			default =0
//Bit  1,		blend_en			default =0
//Bit  0,		wm_en			default =0
#define P_WM_SPACE_RESOLUTION                      (volatile uint32_t *)0xff00c6c4
//Bit  31:25,	reserved
//Bit  24:16,	spacing_horz			default =10
//Bit  15:9,    reserved
//Bit  8:0,		spacing_vert			default =12
#define P_WM_SYMBOLS_NUM                           (volatile uint32_t *)0xff00c6c8
//Bit  31:8, reserved
//Bit  7:4, symbols_cols		1~10;	default =5	
//Bit  3:0, symbols_rows		1~10;	default =2 	
#define P_WM_MARK_RESOLUTION                       (volatile uint32_t *)0xff00c6cc
//Bit  31:20,  mark_hsize		mark_buffer_width;  	default =1820
//Bit  19:8,   mark_vsize		mark_buffer_height; 	default =1820             t =780
//Bit  7:6,		reserved
//Bit  5:0,		scale			default =13                  // scale up
#define P_WM_FREQ_DIST_LEFT                        (volatile uint32_t *)0xff00c6d0
//Bit  31:21, reserved
//Bit  20:0, freq_dist_left			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define P_WM_FREQ_DIST_RIGHT                       (volatile uint32_t *)0xff00c6d4
//Bit  31:21, reserved
//Bit  20:0, freq_dist_right			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define P_WM_FREQ_DIST_TOP                         (volatile uint32_t *)0xff00c6d8
//Bit  31:21, reserved
//Bit  20:0, freq_dist_top			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define P_WM_SYMBOLS_XPOS                          (volatile uint32_t *)0xff00c6dc
//Bit  31:29, reserved
//Bit  28:16, symbols_xpos_start			default =1536      // SYMBOLS_XPOS * h_res
//Bit  15:13, reserved
//Bit  12:0,  symbols_xpos_end			default =3356        // SYMBOLS_XPOS * h_res + mark_hsize
#define P_WM_SYMBOLS_YPOS                          (volatile uint32_t *)0xff00c6e0
//Bit  31:29, reserved
//Bit  28:16, symbols_ypos_start			default =756      // SYMBOLS_yPOS * y_res
//Bit  15:13, reserved
//Bit  12:0,  symbols_ypos_end			    default =1536        // SYMBOLS_yPOS * y_res + mark_vsize
#define P_WM_STORAGE_SETTING                       (volatile uint32_t *)0xff00c6e4
//Bit  31:28, reserved
//Bit  27:16, direction_max		default = 80
//Bit	  15, reserved
//Bit   14:8, storage_s			default =18               // biggest is 72      S
//Bit      7, reserved
//Bit    6:0, storage_max_distance			default =36    // biggest is 72      max_distance
#define P_WM_VIDEO_RESOLUTION                      (volatile uint32_t *)0xff00c6e8
//Bit  31:29, reserved
//Bit  28:16, h_res			default =3840                   // video hsize
//Bit  15:13, reserved
//Bit  12:0,  v_res			default =2160                   // video vsize
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD0         (volatile uint32_t *)0xff00c6ec
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_0		default =48
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_1		default =60
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD1         (volatile uint32_t *)0xff00c6f0
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_2		default = 68
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_3		default = 80
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD2         (volatile uint32_t *)0xff00c6f4
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_4		default = 88
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_5		default = 96
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD3         (volatile uint32_t *)0xff00c6f8
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_6		default = 100
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_7		default = 108
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD4         (volatile uint32_t *)0xff00c6fc
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_8		default = 112
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_9		default = 116
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD5         (volatile uint32_t *)0xff00c700
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_10		default = 120
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_11		default = 124
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG0      (volatile uint32_t *)0xff00c704
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_0		default =320
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_1		default = 328
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG1      (volatile uint32_t *)0xff00c708
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_2		default = 332
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_3		default = 340
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG2      (volatile uint32_t *)0xff00c70c
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_4		default = 344
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_5		default = 348
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG3      (volatile uint32_t *)0xff00c710
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_6		default = 352
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_7		default = 356
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG4      (volatile uint32_t *)0xff00c714
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_8		default = 360
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_9		default = 368
#define P_WM_EMBEDDING_STRENGTH_THRESHOLD_BG5      (volatile uint32_t *)0xff00c718
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_10		default = 372
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_11		default = 380
#define P_WM_AM_LUT_DATA_PORT                      (volatile uint32_t *)0xff00c71c
#define P_WM_AM_LUT_ADDR_PORT                      (volatile uint32_t *)0xff00c720
#define P_WM_STATUS_RO                             (volatile uint32_t *)0xff00c724
//Bit  31,  ro_resolution_changed
//Bit  30:29, reserved
//Bit  30:16, ro_hsize_in
//Bit  15:13, reserved
//Bit  8:0,   ro_vsize_in
#define P_WM_STATUS_RAM_RO                         (volatile uint32_t *)0xff00c728
//Bit  31:9,  reserved
//Bit  8:0,   ro_ram_addr
#define P_WM_THRES_ADDR_PORT                       (volatile uint32_t *)0xff00c72c
#define P_WM_THRES_DATA_PORT                       (volatile uint32_t *)0xff00c734
//
// Closing file:  vpp_vmx_wm_regs.h
//
//
// Reading file:  ngptv_reg.h
//
//// synopsys translate_off
//`ifdef VPP_WM_REGS_H
//`else
//    `define VPP_WM_REGS_H
//// synopsys translate_on
#define P_REG_NGPTV_CTRL0                          (volatile uint32_t *)0xff00c6ac
//Bit 31:25,        reserved
//Bit 24,           bypass_latch
//Bit 23,           count_enable                             deafult=1
//Bit 22,           soft_rst
//Bit 21,           count_rst
//Bit 20,           bypass run
//Bit 19:14,        ochannel_sel                             deafult=0x24
//Bit 13:8,         ichannel_sel                             deafult=0x24
//Bit 3,            8bit mode
//Bit 2,            10bit mode
//Bit 1,            reg_sync enable
//Bit 0,            bypass
#define P_REG_NGPTV_CTRL1                          (volatile uint32_t *)0xff00c6b0
//Bit 31:7          reserved
//Bit 6             reset sw                            default=0
//Bit 5:0           gclk_ctrl
#define P_REG_NGPTV_CTRL2                          (volatile uint32_t *)0xff00c6b4
//Bit 31:8          reserved
//Bit 7             SpareIn
//Bit 6             NG_EnableServiceIn
//Bit 5:4           reserved
//Bit 3             NG_DebugEnableIn
//Bit 2             reserved
//Bit 1             NG_Payload24_56n
//Bit 0             NG_YUVnRGBIn
#define P_REG_NGPTV_CTRL3                          (volatile uint32_t *)0xff00c738
//Bit 31:0          NG_KeyIn                            default=0x01ac7f33
#define P_REG_NGPTV_CTRL4                          (volatile uint32_t *)0xff00c73c
//Bit 31:0          NG_PayloadDataIn[31:0]              default=0x6789abcd
#define P_REG_NGPTV_CTRL5                          (volatile uint32_t *)0xff00c7c0
//Bit 31:26         Reserved
//Bit 25:24         NG_FrameTypeIn                      default=3
//Bit 23:0          NG_PayloadDataIn                    default=0x012345
#define P_REG_NGPTV_CTRL6                          (volatile uint32_t *)0xff00c7c4
//Bit 31:0          NG_SettingIn[31:0]                  default=0x18c6318c
#define P_REG_NGPTV_CTRL7                          (volatile uint32_t *)0xff00c7c8
//Bit 31:0          NG_SettingIn[63:32]                 default=0x84210842
#define P_REG_NGPTV_CTRL8                          (volatile uint32_t *)0xff00c7cc
//Bit 31:0          NG_SettingIn[95:64]                 default=0x21084210
#define P_REG_NGPTV_CTRL9                          (volatile uint32_t *)0xff00c7d0
//Bit 31:0          NG_SettingIn[127:96]                default=0x8c631084
#define P_REG_NGPTV_CTRL10                         (volatile uint32_t *)0xff00c7d4
//Bit 31:0          NG_SettingIn[159:128]               default=0x84210631
#define P_REG_NGPTV_CTRL11                         (volatile uint32_t *)0xff00c7d8
//Bit 31:16         Reserved
//Bit 15:8          NG_FrameRateIn                      default=0x18
//Bit 7             Reserved
//Bit 6:5           NG_CoreIDIn                         default=0
//Bit 4:0           NG_SettingIn[165:160]               default=0x10
#define P_REG_NGPTV_CTRL12                         (volatile uint32_t *)0xff00c7dc
//Bit 31:29         Reserved
//Bit 28:16         vsize                               default=0x438
//Bit 16:13         Reserved
//Bit 12:0          hsize                               default=0x780
#define P_REG_NGPTV_CTRL13                         (volatile uint32_t *)0xff00c7e0
//Bit 31:29         Reserved
//Bit 28:16         reg_vphstart                               default=0x0
//Bit 16:13         Reserved
//Bit 12:0          reg_vphend                               default=0x437
#define P_REG_NGPTV_CTRL14                         (volatile uint32_t *)0xff00c7e4
//Bit 31:13         Reserved
//Bit 12:0          reg_3d_right_st                               default=0x3c0
#define P_REG_NGPTV_CTRL15                         (volatile uint32_t *)0xff00c7e8
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart0                               default=0x0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend0                               default=0x437
#define P_REG_NGPTV_CTRL16                         (volatile uint32_t *)0xff00c7ec
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart1                                default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend1                               default=0
#define P_REG_NGPTV_CTRL17                         (volatile uint32_t *)0xff00c7f0
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart2                               default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend2                               default=0
#define P_REG_NGPTV_CTRL18                         (volatile uint32_t *)0xff00c7f4
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart3                               default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend3                               default=0
#define P_RO_NGPTV_CTRL19                          (volatile uint32_t *)0xff00c7f8
//Bit 31            dat_val_in
//Bit 30            in_hold
//Bit 29            out_hold
//Bit 28:16         vcnt
//Bit 15:12         NG_ErrorOut
//Bit 11:0          NG_VersionOut
//
// Closing file:  ngptv_reg.h
//
// 8'hd0-8hef
//
// Reading file:  bt2020_regs.h
//
// synopsys translate_off
// synopsys translate_on
//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
//Bit 17:6  for clock gating
//Bit 5:4   pscale_mode ch2
//Bit 3:2   pscale_mode ch1
//Bit 1:0   pscale_mode ch0
#define P_VPP_EOTF_CTL                             (volatile uint32_t *)0xff00c740
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VPP_EOTF_COEF00_01                       (volatile uint32_t *)0xff00c744
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_VPP_EOTF_COEF02_10                       (volatile uint32_t *)0xff00c748
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VPP_EOTF_COEF11_12                       (volatile uint32_t *)0xff00c74c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VPP_EOTF_COEF20_21                       (volatile uint32_t *)0xff00c750
//Bit 28:16 coef22
//Bit   2:0 coef_rs
#define P_VPP_EOTF_COEF22_RS                       (volatile uint32_t *)0xff00c754
#define P_VPP_EOTF_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00c758
#define P_VPP_EOTF_LUT_DATA_PORT                   (volatile uint32_t *)0xff00c75c
#define P_VPP_EOTF_3X3_OFST_0                      (volatile uint32_t *)0xff00c760
#define P_VPP_EOTF_3X3_OFST_1                      (volatile uint32_t *)0xff00c764
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  bt2020_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_partb_reg.h
//
// -----------------------------------------------
// REG_BASE:  VPPD_VCBUS_BASE = 0x32
// -----------------------------------------------
//
// Reading file:  vpp_vadj_regs.h
//
// synopsys translate_off
// synopsys translate_on
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
//`define VD1_IF0_GEN_REG            8'h0
//`define VD1_IF0_CANVAS0            8'h1
//`define VD1_IF0_CANVAS1            8'h2
//`define VD1_IF0_LUMA_X0            8'h3
//`define VD1_IF0_LUMA_Y0            8'h4
//`define VD1_IF0_CHROMA_X0          8'h5
//`define VD1_IF0_CHROMA_Y0          8'h6
//`define VD1_IF0_LUMA_X1            8'h7
//`define VD1_IF0_LUMA_Y1            8'h8
//`define VD1_IF0_CHROMA_X1          8'h9
//`define VD1_IF0_CHROMA_Y1          8'ha
//`define VD1_IF0_RPT_LOOP           8'hb
//`define VD1_IF0_LUMA0_RPT_PAT      8'hc
//`define VD1_IF0_CHROMA0_RPT_PAT    8'hd
//`define VD1_IF0_LUMA1_RPT_PAT      8'he
//`define VD1_IF0_CHROMA1_RPT_PAT    8'hf
//`define VD1_IF0_LUMA_PSEL          8'h10
//`define VD1_IF0_CHROMA_PSEL        8'h11
//`define VD1_IF0_DUMMY_PIXEL        8'h12
//`define VD1_IF0_LUMA_FIFO_SIZE     8'h13
//`define VD1_IF0_AXI_CMD_CNT        8'h14
//`define VD1_IF0_AXI_RDAT_CNT       8'h15
//`define VD1_IF0_GEN_REG3           8'h16
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    vertical formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)
//Bit 0     vertical formatter enable
//`define VIU_VD1_FMT_CTRL           8'h18       //29'h0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
//`define VIU_VD1_FMT_W              8'h19       //28'h0
//`define VD1_IF0_RANGE_MAP_Y        8'h1a
//`define VD1_IF0_RANGE_MAP_CB       8'h1b
//`define VD1_IF0_RANGE_MAP_CR       8'h1c
//`define VD1_IF0_GEN_REG2           8'h1d
//`define VD1_IF0_PROT_CNTL          8'h1e
//`define VD1_IF0_URGENT_CTRL        8'h1f
//------------------------------------------------------------------------------
// VD2 path
//------------------------------------------------------------------------------
//`define VD2_IF0_GEN_REG            8'h20
//`define VD2_IF0_CANVAS0            8'h21
//`define VD2_IF0_CANVAS1            8'h22
//`define VD2_IF0_LUMA_X0            8'h23
//`define VD2_IF0_LUMA_Y0            8'h24
//`define VD2_IF0_CHROMA_X0          8'h25
//`define VD2_IF0_CHROMA_Y0          8'h26
//`define VD2_IF0_LUMA_X1            8'h27
//`define VD2_IF0_LUMA_Y1            8'h28
//`define VD2_IF0_CHROMA_X1          8'h29
//`define VD2_IF0_CHROMA_Y1          8'h2a
//`define VD2_IF0_RPT_LOOP           8'h2b
//`define VD2_IF0_LUMA0_RPT_PAT      8'h2c
//`define VD2_IF0_CHROMA0_RPT_PAT    8'h2d
//`define VD2_IF0_LUMA1_RPT_PAT      8'h2e
//`define VD2_IF0_CHROMA1_RPT_PAT    8'h2f
//`define VD2_IF0_LUMA_PSEL          8'h30
//`define VD2_IF0_CHROMA_PSEL        8'h31
//`define VD2_IF0_DUMMY_PIXEL        8'h32
//`define VD2_IF0_LUMA_FIFO_SIZE     8'h33
//`define VD2_IF0_AXI_CMD_CNT        8'h34
//`define VD2_IF0_AXI_RDAT_CNT       8'h35
//`define VD2_IF0_GEN_REG3           8'h36
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 17    vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    vertical formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)
//Bit 0     vertical formatter enable
//`define VIU_VD2_FMT_CTRL           8'h38       //29'h0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
//`define VIU_VD2_FMT_W              8'h39       //28'h0
//`define VD2_IF0_RANGE_MAP_Y        8'h3a
//`define VD2_IF0_RANGE_MAP_CB       8'h3b
//`define VD2_IF0_RANGE_MAP_CR       8'h3c
//`define VD2_IF0_GEN_REG2           8'h3d
//`define VD2_IF0_PROT_CNTL          8'h3e
//`define VD2_IF0_URGENT_CTRL        8'h3f
#define P_VPP_VADJ1_MISC                           (volatile uint32_t *)0xff00ca00
#define P_VPP_VADJ1_BLACK_VAL                      (volatile uint32_t *)0xff00ca04
#define P_VPP_VADJ1_Y                              (volatile uint32_t *)0xff00ca08
#define P_VPP_VADJ1_MA_MB                          (volatile uint32_t *)0xff00ca0c
#define P_VPP_VADJ1_MC_MD                          (volatile uint32_t *)0xff00ca10
#define P_VPP_VADJ1_CURV_0                         (volatile uint32_t *)0xff00ca14
#define P_VPP_VADJ1_CURV_1                         (volatile uint32_t *)0xff00ca18
#define P_VPP_VADJ1_CURV_2                         (volatile uint32_t *)0xff00ca1c
#define P_VPP_VADJ1_CURV_3                         (volatile uint32_t *)0xff00ca20
#define P_VPP_VD1_RGB_CTRST                        (volatile uint32_t *)0xff00ca24
#define P_VPP_VD1_RGB_BRGHT                        (volatile uint32_t *)0xff00ca28
#define P_VPP_VD1_RGB_DLUT_0_3                     (volatile uint32_t *)0xff00ca2c
#define P_VPP_VD1_RGB_DLUT_4_7                     (volatile uint32_t *)0xff00ca30
#define P_VPP_VD1_RGB_DLUT_8_11                    (volatile uint32_t *)0xff00ca34
#define P_VPP_VD1_MATRIX_COEF00_01                 (volatile uint32_t *)0xff00ca40
#define P_VPP_VD1_MATRIX_COEF02_10                 (volatile uint32_t *)0xff00ca44
#define P_VPP_VD1_MATRIX_COEF11_12                 (volatile uint32_t *)0xff00ca48
#define P_VPP_VD1_MATRIX_COEF20_21                 (volatile uint32_t *)0xff00ca4c
#define P_VPP_VD1_MATRIX_COEF22                    (volatile uint32_t *)0xff00ca50
#define P_VPP_VD1_MATRIX_COEF13_14                 (volatile uint32_t *)0xff00ca54
#define P_VPP_VD1_MATRIX_COEF23_24                 (volatile uint32_t *)0xff00ca58
#define P_VPP_VD1_MATRIX_COEF15_25                 (volatile uint32_t *)0xff00ca5c
#define P_VPP_VD1_MATRIX_CLIP                      (volatile uint32_t *)0xff00ca60
#define P_VPP_VD1_MATRIX_OFFSET0_1                 (volatile uint32_t *)0xff00ca64
#define P_VPP_VD1_MATRIX_OFFSET2                   (volatile uint32_t *)0xff00ca68
#define P_VPP_VD1_MATRIX_PRE_OFFSET0_1             (volatile uint32_t *)0xff00ca6c
#define P_VPP_VD1_MATRIX_PRE_OFFSET2               (volatile uint32_t *)0xff00ca70
#define P_VPP_VD1_MATRIX_EN_CTRL                   (volatile uint32_t *)0xff00ca74
#define P_VPP_VADJ2_MISC                           (volatile uint32_t *)0xff00ca80
#define P_VPP_VADJ2_BLACK_VAL                      (volatile uint32_t *)0xff00ca84
#define P_VPP_VADJ2_Y                              (volatile uint32_t *)0xff00ca88
#define P_VPP_VADJ2_MA_MB                          (volatile uint32_t *)0xff00ca8c
#define P_VPP_VADJ2_MC_MD                          (volatile uint32_t *)0xff00ca90
#define P_VPP_VADJ2_CURV_0                         (volatile uint32_t *)0xff00ca94
#define P_VPP_VADJ2_CURV_1                         (volatile uint32_t *)0xff00ca98
#define P_VPP_VADJ2_CURV_2                         (volatile uint32_t *)0xff00ca9c
#define P_VPP_VADJ2_CURV_3                         (volatile uint32_t *)0xff00caa0
#define P_VPP_POST_RGB_CTRST                       (volatile uint32_t *)0xff00caa4
#define P_VPP_POST_RGB_BRGHT                       (volatile uint32_t *)0xff00caa8
#define P_VPP_POST_RGB_DLUT_0_3                    (volatile uint32_t *)0xff00caac
#define P_VPP_POST_RGB_DLUT_4_7                    (volatile uint32_t *)0xff00cab0
#define P_VPP_POST_RGB_DLUT_8_11                   (volatile uint32_t *)0xff00cab4
#define P_VPP_POST_MATRIX_COEF00_01                (volatile uint32_t *)0xff00cac0
#define P_VPP_POST_MATRIX_COEF02_10                (volatile uint32_t *)0xff00cac4
#define P_VPP_POST_MATRIX_COEF11_12                (volatile uint32_t *)0xff00cac8
#define P_VPP_POST_MATRIX_COEF20_21                (volatile uint32_t *)0xff00cacc
#define P_VPP_POST_MATRIX_COEF22                   (volatile uint32_t *)0xff00cad0
#define P_VPP_POST_MATRIX_COEF13_14                (volatile uint32_t *)0xff00cad4
#define P_VPP_POST_MATRIX_COEF23_24                (volatile uint32_t *)0xff00cad8
#define P_VPP_POST_MATRIX_COEF15_25                (volatile uint32_t *)0xff00cadc
#define P_VPP_POST_MATRIX_CLIP                     (volatile uint32_t *)0xff00cae0
#define P_VPP_POST_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff00cae4
#define P_VPP_POST_MATRIX_OFFSET2                  (volatile uint32_t *)0xff00cae8
#define P_VPP_POST_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff00caec
#define P_VPP_POST_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff00caf0
#define P_VPP_POST_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff00caf4
#define P_VPP_VD1_MATRIX_SAT                       (volatile uint32_t *)0xff00cb00
#define P_VPP_POST_MATRIX_SAT                      (volatile uint32_t *)0xff00cb04
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_vadj_regs.h
//
// -----------------------------------------------
// REG_BASE:  DOLBY1A_VCBUS_BASE = 0x33
// -----------------------------------------------
//
// Reading file:  dolby1a_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_CORE1A_REG_START                   (volatile uint32_t *)0xff00cc00
#define P_DOLBY_CORE1A_CLKGATE_CTRL                (volatile uint32_t *)0xff00cfc8
#define P_DOLBY_CORE1A_SWAP_CTRL0                  (volatile uint32_t *)0xff00cfcc
#define P_DOLBY_CORE1A_SWAP_CTRL1                  (volatile uint32_t *)0xff00cfd0
#define P_DOLBY_CORE1A_SWAP_CTRL2                  (volatile uint32_t *)0xff00cfd4
#define P_DOLBY_CORE1A_SWAP_CTRL3                  (volatile uint32_t *)0xff00cfd8
#define P_DOLBY_CORE1A_SWAP_CTRL4                  (volatile uint32_t *)0xff00cfdc
#define P_DOLBY_CORE1A_SWAP_CTRL5                  (volatile uint32_t *)0xff00cfe0
#define P_DOLBY_CORE1A_DMA_CTRL                    (volatile uint32_t *)0xff00cfe4
#define P_DOLBY_CORE1A_DMA_STATUS                  (volatile uint32_t *)0xff00cfe8
#define P_DOLBY_CORE1A_STATUS0                     (volatile uint32_t *)0xff00cfec
#define P_DOLBY_CORE1A_STATUS1                     (volatile uint32_t *)0xff00cff0
#define P_DOLBY_CORE1A_STATUS2                     (volatile uint32_t *)0xff00cff4
#define P_DOLBY_CORE1A_STATUS3                     (volatile uint32_t *)0xff00cff8
#define P_DOLBY_CORE1A_DMA_PORT                    (volatile uint32_t *)0xff00cffc
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dolby1a_regs.h
//
// -----------------------------------------------
// REG_BASE:  DOLBY2A_VCBUS_BASE = 0x34
// -----------------------------------------------
//
// Reading file:  dolby2a_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_CORE2A_REG_START                   (volatile uint32_t *)0xff00d000
#define P_DOLBY_CORE2A_CLKGATE_CTRL                (volatile uint32_t *)0xff00d0c8
#define P_DOLBY_CORE2A_SWAP_CTRL0                  (volatile uint32_t *)0xff00d0cc
#define P_DOLBY_CORE2A_SWAP_CTRL1                  (volatile uint32_t *)0xff00d0d0
#define P_DOLBY_CORE2A_SWAP_CTRL2                  (volatile uint32_t *)0xff00d0d4
#define P_DOLBY_CORE2A_SWAP_CTRL3                  (volatile uint32_t *)0xff00d0d8
#define P_DOLBY_CORE2A_SWAP_CTRL4                  (volatile uint32_t *)0xff00d0dc
#define P_DOLBY_CORE2A_SWAP_CTRL5                  (volatile uint32_t *)0xff00d0e0
#define P_DOLBY_CORE2A_DMA_CTRL                    (volatile uint32_t *)0xff00d0e4
#define P_DOLBY_CORE2A_DMA_STATUS                  (volatile uint32_t *)0xff00d0e8
#define P_DOLBY_CORE2A_STATUS0                     (volatile uint32_t *)0xff00d0ec
#define P_DOLBY_CORE2A_STATUS1                     (volatile uint32_t *)0xff00d0f0
#define P_DOLBY_CORE2A_STATUS2                     (volatile uint32_t *)0xff00d0f4
#define P_DOLBY_CORE2A_STATUS3                     (volatile uint32_t *)0xff00d0f8
#define P_DOLBY_CORE2A_DMA_PORT                    (volatile uint32_t *)0xff00d0fc
#define P_DOLBY_CORE2A_AXI2DMA_CTRL0               (volatile uint32_t *)0xff00d100
#define P_DOLBY_CORE2A_AXI2DMA_CTRL1               (volatile uint32_t *)0xff00d104
#define P_DOLBY_CORE2A_AXI2DMA_CTRL2               (volatile uint32_t *)0xff00d108
#define P_DOLBY_CORE2A_AXI2DMA_CTRL3               (volatile uint32_t *)0xff00d10c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dolby2a_regs.h
//
// -----------------------------------------------
// REG_BASE:  DOLBY2B_VCBUS_BASE = 0x35
// -----------------------------------------------
//`include "dolby2b_regs.h"
// -----------------------------------------------
// REG_BASE:  DOLBY3_VCBUS_BASE = 0x36
// -----------------------------------------------
//
// Reading file:  dolby3_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_CORE3_REG_START                    (volatile uint32_t *)0xff00d800
#define P_DOLBY_CORE3_CLKGATE_CTRL                 (volatile uint32_t *)0xff00dbc0
#define P_DOLBY_CORE3_SWAP_CTRL0                   (volatile uint32_t *)0xff00dbc4
#define P_DOLBY_CORE3_SWAP_CTRL1                   (volatile uint32_t *)0xff00dbc8
#define P_DOLBY_CORE3_SWAP_CTRL2                   (volatile uint32_t *)0xff00dbcc
#define P_DOLBY_CORE3_SWAP_CTRL3                   (volatile uint32_t *)0xff00dbd0
#define P_DOLBY_CORE3_SWAP_CTRL4                   (volatile uint32_t *)0xff00dbd4
#define P_DOLBY_CORE3_SWAP_CTRL5                   (volatile uint32_t *)0xff00dbd8
#define P_DOLBY_CORE3_SWAP_CTRL6                   (volatile uint32_t *)0xff00dbdc
#define P_DOLBY_CORE3_SWAP_CTRL7                   (volatile uint32_t *)0xff00dbe0
#define P_DOLBY_CORE3_SWAP_CTRL8                   (volatile uint32_t *)0xff00dbe4
#define P_DOLBY_CORE3_SWAP_CTRL9                   (volatile uint32_t *)0xff00dbe8
#define P_DOLBY_CORE3_STATUS0                      (volatile uint32_t *)0xff00dbec
#define P_DOLBY_CORE3_STATUS1                      (volatile uint32_t *)0xff00dbf0
#define P_DOLBY_CORE3_STATUS2                      (volatile uint32_t *)0xff00dbf4
#define P_DOLBY_CORE3_STATUS3                      (volatile uint32_t *)0xff00dbf8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dolby3_regs.h
//
//
// Reading file:  vpu_madc_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MADC_VCBUS_BASE = 0x37
// -----------------------------------------------
// 0x00-0x28
//
// Reading file:  nr4_nm_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR4_MCNR_SAD_GAIN                        (volatile uint32_t *)0xff00dc00
//Bit 31:25        reserved
//Bit 24           reg_nr4_bld12vs3_usemaxsad     // unsigned , default = 0  use minsad/maxsad instead of minsad/avgsad to decision if it was texture or flat region, 1: use minsad/maxsad
//Bit 23:16        reg_nr4_bld12vs3_rate_gain     // unsigned , default = 64  gain to minsad/maxsad or minsad/avgsad before LUT, 64 normalized as "1"
//Bit 15: 8        reg_nr4_bld1vs2_rate_gain      // unsigned , default = 32  gain to minsad/maxsad or minsad/avgsad before the LUT, 64 normalized as"1"
//Bit  7: 0        reg_nr4_coefblt_gain           // unsigned , default = 64  gain to final coefblt, normalized 64 as "1"
#define P_NR4_MCNR_LPF_CTRL                        (volatile uint32_t *)0xff00dc04
//Bit 31            reserved
//Bit 30:22        reg_nr4_preflt_alpofst         // signed , default = 0  pre filter alpha ofst
//Bit 21:16        reg_nr4_preflt_alpgain         // unsigned , default = 16  pre filter alpha gain
//Bit 15:14        reg_nr4_preflt_alpsel          // unsigned , default = 3  pre filter alpha selection for adaptive blending, 0: mv pointed sad, 1: weighted mv pointed sad, 2or3: coefblt
//Bit 13: 8        reg_nr4_avgsad_gain            // unsigned , default = 8  gain for avg sad before luts
//Bit  7            reserved
//Bit  6           reg_nr4_maxsad_mod             // unsigned , default = 1  max sad select mode, 0: mx2_sad, 1: max sad
//Bit  5           reg_nr4_minsad_mod             // unsigned , default = 1  min sad select mode, 0: sad with min err, 1: min sad
//Bit  4           reg_nr4_minmaxsad_lpf          // unsigned , default = 1  mode of lpf for minmaxsad, 0: no LPF, 1: [1 2 1]/4
//Bit  3           reg_nr4_avgsad_lpf             // unsigned , default = 1  mode of lpf for avgsad, 0: no LPF, 1: [1 2 1]/4
//Bit  2           reg_nr4_minavgsad_ratio_lpf    // unsigned , default = 1  mode of lpf for minsad/avgsad and zmvsad/avgsad, 0: no LPF, 1: [1 2 1]/4
//Bit  1           reg_nr4_bldvs_lut_lpf          // unsigned , default = 1  mode of lpf for bld12vs3 and bld1vs2 LUT results, 0: no LPF, 1: [1 2 1]/4
//Bit  0           reg_nr4_final_coef_lpf         // unsigned , default = 1  mode of lpf for final coef_blt_blend123, 0: no LPF, 1: [1 2 1]/4
#define P_NR4_MCNR_BLD_VS3LUT0                     (volatile uint32_t *)0xff00dc08
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut0     // unsigned , default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut1     // unsigned , default = 8
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut2     // unsigned , default = 10
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut3     // unsigned , default = 11
#define P_NR4_MCNR_BLD_VS3LUT1                     (volatile uint32_t *)0xff00dc0c
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut4     // unsigned , default = 12
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut5     // unsigned , default = 14
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut6     // unsigned , default = 16
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut7     // unsigned , default = 24
#define P_NR4_MCNR_BLD_VS3LUT2                     (volatile uint32_t *)0xff00dc10
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut8     // unsigned , default = 50
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut9     // unsigned , default = 58
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut10    // unsigned , default = 63
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut11    // unsigned , default = 63
#define P_NR4_MCNR_BLD_VS2LUT0                     (volatile uint32_t *)0xff00dc14
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld1vs2_lut0      // unsigned , default = 63
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld1vs2_lut1      // unsigned , default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld1vs2_lut2      // unsigned , default = 16
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld1vs2_lut3      // unsigned , default = 8
#define P_NR4_MCNR_BLD_VS2LUT1                     (volatile uint32_t *)0xff00dc18
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld1vs2_lut4      // unsigned , default = 4
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld1vs2_lut5      // unsigned , default = 2
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld1vs2_lut6      // unsigned , default = 1
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld1vs2_lut7      // unsigned , default = 0
#define P_NR4_COEFBLT_LUT10                        (volatile uint32_t *)0xff00dc1c
//Bit 31:24        reg_nr4_coefblt_lut10     // signed , default = -128
//Bit 23:16        reg_nr4_coefblt_lut11     // signed , default = -128
//Bit 15: 8        reg_nr4_coefblt_lut12     // signed , default = -126
//Bit  7: 0        reg_nr4_coefblt_lut13     // signed , default = -124
#define P_NR4_COEFBLT_LUT11                        (volatile uint32_t *)0xff00dc20
//Bit 31:24        reg_nr4_coefblt_lut14     // signed , default = -120
//Bit 23:16        reg_nr4_coefblt_lut15     // signed , default = -110
//Bit 15: 8        reg_nr4_coefblt_lut16     // signed , default = -100
//Bit  7: 0        reg_nr4_coefblt_lut17     // signed , default = -90
#define P_NR4_COEFBLT_LUT12                        (volatile uint32_t *)0xff00dc24
//Bit 31:24        reg_nr4_coefblt_lut18     // signed , default = -56
//Bit 23:16        reg_nr4_coefblt_lut19     // signed , default = -32
//Bit 15: 8        reg_nr4_coefblt_lut110    // signed , default = -64
//Bit  7: 0        reg_nr4_coefblt_lut111    // signed , default = -128
#define P_NR4_COEFBLT_LUT20                        (volatile uint32_t *)0xff00dc28
//Bit 31:24        reg_nr4_coefblt_lut20     // signed , default = -128
//Bit 23:16        reg_nr4_coefblt_lut21     // signed , default = -120
//Bit 15: 8        reg_nr4_coefblt_lut22     // signed , default = -112
//Bit  7: 0        reg_nr4_coefblt_lut23     // signed , default = -104
#define P_NR4_COEFBLT_LUT21                        (volatile uint32_t *)0xff00dc2c
//Bit 31:24        reg_nr4_coefblt_lut24     // signed , default = -96
//Bit 23:16        reg_nr4_coefblt_lut25     // signed , default = -88
//Bit 15: 8        reg_nr4_coefblt_lut26     // signed , default = -76
//Bit  7: 0        reg_nr4_coefblt_lut27     // signed , default = -64
#define P_NR4_COEFBLT_LUT22                        (volatile uint32_t *)0xff00dc30
//Bit 31:24        reg_nr4_coefblt_lut28     // signed , default = -48
//Bit 23:16        reg_nr4_coefblt_lut29     // signed , default = -32
//Bit 15: 8        reg_nr4_coefblt_lut210    // signed , default = -64
//Bit  7: 0        reg_nr4_coefblt_lut211    // signed , default = -108
#define P_NR4_COEFBLT_LUT30                        (volatile uint32_t *)0xff00dc34
//Bit 31:24        reg_nr4_coefblt_lut30     // signed , default = 8
//Bit 23:16        reg_nr4_coefblt_lut31     // signed , default = 16
//Bit 15: 8        reg_nr4_coefblt_lut32     // signed , default = 24
//Bit  7: 0        reg_nr4_coefblt_lut33     // signed , default = 30
#define P_NR4_COEFBLT_LUT31                        (volatile uint32_t *)0xff00dc38
//Bit 31:24        reg_nr4_coefblt_lut34     // signed , default = 36
//Bit 23:16        reg_nr4_coefblt_lut35     // signed , default = 48
//Bit 15: 8        reg_nr4_coefblt_lut36     // signed , default = 70
//Bit  7: 0        reg_nr4_coefblt_lut37     // signed , default = 96
#define P_NR4_COEFBLT_LUT32                        (volatile uint32_t *)0xff00dc3c
//Bit 31:24        reg_nr4_coefblt_lut38     // signed , default = 120
//Bit 23:16        reg_nr4_coefblt_lut39     // signed , default = 64
//Bit 15: 8        reg_nr4_coefblt_lut310    // signed , default = 16
//Bit  7: 0        reg_nr4_coefblt_lut311    // signed , default = -8
#define P_NR4_COEFBLT_CONV                         (volatile uint32_t *)0xff00dc40
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_coefblt_convmin   // unsigned , default = 0  minimum of coef. bilateral conversion
//Bit 15: 8        reg_nr4_coefblt_convmax   // unsigned , default = 255  maximum of coef. bilateral conversion
//Bit  7: 0        reg_nr4_coefblt_convmid   // unsigned , default = 128  value at midpoint of coef. bilateral conversion
#define P_NR4_DBGWIN_YX0                           (volatile uint32_t *)0xff00dc44
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_dgbwin_yx0        // unsigned , default = 100  ystart for debug window
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_dgbwin_yx1        // unsigned , default = 160  yend   for debug window
#define P_NR4_DBGWIN_YX1                           (volatile uint32_t *)0xff00dc48
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_dgbwin_yx2        // unsigned , default = 200  xstart for debug window
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_dgbwin_yx3        // unsigned , default = 300  xend   for debug window
#define P_NR4_NM_X_CFG                             (volatile uint32_t *)0xff00dc4c
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_nm_xst            // unsigned , default = 8  start for noise meter statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_nm_xed            // unsigned , default = 711  end for noise meter statistic, dft = HSIZE-8-1;
#define P_NR4_NM_Y_CFG                             (volatile uint32_t *)0xff00dc50
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_nm_yst            // unsigned , default = 8  start for noise meter statistic, dft = 8;
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_nm_yed            // unsigned , default = 231  end for noise meter statistic, dft = VSIZE-8-1;
#define P_NR4_NM_SAD_THD                           (volatile uint32_t *)0xff00dc54
//Bit 31: 8        reserved
//Bit  7: 0        reg_nr4_nm_sad_thd        // unsigned , default = 255  threshold for (flat region) sad count, dft = 4
#define P_NR4_MCNR_BANDSPLIT_PRAM                  (volatile uint32_t *)0xff00dc58
//Bit 31: 5        reserved
//Bit  4           reg_nr4_mc_use_bandsplit     // unsigned , default = 1  separate lp and us for mc IIR filter, 0: no BS used; 1: use BS
//Bit  3           reg_nr4_mc_apply_on_lp       // unsigned , default = 1  use mcnr only on lowpass portion;
//Bit  2           reg_nr4_mc_apply_on_us       // unsigned , default = 1  use mcnr only on lp complimentary portion;
//Bit  1: 0        reg_nr4_mc_zmvbs_use_adplpf  // unsigned , default = 1  use adaptive LPF for the zmv pointing data for MCNR, for abs(mvx)<th
#define P_NR4_MCNR_ALP1_SGN_COR                    (volatile uint32_t *)0xff00dc5c
//Bit 31:24        reg_nr4_mc_aph1_sgn_coring0  // unsigned , default = 10  coring to cur-pre before do sgn decision
//Bit 23:16        reg_nr4_mc_aph1_sgn_coring1  // unsigned , default = 7  coring to cur-pre before do sgn decision
//Bit 15: 8        reg_nr4_mc_aph1_sgn_core_max0 // unsigned , default = 90  maximum of coring, default = 30/15
//Bit  7: 0        reg_nr4_mc_aph1_sgn_core_max1 // unsigned , default = 15  maximum of coring, default = 30/15
#define P_NR4_MCNR_ALP1_SGN_PRAM                   (volatile uint32_t *)0xff00dc60
//Bit 31:11        reserved
//Bit 10           reg_nr4_mc_alp1_sgn_half       // unsigned , default = 1  half block sgn sum mode enable, 0: only use 3x5 whole block sum of sgns; 1: use max(sgn_3x5, sqrt(sgn_left+sgn_righ))
//Bit  9           reg_nr4_mc_alp1_sgn_frczmv   // unsigned , default = 1  force zmv to calculate the sign_sum;
//Bit  8           reg_nr4_mc_alp1_sgnmvx_mode  // unsigned , default = 1  blend mode of sgnlut and mvxlut blend mode: 0: sgnlut+ mvxlut; 1: max(sgnlut, mvxlut), default =1
//Bit  7: 4        reg_nr4_mc_aph1_sgn_crate0   // unsigned , default = 4  rate to var, norm to 16 as 1, default = 2
//Bit  3: 0        reg_nr4_mc_aph1_sgn_crate1   // unsigned , default = 2  rate to var, norm to 16 as 1, default = 2
#define P_NR4_MCNR_ALP1_MVX_LUT1                   (volatile uint32_t *)0xff00dc64
//Bit 31:28        reg_nr4_mc_alp1_mvx_luty3  // unsigned , default = 14  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc3  // unsigned , default = 14  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 23:20        reg_nr4_mc_alp1_mvx_luty2  // unsigned , default = 12  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc2  // unsigned , default = 12  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 15:12        reg_nr4_mc_alp1_mvx_luty1  // unsigned , default = 5  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc1  // unsigned , default = 5  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty0  // unsigned , default = 3  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc0  // unsigned , default = 3  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define P_NR4_MCNR_ALP1_MVX_LUT2                   (volatile uint32_t *)0xff00dc68
//Bit 31:28        reg_nr4_mc_alp1_mvx_luty7  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc7  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 23:20        reg_nr4_mc_alp1_mvx_luty6  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc6  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 15:12        reg_nr4_mc_alp1_mvx_luty5  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc5  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty4  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc4  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define P_NR4_MCNR_ALP1_MVX_LUT3                   (volatile uint32_t *)0xff00dc6c
//Bit 31: 8        reserved
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty8  // unsigned , default = 6  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc8  // unsigned , default = 6  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define P_NR4_MCNR_ALP1_LP_PRAM                    (volatile uint32_t *)0xff00dc70
//Bit 31:18        reserved
//Bit 17:16        reg_nr4_mc_alp1_lp_sel    // unsigned , default = 1  mode for alp1_lp for lp portion IIR, 0: apha1, 1:dc_dif vs ac analysis; 2: gain/ofst of alp1; 3: max of #1/#2 results
//Bit 15: 8        reg_nr4_mc_alp1_lp_gain   // unsigned , default = 64  gain to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =64;
//Bit  7: 0        reg_nr4_mc_alp1_lp_ofst   // signed , default = 0  offset to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =10;
#define P_NR4_MCNR_ALP1_SGN_LUT1                   (volatile uint32_t *)0xff00dc74
//Bit 31:28        reg_nr4_mc_alp1_sgn_lut0  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 27:24        reg_nr4_mc_alp1_sgn_lut1  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 23:20        reg_nr4_mc_alp1_sgn_lut2  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 19:16        reg_nr4_mc_alp1_sgn_lut3  // unsigned , default = 4  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 15:12        reg_nr4_mc_alp1_sgn_lut4  // unsigned , default = 5  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut5  // unsigned , default = 6  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut6  // unsigned , default = 7  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut7  // unsigned , default = 8  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
#define P_NR4_MCNR_ALP1_SGN_LUT2                   (volatile uint32_t *)0xff00dc78
//Bit 31:28        reg_nr4_mc_alp1_sgn_lut8   // unsigned , default = 9  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 27:24        reg_nr4_mc_alp1_sgn_lut9   // unsigned , default = 10  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 23:20        reg_nr4_mc_alp1_sgn_lut10  // unsigned , default = 11  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 19:16        reg_nr4_mc_alp1_sgn_lut11  // unsigned , default = 12  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 15:12        reg_nr4_mc_alp1_sgn_lut12  // unsigned , default = 13  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut13  // unsigned , default = 14  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut14  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut15  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
#define P_NR4_RO_NM_SAD_SUM                        (volatile uint32_t *)0xff00dc7c
//Bit 31: 0        ro_nr4_nm_sad_sum         // unsigned , default = 0  sum of sad, for scene change detection, in noise meter
#define P_NR4_RO_NM_SAD_CNT                        (volatile uint32_t *)0xff00dc80
//Bit 31: 0        ro_nr4_nm_sad_cnt         // unsigned , default = 0  cnt of sad, for scene change detection, in noise meter
#define P_NR4_RO_NM_VAR_SUM                        (volatile uint32_t *)0xff00dc84
//Bit 31: 0        ro_nr4_nm_var_sum         // unsigned , default = 0  sum of var, for noise level detection, in noise meter
#define P_NR4_RO_NM_VAR_SCNT                       (volatile uint32_t *)0xff00dc88
//Bit 31: 0        ro_nr4_nm_var_cnt         // unsigned , default = 0  cnt of var, for noise level detection, in noise meter
#define P_NR4_RO_NM_VAR_MIN_MAX                    (volatile uint32_t *)0xff00dc8c
//Bit 31:22        reserved
//Bit 21:12        ro_nr4_nm_min_var         // unsigned , default = 1023  min of var, for noise level detection, in noise meter
//Bit 11:10        reserved
//Bit  9: 0        ro_nr4_nm_max_var         // unsigned , default = 0  max of var, for noise level detection, in noise meter
#define P_NR4_RO_NR4_DBGPIX_NUM                    (volatile uint32_t *)0xff00dc90
//Bit 31:28        reserved
//Bit 27: 0        ro_nr4_dbgpix_num         // unsigned , default = 0  number of pixels statistic involved (removed?)
#define P_NR4_RO_NR4_BLDVS2_SUM                    (volatile uint32_t *)0xff00dc94
//Bit 31: 0        ro_nr4_bld1vs2_sum        // unsigned , default = 0  sum of blend_1vs2 with the debug window
#define P_NR4_BLDVS3_SUM                           (volatile uint32_t *)0xff00dc98
//Bit 31: 0        ro_nr4_bld12vs3_sum       // unsigned , default = 0  sum of blend_12vs3 with the debug window
#define P_NR4_COEF12_SUM                           (volatile uint32_t *)0xff00dc9c
//Bit 31: 0        ro_nr4_coef12_sum         // signed , default = 0  sum of coef_blt_blend12 with the debug window, under 8 bits precision
#define P_NR4_COEF123_SUM                          (volatile uint32_t *)0xff00dca0
//Bit 31: 0        ro_nr4_coef123_sum        // signed , default = 0  sum of coef_final with the debug window, under 8 bits precision
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr4_nm_regs.h
//
// 0x30-0x32
//
// Reading file:  vpu_xlr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_XLR_CTRL                                 (volatile uint32_t *)0xff00dcc0
//Bit 31:23        reserved
//Bit 22           reg_xlr_en                // unsigned , default = 1   enable bits for xlr function, 1: enable, 0: disable	       default = 1
//Bit 21           reg_xlr_side_en           // unsigned , default = 1   enable to filter the above and below lines with xlr filter, default = 1
//Bit 20           reg_xlr_3lines            // unsigned , default = 1   3 lines version enable                    default= 0
//Bit 19:16        reg_xlr_simlp_gain        // unsigned , default = 12   gain to simlp  to decide if need the XLR, default= 12
//Bit 15:14        reserved
//Bit 13: 8        reg_xlr_ooplp_gain        // unsigned , default = 6    gain to out-of-phase lp error to decide if need the XLR, birn to 16 as 1, default= 3
//Bit  7: 0        reg_xlr_dislp_thrd        // unsigned , default = 64   threshold to lp error to discard XLR. default= 80
#define P_XLR_THRD                                 (volatile uint32_t *)0xff00dcc4
//Bit 31:28        reserved
//Bit 27:24        reg_xlr_txt_core          // unsigned , default = 3    coring to texture                         default = 3, (3/32)
//Bit 23:16        reg_xlr_err_thrd2         // unsigned , default = 5    threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, default= {20, 10, 5}
//Bit 15: 8        reg_xlr_err_thrd1         // unsigned , default = 10   threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, default= {20, 10, 5}
//Bit  7: 0        reg_xlr_err_thrd0         // unsigned , default = 20   threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, default= {20, 10, 5}
#define P_XLR_HCT_THRD                             (volatile uint32_t *)0xff00dcc8
//Bit 31:28        reserved
//Bit 27:26        reg_xlr_hct_step          // unsigned , default = 1  horizontal chroma diff steps, 0: abs[-1 (2) -1]; 1: abs[-1 0 (2) 0 -1], 2: abs[-1 0 0 (2) 0 0 -1]; 3:abs[-1 0 0 0 (2) 0 0 0 -1]
//Bit 25:24        reg_xlr_hct_lpf           // unsigned , default = 1  horizontal chroma diff low-pass filter enable, 0: no HLPF; 1: [1 2 1]; 2: max[-1:1]; 3: max[-2:2]
//Bit 23:16        reg_xlr_hct_thr           // unsigned , default = 20  horizontal chroma diff threshold for xlr enable, to save the horizontal no color tran mode
//Bit 15: 8        reg_xlr_sat_thr           // unsigned , default = 8  saturation threshold for xlr enable, the smaller of the threshold , the more will do xlr;
//Bit  7: 2        reg_xlr_hmargin           // unsigned , default = 3  left/right number of pixels without xlr;
//Bit  1            reserved
//Bit  0           reg_xlr_hpf_only          // unsigned , default = 0  enable for only do xlr filter on high pass portion of the data, instead full data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_xlr_regs.h
//
// 0x38-0x3f
//
// Reading file:  nr_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR_DB_FLT_CTRL                           (volatile uint32_t *)0xff00dce0
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 0  0 : no reset seed  1: reload chroma seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 0  0 : no reset seed  1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strength of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define P_NR_DB_FLT_YC_THRD                        (volatile uint32_t *)0xff00dce4
//Bit 31:28        reg_nrdeband_luma_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 27:24        reg_nrdeband_luma_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
//Bit 23:20        reg_nrdeband_luma_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit 19:16        reg_nrdeband_luma_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
//Bit 15:12        reg_nrdeband_chrm_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 11: 8        reg_nrdeband_chrm_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
//Bit  7: 4        reg_nrdeband_chrm_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  3: 0        reg_nrdeband_chrm_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define P_NR_DB_FLT_RANDLUT                        (volatile uint32_t *)0xff00dce8
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   lut0
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   lut0
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   lut0
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   lut0
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   lut0
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   lut0
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   lut0
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   lut0
#define P_NR_DB_FLT_PXI_THRD                       (volatile uint32_t *)0xff00dcec
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
#define P_NR_DB_FLT_SEED_Y                         (volatile uint32_t *)0xff00dcf0
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define P_NR_DB_FLT_SEED_U                         (volatile uint32_t *)0xff00dcf4
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
#define P_NR_DB_FLT_SEED_V                         (volatile uint32_t *)0xff00dcf8
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_NR_DB_FLT_SEED3                          (volatile uint32_t *)0xff00dcfc
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr_deband_regs.h
//
// 0x40-0x43
//
// Reading file:  nr_downscale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_NR_DS_BUF_SIZE                           (volatile uint32_t *)0xff00dd00
//Bit 31:24        dsbuf_rowmax               // unsigned , default = 96
//Bit 23:16        dsbuf_colmax               // unsigned , default = 128
//Bit 15: 8        dsbuf_orow                 // unsigned , default = 128
//Bit  7: 0        dsbuf_ocol                 // unsigned , default = 128
#define P_NR_DS_CTRL                               (volatile uint32_t *)0xff00dd04
//Bit 31:30        reserved
//Bit 29:24        reg_h_step                 // unsigned , default = 8   rand lut0
//Bit 23:22        reserved
//Bit 21:16        reg_v_step                 // unsigned , default = 8   rand lut0
//Bit 15            reserved
//Bit 14:12        reg_haa_sel                // unsigned , default = 4
//Bit 11            reserved
//Bit 10: 8        reg_vaa_sel                // unsigned , default = 4
//Bit  7            reserved
//Bit  6: 4        reg_use_hphase             // unsigned , default = 1
//Bit  3: 1        reserved
//Bit  0           reg_yuv_bldmode            // unsigned , default = 0
#define P_NR_DS_OFFSET                             (volatile uint32_t *)0xff00dd08
//Bit 31:26        reserved
//Bit 25:16        reg_h_ofst                // signed , default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_v_ofst                // signed , default = 0
#define P_NR_DS_BLD_COEF                           (volatile uint32_t *)0xff00dd0c
//Bit 31:24        reserved
//Bit 23:16        reg_yuv_bldcoef2          // unsigned , default = 128
//Bit 15: 8        reg_yuv_bldcoef1          // unsigned , default = 64
//Bit  7: 0        reg_yuv_bldcoef0          // unsigned , default = 64
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  nr_downscale_regs.h
//
// 0x44-0xbf
//
// Reading file:  di_scale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DI_SCO_FIFO_CTRL                         (volatile uint32_t *)0xff00dd38
#define P_DI_SC_TOP_CTRL                           (volatile uint32_t *)0xff00dd3c
// dummy data used in the DI preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define P_DI_SC_DUMMY_DATA                         (volatile uint32_t *)0xff00dd40
//input line length used in DI
#define P_DI_SC_LINE_IN_LENGTH                     (volatile uint32_t *)0xff00dd44
//input Picture height used in DI
#define P_DI_SC_PIC_IN_HEIGHT                      (volatile uint32_t *)0xff00dd48
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
//Bit 6:0 	coef index
#define P_DI_SC_COEF_IDX                           (volatile uint32_t *)0xff00dd4c
//coefficients for vertical filter and horizontal filter
#define P_DI_SC_COEF                               (volatile uint32_t *)0xff00dd50
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		.
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region	
//		.
//  ---------------------------
//  ---------------------------  <------ region1_startp
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_DI_VSC_REGION12_STARTP                   (volatile uint32_t *)0xff00dd54
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_DI_VSC_REGION34_STARTP                   (volatile uint32_t *)0xff00dd58
#define P_DI_VSC_REGION4_ENDP                      (volatile uint32_t *)0xff00dd5c
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define P_DI_VSC_START_PHASE_STEP                  (volatile uint32_t *)0xff00dd60
//vertical scaler region0 phase slope, Bit24 signed bit
#define P_DI_VSC_REGION0_PHASE_SLOPE               (volatile uint32_t *)0xff00dd64
//vertical scaler region1 phase slope, Bit24 signed bit
#define P_DI_VSC_REGION1_PHASE_SLOPE               (volatile uint32_t *)0xff00dd68
//vertical scaler region3 phase slope, Bit24 signed bit
#define P_DI_VSC_REGION3_PHASE_SLOPE               (volatile uint32_t *)0xff00dd6c
//vertical scaler region4 phase slope, Bit24 signed bit
#define P_DI_VSC_REGION4_PHASE_SLOPE               (volatile uint32_t *)0xff00dd70
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field
#define P_DI_VSC_PHASE_CTRL                        (volatile uint32_t *)0xff00dd74
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define P_DI_VSC_INI_PHASE                         (volatile uint32_t *)0xff00dd78
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define P_DI_HSC_REGION12_STARTP                   (volatile uint32_t *)0xff00dd80
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define P_DI_HSC_REGION34_STARTP                   (volatile uint32_t *)0xff00dd84
#define P_DI_HSC_REGION4_ENDP                      (volatile uint32_t *)0xff00dd88
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define P_DI_HSC_START_PHASE_STEP                  (volatile uint32_t *)0xff00dd8c
//horizontal scaler region0 phase slope, Bit24 signed bit
#define P_DI_HSC_REGION0_PHASE_SLOPE               (volatile uint32_t *)0xff00dd90
//horizontal scaler region1 phase slope, Bit24 signed bit
#define P_DI_HSC_REGION1_PHASE_SLOPE               (volatile uint32_t *)0xff00dd94
//horizontal scaler region3 phase slope, Bit24 signed bit
#define P_DI_HSC_REGION3_PHASE_SLOPE               (volatile uint32_t *)0xff00dd98
//horizontal scaler region4 phase slope, Bit24 signed bit
#define P_DI_HSC_REGION4_PHASE_SLOPE               (volatile uint32_t *)0xff00dd9c
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0
//Bit 15:0    horizontal scaler top field initial phase0
#define P_DI_HSC_PHASE_CTRL                        (volatile uint32_t *)0xff00dda0
// Bit 31 if false, di_scale swap layer bypass
// bit 30 if true, scale before diwr, else scaler before nrwr
// Bit 22 if true, divide VSC line length 2 as the HSC input length, othwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwidth needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
// Bit 2:0 vertical scaler bank length
#define P_DI_SC_MISC                               (volatile uint32_t *)0xff00dda4
#define P_DI_HSC_PHASE_CTRL1                       (volatile uint32_t *)0xff00dda8
#define P_DI_HSC_INI_PAT_CTRL                      (volatile uint32_t *)0xff00ddac
#define P_DI_SC_GCLK_CTRL                          (volatile uint32_t *)0xff00ddb0
#define P_DI_SC_HOLD_LINE                          (volatile uint32_t *)0xff00ddb4
#define P_DI_HDR_IN_HSIZE                          (volatile uint32_t *)0xff00ddb8
#define P_DI_HDR_IN_VSIZE                          (volatile uint32_t *)0xff00ddbc
#define DI_HDR_OFFSET         0x70
#define P_DI_HDR2_CTRL                             (volatile uint32_t *)0xff00ddc0
#define P_DI_HDR2_CLK_GATE                         (volatile uint32_t *)0xff00ddc4
#define P_DI_HDR2_MATRIXI_COEF00_01                (volatile uint32_t *)0xff00ddc8
#define P_DI_HDR2_MATRIXI_COEF02_10                (volatile uint32_t *)0xff00ddcc
#define P_DI_HDR2_MATRIXI_COEF11_12                (volatile uint32_t *)0xff00ddd0
#define P_DI_HDR2_MATRIXI_COEF20_21                (volatile uint32_t *)0xff00ddd4
#define P_DI_HDR2_MATRIXI_COEF22                   (volatile uint32_t *)0xff00ddd8
#define P_DI_HDR2_MATRIXI_COEF30_31                (volatile uint32_t *)0xff00dddc
#define P_DI_HDR2_MATRIXI_COEF32_40                (volatile uint32_t *)0xff00dde0
#define P_DI_HDR2_MATRIXI_COEF41_42                (volatile uint32_t *)0xff00dde4
#define P_DI_HDR2_MATRIXI_OFFSET0_1                (volatile uint32_t *)0xff00dde8
#define P_DI_HDR2_MATRIXI_OFFSET2                  (volatile uint32_t *)0xff00ddec
#define P_DI_HDR2_MATRIXI_PRE_OFFSET0_1            (volatile uint32_t *)0xff00ddf0
#define P_DI_HDR2_MATRIXI_PRE_OFFSET2              (volatile uint32_t *)0xff00ddf4
#define P_DI_HDR2_MATRIXO_COEF00_01                (volatile uint32_t *)0xff00ddf8
#define P_DI_HDR2_MATRIXO_COEF02_10                (volatile uint32_t *)0xff00ddfc
#define P_DI_HDR2_MATRIXO_COEF11_12                (volatile uint32_t *)0xff00de00
#define P_DI_HDR2_MATRIXO_COEF20_21                (volatile uint32_t *)0xff00de04
#define P_DI_HDR2_MATRIXO_COEF22                   (volatile uint32_t *)0xff00de08
#define P_DI_HDR2_MATRIXO_COEF30_31                (volatile uint32_t *)0xff00de0c
#define P_DI_HDR2_MATRIXO_COEF32_40                (volatile uint32_t *)0xff00de10
#define P_DI_HDR2_MATRIXO_COEF41_42                (volatile uint32_t *)0xff00de14
#define P_DI_HDR2_MATRIXO_OFFSET0_1                (volatile uint32_t *)0xff00de18
#define P_DI_HDR2_MATRIXO_OFFSET2                  (volatile uint32_t *)0xff00de1c
#define P_DI_HDR2_MATRIXO_PRE_OFFSET0_1            (volatile uint32_t *)0xff00de20
#define P_DI_HDR2_MATRIXO_PRE_OFFSET2              (volatile uint32_t *)0xff00de24
#define P_DI_HDR2_MATRIXI_CLIP                     (volatile uint32_t *)0xff00de28
#define P_DI_HDR2_MATRIXO_CLIP                     (volatile uint32_t *)0xff00de2c
#define P_DI_HDR2_CGAIN_OFFT                       (volatile uint32_t *)0xff00de30
#define P_DI_EOTF_LUT_ADDR_PORT                    (volatile uint32_t *)0xff00de38
#define P_DI_EOTF_LUT_DATA_PORT                    (volatile uint32_t *)0xff00de3c
#define P_DI_OETF_LUT_ADDR_PORT                    (volatile uint32_t *)0xff00de40
#define P_DI_OETF_LUT_DATA_PORT                    (volatile uint32_t *)0xff00de44
#define P_DI_CGAIN_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00de48
#define P_DI_CGAIN_LUT_DATA_PORT                   (volatile uint32_t *)0xff00de4c
#define P_DI_HDR2_CGAIN_COEF0                      (volatile uint32_t *)0xff00de50
#define P_DI_HDR2_CGAIN_COEF1                      (volatile uint32_t *)0xff00de54
#define P_DI_OGAIN_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00de58
#define P_DI_OGAIN_LUT_DATA_PORT                   (volatile uint32_t *)0xff00de5c
#define P_DI_HDR2_ADPS_CTRL                        (volatile uint32_t *)0xff00de60
#define P_DI_HDR2_ADPS_ALPHA0                      (volatile uint32_t *)0xff00de64
#define P_DI_HDR2_ADPS_ALPHA1                      (volatile uint32_t *)0xff00de68
#define P_DI_HDR2_ADPS_BETA0                       (volatile uint32_t *)0xff00de6c
#define P_DI_HDR2_ADPS_BETA1                       (volatile uint32_t *)0xff00de70
#define P_DI_HDR2_ADPS_BETA2                       (volatile uint32_t *)0xff00de74
#define P_DI_HDR2_ADPS_COEF0                       (volatile uint32_t *)0xff00de78
#define P_DI_HDR2_ADPS_COEF1                       (volatile uint32_t *)0xff00de7c
#define P_DI_HDR2_GMUT_CTRL                        (volatile uint32_t *)0xff00de80
#define P_DI_HDR2_GMUT_COEF0                       (volatile uint32_t *)0xff00de84
#define P_DI_HDR2_GMUT_COEF1                       (volatile uint32_t *)0xff00de88
#define P_DI_HDR2_GMUT_COEF2                       (volatile uint32_t *)0xff00de8c
#define P_DI_HDR2_GMUT_COEF3                       (volatile uint32_t *)0xff00de90
#define P_DI_HDR2_GMUT_COEF4                       (volatile uint32_t *)0xff00de94
#define P_DI_HDR2_PIPE_CTRL1                       (volatile uint32_t *)0xff00de98
#define P_DI_HDR2_PIPE_CTRL2                       (volatile uint32_t *)0xff00de9c
#define P_DI_HDR2_PIPE_CTRL3                       (volatile uint32_t *)0xff00dea0
#define P_DI_HDR2_PROC_WIN1                        (volatile uint32_t *)0xff00dea4
#define P_DI_HDR2_PROC_WIN2                        (volatile uint32_t *)0xff00dea8
#define P_DI_HDR2_MATRIXI_EN_CTRL                  (volatile uint32_t *)0xff00deac
#define P_DI_HDR2_MATRIXO_EN_CTRL                  (volatile uint32_t *)0xff00deb0
#define P_DI_HDR2_HIST_CTRL                        (volatile uint32_t *)0xff00deb4
#define P_DI_HDR2_HIST_H_START_END                 (volatile uint32_t *)0xff00deb8
#define P_DI_HDR2_HIST_V_START_END                 (volatile uint32_t *)0xff00debc
#define P_DI_HDR2_HIST_RD                          (volatile uint32_t *)0xff00de34
#define P_DI_VIU_HSC_WIDTHM1                       (volatile uint32_t *)0xff00dec0
#define P_DI_VIU_HSC_PHASE_STEP                    (volatile uint32_t *)0xff00dec4
#define P_DI_VIU_HSC_CTRL                          (volatile uint32_t *)0xff00dec8
#define P_DI_VIU_HSC_PHASE_CTRL                    (volatile uint32_t *)0xff00decc
#define P_DI_VIU_HSC_COEF                          (volatile uint32_t *)0xff00ded0
#define P_DI_VIU_HSC_COEF_IDX                      (volatile uint32_t *)0xff00ded4
#define P_DI_SC_PREHSC_COEF                        (volatile uint32_t *)0xff00dee4
#define P_DI_SC_PRE_SCALE_CTRL                     (volatile uint32_t *)0xff00dee8
#define P_DI_SC_PREVSC_COEF                        (volatile uint32_t *)0xff00deec
#define P_DI_SC_PREHSC_COEF1                       (volatile uint32_t *)0xff00def0
#define P_DI_DITH_CTRL                             (volatile uint32_t *)0xff00dd10
#define P_DI_DITH_LUT_1                            (volatile uint32_t *)0xff00dd14
#define P_DI_DITH_LUT_2                            (volatile uint32_t *)0xff00dd18
#define P_DI_DITH_LUT_3                            (volatile uint32_t *)0xff00dd1c
#define P_DI_DITH_LUT_4                            (volatile uint32_t *)0xff00dd20
#define P_DI_DITH_LUT_5                            (volatile uint32_t *)0xff00dd24
#define P_DI_DITH_LUT_6                            (volatile uint32_t *)0xff00dd28
#define P_DI_DITH_LUT_7                            (volatile uint32_t *)0xff00dd2c
#define P_DI_DITH_LUT_8                            (volatile uint32_t *)0xff00dd30
#define P_DI_DITH_LUT_9                            (volatile uint32_t *)0xff00dd34
#define P_DI_DITH_LUT_10                           (volatile uint32_t *)0xff00ded8
#define P_DI_DITH_LUT_11                           (volatile uint32_t *)0xff00dedc
#define P_DI_DITH_LUT_12                           (volatile uint32_t *)0xff00dee0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_scale_regs.h
//
// 0xc0~0xff
//
// Reading file:  di_arb_sub_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DI_SUB_RDARB_MODE                        (volatile uint32_t *)0xff00df00
#define P_DI_SUB_RDARB_REQEN_SLV                   (volatile uint32_t *)0xff00df04
#define P_DI_SUB_RDARB_WEIGH0_SLV                  (volatile uint32_t *)0xff00df08
#define P_DI_SUB_RDARB_WEIGH1_SLV                  (volatile uint32_t *)0xff00df0c
#define P_DI_SUB_RDARB_UGT                         (volatile uint32_t *)0xff00df10
#define P_DI_SUB_RDARB_LIMT0                       (volatile uint32_t *)0xff00df14
#define P_DI_SUB_WRARB_MODE                        (volatile uint32_t *)0xff00df18
#define P_DI_SUB_WRARB_REQEN_SLV                   (volatile uint32_t *)0xff00df1c
#define P_DI_SUB_WRARB_WEIGH0_SLV                  (volatile uint32_t *)0xff00df20
#define P_DI_SUB_WRARB_WEIGH1_SLV                  (volatile uint32_t *)0xff00df24
#define P_DI_SUB_WRARB_UGT                         (volatile uint32_t *)0xff00df28
#define P_DI_SUB_RDWR_ARB_STATUS                   (volatile uint32_t *)0xff00df2c
#define P_DI_SUB_ARB_DBG_CTRL                      (volatile uint32_t *)0xff00df30
#define P_DI_SUB_ARB_DBG_STAT                      (volatile uint32_t *)0xff00df34
#define P_CONTRD_CTRL1                             (volatile uint32_t *)0xff00df40
#define P_CONTRD_CTRL2                             (volatile uint32_t *)0xff00df44
#define P_CONTRD_SCOPE_X                           (volatile uint32_t *)0xff00df48
#define P_CONTRD_SCOPE_Y                           (volatile uint32_t *)0xff00df4c
#define P_CONTRD_RO_STAT                           (volatile uint32_t *)0xff00df50
#define P_CONT2RD_CTRL1                            (volatile uint32_t *)0xff00df54
#define P_CONT2RD_CTRL2                            (volatile uint32_t *)0xff00df58
#define P_CONT2RD_SCOPE_X                          (volatile uint32_t *)0xff00df5c
#define P_CONT2RD_SCOPE_Y                          (volatile uint32_t *)0xff00df60
#define P_CONT2RD_RO_STAT                          (volatile uint32_t *)0xff00df64
#define P_MTNRD_CTRL1                              (volatile uint32_t *)0xff00df68
#define P_MTNRD_CTRL2                              (volatile uint32_t *)0xff00df6c
#define P_MTNRD_SCOPE_X                            (volatile uint32_t *)0xff00df70
#define P_MTNRD_SCOPE_Y                            (volatile uint32_t *)0xff00df74
#define P_MTNRD_RO_STAT                            (volatile uint32_t *)0xff00df78
#define P_MCVECRD_CTRL1                            (volatile uint32_t *)0xff00df7c
#define P_MCVECRD_CTRL2                            (volatile uint32_t *)0xff00df80
#define P_MCVECRD_SCOPE_X                          (volatile uint32_t *)0xff00df84
#define P_MCVECRD_SCOPE_Y                          (volatile uint32_t *)0xff00df88
#define P_MCVECRD_RO_STAT                          (volatile uint32_t *)0xff00df8c
#define P_MCINFRD_CTRL1                            (volatile uint32_t *)0xff00df90
#define P_MCINFRD_CTRL2                            (volatile uint32_t *)0xff00df94
#define P_MCINFRD_SCOPE_X                          (volatile uint32_t *)0xff00df98
#define P_MCINFRD_SCOPE_Y                          (volatile uint32_t *)0xff00df9c
#define P_MCINFRD_RO_STAT                          (volatile uint32_t *)0xff00dfa0
#define P_CONTWR_X                                 (volatile uint32_t *)0xff00dfa4
#define P_CONTWR_Y                                 (volatile uint32_t *)0xff00dfa8
#define P_CONTWR_CTRL                              (volatile uint32_t *)0xff00dfac
#define P_CONTWR_CAN_SIZE                          (volatile uint32_t *)0xff00dfb0
#define P_MTNWR_X                                  (volatile uint32_t *)0xff00dfb4
#define P_MTNWR_Y                                  (volatile uint32_t *)0xff00dfb8
#define P_MTNWR_CTRL                               (volatile uint32_t *)0xff00dfbc
#define P_MTNWR_CAN_SIZE                           (volatile uint32_t *)0xff00dfc0
#define P_MCVECWR_X                                (volatile uint32_t *)0xff00dfc4
#define P_MCVECWR_Y                                (volatile uint32_t *)0xff00dfc8
#define P_MCVECWR_CTRL                             (volatile uint32_t *)0xff00dfcc
#define P_MCVECWR_CAN_SIZE                         (volatile uint32_t *)0xff00dfd0
#define P_MCINFWR_X                                (volatile uint32_t *)0xff00dfd4
#define P_MCINFWR_Y                                (volatile uint32_t *)0xff00dfd8
#define P_MCINFWR_CTRL                             (volatile uint32_t *)0xff00dfdc
#define P_MCINFWR_CAN_SIZE                         (volatile uint32_t *)0xff00dfe0
#define P_NRDSWR_X                                 (volatile uint32_t *)0xff00dfe4
#define P_NRDSWR_Y                                 (volatile uint32_t *)0xff00dfe8
#define P_NRDSWR_CTRL                              (volatile uint32_t *)0xff00dfec
#define P_NRDSWR_CAN_SIZE                          (volatile uint32_t *)0xff00dff0
#define P_CONTRD_BADDR                             (volatile uint32_t *)0xff00dca4
#define P_CONT2RD_BADDR                            (volatile uint32_t *)0xff00dca8
#define P_MTNRD_BADDR                              (volatile uint32_t *)0xff00dcac
#define P_MCVECRD_BADDR                            (volatile uint32_t *)0xff00dcb0
#define P_MCINFRD_BADDR                            (volatile uint32_t *)0xff00dcb4
#define P_CONTWR_BADDR                             (volatile uint32_t *)0xff00dcd0
#define P_CONTWR_STRIDE                            (volatile uint32_t *)0xff00dcd4
#define P_MTNWR_BADDR                              (volatile uint32_t *)0xff00dcd8
#define P_MTNWR_STRIDE                             (volatile uint32_t *)0xff00dcdc
#define P_MCVECWR_BADDR                            (volatile uint32_t *)0xff00dcb8
#define P_MCVECWR_STRIDE                           (volatile uint32_t *)0xff00dcbc
#define P_MCINFWR_BADDR                            (volatile uint32_t *)0xff00df38
#define P_MCINFWR_STRIDE                           (volatile uint32_t *)0xff00df3c
#define P_NRDSWR_BADDR                             (volatile uint32_t *)0xff00dff4
#define P_NRDSWR_STRIDE                            (volatile uint32_t *)0xff00dff8
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  di_arb_sub_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_madc_regs.h
//
//
// Reading file:  vpp_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_HDR2_VCBUS_BASE = 0x38
// -----------------------------------------------
#define VD1_HDR2_OFFSET            0x00
#define VD2_HDR2_OFFSET            0x50
#define OSD1_HDR2_OFFSET           0xa0
//`include "hdr2_top_reg.h"
//vd1 0x00 - -x35
#define P_VD1_HDR2_CTRL                            (volatile uint32_t *)0xff00e000
#define P_VD1_HDR2_CLK_GATE                        (volatile uint32_t *)0xff00e004
#define P_VD1_HDR2_MATRIXI_COEF00_01               (volatile uint32_t *)0xff00e008
#define P_VD1_HDR2_MATRIXI_COEF02_10               (volatile uint32_t *)0xff00e00c
#define P_VD1_HDR2_MATRIXI_COEF11_12               (volatile uint32_t *)0xff00e010
#define P_VD1_HDR2_MATRIXI_COEF20_21               (volatile uint32_t *)0xff00e014
#define P_VD1_HDR2_MATRIXI_COEF22                  (volatile uint32_t *)0xff00e018
#define P_VD1_HDR2_MATRIXI_COEF30_31               (volatile uint32_t *)0xff00e01c
#define P_VD1_HDR2_MATRIXI_COEF32_40               (volatile uint32_t *)0xff00e020
#define P_VD1_HDR2_MATRIXI_COEF41_42               (volatile uint32_t *)0xff00e024
#define P_VD1_HDR2_MATRIXI_OFFSET0_1               (volatile uint32_t *)0xff00e028
#define P_VD1_HDR2_MATRIXI_OFFSET2                 (volatile uint32_t *)0xff00e02c
#define P_VD1_HDR2_MATRIXI_PRE_OFFSET0_1           (volatile uint32_t *)0xff00e030
#define P_VD1_HDR2_MATRIXI_PRE_OFFSET2             (volatile uint32_t *)0xff00e034
#define P_VD1_HDR2_MATRIXO_COEF00_01               (volatile uint32_t *)0xff00e038
#define P_VD1_HDR2_MATRIXO_COEF02_10               (volatile uint32_t *)0xff00e03c
#define P_VD1_HDR2_MATRIXO_COEF11_12               (volatile uint32_t *)0xff00e040
#define P_VD1_HDR2_MATRIXO_COEF20_21               (volatile uint32_t *)0xff00e044
#define P_VD1_HDR2_MATRIXO_COEF22                  (volatile uint32_t *)0xff00e048
#define P_VD1_HDR2_MATRIXO_COEF30_31               (volatile uint32_t *)0xff00e04c
#define P_VD1_HDR2_MATRIXO_COEF32_40               (volatile uint32_t *)0xff00e050
#define P_VD1_HDR2_MATRIXO_COEF41_42               (volatile uint32_t *)0xff00e054
#define P_VD1_HDR2_MATRIXO_OFFSET0_1               (volatile uint32_t *)0xff00e058
#define P_VD1_HDR2_MATRIXO_OFFSET2                 (volatile uint32_t *)0xff00e05c
#define P_VD1_HDR2_MATRIXO_PRE_OFFSET0_1           (volatile uint32_t *)0xff00e060
#define P_VD1_HDR2_MATRIXO_PRE_OFFSET2             (volatile uint32_t *)0xff00e064
#define P_VD1_HDR2_MATRIXI_CLIP                    (volatile uint32_t *)0xff00e068
#define P_VD1_HDR2_MATRIXO_CLIP                    (volatile uint32_t *)0xff00e06c
#define P_VD1_HDR2_CGAIN_OFFT                      (volatile uint32_t *)0xff00e070
#define P_VD1_EOTF_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00e078
#define P_VD1_EOTF_LUT_DATA_PORT                   (volatile uint32_t *)0xff00e07c
#define P_VD1_OETF_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00e080
#define P_VD1_OETF_LUT_DATA_PORT                   (volatile uint32_t *)0xff00e084
#define P_VD1_CGAIN_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e088
#define P_VD1_CGAIN_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e08c
#define P_VD1_HDR2_CGAIN_COEF0                     (volatile uint32_t *)0xff00e090
#define P_VD1_HDR2_CGAIN_COEF1                     (volatile uint32_t *)0xff00e094
#define P_VD1_OGAIN_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e098
#define P_VD1_OGAIN_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e09c
#define P_VD1_HDR2_ADPS_CTRL                       (volatile uint32_t *)0xff00e0a0
#define P_VD1_HDR2_ADPS_ALPHA0                     (volatile uint32_t *)0xff00e0a4
#define P_VD1_HDR2_ADPS_ALPHA1                     (volatile uint32_t *)0xff00e0a8
#define P_VD1_HDR2_ADPS_BETA0                      (volatile uint32_t *)0xff00e0ac
#define P_VD1_HDR2_ADPS_BETA1                      (volatile uint32_t *)0xff00e0b0
#define P_VD1_HDR2_ADPS_BETA2                      (volatile uint32_t *)0xff00e0b4
#define P_VD1_HDR2_ADPS_COEF0                      (volatile uint32_t *)0xff00e0b8
#define P_VD1_HDR2_ADPS_COEF1                      (volatile uint32_t *)0xff00e0bc
#define P_VD1_HDR2_GMUT_CTRL                       (volatile uint32_t *)0xff00e0c0
#define P_VD1_HDR2_GMUT_COEF0                      (volatile uint32_t *)0xff00e0c4
#define P_VD1_HDR2_GMUT_COEF1                      (volatile uint32_t *)0xff00e0c8
#define P_VD1_HDR2_GMUT_COEF2                      (volatile uint32_t *)0xff00e0cc
#define P_VD1_HDR2_GMUT_COEF3                      (volatile uint32_t *)0xff00e0d0
#define P_VD1_HDR2_GMUT_COEF4                      (volatile uint32_t *)0xff00e0d4
#define P_VD1_HDR2_PIPE_CTRL1                      (volatile uint32_t *)0xff00e0d8
#define P_VD1_HDR2_PIPE_CTRL2                      (volatile uint32_t *)0xff00e0dc
#define P_VD1_HDR2_PIPE_CTRL3                      (volatile uint32_t *)0xff00e0e0
#define P_VD1_HDR2_PROC_WIN1                       (volatile uint32_t *)0xff00e0e4
#define P_VD1_HDR2_PROC_WIN2                       (volatile uint32_t *)0xff00e0e8
#define P_VD1_HDR2_MATRIXI_EN_CTRL                 (volatile uint32_t *)0xff00e0ec
#define P_VD1_HDR2_MATRIXO_EN_CTRL                 (volatile uint32_t *)0xff00e0f0
#define P_VD1_HDR2_HIST_CTRL                       (volatile uint32_t *)0xff00e0f4
#define P_VD1_HDR2_HIST_H_START_END                (volatile uint32_t *)0xff00e0f8
#define P_VD1_HDR2_HIST_V_START_END                (volatile uint32_t *)0xff00e0fc
#define P_VD1_HDR2_HIST_RD                         (volatile uint32_t *)0xff00e074
//vd2 0x50 - 0x85
#define P_VD2_HDR2_CTRL                            (volatile uint32_t *)0xff00e140
#define P_VD2_HDR2_CLK_GATE                        (volatile uint32_t *)0xff00e144
#define P_VD2_HDR2_MATRIXI_COEF00_01               (volatile uint32_t *)0xff00e148
#define P_VD2_HDR2_MATRIXI_COEF02_10               (volatile uint32_t *)0xff00e14c
#define P_VD2_HDR2_MATRIXI_COEF11_12               (volatile uint32_t *)0xff00e150
#define P_VD2_HDR2_MATRIXI_COEF20_21               (volatile uint32_t *)0xff00e154
#define P_VD2_HDR2_MATRIXI_COEF22                  (volatile uint32_t *)0xff00e158
#define P_VD2_HDR2_MATRIXI_COEF30_31               (volatile uint32_t *)0xff00e15c
#define P_VD2_HDR2_MATRIXI_COEF32_40               (volatile uint32_t *)0xff00e160
#define P_VD2_HDR2_MATRIXI_COEF41_42               (volatile uint32_t *)0xff00e164
#define P_VD2_HDR2_MATRIXI_OFFSET0_1               (volatile uint32_t *)0xff00e168
#define P_VD2_HDR2_MATRIXI_OFFSET2                 (volatile uint32_t *)0xff00e16c
#define P_VD2_HDR2_MATRIXI_PRE_OFFSET0_1           (volatile uint32_t *)0xff00e170
#define P_VD2_HDR2_MATRIXI_PRE_OFFSET2             (volatile uint32_t *)0xff00e174
#define P_VD2_HDR2_MATRIXO_COEF00_01               (volatile uint32_t *)0xff00e178
#define P_VD2_HDR2_MATRIXO_COEF02_10               (volatile uint32_t *)0xff00e17c
#define P_VD2_HDR2_MATRIXO_COEF11_12               (volatile uint32_t *)0xff00e180
#define P_VD2_HDR2_MATRIXO_COEF20_21               (volatile uint32_t *)0xff00e184
#define P_VD2_HDR2_MATRIXO_COEF22                  (volatile uint32_t *)0xff00e188
#define P_VD2_HDR2_MATRIXO_COEF30_31               (volatile uint32_t *)0xff00e18c
#define P_VD2_HDR2_MATRIXO_COEF32_40               (volatile uint32_t *)0xff00e190
#define P_VD2_HDR2_MATRIXO_COEF41_42               (volatile uint32_t *)0xff00e194
#define P_VD2_HDR2_MATRIXO_OFFSET0_1               (volatile uint32_t *)0xff00e198
#define P_VD2_HDR2_MATRIXO_OFFSET2                 (volatile uint32_t *)0xff00e19c
#define P_VD2_HDR2_MATRIXO_PRE_OFFSET0_1           (volatile uint32_t *)0xff00e1a0
#define P_VD2_HDR2_MATRIXO_PRE_OFFSET2             (volatile uint32_t *)0xff00e1a4
#define P_VD2_HDR2_MATRIXI_CLIP                    (volatile uint32_t *)0xff00e1a8
#define P_VD2_HDR2_MATRIXO_CLIP                    (volatile uint32_t *)0xff00e1ac
#define P_VD2_HDR2_CGAIN_OFFT                      (volatile uint32_t *)0xff00e1b0
#define P_VD2_EOTF_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00e1b8
#define P_VD2_EOTF_LUT_DATA_PORT                   (volatile uint32_t *)0xff00e1bc
#define P_VD2_OETF_LUT_ADDR_PORT                   (volatile uint32_t *)0xff00e1c0
#define P_VD2_OETF_LUT_DATA_PORT                   (volatile uint32_t *)0xff00e1c4
#define P_VD2_CGAIN_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e1c8
#define P_VD2_CGAIN_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e1cc
#define P_VD2_HDR2_CGAIN_COEF0                     (volatile uint32_t *)0xff00e1d0
#define P_VD2_HDR2_CGAIN_COEF1                     (volatile uint32_t *)0xff00e1d4
#define P_VD2_OGAIN_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e1d8
#define P_VD2_OGAIN_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e1dc
#define P_VD2_HDR2_ADPS_CTRL                       (volatile uint32_t *)0xff00e1e0
#define P_VD2_HDR2_ADPS_ALPHA0                     (volatile uint32_t *)0xff00e1e4
#define P_VD2_HDR2_ADPS_ALPHA1                     (volatile uint32_t *)0xff00e1e8
#define P_VD2_HDR2_ADPS_BETA0                      (volatile uint32_t *)0xff00e1ec
#define P_VD2_HDR2_ADPS_BETA1                      (volatile uint32_t *)0xff00e1f0
#define P_VD2_HDR2_ADPS_BETA2                      (volatile uint32_t *)0xff00e1f4
#define P_VD2_HDR2_ADPS_COEF0                      (volatile uint32_t *)0xff00e1f8
#define P_VD2_HDR2_ADPS_COEF1                      (volatile uint32_t *)0xff00e1fc
#define P_VD2_HDR2_GMUT_CTRL                       (volatile uint32_t *)0xff00e200
#define P_VD2_HDR2_GMUT_COEF0                      (volatile uint32_t *)0xff00e204
#define P_VD2_HDR2_GMUT_COEF1                      (volatile uint32_t *)0xff00e208
#define P_VD2_HDR2_GMUT_COEF2                      (volatile uint32_t *)0xff00e20c
#define P_VD2_HDR2_GMUT_COEF3                      (volatile uint32_t *)0xff00e210
#define P_VD2_HDR2_GMUT_COEF4                      (volatile uint32_t *)0xff00e214
#define P_VD2_HDR2_PIPE_CTRL1                      (volatile uint32_t *)0xff00e218
#define P_VD2_HDR2_PIPE_CTRL2                      (volatile uint32_t *)0xff00e21c
#define P_VD2_HDR2_PIPE_CTRL3                      (volatile uint32_t *)0xff00e220
#define P_VD2_HDR2_PROC_WIN1                       (volatile uint32_t *)0xff00e224
#define P_VD2_HDR2_PROC_WIN2                       (volatile uint32_t *)0xff00e228
#define P_VD2_HDR2_MATRIXI_EN_CTRL                 (volatile uint32_t *)0xff00e22c
#define P_VD2_HDR2_MATRIXO_EN_CTRL                 (volatile uint32_t *)0xff00e230
#define P_VD2_HDR2_HIST_CTRL                       (volatile uint32_t *)0xff00e234
#define P_VD2_HDR2_HIST_H_START_END                (volatile uint32_t *)0xff00e238
#define P_VD2_HDR2_HIST_V_START_END                (volatile uint32_t *)0xff00e23c
#define P_VD2_HDR2_HIST_RD                         (volatile uint32_t *)0xff00e1b4
//osd1 0xa0 - 0xd5
#define P_OSD1_HDR2_CTRL                           (volatile uint32_t *)0xff00e280
#define P_OSD1_HDR2_CLK_GATE                       (volatile uint32_t *)0xff00e284
#define P_OSD1_HDR2_MATRIXI_COEF00_01              (volatile uint32_t *)0xff00e288
#define P_OSD1_HDR2_MATRIXI_COEF02_10              (volatile uint32_t *)0xff00e28c
#define P_OSD1_HDR2_MATRIXI_COEF11_12              (volatile uint32_t *)0xff00e290
#define P_OSD1_HDR2_MATRIXI_COEF20_21              (volatile uint32_t *)0xff00e294
#define P_OSD1_HDR2_MATRIXI_COEF22                 (volatile uint32_t *)0xff00e298
#define P_OSD1_HDR2_MATRIXI_COEF30_31              (volatile uint32_t *)0xff00e29c
#define P_OSD1_HDR2_MATRIXI_COEF32_40              (volatile uint32_t *)0xff00e2a0
#define P_OSD1_HDR2_MATRIXI_COEF41_42              (volatile uint32_t *)0xff00e2a4
#define P_OSD1_HDR2_MATRIXI_OFFSET0_1              (volatile uint32_t *)0xff00e2a8
#define P_OSD1_HDR2_MATRIXI_OFFSET2                (volatile uint32_t *)0xff00e2ac
#define P_OSD1_HDR2_MATRIXI_PRE_OFFSET0_1          (volatile uint32_t *)0xff00e2b0
#define P_OSD1_HDR2_MATRIXI_PRE_OFFSET2            (volatile uint32_t *)0xff00e2b4
#define P_OSD1_HDR2_MATRIXO_COEF00_01              (volatile uint32_t *)0xff00e2b8
#define P_OSD1_HDR2_MATRIXO_COEF02_10              (volatile uint32_t *)0xff00e2bc
#define P_OSD1_HDR2_MATRIXO_COEF11_12              (volatile uint32_t *)0xff00e2c0
#define P_OSD1_HDR2_MATRIXO_COEF20_21              (volatile uint32_t *)0xff00e2c4
#define P_OSD1_HDR2_MATRIXO_COEF22                 (volatile uint32_t *)0xff00e2c8
#define P_OSD1_HDR2_MATRIXO_COEF30_31              (volatile uint32_t *)0xff00e2cc
#define P_OSD1_HDR2_MATRIXO_COEF32_40              (volatile uint32_t *)0xff00e2d0
#define P_OSD1_HDR2_MATRIXO_COEF41_42              (volatile uint32_t *)0xff00e2d4
#define P_OSD1_HDR2_MATRIXO_OFFSET0_1              (volatile uint32_t *)0xff00e2d8
#define P_OSD1_HDR2_MATRIXO_OFFSET2                (volatile uint32_t *)0xff00e2dc
#define P_OSD1_HDR2_MATRIXO_PRE_OFFSET0_1          (volatile uint32_t *)0xff00e2e0
#define P_OSD1_HDR2_MATRIXO_PRE_OFFSET2            (volatile uint32_t *)0xff00e2e4
#define P_OSD1_HDR2_MATRIXI_CLIP                   (volatile uint32_t *)0xff00e2e8
#define P_OSD1_HDR2_MATRIXO_CLIP                   (volatile uint32_t *)0xff00e2ec
#define P_OSD1_HDR2_CGAIN_OFFT                     (volatile uint32_t *)0xff00e2f0
#define P_OSD1_EOTF_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e2f8
#define P_OSD1_EOTF_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e2fc
#define P_OSD1_OETF_LUT_ADDR_PORT                  (volatile uint32_t *)0xff00e300
#define P_OSD1_OETF_LUT_DATA_PORT                  (volatile uint32_t *)0xff00e304
#define P_OSD1_CGAIN_LUT_ADDR_PORT                 (volatile uint32_t *)0xff00e308
#define P_OSD1_CGAIN_LUT_DATA_PORT                 (volatile uint32_t *)0xff00e30c
#define P_OSD1_HDR2_CGAIN_COEF0                    (volatile uint32_t *)0xff00e310
#define P_OSD1_HDR2_CGAIN_COEF1                    (volatile uint32_t *)0xff00e314
#define P_OSD1_OGAIN_LUT_ADDR_PORT                 (volatile uint32_t *)0xff00e318
#define P_OSD1_OGAIN_LUT_DATA_PORT                 (volatile uint32_t *)0xff00e31c
#define P_OSD1_HDR2_ADPS_CTRL                      (volatile uint32_t *)0xff00e320
#define P_OSD1_HDR2_ADPS_ALPHA0                    (volatile uint32_t *)0xff00e324
#define P_OSD1_HDR2_ADPS_ALPHA1                    (volatile uint32_t *)0xff00e328
#define P_OSD1_HDR2_ADPS_BETA0                     (volatile uint32_t *)0xff00e32c
#define P_OSD1_HDR2_ADPS_BETA1                     (volatile uint32_t *)0xff00e330
#define P_OSD1_HDR2_ADPS_BETA2                     (volatile uint32_t *)0xff00e334
#define P_OSD1_HDR2_ADPS_COEF0                     (volatile uint32_t *)0xff00e338
#define P_OSD1_HDR2_ADPS_COEF1                     (volatile uint32_t *)0xff00e33c
#define P_OSD1_HDR2_GMUT_CTRL                      (volatile uint32_t *)0xff00e340
#define P_OSD1_HDR2_GMUT_COEF0                     (volatile uint32_t *)0xff00e344
#define P_OSD1_HDR2_GMUT_COEF1                     (volatile uint32_t *)0xff00e348
#define P_OSD1_HDR2_GMUT_COEF2                     (volatile uint32_t *)0xff00e34c
#define P_OSD1_HDR2_GMUT_COEF3                     (volatile uint32_t *)0xff00e350
#define P_OSD1_HDR2_GMUT_COEF4                     (volatile uint32_t *)0xff00e354
#define P_OSD1_HDR2_PIPE_CTRL1                     (volatile uint32_t *)0xff00e358
#define P_OSD1_HDR2_PIPE_CTRL2                     (volatile uint32_t *)0xff00e35c
#define P_OSD1_HDR2_PIPE_CTRL3                     (volatile uint32_t *)0xff00e360
#define P_OSD1_HDR2_PROC_WIN1                      (volatile uint32_t *)0xff00e364
#define P_OSD1_HDR2_PROC_WIN2                      (volatile uint32_t *)0xff00e368
#define P_OSD1_HDR2_MATRIXI_EN_CTRL                (volatile uint32_t *)0xff00e36c
#define P_OSD1_HDR2_MATRIXO_EN_CTRL                (volatile uint32_t *)0xff00e370
#define P_OSD1_HDR2_HIST_CTRL                      (volatile uint32_t *)0xff00e374
#define P_OSD1_HDR2_HIST_H_START_END               (volatile uint32_t *)0xff00e378
#define P_OSD1_HDR2_HIST_V_START_END               (volatile uint32_t *)0xff00e37c
#define P_OSD1_HDR2_HIST_RD                        (volatile uint32_t *)0xff00e2f4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_hdr2_regs.h
//
//
// Reading file:  vpp_misc_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_MISC_VCBUS_BASE = 0x39
// -----------------------------------------------
//0x01-0a
//
// Reading file:  vpp_vd2_mat_3x3_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VPP_VD2_MATRIX_COEF00_01                 (volatile uint32_t *)0xff00e404
#define P_VPP_VD2_MATRIX_COEF02_10                 (volatile uint32_t *)0xff00e408
#define P_VPP_VD2_MATRIX_COEF11_12                 (volatile uint32_t *)0xff00e40c
#define P_VPP_VD2_MATRIX_COEF20_21                 (volatile uint32_t *)0xff00e410
#define P_VPP_VD2_MATRIX_COEF22                    (volatile uint32_t *)0xff00e414
#define P_VPP_VD2_MATRIX_OFFSET0_1                 (volatile uint32_t *)0xff00e418
#define P_VPP_VD2_MATRIX_OFFSET2                   (volatile uint32_t *)0xff00e41c
#define P_VPP_VD2_MATRIX_CLIP                      (volatile uint32_t *)0xff00e420
#define P_VPP_VD2_MATRIX_PRE_OFFSET0_1             (volatile uint32_t *)0xff00e424
#define P_VPP_VD2_MATRIX_PRE_OFFSET2               (volatile uint32_t *)0xff00e428
#define P_VPP_VD2_MATRIX_EN_CTRL                   (volatile uint32_t *)0xff00e42c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_vd2_mat_3x3_regs.h
//
//0x10-1c
//
// Reading file:  vpp_osd1_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VPP_OSD1_MATRIX_COEF00_01                (volatile uint32_t *)0xff00e440
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF02_10                (volatile uint32_t *)0xff00e444
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF11_12                (volatile uint32_t *)0xff00e448
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF20_21                (volatile uint32_t *)0xff00e44c
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF22                   (volatile uint32_t *)0xff00e450
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF13_14                (volatile uint32_t *)0xff00e454
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF23_24                (volatile uint32_t *)0xff00e458
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define P_VPP_OSD1_MATRIX_COEF15_25                (volatile uint32_t *)0xff00e45c
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define P_VPP_OSD1_MATRIX_CLIP                     (volatile uint32_t *)0xff00e460
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define P_VPP_OSD1_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff00e464
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define P_VPP_OSD1_MATRIX_OFFSET2                  (volatile uint32_t *)0xff00e468
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define P_VPP_OSD1_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff00e46c
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define P_VPP_OSD1_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff00e470
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define P_VPP_OSD1_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff00e474
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_osd1_mat_3x5_regs.h
//
//0x20-2c
//
// Reading file:  vpp_osd2_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VPP_OSD2_MATRIX_COEF00_01                (volatile uint32_t *)0xff00e480
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF02_10                (volatile uint32_t *)0xff00e484
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF11_12                (volatile uint32_t *)0xff00e488
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF20_21                (volatile uint32_t *)0xff00e48c
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF22                   (volatile uint32_t *)0xff00e490
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF13_14                (volatile uint32_t *)0xff00e494
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF23_24                (volatile uint32_t *)0xff00e498
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define P_VPP_OSD2_MATRIX_COEF15_25                (volatile uint32_t *)0xff00e49c
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define P_VPP_OSD2_MATRIX_CLIP                     (volatile uint32_t *)0xff00e4a0
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define P_VPP_OSD2_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff00e4a4
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define P_VPP_OSD2_MATRIX_OFFSET2                  (volatile uint32_t *)0xff00e4a8
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define P_VPP_OSD2_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff00e4ac
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define P_VPP_OSD2_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff00e4b0
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define P_VPP_OSD2_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff00e4b4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_osd2_mat_3x5_regs.h
//
//0x30-3c
//`include "vpp_post_mat_3x5_regs.h"
//0x40-0x5f
//
// Reading file:  vpp_vd2_scale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VD2_SCALE_COEF_IDX                       (volatile uint32_t *)0xff00e50c
#define P_VD2_SCALE_COEF                           (volatile uint32_t *)0xff00e510
#define P_VD2_VSC_REGION12_STARTP                  (volatile uint32_t *)0xff00e514
#define P_VD2_VSC_REGION34_STARTP                  (volatile uint32_t *)0xff00e518
#define P_VD2_VSC_REGION4_ENDP                     (volatile uint32_t *)0xff00e51c
#define P_VD2_VSC_START_PHASE_STEP                 (volatile uint32_t *)0xff00e520
#define P_VD2_VSC_REGION0_PHASE_SLOPE              (volatile uint32_t *)0xff00e524
#define P_VD2_VSC_REGION1_PHASE_SLOPE              (volatile uint32_t *)0xff00e528
#define P_VD2_VSC_REGION3_PHASE_SLOPE              (volatile uint32_t *)0xff00e52c
#define P_VD2_VSC_REGION4_PHASE_SLOPE              (volatile uint32_t *)0xff00e530
#define P_VD2_VSC_PHASE_CTRL                       (volatile uint32_t *)0xff00e534
#define P_VD2_VSC_INI_PHASE                        (volatile uint32_t *)0xff00e538
#define P_VD2_HSC_REGION12_STARTP                  (volatile uint32_t *)0xff00e53c
#define P_VD2_HSC_REGION34_STARTP                  (volatile uint32_t *)0xff00e540
#define P_VD2_HSC_REGION4_ENDP                     (volatile uint32_t *)0xff00e544
#define P_VD2_HSC_START_PHASE_STEP                 (volatile uint32_t *)0xff00e548
#define P_VD2_HSC_REGION0_PHASE_SLOPE              (volatile uint32_t *)0xff00e54c
#define P_VD2_HSC_REGION1_PHASE_SLOPE              (volatile uint32_t *)0xff00e550
#define P_VD2_HSC_REGION3_PHASE_SLOPE              (volatile uint32_t *)0xff00e554
#define P_VD2_HSC_REGION4_PHASE_SLOPE              (volatile uint32_t *)0xff00e558
#define P_VD2_HSC_PHASE_CTRL                       (volatile uint32_t *)0xff00e55c
#define P_VD2_SC_MISC                              (volatile uint32_t *)0xff00e560
#define P_VD2_SCO_FIFO_CTRL                        (volatile uint32_t *)0xff00e564
#define P_VD2_HSC_PHASE_CTRL1                      (volatile uint32_t *)0xff00e568
#define P_VD2_HSC_INI_PAT_CTRL                     (volatile uint32_t *)0xff00e56c
#define P_VD2_SC_GCLK_CTRL                         (volatile uint32_t *)0xff00e570
#define P_VD2_PREHSC_COEF                          (volatile uint32_t *)0xff00e574
#define P_VD2_PRE_SCALE_CTRL                       (volatile uint32_t *)0xff00e578
#define P_VD2_PREVSC_COEF                          (volatile uint32_t *)0xff00e57c
#define P_VD2_PREHSC_COEF1                         (volatile uint32_t *)0xff00e508
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_vd2_scale_regs.h
//
#define P_VPP_PRE_BLEND_CTRL                       (volatile uint32_t *)0xff00e580
//Bit 31:28  reserved
//Bit 27:20  hold_lines                //unsigned , default = 8'h4
//Bit 19:16  din_premult_en            //unsigned , default = 4'h0
//Bit 15:0   din_reoder_sel            //unsigned , default = 16'h1
#define P_VPP_PRE_BLEND_BLEND_DUMMY_DATA           (volatile uint32_t *)0xff00e584
//Bit 31:28  reserved
//Bit 27:16  blend0_dummy_data_y       //unsigned , default = 8'h10
//Bit 15:8   blend0_dummy_data_cb      //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr      //unsigned , default = 8'h0
#define P_VPP_PRE_BLEND_DUMMY_ALPHA                (volatile uint32_t *)0xff00e588
//Bit 31:29  reserved
//Bit 28:20  blend0_dummy_alpha        //unsigned , default = 9'h0
//Bit 19:11  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 8:0    blend2_dummy_alpha        //unsigned , default = 9'h0
#define P_VPP_PRE_BLEND2_RO_CURRENT_XY             (volatile uint32_t *)0xff00e58c
//Bit 31:0  ro_blend2_current_xy          //unsigned , default = 32'h0
#define P_VPP_POST_BLEND_CTRL                      (volatile uint32_t *)0xff00e59c
//Bit 31:28  reserved
//Bit 27:20  hold_lines                //unsigned , default = 8'h4
//Bit 19:16  din_premult_en            //unsigned , default = 4'h0
//Bit 15:0   din_reoder_sel            //unsigned , default = 16'h1
#define P_VPP_POST_BLEND_BLEND_DUMMY_DATA          (volatile uint32_t *)0xff00e5a0
//Bit 31:28  reserved
//Bit 27:16  blend0_dummy_data_y       //unsigned , default = 8'h10
//Bit 15:8   blend0_dummy_data_cb      //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr      //unsigned , default = 8'h0
#define P_VPP_POST_BLEND_DUMMY_ALPHA               (volatile uint32_t *)0xff00e5a4
//Bit 31:29  reserved
//Bit 28:20  blend0_dummy_alpha        //unsigned , default = 9'h0
//Bit 19:11  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 8:0    blend2_dummy_alpha        //unsigned , default = 9'h0
#define P_VPP_POST_BLEND2_RO_CURRENT_XY            (volatile uint32_t *)0xff00e5a8
//Bit 31:0  ro_blend2_current_xy          //unsigned , default = 32'h0
#define P_VPP_AFBC_RDARB_MODE                      (volatile uint32_t *)0xff00e5c0
#define P_VPP_AFBC_RDARB_REQEN_SLV                 (volatile uint32_t *)0xff00e5c4
#define P_VPP_AFBC_RDARB_WEIGH0_SLV                (volatile uint32_t *)0xff00e5c8
#define P_VPP_AFBC_RDWR_ARB_STATUS                 (volatile uint32_t *)0xff00e5cc
#define P_VPP_AFBC_ARB_DBG_CTRL                    (volatile uint32_t *)0xff00e5d0
#define P_VPP_AFBC_ARB_DBG_STAT                    (volatile uint32_t *)0xff00e5d4
#define P_VPP_RDARB_MODE                           (volatile uint32_t *)0xff00e5e0
#define P_VPP_RDARB_REQEN_SLV                      (volatile uint32_t *)0xff00e5e4
#define P_VPP_RDARB_WEIGH0_SLV                     (volatile uint32_t *)0xff00e5e8
#define P_VPP_RDARB_WEIGH1_SLV                     (volatile uint32_t *)0xff00e5ec
#define P_VPP_RDWR_ARB_STATUS                      (volatile uint32_t *)0xff00e5f0
#define P_VPP_ARB_DBG_CTRL                         (volatile uint32_t *)0xff00e5f8
#define P_VPP_ARB_DBG_STAT                         (volatile uint32_t *)0xff00e5fc
//ox80-0x9f & 0xe0-0xef
//
// Reading file:  vpu_primesl_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_PRIMESL_LUTC_ADDR_PORT                   (volatile uint32_t *)0xff00e600
#define P_PRIMESL_LUTC_DATA_PORT                   (volatile uint32_t *)0xff00e604
#define P_PRIMESL_LUTP_ADDR_PORT                   (volatile uint32_t *)0xff00e608
#define P_PRIMESL_LUTP_DATA_PORT                   (volatile uint32_t *)0xff00e60c
#define P_PRIMESL_LUTD_ADDR_PORT                   (volatile uint32_t *)0xff00e610
#define P_PRIMESL_LUTD_DATA_PORT                   (volatile uint32_t *)0xff00e614
#define P_PRIMESL_CTRL0                            (volatile uint32_t *)0xff00e640
//Bit 31:30        reserved
//Bit 29           legacy_mode_en            // unsigned , default = 0  = 'h0
//Bit 28           clip_en                   // unsigned , default = 1  = 'h0
//Bit 27            reserved
//Bit 26:16        inv_chroma_ratio          // unsigned , default = 0  = 'h0,
//Bit 15            reserved
//Bit 14: 4        inv_y_ratio               // unsigned , default = 0  = 'h0,
//Bit  3           reg_gclk_ctrl             // unsigned , default = 0  = 'h0,
//Bit  2: 1        gclk_ctrl                 // unsigned , default = 0  = 'h0,
//Bit  0           primesl_en                // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL1                            (volatile uint32_t *)0xff00e644
//Bit 31:26        reserved
//Bit 25:16        l_headroom                // unsigned , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        footroom                  // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL2                            (volatile uint32_t *)0xff00e648
//Bit 31:10        reserved
//Bit  9: 0        c_headroom                // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL3                            (volatile uint32_t *)0xff00e64c
//Bit 31:16        mub                       // unsigned , default = 0  = 'h0,
//Bit 15: 0        mua                       // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL4                            (volatile uint32_t *)0xff00e650
//Bit 31:26        reserved
//Bit 25:16        oct_7_1                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_0                   // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL5                            (volatile uint32_t *)0xff00e654
//Bit 31:26        reserved
//Bit 25:16        oct_7_3                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_2                   // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL6                            (volatile uint32_t *)0xff00e658
//Bit 31:26        reserved
//Bit 25:16        oct_7_5                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_4                   // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL7                            (volatile uint32_t *)0xff00e65c
//Bit 31:10        reserved
//Bit  9: 0        oct_7_6                   // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL8                            (volatile uint32_t *)0xff00e660
//Bit 31:29        reserved
//Bit 28:16        d_lut_threshold_3_1       // unsigned , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        d_lut_threshold_3_0       // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL9                            (volatile uint32_t *)0xff00e664
//Bit 31:13        reserved
//Bit 12: 0        d_lut_threshold_3_2       // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL10                           (volatile uint32_t *)0xff00e668
//Bit 31:16        reserved
//Bit 15:12        d_lut_step_4_3            // unsigned , default = 0  = 'h0,
//Bit 11: 8        d_lut_step_4_2            // unsigned , default = 0  = 'h0,
//Bit  7: 4        d_lut_step_4_1            // unsigned , default = 0  = 'h0,
//Bit  3: 0        d_lut_step_4_0            // unsigned , default = 0  = 'h0,
#define P_PRIMESL_CTRL11                           (volatile uint32_t *)0xff00e66c
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_0               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_1               // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL12                           (volatile uint32_t *)0xff00e670
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_2               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_3               // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL13                           (volatile uint32_t *)0xff00e674
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_4               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_5               // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL14                           (volatile uint32_t *)0xff00e678
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_6               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_7               // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL15                           (volatile uint32_t *)0xff00e67c
//Bit 31:13        reserved
//Bit 12: 0        rgb2yuv_9_8               // signed , default = 0  = 'h0,
#define P_PRIMESL_CTRL16                           (volatile uint32_t *)0xff00e780
//Bit 31            reserved
//Bit 30           byp_s_lut                 // unsigned , default = 0  = 'h0,
//Bit 29           byp_d_lut                 // unsigned , default = 0  = 'h0,
//Bit 28           byp_mat                   // unsigned , default = 0  = 'h0,
//Bit 27           rgb_swap                  // unsigned , default = 0  = 'h0,
//Bit 26:24        uv_shift                  // unsigned , default = 0  = 'h0,
//Bit 23:22        rgb_shift                 // unsigned , default = 0  = 'h0,
//Bit 21:20        rgb_clip                  // unsigned , default = 3  = 'h3,
//Bit 19:18        reserved
//Bit 17:16        rgb_rs                    // unsigned , default = 0  = 'h0,
//Bit 15:14        reserved
//Bit 13: 0        reg_s                     // signed , default = 1024  = 'h1024,
#define P_PRIMESL_OMAT_OFFSET0                     (volatile uint32_t *)0xff00e784
//Bit 31:28        reserved
//Bit 27:16        pre_offset0               // unsigned , default = 512  = 'h512
//Bit 15:12        reserved
//Bit 11: 0        pre_offset1               // unsigned , default = 512  = 'h512
#define P_PRIMESL_OMAT_OFFSET1                     (volatile uint32_t *)0xff00e788
//Bit 31:28        reserved
//Bit 27:16        pre_offset2               // unsigned , default = 512  = 'h512
//Bit 15:12        reserved
//Bit 11: 0        offset0                   // unsigned , default = 256  = 'h256
#define P_PRIMESL_OMAT_OFFSET2                     (volatile uint32_t *)0xff00e78c
//Bit 31:28        reserved
//Bit 27:16        offset1                   // unsigned , default = 2048  = 'h2048
//Bit 15:12        reserved
//Bit 11: 0        offset2                   // unsigned , default = 2048  = 'h2048
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_primesl_regs.h
//
//oxa0-0xaf
//
// Reading file:  vpp_post2_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VPP_POST2_MATRIX_COEF00_01               (volatile uint32_t *)0xff00e680
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF02_10               (volatile uint32_t *)0xff00e684
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF11_12               (volatile uint32_t *)0xff00e688
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF20_21               (volatile uint32_t *)0xff00e68c
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF22                  (volatile uint32_t *)0xff00e690
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF13_14               (volatile uint32_t *)0xff00e694
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF23_24               (volatile uint32_t *)0xff00e698
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define P_VPP_POST2_MATRIX_COEF15_25               (volatile uint32_t *)0xff00e69c
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define P_VPP_POST2_MATRIX_CLIP                    (volatile uint32_t *)0xff00e6a0
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define P_VPP_POST2_MATRIX_OFFSET0_1               (volatile uint32_t *)0xff00e6a4
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define P_VPP_POST2_MATRIX_OFFSET2                 (volatile uint32_t *)0xff00e6a8
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define P_VPP_POST2_MATRIX_PRE_OFFSET0_1           (volatile uint32_t *)0xff00e6ac
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define P_VPP_POST2_MATRIX_PRE_OFFSET2             (volatile uint32_t *)0xff00e6b0
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define P_VPP_POST2_MATRIX_EN_CTRL                 (volatile uint32_t *)0xff00e6b4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_post2_mat_3x5_regs.h
//
//0xb0-0xcf
//
// Reading file:  osd_blend_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define P_VIU_OSD_BLEND_CTRL                       (volatile uint32_t *)0xff00e6c0
//Bit 31:29  hold_lines                     //unsigned , default = 3'h0
//Bit 28:27  blend2_premult_en              //unsigned , default = 2'h3
//Bit 26     din0_byp_blend                 //unsigned , default = 1'h1
//Bit 25     din2_osd_sel                   //unsigned , default = 1'h1
//Bit 24     din3_osd_sel                   //unsigned , default = 1'h1
//Bit 23:20  blend_din_en                   //unsigned , default = 4'h5
//Bit 19:16  din_premult_en                 //unsigned , default = 4'h0
//Bit 15:0   din_reoder_sel                 //unsigned , default = 16'h2341
#define P_VIU_OSD_BLEND_CTRL1                      (volatile uint32_t *)0xff00e700
//Bit 31:6  reserved
//Bit 5:4   reg_alp_mapping_mode
//Bit 2:1   reg_div_gclk_en
//Bit 0     reg_div_alpha_en
#define P_VIU_OSD_BLEND_DIN0_SCOPE_H               (volatile uint32_t *)0xff00e6c4
//Bit 31:29  reserved
//Bit 28:16  bld_din0_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din0_h_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN0_SCOPE_V               (volatile uint32_t *)0xff00e6c8
//Bit 31:29  reserved
//Bit 28:16  bld_din0_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din0_v_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN1_SCOPE_H               (volatile uint32_t *)0xff00e6cc
//Bit 31:29  reserved
//Bit 28:16  bld_din1_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din1_h_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN1_SCOPE_V               (volatile uint32_t *)0xff00e6d0
//Bit 31:29  reserved
//Bit 28:16  bld_din1_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din1_v_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN2_SCOPE_H               (volatile uint32_t *)0xff00e6d4
//Bit 31:29  reserved
//Bit 28:16  bld_din2_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din2_h_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN2_SCOPE_V               (volatile uint32_t *)0xff00e6d8
//Bit 31:29  reserved
//Bit 28:16  bld_din2_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din2_v_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN3_SCOPE_H               (volatile uint32_t *)0xff00e6dc
//Bit 31:29  reserved
//Bit 28:16  bld_din3_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din3_h_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DIN3_SCOPE_V               (volatile uint32_t *)0xff00e6e0
//Bit 31:29  reserved
//Bit 28:16  bld_din3_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din3_v_start        ///unsigned , default = 13'h0
#define P_VIU_OSD_BLEND_DUMMY_DATA0                (volatile uint32_t *)0xff00e6e4
//Bit 31:28  reserved
//Bit 23:16  blend0_dummy_data_y             //unsigned , default = 8'h00
//Bit 15:8   blend0_dummy_data_cb            //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr            //unsigned , default = 8'h80
#define P_VIU_OSD_BLEND_DUMMY_ALPHA                (volatile uint32_t *)0xff00e6e8
//Bit 31:29  reserved
//Bit 28:20  blend0_dummy_alpha              //unsigned , default = 9'h0
//Bit 19:11  blend1_dummy_alpha              //unsigned , default = 9'h0
//Bit 8:0    blend2_dummy_alpha              //unsigned , default = 9'h0
#define P_VIU_OSD_BLEND_BLEND0_SIZE                (volatile uint32_t *)0xff00e6ec
//Bit 31:29  reserved
//Bit 28:16  blend0_vsize                    //unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   blend0_hsize                    //unsigned , default = 13'h2d0
#define P_VIU_OSD_BLEND_BLEND1_SIZE                (volatile uint32_t *)0xff00e6f0
//Bit 31:29  reserved
//Bit 28:16  blend1_vsize                    //unsigned  , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   blend1_hsize                    ///unsigned , default = 13'h2d0
//`define   VIU_OSD_BLEND_DOUT0_HV_START       8'hbd
//Bit 31:29  reserved
//Bit 28:0   osd_blend_dout0_hv_start        //unsigned  , default = 29'h0
//`define   VIU_OSD_BLEND_DOUT1_HV_START       8'hbe
//Bit 31:29  reserved
//Bit 28:0   osd_blend_dout1_hv_start        //unsigned  , default = 29'h0
#define P_VIU_OSD_HOLD_LINE_HIGH_BITS              (volatile uint32_t *)0xff00e704
//Bit 31:8  reserved
//Bit 7:0   hold_line_high_bits              //unsigned , default = 32'h0
#define P_VIU_OSD_BLEND_RO_CURRENT_XY              (volatile uint32_t *)0xff00e6fc
//Bit 31:0  ro_blend2_current_xy             //unsigned , default = 32'h0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  osd_blend_reg.h
//
#define P_VPP_LUT3D_CTRL                           (volatile uint32_t *)0xff00e740
#define P_VPP_LUT3D_CBUS2RAM_CTRL                  (volatile uint32_t *)0xff00e744
#define P_VPP_LUT3D_RAM_ADDR                       (volatile uint32_t *)0xff00e748
#define P_VPP_LUT3D_RAM_DATA                       (volatile uint32_t *)0xff00e74c
#define P_VPP_GAMMA_CTRL                           (volatile uint32_t *)0xff00e750
#define P_VPP_GAMMA_BIN_ADDR                       (volatile uint32_t *)0xff00e754
#define P_VPP_GAMMA_BIN_DATA                       (volatile uint32_t *)0xff00e758
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_misc_regs.h
//
//========================================================================
//  MALI AFBCD
//========================================================================
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD0_VCBUS_BASE = 0x3a
// -----------------------------------------------
//
// Reading file:  vpp_mali_tx300_afbc_regs.h
//
// synopsys translate_off
// synopsys translate_on
 //0x00 - 0x80
#define P_VPU_MAFBC_BLOCK_ID                       (volatile uint32_t *)0xff00e800
#define P_VPU_MAFBC_IRQ_RAW_STATUS                 (volatile uint32_t *)0xff00e804
#define P_VPU_MAFBC_IRQ_CLEAR                      (volatile uint32_t *)0xff00e808
#define P_VPU_MAFBC_IRQ_MASK                       (volatile uint32_t *)0xff00e80c
#define P_VPU_MAFBC_IRQ_STATUS                     (volatile uint32_t *)0xff00e810
#define P_VPU_MAFBC_COMMAND                        (volatile uint32_t *)0xff00e814
#define P_VPU_MAFBC_STATUS                         (volatile uint32_t *)0xff00e818
#define P_VPU_MAFBC_SURFACE_CFG                    (volatile uint32_t *)0xff00e81c
#define P_VPU_MAFBC_AXI_CFG                        (volatile uint32_t *)0xff00e820
#define P_VPU_MAFBC_HEADER_BUF_ADDR_LOW_S0         (volatile uint32_t *)0xff00e840
#define P_VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S0        (volatile uint32_t *)0xff00e844
#define P_VPU_MAFBC_FORMAT_SPECIFIER_S0            (volatile uint32_t *)0xff00e848
#define P_VPU_MAFBC_BUFFER_WIDTH_S0                (volatile uint32_t *)0xff00e84c
#define P_VPU_MAFBC_BUFFER_HEIGHT_S0               (volatile uint32_t *)0xff00e850
#define P_VPU_MAFBC_BOUNDING_BOX_X_START_S0        (volatile uint32_t *)0xff00e854
#define P_VPU_MAFBC_BOUNDING_BOX_X_END_S0          (volatile uint32_t *)0xff00e858
#define P_VPU_MAFBC_BOUNDING_BOX_Y_START_S0        (volatile uint32_t *)0xff00e85c
#define P_VPU_MAFBC_BOUNDING_BOX_Y_END_S0          (volatile uint32_t *)0xff00e860
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S0         (volatile uint32_t *)0xff00e864
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S0        (volatile uint32_t *)0xff00e868
#define P_VPU_MAFBC_OUTPUT_BUF_STRIDE_S0           (volatile uint32_t *)0xff00e86c
#define P_VPU_MAFBC_PREFETCH_CFG_S0                (volatile uint32_t *)0xff00e870
#define P_VPU_MAFBC_PAYLOAD_MIN_LOW_S0             (volatile uint32_t *)0xff00e874
#define P_VPU_MAFBC_PAYLOAD_MIN_HIGH_S0            (volatile uint32_t *)0xff00e878
#define P_VPU_MAFBC_PAYLOAD_MAX_LOW_S0             (volatile uint32_t *)0xff00e87c
#define P_VPU_MAFBC_PAYLOAD_MAX_HIGH_S0            (volatile uint32_t *)0xff00e880
#define P_VPU_MAFBC_HEADER_BUF_ADDR_LOW_S1         (volatile uint32_t *)0xff00e8c0
#define P_VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S1        (volatile uint32_t *)0xff00e8c4
#define P_VPU_MAFBC_FORMAT_SPECIFIER_S1            (volatile uint32_t *)0xff00e8c8
#define P_VPU_MAFBC_BUFFER_WIDTH_S1                (volatile uint32_t *)0xff00e8cc
#define P_VPU_MAFBC_BUFFER_HEIGHT_S1               (volatile uint32_t *)0xff00e8d0
#define P_VPU_MAFBC_BOUNDING_BOX_X_START_S1        (volatile uint32_t *)0xff00e8d4
#define P_VPU_MAFBC_BOUNDING_BOX_X_END_S1          (volatile uint32_t *)0xff00e8d8
#define P_VPU_MAFBC_BOUNDING_BOX_Y_START_S1        (volatile uint32_t *)0xff00e8dc
#define P_VPU_MAFBC_BOUNDING_BOX_Y_END_S1          (volatile uint32_t *)0xff00e8e0
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S1         (volatile uint32_t *)0xff00e8e4
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S1        (volatile uint32_t *)0xff00e8e8
#define P_VPU_MAFBC_OUTPUT_BUF_STRIDE_S1           (volatile uint32_t *)0xff00e8ec
#define P_VPU_MAFBC_PREFETCH_CFG_S1                (volatile uint32_t *)0xff00e8f0
#define P_VPU_MAFBC_PAYLOAD_MIN_LOW_S1             (volatile uint32_t *)0xff00e8f4
#define P_VPU_MAFBC_PAYLOAD_MIN_HIGH_S1            (volatile uint32_t *)0xff00e8f8
#define P_VPU_MAFBC_PAYLOAD_MAX_LOW_S1             (volatile uint32_t *)0xff00e8fc
#define P_VPU_MAFBC_PAYLOAD_MAX_HIGH_S1            (volatile uint32_t *)0xff00e900
#define P_VPU_MAFBC_HEADER_BUF_ADDR_LOW_S2         (volatile uint32_t *)0xff00e940
#define P_VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S2        (volatile uint32_t *)0xff00e944
#define P_VPU_MAFBC_FORMAT_SPECIFIER_S2            (volatile uint32_t *)0xff00e948
#define P_VPU_MAFBC_BUFFER_WIDTH_S2                (volatile uint32_t *)0xff00e94c
#define P_VPU_MAFBC_BUFFER_HEIGHT_S2               (volatile uint32_t *)0xff00e950
#define P_VPU_MAFBC_BOUNDING_BOX_X_START_S2        (volatile uint32_t *)0xff00e954
#define P_VPU_MAFBC_BOUNDING_BOX_X_END_S2          (volatile uint32_t *)0xff00e958
#define P_VPU_MAFBC_BOUNDING_BOX_Y_START_S2        (volatile uint32_t *)0xff00e95c
#define P_VPU_MAFBC_BOUNDING_BOX_Y_END_S2          (volatile uint32_t *)0xff00e960
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S2         (volatile uint32_t *)0xff00e964
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S2        (volatile uint32_t *)0xff00e968
#define P_VPU_MAFBC_OUTPUT_BUF_STRIDE_S2           (volatile uint32_t *)0xff00e96c
#define P_VPU_MAFBC_PREFETCH_CFG_S2                (volatile uint32_t *)0xff00e970
#define P_VPU_MAFBC_PAYLOAD_MIN_LOW_S2             (volatile uint32_t *)0xff00e974
#define P_VPU_MAFBC_PAYLOAD_MIN_HIGH_S2            (volatile uint32_t *)0xff00e978
#define P_VPU_MAFBC_PAYLOAD_MAX_LOW_S2             (volatile uint32_t *)0xff00e97c
#define P_VPU_MAFBC_PAYLOAD_MAX_HIGH_S2            (volatile uint32_t *)0xff00e980
#define P_VPU_MAFBC_HEADER_BUF_ADDR_LOW_S3         (volatile uint32_t *)0xff00e9c0
#define P_VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S3        (volatile uint32_t *)0xff00e9c4
#define P_VPU_MAFBC_FORMAT_SPECIFIER_S3            (volatile uint32_t *)0xff00e9c8
#define P_VPU_MAFBC_BUFFER_WIDTH_S3                (volatile uint32_t *)0xff00e9cc
#define P_VPU_MAFBC_BUFFER_HEIGHT_S3               (volatile uint32_t *)0xff00e9d0
#define P_VPU_MAFBC_BOUNDING_BOX_X_START_S3        (volatile uint32_t *)0xff00e9d4
#define P_VPU_MAFBC_BOUNDING_BOX_X_END_S3          (volatile uint32_t *)0xff00e9d8
#define P_VPU_MAFBC_BOUNDING_BOX_Y_START_S3        (volatile uint32_t *)0xff00e9dc
#define P_VPU_MAFBC_BOUNDING_BOX_Y_END_S3          (volatile uint32_t *)0xff00e9e0
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S3         (volatile uint32_t *)0xff00e9e4
#define P_VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S3        (volatile uint32_t *)0xff00e9e8
#define P_VPU_MAFBC_OUTPUT_BUF_STRIDE_S3           (volatile uint32_t *)0xff00e9ec
#define P_VPU_MAFBC_PREFETCH_CFG_S3                (volatile uint32_t *)0xff00e9f0
#define P_VPU_MAFBC_PAYLOAD_MIN_LOW_S3             (volatile uint32_t *)0xff00e9f4
#define P_VPU_MAFBC_PAYLOAD_MIN_HIGH_S3            (volatile uint32_t *)0xff00e9f8
#define P_VPU_MAFBC_PAYLOAD_MAX_LOW_S3             (volatile uint32_t *)0xff00e9fc
#define P_VPU_MAFBC_PAYLOAD_MAX_HIGH_S3            (volatile uint32_t *)0xff00ea00
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_mali_tx300_afbc_regs.h
//
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD1_VCBUS_BASE = 0x3b
// -----------------------------------------------
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD2_VCBUS_BASE = 0x3c
// -----------------------------------------------
// -----------------------------------------------
// REG_BASE:  VPU_OSDSC_BLD_VCBUS_BASE = 0x3d
// -----------------------------------------------
//
// Reading file:  vpu_osdsc_bld_regs.h
//
// synopsys translate_off
// synopsys translate_on
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define P_OSD2_VSC_PHASE_STEP                      (volatile uint32_t *)0xff00f400
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define P_OSD2_VSC_INI_PHASE                       (volatile uint32_t *)0xff00f404
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define P_OSD2_VSC_CTRL0                           (volatile uint32_t *)0xff00f408
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define P_OSD2_HSC_PHASE_STEP                      (volatile uint32_t *)0xff00f40c
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define P_OSD2_HSC_INI_PHASE                       (volatile uint32_t *)0xff00f410
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define P_OSD2_HSC_CTRL0                           (volatile uint32_t *)0xff00f414
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define P_OSD2_HSC_INI_PAT_CTRL                    (volatile uint32_t *)0xff00f418
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define P_OSD2_SC_DUMMY_DATA                       (volatile uint32_t *)0xff00f41c
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define P_OSD2_SC_CTRL0                            (volatile uint32_t *)0xff00f420
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define P_OSD2_SCI_WH_M1                           (volatile uint32_t *)0xff00f424
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define P_OSD2_SCO_H_START_END                     (volatile uint32_t *)0xff00f428
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define P_OSD2_SCO_V_START_END                     (volatile uint32_t *)0xff00f42c
#define P_OSD2_DB_FLT_CTRL                         (volatile uint32_t *)0xff00f430
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strength of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define P_OSD2_DB_FLT_CTRL1                        (volatile uint32_t *)0xff00f434
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define P_OSD2_DB_FLT_LUMA_THRD                    (volatile uint32_t *)0xff00f438
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define P_OSD2_DB_FLT_CHRM_THRD                    (volatile uint32_t *)0xff00f43c
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define P_OSD2_DB_FLT_RANDLUT                      (volatile uint32_t *)0xff00f440
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define P_OSD2_DB_FLT_PXI_THRD                     (volatile uint32_t *)0xff00f444
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define P_OSD2_DB_FLT_SEED_Y                       (volatile uint32_t *)0xff00f448
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define P_OSD2_DB_FLT_SEED_U                       (volatile uint32_t *)0xff00f44c
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define P_OSD2_DB_FLT_SEED_V                       (volatile uint32_t *)0xff00f450
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD2_DB_FLT_SEED3                        (volatile uint32_t *)0xff00f454
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD2_DB_FLT_SEED4                        (volatile uint32_t *)0xff00f458
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD2_DB_FLT_SEED5                        (volatile uint32_t *)0xff00f45c
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD2_SCALE_COEF_IDX                      (volatile uint32_t *)0xff00f460
//coefficients for vertical filter and horizontal filter
#define P_OSD2_SCALE_COEF                          (volatile uint32_t *)0xff00f464
#define P_OSD34_SCALE_COEF_IDX                     (volatile uint32_t *)0xff00f478
//coefficients for vertical filter and horizontal filter
#define P_OSD34_SCALE_COEF                         (volatile uint32_t *)0xff00f47c
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define P_OSD34_VSC_PHASE_STEP                     (volatile uint32_t *)0xff00f480
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define P_OSD34_VSC_INI_PHASE                      (volatile uint32_t *)0xff00f484
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define P_OSD34_VSC_CTRL0                          (volatile uint32_t *)0xff00f488
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define P_OSD34_HSC_PHASE_STEP                     (volatile uint32_t *)0xff00f48c
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define P_OSD34_HSC_INI_PHASE                      (volatile uint32_t *)0xff00f490
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define P_OSD34_HSC_CTRL0                          (volatile uint32_t *)0xff00f494
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define P_OSD34_HSC_INI_PAT_CTRL                   (volatile uint32_t *)0xff00f498
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define P_OSD34_SC_DUMMY_DATA                      (volatile uint32_t *)0xff00f49c
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define P_OSD34_SC_CTRL0                           (volatile uint32_t *)0xff00f4a0
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define P_OSD34_SCI_WH_M1                          (volatile uint32_t *)0xff00f4a4
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define P_OSD34_SCO_H_START_END                    (volatile uint32_t *)0xff00f4a8
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define P_OSD34_SCO_V_START_END                    (volatile uint32_t *)0xff00f4ac
#define P_OSD34_DB_FLT_CTRL                        (volatile uint32_t *)0xff00f4b0
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strength of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define P_OSD34_DB_FLT_CTRL1                       (volatile uint32_t *)0xff00f4b4
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define P_OSD34_DB_FLT_LUMA_THRD                   (volatile uint32_t *)0xff00f4b8
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define P_OSD34_DB_FLT_CHRM_THRD                   (volatile uint32_t *)0xff00f4bc
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define P_OSD34_DB_FLT_RANDLUT                     (volatile uint32_t *)0xff00f4c0
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define P_OSD34_DB_FLT_PXI_THRD                    (volatile uint32_t *)0xff00f4c4
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define P_OSD34_DB_FLT_SEED_Y                      (volatile uint32_t *)0xff00f4c8
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define P_OSD34_DB_FLT_SEED_U                      (volatile uint32_t *)0xff00f4cc
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define P_OSD34_DB_FLT_SEED_V                      (volatile uint32_t *)0xff00f4d0
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD34_DB_FLT_SEED3                       (volatile uint32_t *)0xff00f4d4
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD34_DB_FLT_SEED4                       (volatile uint32_t *)0xff00f4d8
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_OSD34_DB_FLT_SEED5                       (volatile uint32_t *)0xff00f4dc
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
//Bit 7    reg_mul_alp_en
//Bit 5:4, reg_alp_map_mode
//Bit 2:1, reg_div_gclk_en
//Bit 0,   reg_div_alpha_en
#define P_OSD2_SC_DIV_ALPHA                        (volatile uint32_t *)0xff00f4e0
//Bit 7    reg_mul_alp_en
//Bit 5:4, reg_alp_map_mode
//Bit 2:1, reg_div_gclk_en
//Bit 0,   reg_div_alpha_en
#define P_OSD34_SC_DIV_ALPHA                       (volatile uint32_t *)0xff00f4e4
// for osd3 & osd4 blend
#define P_OSD34_OUT_HSCOPE                         (volatile uint32_t *)0xff00f500
#define P_OSD34_OUT_VSCOPE                         (volatile uint32_t *)0xff00f504
#define P_OSD34_DUMMY_DATA                         (volatile uint32_t *)0xff00f508
#define P_OSD34_BLEND_CTRL0                        (volatile uint32_t *)0xff00f50c
#define P_OSD34_BLEND_CTRL1                        (volatile uint32_t *)0xff00f510
#define P_OSD34_RO_HV_CNT                          (volatile uint32_t *)0xff00f514
#define P_VPP_WRAP_OSD1_MATRIX_COEF00_01           (volatile uint32_t *)0xff00f580
#define P_VPP_WRAP_OSD1_MATRIX_COEF02_10           (volatile uint32_t *)0xff00f584
#define P_VPP_WRAP_OSD1_MATRIX_COEF11_12           (volatile uint32_t *)0xff00f588
#define P_VPP_WRAP_OSD1_MATRIX_COEF20_21           (volatile uint32_t *)0xff00f58c
#define P_VPP_WRAP_OSD1_MATRIX_COEF22              (volatile uint32_t *)0xff00f590
#define P_VPP_WRAP_OSD1_MATRIX_COEF13_14           (volatile uint32_t *)0xff00f594
#define P_VPP_WRAP_OSD1_MATRIX_COEF23_24           (volatile uint32_t *)0xff00f598
#define P_VPP_WRAP_OSD1_MATRIX_COEF15_25           (volatile uint32_t *)0xff00f59c
#define P_VPP_WRAP_OSD1_MATRIX_CLIP                (volatile uint32_t *)0xff00f5a0
#define P_VPP_WRAP_OSD1_MATRIX_OFFSET0_1           (volatile uint32_t *)0xff00f5a4
#define P_VPP_WRAP_OSD1_MATRIX_OFFSET2             (volatile uint32_t *)0xff00f5a8
#define P_VPP_WRAP_OSD1_MATRIX_PRE_OFFSET0_1       (volatile uint32_t *)0xff00f5ac
#define P_VPP_WRAP_OSD1_MATRIX_PRE_OFFSET2         (volatile uint32_t *)0xff00f5b0
#define P_VPP_WRAP_OSD1_MATRIX_EN_CTRL             (volatile uint32_t *)0xff00f5b4
#define P_VPP_WRAP_OSD2_MATRIX_COEF00_01           (volatile uint32_t *)0xff00f5c0
#define P_VPP_WRAP_OSD2_MATRIX_COEF02_10           (volatile uint32_t *)0xff00f5c4
#define P_VPP_WRAP_OSD2_MATRIX_COEF11_12           (volatile uint32_t *)0xff00f5c8
#define P_VPP_WRAP_OSD2_MATRIX_COEF20_21           (volatile uint32_t *)0xff00f5cc
#define P_VPP_WRAP_OSD2_MATRIX_COEF22              (volatile uint32_t *)0xff00f5d0
#define P_VPP_WRAP_OSD2_MATRIX_COEF13_14           (volatile uint32_t *)0xff00f5d4
#define P_VPP_WRAP_OSD2_MATRIX_COEF23_24           (volatile uint32_t *)0xff00f5d8
#define P_VPP_WRAP_OSD2_MATRIX_COEF15_25           (volatile uint32_t *)0xff00f5dc
#define P_VPP_WRAP_OSD2_MATRIX_CLIP                (volatile uint32_t *)0xff00f5e0
#define P_VPP_WRAP_OSD2_MATRIX_OFFSET0_1           (volatile uint32_t *)0xff00f5e4
#define P_VPP_WRAP_OSD2_MATRIX_OFFSET2             (volatile uint32_t *)0xff00f5e8
#define P_VPP_WRAP_OSD2_MATRIX_PRE_OFFSET0_1       (volatile uint32_t *)0xff00f5ec
#define P_VPP_WRAP_OSD2_MATRIX_PRE_OFFSET2         (volatile uint32_t *)0xff00f5f0
#define P_VPP_WRAP_OSD2_MATRIX_EN_CTRL             (volatile uint32_t *)0xff00f5f4
#define P_VIU_OSD3_CTRL_STAT                       (volatile uint32_t *)0xff00f600
#define P_VIU_OSD3_CTRL_STAT2                      (volatile uint32_t *)0xff00f604
#define P_VIU_OSD3_COLOR_ADDR                      (volatile uint32_t *)0xff00f608
#define P_VIU_OSD3_COLOR                           (volatile uint32_t *)0xff00f60c
#define P_VIU_OSD3_TCOLOR_AG0                      (volatile uint32_t *)0xff00f610
#define P_VIU_OSD3_TCOLOR_AG1                      (volatile uint32_t *)0xff00f614
#define P_VIU_OSD3_TCOLOR_AG2                      (volatile uint32_t *)0xff00f618
#define P_VIU_OSD3_TCOLOR_AG3                      (volatile uint32_t *)0xff00f61c
#define P_VIU_OSD3_BLK0_CFG_W0                     (volatile uint32_t *)0xff00f620
#define P_VIU_OSD3_BLK1_CFG_W0                     (volatile uint32_t *)0xff00f624
#define P_VIU_OSD3_BLK2_CFG_W0                     (volatile uint32_t *)0xff00f628
#define P_VIU_OSD3_BLK3_CFG_W0                     (volatile uint32_t *)0xff00f62c
#define P_VIU_OSD3_BLK0_CFG_W1                     (volatile uint32_t *)0xff00f630
#define P_VIU_OSD3_BLK1_CFG_W1                     (volatile uint32_t *)0xff00f634
#define P_VIU_OSD3_BLK2_CFG_W1                     (volatile uint32_t *)0xff00f638
#define P_VIU_OSD3_BLK3_CFG_W1                     (volatile uint32_t *)0xff00f63c
#define P_VIU_OSD3_BLK0_CFG_W2                     (volatile uint32_t *)0xff00f640
#define P_VIU_OSD3_BLK1_CFG_W2                     (volatile uint32_t *)0xff00f644
#define P_VIU_OSD3_BLK2_CFG_W2                     (volatile uint32_t *)0xff00f648
#define P_VIU_OSD3_BLK3_CFG_W2                     (volatile uint32_t *)0xff00f64c
#define P_VIU_OSD3_BLK0_CFG_W3                     (volatile uint32_t *)0xff00f650
#define P_VIU_OSD3_BLK1_CFG_W3                     (volatile uint32_t *)0xff00f654
#define P_VIU_OSD3_BLK2_CFG_W3                     (volatile uint32_t *)0xff00f658
#define P_VIU_OSD3_BLK3_CFG_W3                     (volatile uint32_t *)0xff00f65c
#define P_VIU_OSD3_BLK0_CFG_W4                     (volatile uint32_t *)0xff00f660
#define P_VIU_OSD3_BLK1_CFG_W4                     (volatile uint32_t *)0xff00f664
#define P_VIU_OSD3_BLK2_CFG_W4                     (volatile uint32_t *)0xff00f668
#define P_VIU_OSD3_BLK3_CFG_W4                     (volatile uint32_t *)0xff00f66c
#define P_VIU_OSD3_FIFO_CTRL_STAT                  (volatile uint32_t *)0xff00f670
#define P_VIU_OSD3_TEST_RDDATA                     (volatile uint32_t *)0xff00f674
#define P_VIU_OSD3_PROT_CTRL                       (volatile uint32_t *)0xff00f678
#define P_VIU_OSD3_MALI_UNPACK_CTRL                (volatile uint32_t *)0xff00f67c
#define P_VIU_OSD3_DIMM_CTRL                       (volatile uint32_t *)0xff00f680
#define P_VIU_OSD3_NORMAL_SWAP                     (volatile uint32_t *)0xff00f684
#define P_VIU_OSD3_MATRIX_COEF00_01                (volatile uint32_t *)0xff00f6c0
#define P_VIU_OSD3_MATRIX_COEF02_10                (volatile uint32_t *)0xff00f6c4
#define P_VIU_OSD3_MATRIX_COEF11_12                (volatile uint32_t *)0xff00f6c8
#define P_VIU_OSD3_MATRIX_COEF20_21                (volatile uint32_t *)0xff00f6cc
#define P_VIU_OSD3_MATRIX_COEF22                   (volatile uint32_t *)0xff00f6d0
#define P_VIU_OSD3_MATRIX_COEF13_14                (volatile uint32_t *)0xff00f6d4
#define P_VIU_OSD3_MATRIX_COEF23_24                (volatile uint32_t *)0xff00f6d8
#define P_VIU_OSD3_MATRIX_COEF15_25                (volatile uint32_t *)0xff00f6dc
#define P_VIU_OSD3_MATRIX_CLIP                     (volatile uint32_t *)0xff00f6e0
#define P_VIU_OSD3_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff00f6e4
#define P_VIU_OSD3_MATRIX_OFFSET2                  (volatile uint32_t *)0xff00f6e8
#define P_VIU_OSD3_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff00f6ec
#define P_VIU_OSD3_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff00f6f0
#define P_VIU_OSD3_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff00f6f4
#define P_VIU_OSD4_CTRL_STAT                       (volatile uint32_t *)0xff00f700
#define P_VIU_OSD4_CTRL_STAT2                      (volatile uint32_t *)0xff00f704
#define P_VIU_OSD4_COLOR_ADDR                      (volatile uint32_t *)0xff00f708
#define P_VIU_OSD4_COLOR                           (volatile uint32_t *)0xff00f70c
#define P_VIU_OSD4_TCOLOR_AG0                      (volatile uint32_t *)0xff00f710
#define P_VIU_OSD4_TCOLOR_AG1                      (volatile uint32_t *)0xff00f714
#define P_VIU_OSD4_TCOLOR_AG2                      (volatile uint32_t *)0xff00f718
#define P_VIU_OSD4_TCOLOR_AG3                      (volatile uint32_t *)0xff00f71c
#define P_VIU_OSD4_BLK0_CFG_W0                     (volatile uint32_t *)0xff00f720
#define P_VIU_OSD4_BLK1_CFG_W0                     (volatile uint32_t *)0xff00f724
#define P_VIU_OSD4_BLK2_CFG_W0                     (volatile uint32_t *)0xff00f728
#define P_VIU_OSD4_BLK3_CFG_W0                     (volatile uint32_t *)0xff00f72c
#define P_VIU_OSD4_BLK0_CFG_W1                     (volatile uint32_t *)0xff00f730
#define P_VIU_OSD4_BLK1_CFG_W1                     (volatile uint32_t *)0xff00f734
#define P_VIU_OSD4_BLK2_CFG_W1                     (volatile uint32_t *)0xff00f738
#define P_VIU_OSD4_BLK3_CFG_W1                     (volatile uint32_t *)0xff00f73c
#define P_VIU_OSD4_BLK0_CFG_W2                     (volatile uint32_t *)0xff00f740
#define P_VIU_OSD4_BLK1_CFG_W2                     (volatile uint32_t *)0xff00f744
#define P_VIU_OSD4_BLK2_CFG_W2                     (volatile uint32_t *)0xff00f748
#define P_VIU_OSD4_BLK3_CFG_W2                     (volatile uint32_t *)0xff00f74c
#define P_VIU_OSD4_BLK0_CFG_W3                     (volatile uint32_t *)0xff00f750
#define P_VIU_OSD4_BLK1_CFG_W3                     (volatile uint32_t *)0xff00f754
#define P_VIU_OSD4_BLK2_CFG_W3                     (volatile uint32_t *)0xff00f758
#define P_VIU_OSD4_BLK3_CFG_W3                     (volatile uint32_t *)0xff00f75c
#define P_VIU_OSD4_BLK0_CFG_W4                     (volatile uint32_t *)0xff00f760
#define P_VIU_OSD4_BLK1_CFG_W4                     (volatile uint32_t *)0xff00f764
#define P_VIU_OSD4_BLK2_CFG_W4                     (volatile uint32_t *)0xff00f768
#define P_VIU_OSD4_BLK3_CFG_W4                     (volatile uint32_t *)0xff00f76c
#define P_VIU_OSD4_FIFO_CTRL_STAT                  (volatile uint32_t *)0xff00f770
#define P_VIU_OSD4_TEST_RDDATA                     (volatile uint32_t *)0xff00f774
#define P_VIU_OSD4_PROT_CTRL                       (volatile uint32_t *)0xff00f778
#define P_VIU_OSD4_MALI_UNPACK_CTRL                (volatile uint32_t *)0xff00f77c
#define P_VIU_OSD4_DIMM_CTRL                       (volatile uint32_t *)0xff00f780
#define P_VIU_OSD4_NORMAL_SWAP                     (volatile uint32_t *)0xff00f784
#define P_VIU_OSD4_MATRIX_COEF00_01                (volatile uint32_t *)0xff00f7c0
#define P_VIU_OSD4_MATRIX_COEF02_10                (volatile uint32_t *)0xff00f7c4
#define P_VIU_OSD4_MATRIX_COEF11_12                (volatile uint32_t *)0xff00f7c8
#define P_VIU_OSD4_MATRIX_COEF20_21                (volatile uint32_t *)0xff00f7cc
#define P_VIU_OSD4_MATRIX_COEF22                   (volatile uint32_t *)0xff00f7d0
#define P_VIU_OSD4_MATRIX_COEF13_14                (volatile uint32_t *)0xff00f7d4
#define P_VIU_OSD4_MATRIX_COEF23_24                (volatile uint32_t *)0xff00f7d8
#define P_VIU_OSD4_MATRIX_COEF15_25                (volatile uint32_t *)0xff00f7dc
#define P_VIU_OSD4_MATRIX_CLIP                     (volatile uint32_t *)0xff00f7e0
#define P_VIU_OSD4_MATRIX_OFFSET0_1                (volatile uint32_t *)0xff00f7e4
#define P_VIU_OSD4_MATRIX_OFFSET2                  (volatile uint32_t *)0xff00f7e8
#define P_VIU_OSD4_MATRIX_PRE_OFFSET0_1            (volatile uint32_t *)0xff00f7ec
#define P_VIU_OSD4_MATRIX_PRE_OFFSET2              (volatile uint32_t *)0xff00f7f0
#define P_VIU_OSD4_MATRIX_EN_CTRL                  (volatile uint32_t *)0xff00f7f4
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpu_osdsc_bld_regs.h
//
// -----------------------------------------------
// REG_BASE:  VPPF_VCBUS_BASE = 0x40
// -----------------------------------------------
//
// Reading file:  lc_stts_curve.h
//
#define P_LC_CURVE_CTRL                            (volatile uint32_t *)0xff010000
    //Bit 31  :12     reg_lc_misc                        U     RW        default = 'h0     None
    //Bit 11  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :8      reg_lc_hist_curve_nodes_hlpf       U     RW        default = 'h1      horizontal lpf of the ram_curve_nodes, 0: no LPF, 1= [1 2 1]; 2: [1 2 2 2 1]/8
    //Bit 7   :6      reserved                           U     RW        default = 'h0     None
    //Bit 5   :4      reg_lc_hist_curve_nodes_vlpf       U     RW        default = 'h1      vertical lpf of the ram_curve_nodes, 0: no LPF, 1= [1 2 1]; 2: [1 2 2 2 1]/8
    //Bit 3   :2      reserved                           U     RW        default = 'h0     None
    //Bit 1           reg_lc_blackbar_mute_en            U     RW        default = 'h1     mute the black bar corresponding bin, 0: no mute, 1: mute enable; default=1
    //Bit 0           reg_lc_curve_en                    U     RW        default = 'h1      default=0
#define P_LC_CURVE_HV_NUM                          (volatile uint32_t *)0xff010004
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :8      reg_lc_cur_blk_hnum                U     RW        default = 'hc      lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8), should be same as reg_lc_blk_hnum
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4   :0      reg_lc_cur_blk_vnum                U     RW        default = 'h8      lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12), should be same as reg_lc_blk_vnum
#define P_LC_CURVE_LMT_RAT                         (volatile uint32_t *)0xff010008
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lmtrat_minmax                  U     RW        default = 'h6     x/1024 of amount
    //Bit 7   :0      reg_lmtrat_valid                   U     RW        default = 'h14     x/1024 of amount
#define P_LC_CURVE_CONTRAST_LH                     (volatile uint32_t *)0xff01000c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_contrast_low                U     RW        default = 'h10     contrast gain to the lc for dark side, normalized 256 as "1", set adaptive TODO
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_contrast_hig                U     RW        default = 'h18     contrast gain to the lc for bright side, normalized 256 as "1"
#define P_LC_CURVE_CONTRAST__LMT_LH                (volatile uint32_t *)0xff010010
    //Bit 31  :24     reg_lc_cntstlmt_low_0              U     RW        default = 'ha     limit for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 23  :16     reg_lc_cntstlmt_hig_0              U     RW        default = 'h14     limit for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
    //Bit 15  :8      reg_lc_cntstlmt_low_1              U     RW        default = 'hff     limit for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 7   :0      reg_lc_cntstlmt_hig_1              U     RW        default = 'hff     limit for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define P_LC_CURVE_CONTRAST_SCL_LH                 (volatile uint32_t *)0xff010014
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_cntstscl_low                U     RW        default = 'h40     scale for the contrast low, norm 8 as 1; delta_low = MIN(delta_low, MIN(MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 7   :0      reg_lc_cntstscl_hig                U     RW        default = 'h20     scale for the contrast high,norm 8 as 1; delta_hig = MIN(delta_hig, MIN(MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define P_LC_CURVE_CONTRAST_BVN_LH                 (volatile uint32_t *)0xff010018
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_cntstbvn_low                U     RW        default = 'h20     scale to num_m as limit of min_val to minBV distance, to protect mono-color, default = 32; min_val= MAX(min_val, minBV- MAX(num_m-1,0)*bvn_low)
    //Bit 7   :0      reg_lc_cntstbvn_hig                U     RW        default = 'h20     scale to num_m as limit of max_val to maxBV distance, to protect mono-color, default = 32; min_val= MIN(max_val, maxBV+ MAX(num_m-1,0)*bvn_lo
#define P_LC_CURVE_MISC0                           (volatile uint32_t *)0xff01001c
    //Bit 31  :20     reserved                           U     RW        default = 'h0     None
    //Bit 19  :16     reg_lc_num_m_coring                U     RW        default = 'h1     coring to num_m, soft coring,default = 2;
    //Bit 15  :8      reg_lc_vbin_min                    U     RW        default = 'h30     4x is min width of valid histogram bin num,
    //Bit 7   :0      reg_lc_slope_max_face              U     RW        default = 'h38      maximum slope for the pkBin-maxBV range curve to do face protection, normalized to 32 as 1, default= 48
#define P_LC_CURVE_YPKBV_RAT                       (volatile uint32_t *)0xff010020
    //Bit 31  :24     reg_lc_ypkbv_ratio_0               U     RW        default = 'h8c      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 23  :16     reg_lc_ypkbv_ratio_1               U     RW        default = 'ha0      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 15  :8      reg_lc_ypkbv_ratio_2               U     RW        default = 'h78      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 7   :0      reg_lc_ypkbv_ratio_3               U     RW        default = 'h60      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
#define P_LC_CURVE_YPKBV_SLP_LMT                   (volatile uint32_t *)0xff010024
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_ypkbv_slope_lmt_0           U     RW        default = 'hc      min max slop for the curves to avoid artifacts, [0] for min_slope, [1] for max_slop, e.g.max_slope= limit*(pkBv-minBv)+min_val as high bound of the ypkBV; normalized to 32 as 1
    //Bit 7   :0      reg_lc_ypkbv_slope_lmt_1           U     RW        default = 'h60     None
#define P_LC_CURVE_YMINVAL_LMT_0_1                 (volatile uint32_t *)0xff010028
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_0               U     RW        default = 'h30      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_1               U     RW        default = 'h50      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_2_3                 (volatile uint32_t *)0xff01002c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_2               U     RW        default = 'h78      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_3               U     RW        default = 'h80      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_4_5                 (volatile uint32_t *)0xff010030
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_4               U     RW        default = 'ha0      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_5               U     RW        default = 'hc4      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_6_7                 (volatile uint32_t *)0xff010034
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_6               U     RW        default = 'he0      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_7               U     RW        default = 'h100      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_8_9                 (volatile uint32_t *)0xff010038
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_8               U     RW        default = 'h120      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_9               U     RW        default = 'h140      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_10_11               (volatile uint32_t *)0xff01003c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_10              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_11              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMAXVAL_LMT_0_1                 (volatile uint32_t *)0xff010040
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_0         U     RW        default = 'h78      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_1         U     RW        default = 'h96      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_2_3                 (volatile uint32_t *)0xff010044
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_2         U     RW        default = 'he6      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_3         U     RW        default = 'h112      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_4_5                 (volatile uint32_t *)0xff010048
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_4         U     RW        default = 'h14a      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_5         U     RW        default = 'h180      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_6_7                 (volatile uint32_t *)0xff01004c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_6         U     RW        default = 'h1d4      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_7         U     RW        default = 'h200      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_8_9                 (volatile uint32_t *)0xff010050
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_8         U     RW        default = 'h240      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_9         U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_10_11               (volatile uint32_t *)0xff010054
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_10        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_11        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_HISTVLD_THRD                    (volatile uint32_t *)0xff010058
    //Bit 31  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_histvld_thrd                U     RW        default = 'h1fa      threshold to compare to bin to get number of valid bins
#define P_LC_CURVE_BB_MUTE_THRD                    (volatile uint32_t *)0xff01005c
    //Bit 31  :24     reserved                           U     RW        default = 'h0     None
    //Bit 23  :0      reg_lc_blackbar_mute_thrd          U     RW        default = 'h2a30      1/8 of the region
#define P_LC_CURVE_INT_STATUS                      (volatile uint32_t *)0xff010060
#define P_LC_CURVE_RAM_CTRL                        (volatile uint32_t *)0xff010080
#define P_LC_CURVE_RAM_ADDR                        (volatile uint32_t *)0xff010084
#define P_LC_CURVE_RAM_DATA                        (volatile uint32_t *)0xff010088
#define P_LC_CURVE_YMINVAL_LMT_12_13               (volatile uint32_t *)0xff010100
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_12              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_13              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMINVAL_LMT_14_15               (volatile uint32_t *)0xff010104
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_14              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_15              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define P_LC_CURVE_YMAXVAL_LMT_12_13               (volatile uint32_t *)0xff010108
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_12        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_13        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define P_LC_CURVE_YMAXVAL_LMT_14_15               (volatile uint32_t *)0xff01010c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_14        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_15        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
//u10, lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV])
#define P_LC_CURVE_YPKBV_LMT_0_1                   (volatile uint32_t *)0xff010110
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_0         U     RW        default = 'h78      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_1         U     RW        default = 'h96      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_2_3                   (volatile uint32_t *)0xff010114
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_2         U     RW        default = 'he6      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_3         U     RW        default = 'h112      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_4_5                   (volatile uint32_t *)0xff010118
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_4         U     RW        default = 'h14a      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_5         U     RW        default = 'h180      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_6_7                   (volatile uint32_t *)0xff01011c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_6         U     RW        default = 'h1d4      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_7         U     RW        default = 'h200      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_8_9                   (volatile uint32_t *)0xff010120
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_8         U     RW        default = 'h240      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_9         U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_10_11                 (volatile uint32_t *)0xff010124
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_10        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_11        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_12_13                 (volatile uint32_t *)0xff010128
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_12        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_13        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define P_LC_CURVE_YPKBV_LMT_14_15                 (volatile uint32_t *)0xff01012c
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_14        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_15        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
//-------------------------------------------------------------
#define P_LC_STTS_GCLK_CTRL0                       (volatile uint32_t *)0xff0100a0
#define P_LC_STTS_CTRL0                            (volatile uint32_t *)0xff0100a4
#define P_LC_STTS_WIDTHM1_HEIGHTM1                 (volatile uint32_t *)0xff0100a8
#define P_LC_STTS_MATRIX_COEF00_01                 (volatile uint32_t *)0xff0100ac
#define P_LC_STTS_MATRIX_COEF02_10                 (volatile uint32_t *)0xff0100b0
#define P_LC_STTS_MATRIX_COEF11_12                 (volatile uint32_t *)0xff0100b4
#define P_LC_STTS_MATRIX_COEF20_21                 (volatile uint32_t *)0xff0100b8
#define P_LC_STTS_MATRIX_COEF22                    (volatile uint32_t *)0xff0100bc
#define P_LC_STTS_MATRIX_OFFSET0_1                 (volatile uint32_t *)0xff0100c0
#define P_LC_STTS_MATRIX_OFFSET2                   (volatile uint32_t *)0xff0100c4
#define P_LC_STTS_MATRIX_PRE_OFFSET0_1             (volatile uint32_t *)0xff0100c8
#define P_LC_STTS_MATRIX_PRE_OFFSET2               (volatile uint32_t *)0xff0100cc
#define P_LC_STTS_MATRIX_HL_COLOR                  (volatile uint32_t *)0xff0100d0
#define P_LC_STTS_MATRIX_PROBE_POS                 (volatile uint32_t *)0xff0100d4
#define P_LC_STTS_MATRIX_PROBE_COLOR               (volatile uint32_t *)0xff0100d8
#define P_LC_STTS_HIST_REGION_IDX                  (volatile uint32_t *)0xff0100dc
#define P_LC_STTS_HIST_SET_REGION                  (volatile uint32_t *)0xff0100e0
#define P_LC_STTS_HIST_READ_REGION                 (volatile uint32_t *)0xff0100e4
#define P_LC_STTS_HIST_START_RD_REGION             (volatile uint32_t *)0xff0100e8
#define P_LC_STTS_WHITE_INFO                       (volatile uint32_t *)0xff0100ec
#define P_LC_STTS_BLACK_INFO                       (volatile uint32_t *)0xff0100f0
//
// Closing file:  lc_stts_curve.h
//
// -----------------------------------------------
// REG_BASE:  VDIN_AFBCE_VCBUS_BASE = 0x41
// -----------------------------------------------
//
// Reading file:  vdin_afbce_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
#define P_VDIN2_WR_CTRL                            (volatile uint32_t *)0xff010404
#define P_VDIN2_WR_CTRL2                           (volatile uint32_t *)0xff010408
#define P_VDIN2_WR_H_START_END                     (volatile uint32_t *)0xff01040c
#define P_VDIN2_WR_V_START_END                     (volatile uint32_t *)0xff010410
#define P_VDIN2_DBG_AXI_CMD_CNT                    (volatile uint32_t *)0xff010414
#define P_VDIN2_DBG_AXI_DAT_CNT                    (volatile uint32_t *)0xff010418
#define P_VDIN2_WR_URGENT_CTRL                     (volatile uint32_t *)0xff01041c
#define P_VDIN2_RO_WRMIF_STATUS                    (volatile uint32_t *)0xff010420
#define P_VDIN2_WR_BADDR_LUMA                      (volatile uint32_t *)0xff010440
#define P_VDIN2_WR_BADDR_CHROMA                    (volatile uint32_t *)0xff010444
#define P_VDIN2_WR_STRIDE_LUMA                     (volatile uint32_t *)0xff010448
#define P_VDIN2_WR_STRIDE_CHROMA                   (volatile uint32_t *)0xff01044c
#define P_VDIN_TOP_SECURE0_ST_RO                   (volatile uint32_t *)0xff010424
#define P_VDIN_TOP_SECURE_DUMMY                    (volatile uint32_t *)0xff010428
#define P_VDIN_TOP_DOUBLE_CTRL                     (volatile uint32_t *)0xff01042c
#define P_VDIN_TOP_SECURE1_ST_RO                   (volatile uint32_t *)0xff010430
#define P_VDIN_TOP_MISC                            (volatile uint32_t *)0xff010434
#define P_VDIN_TOP_SECURE_REG0                     (volatile uint32_t *)0xff010438
#define P_VDIN_TOP_SECURE_REG1                     (volatile uint32_t *)0xff01043c
// 8'ha0 ~ 8'hc6
//
// Reading file:  vdin_afbc_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_AFBCE_ENABLE                             (volatile uint32_t *)0xff010680
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    afbce_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define P_AFBCE_MODE                               (volatile uint32_t *)0xff010684
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved         unsigned, default = 0 , enable singal of crop
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define P_AFBCE_SIZE_IN                            (volatile uint32_t *)0xff010688
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vertical size in  unit: pixel
#define P_AFBCE_BLK_SIZE_IN                        (volatile uint32_t *)0xff01068c
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horizontal size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vertical size in  unit: pixel
#define P_AFBCE_HEAD_BADDR                         (volatile uint32_t *)0xff010690
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define P_AFBCE_MIF_SIZE                           (volatile uint32_t *)0xff010694
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define P_AFBCE_PIXEL_IN_HOR_SCOPE                 (volatile uint32_t *)0xff010698
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define P_AFBCE_PIXEL_IN_VER_SCOPE                 (volatile uint32_t *)0xff01069c
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define P_AFBCE_CONV_CTRL                          (volatile uint32_t *)0xff0106a0
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define P_AFBCE_MIF_HOR_SCOPE                      (volatile uint32_t *)0xff0106a4
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define P_AFBCE_MIF_VER_SCOPE                      (volatile uint32_t *)0xff0106a8
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define P_AFBCE_STAT1                              (volatile uint32_t *)0xff0106ac
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define P_AFBCE_STAT2                              (volatile uint32_t *)0xff0106b0
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define P_AFBCE_FORMAT                             (volatile uint32_t *)0xff0106b4
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define P_AFBCE_MODE_EN                            (volatile uint32_t *)0xff0106b8
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: disable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define P_AFBCE_DWSCALAR                           (volatile uint32_t *)0xff0106bc
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define P_AFBCE_DEFCOLOR_1                         (volatile uint32_t *)0xff0106c0
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define P_AFBCE_DEFCOLOR_2                         (volatile uint32_t *)0xff0106c4
//Bit 31:24        reserved
//Bit 23:12        reg_enc_defaultcolor_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_defaultcolor_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define P_AFBCE_QUANT_ENABLE                       (volatile uint32_t *)0xff0106c8
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_AFBCE_IQUANT_LUT_1                       (volatile uint32_t *)0xff0106cc
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCE_IQUANT_LUT_2                       (volatile uint32_t *)0xff0106d0
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCE_IQUANT_LUT_3                       (volatile uint32_t *)0xff0106d4
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCE_IQUANT_LUT_4                       (volatile uint32_t *)0xff0106d8
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCE_RQUANT_LUT_1                       (volatile uint32_t *)0xff0106dc
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define P_AFBCE_RQUANT_LUT_2                       (volatile uint32_t *)0xff0106e0
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define P_AFBCE_RQUANT_LUT_3                       (volatile uint32_t *)0xff0106e4
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define P_AFBCE_RQUANT_LUT_4                       (volatile uint32_t *)0xff0106e8
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define P_AFBCE_YUV_FORMAT_CONV_MODE               (volatile uint32_t *)0xff0106ec
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define P_AFBCE_DUMMY_DATA                         (volatile uint32_t *)0xff0106f0
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define P_AFBCE_CLR_FLAG                           (volatile uint32_t *)0xff0106f4
//Bit 31:0         reg_afbce_clr_flag           // unsigned, default = 0  ;
#define P_AFBCE_STA_FLAGT                          (volatile uint32_t *)0xff0106f8
//Bit 31:0         ro_afbce_sta_flag        // unsigned, RO,default = 0  ;
#define P_AFBCE_MMU_NUM                            (volatile uint32_t *)0xff0106fc
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define P_AFBCE_MMU_RMIF_CTRL1                     (volatile uint32_t *)0xff010700
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define P_AFBCE_MMU_RMIF_CTRL2                     (volatile uint32_t *)0xff010704
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define P_AFBCE_MMU_RMIF_CTRL3                     (volatile uint32_t *)0xff010708
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define P_AFBCE_MMU_RMIF_CTRL4                     (volatile uint32_t *)0xff01070c
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define P_AFBCE_MMU_RMIF_SCOPE_X                   (volatile uint32_t *)0xff010710
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define P_AFBCE_MMU_RMIF_SCOPE_Y                   (volatile uint32_t *)0xff010714
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define P_AFBCE_MMU_RMIF_RO_STAT                   (volatile uint32_t *)0xff010718
//Bit 15:0  reg_status        // unsigned ,
#define P_AFBCE_PIP_CTRL                           (volatile uint32_t *)0xff010728
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define P_AFBCE_ROT_CTRL                           (volatile uint32_t *)0xff01072c
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define P_AFBCE_DIMM_CTRL                          (volatile uint32_t *)0xff010730
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define P_AFBCE_BND_DEC_MISC                       (volatile uint32_t *)0xff010734
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define P_AFBCE_RD_ARB_MISC                        (volatile uint32_t *)0xff010738
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vdin_afbc_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vdin_afbce_regs.h
//
// -----------------------------------------------
// REG_BASE:  LCD2_VCBUS_BASE = 0x42
// -----------------------------------------------
//`include "a.h"
// -----------------------------------------------
// REG_BASE:  DOLBYTV_VCBUS_BASE = 0x43
// -----------------------------------------------
//
// Reading file:  dolby_tv_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_TV_REG_START                       (volatile uint32_t *)0xff010c00
// dolby register address 0~0xDA
#define P_DOLBY_TV_CLKGATE_CTRL                    (volatile uint32_t *)0xff010fc4
//bit[9:8]  R-RW 0~3 0  dma2axi_clkgate_ctrl         : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[7:6]  R-RW 0~3 0  bl_dolby_swaps_clkgate_ctrl  : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[5:4]  R-RW 0~3 0  el_swaps_clkgate_ctrl        : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[3:2]  R-RW 0~3 0  el_buf_clkgate_ctrl          : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[1:0]  R-RW 0~3 0  top_level_reg_clkgate_ctrl   : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
#define P_DOLBY_TV_SWAP_CTRL0                      (volatile uint32_t *)0xff010fc8
//bit[2]  R-RW 0~1  0   el_41mode      : 1 "bl resolution : el resolution = 4:1", 0 "bl_res : el_res = 1:1"
//bit[1]  R-RW 0~1  0   el_enable      : 1 "enhancement layer is supported", 0 "el is not supported"
//bit[0]  R-RW 0~1  0   source_enable  : 1 "base layer is supported", 0 "bl is not supported"
#define P_DOLBY_TV_SWAP_CTRL1                      (volatile uint32_t *)0xff010fcc
//bit[28:16]  R-RW  0~8191 0  htotal  : total pixels number in each line
//bit[21:0]   R-RW  0~8191 0  vtotal  : total line number in each frame (only support progress frame)
#define P_DOLBY_TV_SWAP_CTRL2                      (volatile uint32_t *)0xff010fd0
//bit[28:16]  R-RW  0~4096 0 hsize  : active pixels number in each line
//bit[21:0]   R-RW  0~3840 0 vsize  : active lines number in each frame
#define P_DOLBY_TV_SWAP_CTRL3                      (volatile uint32_t *)0xff010fd4
//bit[28:16]  R-RW  0~8191 0  hsync_width  : hsync signal width (high effective)
//bit[21:0]   R-RW  0~8191 0  vsync_width  : vysnc singal width (high effective)
#define P_DOLBY_TV_SWAP_CTRL4                      (volatile uint32_t *)0xff010fd8
//bit[28:16]  R-RW  0~8191 0  hsync_backporch  : pixels number between hsync and h_active_duration
//bit[21:0]   R-RW  0~8191 0  vsync_backporch  : lines number between vsync and v_active_duration
#define P_DOLBY_TV_SWAP_CTRL5                      (volatile uint32_t *)0xff010fdc
//[25:8]      R-RW                           :   reg_tunnel_sel for tunnel bit match swap
//bit[4]      R-RW  0~1  0   bl_tunnel_mode  :   1 "hdmi input, source is 12bit422 tunnel in 8bit444", 0 "opt mode, 10 bit 444"
//bit[3:2]    R-RW  0~3  0   bl_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
//bit[1:0]    R-RW  0~3  0   el_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
#define P_DOLBY_TV_SWAP_CTRL6                      (volatile uint32_t *)0xff010fe0
//bit[31]     R-RW  0~1      dm_uv_input     :   uv select
//bit[23:16]  R-RW  0~1  0   dump_ctrl       :   1 "fixed output bitdepth as 12bit", 0 "output bitdepth based on vdr_bit_depth"
//bit[15]     R-RW  0~1      datapath_reset_n_enable : manual reset control
//bit[14]     R-RW  0~1      handshake_reset_n_enable : manual reset control
//bit[13]     R-RW  0~1      axi_reset_n_enable : manual reset control
//bit[5:2]    R-RW  0~15     vdr_bit_depth
//bit[1:0]    R-RW  0~3      reg_hdmi_mode
#define P_DOLBY_TV_SWAP_CTRL7                      (volatile uint32_t *)0xff010fe4
//reserved
#define P_DOLBY_TV_AXI2DMA_CTRL0                   (volatile uint32_t *)0xff010fe8
//bit[31]        R-RW   0~1  0    reg_req_en         :  enable req after line count
//bit[30]        R-RW   0~1  0    reg_id_check       :  check the id of data path and req path
//bit[29]        R-RW   0~1  0    reg_clear_fifo     :  manually reset bit
//bit[28]        R-RW   0~1  0    reg_vsync_rst      :  soft_rst auto reset enable
//bit[27]        R-RW   0~1  0    reg_update_addr    :  manually update start addr
//bit[26]        R-RW   0~1  0    reg_addr_auto      :  auto update start addr enable
//bit[25]        R-RW   0~1  0    reg_keep_receive   :  data path keep receive
//bit[24:19]     R-RW   0~63 0    reg_req_th         :  fifo_room > req_th, then send the request
//bit[18:16]     R-RW   0~7  0    reg_arsize         :  axi arsize
//bit[14:12]     R-RW   0~7  0    reg_arprot         :  axi arprot
//bit[11:8]      R-RW   0~15 0    reg_aruser         :  axi aruser
//bit[5:4]       R-RW   0~3  0    reg_arid           :  axi arid
//bit[3:0]       R-RW   0~2  0    reg_lens           :  default request lens, each burst has "reg_lens+1" data
#define P_DOLBY_TV_AXI2DMA_CTRL1                   (volatile uint32_t *)0xff010fec
//bit[31]        R-RW   0~1     0 axi_addr_mode   :  1 "canvas mode", 0 "normal mode"
//bit[27:16]     R-RW   0~4095  0 dma_size0       :  total data number in dma0
//bit[11:0]      R-RW   0~4095  0 dma_size1       :  total data number in dma1
#define P_DOLBY_TV_AXI2DMA_CTRL2                   (volatile uint32_t *)0xff010ff0
//bit[31:0]      R-RW   0~4294967295  0 axi_start_addr : axi start address
#define P_DOLBY_TV_AXI2DMA_CTRL3                   (volatile uint32_t *)0xff010ff4
//bit[11:0]      R-RW   0~4095        0  hold_line     :  after hold_line the axi slave start requesting
#define P_DOLBY_TV_STATUS0                         (volatile uint32_t *)0xff010ff8
#define P_DOLBY_TV_STATUS1                         (volatile uint32_t *)0xff010ffc
#define P_DOLBY_TV_ADAPTIVE_SCALE_REGADDR          (volatile uint32_t *)0xff010f80
#define P_DOLBY_TV_ADAPTIVE_SCALE_REGDATA          (volatile uint32_t *)0xff010f84
#define P_DOLBY_TV_ADAPTIVE_SCALE_LUTADDR          (volatile uint32_t *)0xff010f88
#define P_DOLBY_TV_ADAPTIVE_SCALE_LUTDATA          (volatile uint32_t *)0xff010f8c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dolby_tv_regs.h
//
// -----------------------------------------------
// REG_BASE:  DOLBY1B_VCBUS_BASE = 0x44
// -----------------------------------------------
//
// Reading file:  dolby1b_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define P_DOLBY_CORE1B_REG_START                   (volatile uint32_t *)0xff011000
#define P_DOLBY_CORE1B_CLKGATE_CTRL                (volatile uint32_t *)0xff0113c8
#define P_DOLBY_CORE1B_SWAP_CTRL0                  (volatile uint32_t *)0xff0113cc
#define P_DOLBY_CORE1B_SWAP_CTRL1                  (volatile uint32_t *)0xff0113d0
#define P_DOLBY_CORE1B_SWAP_CTRL2                  (volatile uint32_t *)0xff0113d4
#define P_DOLBY_CORE1B_SWAP_CTRL3                  (volatile uint32_t *)0xff0113d8
#define P_DOLBY_CORE1B_SWAP_CTRL4                  (volatile uint32_t *)0xff0113dc
#define P_DOLBY_CORE1B_SWAP_CTRL5                  (volatile uint32_t *)0xff0113e0
#define P_DOLBY_CORE1B_DMA_CTRL                    (volatile uint32_t *)0xff0113e4
#define P_DOLBY_CORE1B_DMA_STATUS                  (volatile uint32_t *)0xff0113e8
#define P_DOLBY_CORE1B_STATUS0                     (volatile uint32_t *)0xff0113ec
#define P_DOLBY_CORE1B_STATUS1                     (volatile uint32_t *)0xff0113f0
#define P_DOLBY_CORE1B_STATUS2                     (volatile uint32_t *)0xff0113f4
#define P_DOLBY_CORE1B_STATUS3                     (volatile uint32_t *)0xff0113f8
#define P_DOLBY_CORE1B_DMA_PORT                    (volatile uint32_t *)0xff0113fc
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  dolby1b_regs.h
//
// -----------------------------------------------
// REG_BASE:  FGRAIN_VCBUS_BASE = 0x48
// -----------------------------------------------
//`include "afbcd_mult_regs.h"
//
// Reading file:  afbcd_vd_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//   reg addr map
//   0 -3f :  rdmif
//   40-6f :  afbcd
//   70-7f :  fgrain
////===============================////
#define P_VD1_IF0_GEN_REG                          (volatile uint32_t *)0xff012000
#define P_VD1_IF0_CANVAS0                          (volatile uint32_t *)0xff012004
#define P_VD1_IF0_CANVAS1                          (volatile uint32_t *)0xff012008
#define P_VD1_IF0_LUMA_X0                          (volatile uint32_t *)0xff01200c
#define P_VD1_IF0_LUMA_Y0                          (volatile uint32_t *)0xff012010
#define P_VD1_IF0_CHROMA_X0                        (volatile uint32_t *)0xff012014
#define P_VD1_IF0_CHROMA_Y0                        (volatile uint32_t *)0xff012018
#define P_VD1_IF0_LUMA_X1                          (volatile uint32_t *)0xff01201c
#define P_VD1_IF0_LUMA_Y1                          (volatile uint32_t *)0xff012020
#define P_VD1_IF0_CHROMA_X1                        (volatile uint32_t *)0xff012024
#define P_VD1_IF0_CHROMA_Y1                        (volatile uint32_t *)0xff012028
#define P_VD1_IF0_RPT_LOOP                         (volatile uint32_t *)0xff01202c
#define P_VD1_IF0_LUMA0_RPT_PAT                    (volatile uint32_t *)0xff012030
#define P_VD1_IF0_CHROMA0_RPT_PAT                  (volatile uint32_t *)0xff012034
#define P_VD1_IF0_LUMA1_RPT_PAT                    (volatile uint32_t *)0xff012038
#define P_VD1_IF0_CHROMA1_RPT_PAT                  (volatile uint32_t *)0xff01203c
#define P_VD1_IF0_LUMA_PSEL                        (volatile uint32_t *)0xff012040
#define P_VD1_IF0_CHROMA_PSEL                      (volatile uint32_t *)0xff012044
#define P_VD1_IF0_DUMMY_PIXEL                      (volatile uint32_t *)0xff012048
#define P_VD1_IF0_LUMA_FIFO_SIZE                   (volatile uint32_t *)0xff01204c
#define P_VD1_IF0_AXI_CMD_CNT                      (volatile uint32_t *)0xff012050
#define P_VD1_IF0_AXI_RDAT_CNT                     (volatile uint32_t *)0xff012054
#define P_VD1_IF0_RANGE_MAP_Y                      (volatile uint32_t *)0xff012058
#define P_VD1_IF0_RANGE_MAP_CB                     (volatile uint32_t *)0xff01205c
#define P_VD1_IF0_RANGE_MAP_CR                     (volatile uint32_t *)0xff012060
#define P_VD1_IF0_GEN_REG2                         (volatile uint32_t *)0xff012064
#define P_VD1_IF0_PROT                             (volatile uint32_t *)0xff012068
#define P_VD1_IF0_URGENT_CTRL                      (volatile uint32_t *)0xff01206c
#define P_VD1_IF0_GEN_REG3                         (volatile uint32_t *)0xff012070
#define P_VIU_VD1_FMT_CTRL                         (volatile uint32_t *)0xff012074
#define P_VIU_VD1_FMT_W                            (volatile uint32_t *)0xff012078
#define P_VD1_IF0_BADDR_Y                          (volatile uint32_t *)0xff012080
//Bit 31:0      cntl_f0_baddr_y                        //unsigned, RW, default = 0
#define P_VD1_IF0_BADDR_CB                         (volatile uint32_t *)0xff012084
//Bit 31:0      cntl_f0_baddr_cb                       //unsigned, RW, default = 0
#define P_VD1_IF0_BADDR_CR                         (volatile uint32_t *)0xff012088
//Bit 31:0      cntl_f0_baddr_cr                       //unsigned, RW, default = 0
#define P_VD1_IF0_STRIDE_0                         (volatile uint32_t *)0xff01208c
//Bit 31:29     reserved
//Bit 28:16     cntl_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_y                       //unsigned, RW, default = 256
#define P_VD1_IF0_STRIDE_1                         (volatile uint32_t *)0xff012090
//Bit 31:17     reserved
//Bit 16        cntl_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_cr                      //unsigned, RW, default = 256
#define P_VD1_IF0_BADDR_Y_F1                       (volatile uint32_t *)0xff012094
//Bit 31:0      cntl_f1_baddr_y                     //unsigned, RW, default = 0
#define P_VD1_IF0_BADDR_CB_F1                      (volatile uint32_t *)0xff012098
//Bit 31:0      cntl_f1_baddr_cb                    //unsigned, RW, default = 0
#define P_VD1_IF0_BADDR_CR_F1                      (volatile uint32_t *)0xff01209c
//Bit 31:0      cntl_f1_baddr_cr                    //unsigned, RW, default = 0
#define P_VD1_IF0_STRIDE_0_F1                      (volatile uint32_t *)0xff0120a0
//Bit 31:29     reserved
//Bit 28:16     cntl_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_y                    //unsigned, RW, default = 256
#define P_VD1_IF0_STRIDE_1_F1                      (volatile uint32_t *)0xff0120a4
//Bit 31:27     reserved
//Bit 26        cntl_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        cntl_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        cntl_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     cntl_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     cntl_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     cntl_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17        reserved
//Bit 16        cntl_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_cr                   //unsigned, RW, default = 256
#define P_VD2_IF0_GEN_REG                          (volatile uint32_t *)0xff012200
#define P_VD2_IF0_CANVAS0                          (volatile uint32_t *)0xff012204
#define P_VD2_IF0_CANVAS1                          (volatile uint32_t *)0xff012208
#define P_VD2_IF0_LUMA_X0                          (volatile uint32_t *)0xff01220c
#define P_VD2_IF0_LUMA_Y0                          (volatile uint32_t *)0xff012210
#define P_VD2_IF0_CHROMA_X0                        (volatile uint32_t *)0xff012214
#define P_VD2_IF0_CHROMA_Y0                        (volatile uint32_t *)0xff012218
#define P_VD2_IF0_LUMA_X1                          (volatile uint32_t *)0xff01221c
#define P_VD2_IF0_LUMA_Y1                          (volatile uint32_t *)0xff012220
#define P_VD2_IF0_CHROMA_X1                        (volatile uint32_t *)0xff012224
#define P_VD2_IF0_CHROMA_Y1                        (volatile uint32_t *)0xff012228
#define P_VD2_IF0_RPT_LOOP                         (volatile uint32_t *)0xff01222c
#define P_VD2_IF0_LUMA0_RPT_PAT                    (volatile uint32_t *)0xff012230
#define P_VD2_IF0_CHROMA0_RPT_PAT                  (volatile uint32_t *)0xff012234
#define P_VD2_IF0_LUMA1_RPT_PAT                    (volatile uint32_t *)0xff012238
#define P_VD2_IF0_CHROMA1_RPT_PAT                  (volatile uint32_t *)0xff01223c
#define P_VD2_IF0_LUMA_PSEL                        (volatile uint32_t *)0xff012240
#define P_VD2_IF0_CHROMA_PSEL                      (volatile uint32_t *)0xff012244
#define P_VD2_IF0_DUMMY_PIXEL                      (volatile uint32_t *)0xff012248
#define P_VD2_IF0_LUMA_FIFO_SIZE                   (volatile uint32_t *)0xff01224c
#define P_VD2_IF0_AXI_CMD_CNT                      (volatile uint32_t *)0xff012250
#define P_VD2_IF0_AXI_RDAT_CNT                     (volatile uint32_t *)0xff012254
#define P_VD2_IF0_RANGE_MAP_Y                      (volatile uint32_t *)0xff012258
#define P_VD2_IF0_RANGE_MAP_CB                     (volatile uint32_t *)0xff01225c
#define P_VD2_IF0_RANGE_MAP_CR                     (volatile uint32_t *)0xff012260
#define P_VD2_IF0_GEN_REG2                         (volatile uint32_t *)0xff012264
#define P_VD2_IF0_PROT                             (volatile uint32_t *)0xff012268
#define P_VD2_IF0_URGENT_CTRL                      (volatile uint32_t *)0xff01226c
#define P_VD2_IF0_GEN_REG3                         (volatile uint32_t *)0xff012270
#define P_VIU_VD2_FMT_CTRL                         (volatile uint32_t *)0xff012274
#define P_VIU_VD2_FMT_W                            (volatile uint32_t *)0xff012278
#define P_VD2_IF0_BADDR_Y                          (volatile uint32_t *)0xff012280
//Bit 31:0      cntl_f0_baddr_y                        //unsigned, RW, default = 0
#define P_VD2_IF0_BADDR_CB                         (volatile uint32_t *)0xff012284
//Bit 31:0      cntl_f0_baddr_cb                       //unsigned, RW, default = 0
#define P_VD2_IF0_BADDR_CR                         (volatile uint32_t *)0xff012288
//Bit 31:0      cntl_f0_baddr_cr                       //unsigned, RW, default = 0
#define P_VD2_IF0_STRIDE_0                         (volatile uint32_t *)0xff01228c
//Bit 31:29     reserved
//Bit 28:16     cntl_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_y                       //unsigned, RW, default = 256
#define P_VD2_IF0_STRIDE_1                         (volatile uint32_t *)0xff012290
//Bit 31:17     reserved
//Bit 16        cntl_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_cr                      //unsigned, RW, default = 256
#define P_VD2_IF0_BADDR_Y_F1                       (volatile uint32_t *)0xff012294
//Bit 31:0      cntl_f1_baddr_y                     //unsigned, RW, default = 0
#define P_VD2_IF0_BADDR_CB_F1                      (volatile uint32_t *)0xff012298
//Bit 31:0      cntl_f1_baddr_cb                    //unsigned, RW, default = 0
#define P_VD2_IF0_BADDR_CR_F1                      (volatile uint32_t *)0xff01229c
//Bit 31:0      cntl_f1_baddr_cr                    //unsigned, RW, default = 0
#define P_VD2_IF0_STRIDE_0_F1                      (volatile uint32_t *)0xff0122a0
//Bit 31:29     reserved
//Bit 28:16     cntl_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_y                    //unsigned, RW, default = 256
#define P_VD2_IF0_STRIDE_1_F1                      (volatile uint32_t *)0xff0122a4
//Bit 31:27     reserved
//Bit 26        cntl_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        cntl_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        cntl_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     cntl_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     cntl_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     cntl_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17        reserved
//Bit 16        cntl_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_cr                   //unsigned, RW, default = 256
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  afbcd_vd_regs.h
//
//`include "fgrain_regs.h"      //nouse
// -----------------------------------------------
// REG_BASE:  VPPC_VCBUS_BASE = 0x50
// -----------------------------------------------
//
// Reading file:  srsharp_regs.h
//
// synopsys translate_off
// synopsys translate_on
//SRSHARP0        8'h00  - 8'hff
//SRSHARP1        8'h100 - 8'1ff
#define  SRSHARP0_OFFSET   (0x000<<2)
#define  SRSHARP1_OFFSET   (0x200<<2)

//
// Reading file:  sharp_regs.h
//
#define P_SHARP_HVSIZE                             (volatile uint32_t *)0xff014000
//Bit 31:29,        reserved
//Bit 28:16,        reg_pknr_hsize                                                                                                              . unsigned  , default = 1920
//Bit 15:13,        reserved
//Bit 12: 0,        reg_pknr_vsize                                                                                                              . unsigned  , default = 1080
#define P_SHARP_HVBLANK_NUM                        (volatile uint32_t *)0xff014004
//Bit 31:24,        reserved
//Bit 23:16,        reg_deband_hblank
//Bit 15: 8,        reg_pknr_hblank_num                                                                                                         . unsigned  , default = 20
//Bit  7: 0,        reg_pknr_vblank_num                                                                                                         . unsigned  , default = 73
#define P_NR_GAUSSIAN_MODE                         (volatile uint32_t *)0xff014008
//Bit 31:14,        reserved
//Bit 13:12,        reg_nr_gau_ynorm                      : C adpative coef norm, 0: 128, 1: 256, 2: 512, 3: 1024                         . unsigned  , default = 0
//Bit 11:10,        reserved
//Bit  9: 8,        reg_nr_gau_cnorm                      : C adpative coef norm, 0: 128, 1: 256, 2: 512, 3: 1024                         . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_nr_gau_ymode                      : 0 3x3 filter; 1: 5x5 filter; 2/3:adpative coef                                . unsigned  , default = 1
//Bit  3: 2,        reserved
//Bit  1: 0,        reg_nr_gau_cmode                      : 0 3x3 filter; 1: 5x5 filter; 2/3:adpative coef                                . unsigned  , default = 1
#define P_PK_CON_2CIRHPGAIN_TH_RATE                (volatile uint32_t *)0xff014014
//Bit 31:24,        reg_pk_cirhpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 25
//Bit 23:16,        reg_pk_cirhpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 60
//Bit 15: 8,        reg_pk_cirhpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_pk_cirhpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 20
#define P_PK_CON_2CIRHPGAIN_LIMIT                  (volatile uint32_t *)0xff014018
//Bit 31:24,        reg_pk_cirhpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 155
//Bit 23:16,        reg_pk_cirhpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 150
//Bit 15: 8,        reg_pk_cirhpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define P_PK_CON_2CIRBPGAIN_TH_RATE                (volatile uint32_t *)0xff01401c
//Bit 31:24,        reg_pk_cirbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 20
//Bit 23:16,        reg_pk_cirbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).. unsigned  , default = 50
//Bit 15: 8,        reg_pk_cirbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 50
//Bit  7: 0,        reg_pk_cirbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 25
#define P_PK_CON_2CIRBPGAIN_LIMIT                  (volatile uint32_t *)0xff014020
//Bit 31:24,        reg_pk_cirbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 155
//Bit 23:16,        reg_pk_cirbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 150
//Bit 15: 8,        reg_pk_cirbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define P_PK_CON_2DRTHPGAIN_TH_RATE                (volatile uint32_t *)0xff014024
//Bit 31:24,        reg_pk_drthpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 25
//Bit 23:16,        reg_pk_drthpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 60
//Bit 15: 8,        reg_pk_drthpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_pk_drthpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 20
#define P_PK_CON_2DRTHPGAIN_LIMIT                  (volatile uint32_t *)0xff014028
//Bit 31:24,        reg_pk_drthpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).. unsigned  , default = 105
//Bit 23:16,        reg_pk_drthpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 96
//Bit 15: 8,        reg_pk_drthpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define P_PK_CON_2DRTBPGAIN_TH_RATE                (volatile uint32_t *)0xff01402c
//Bit 31:24,        reg_pk_drtbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 20
//Bit 23:16,        reg_pk_drtbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
//Bit 15: 8,        reg_pk_drtbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
//Bit  7: 0,        reg_pk_drtbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 25
#define P_PK_CON_2DRTBPGAIN_LIMIT                  (volatile uint32_t *)0xff014030
//Bit 31:24,        reg_pk_drtbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 55
//Bit 23:16,        reg_pk_drtbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40
//Bit 15: 8,        reg_pk_drtbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define P_PK_CIRFB_LPF_MODE                        (volatile uint32_t *)0xff014034
//Bit 31:30,        reserved
//Bit 29:28,        reg_cirhp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 27:26,        reserved
//Bit 25:24,        reg_cirhp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_cirhp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
//Bit 19:14,        reserved
//Bit 13:12,        reg_cirbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 11:10,        reserved
//Bit  9: 8,        reg_cirbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_cirbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
//Bit  3: 0,        reserved
#define P_PK_DRTFB_LPF_MODE                        (volatile uint32_t *)0xff014038
//Bit 31:30,        reserved
//Bit 29:28,        reg_drthp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 27:26,        reserved
//Bit 25:24,        reg_drthp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_drthp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
//Bit 19:14,        reserved
//Bit 13:12,        reg_drtbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 11:10,        reserved
//Bit  9: 8,        reg_drtbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_drtbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
//Bit  3: 0,        reserved
#define P_PK_CIRFB_HP_CORING                       (volatile uint32_t *)0xff01403c
//Bit 31:22,        reserved
//Bit 21:16,        reg_cirhp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_cirhp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_cirhp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 0
#define P_PK_CIRFB_BP_CORING                       (volatile uint32_t *)0xff014040
//Bit 31:22,        reserved
//Bit 21:16,        reg_cirbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_cirbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_cirbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define P_PK_DRTFB_HP_CORING                       (volatile uint32_t *)0xff014044
//Bit 31:22,        reserved
//Bit 21:16,        reg_drthp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_drthp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_drthp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define P_PK_DRTFB_BP_CORING                       (volatile uint32_t *)0xff014048
//Bit 31:22,        reserved
//Bit 21:16,        reg_drtbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_drtbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_drtbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define P_PK_CIRFB_BLEND_GAIN                      (volatile uint32_t *)0xff01404c
//Bit 31:28,        reg_hp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 27:24,        reg_hp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 23:20,        reg_hp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 19:16,        reserved
//Bit 15:12,        reg_bp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 11: 8,        reg_bp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit  7: 4,        reg_bp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit  3: 0,        reserved
#define P_NR_ALPY_SSD_GAIN_OFST                    (volatile uint32_t *)0xff014050
//Bit 31:16,        reserved
//Bit 15: 8,        reg_nr_alp0_ssd_gain                        : gain to max ssd normalized 16 as '1'                                          . unsigned  , default = 16
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp0_ssd_ofst                        : offset to ssd before dividing to min_err                                      . signed    , default = -2
#define P_NR_ALP0Y_ERR2CURV_TH_RATE                (volatile uint32_t *)0xff014054
//Bit 31:24,        reg_nr_alp0_minerr_ypar0                    : threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.. unsigned  , default = 10
//Bit 23:16,        reg_nr_alp0_minerr_ypar1                    : threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
//Bit 15: 8,        reg_nr_alp0_minerr_ypar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_nr_alp0_minerr_ypar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
#define P_NR_ALP0Y_ERR2CURV_LIMIT                  (volatile uint32_t *)0xff014058
//Bit 31:24,        reg_nr_alp0_minerr_ypar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
//Bit 23:16,        reg_nr_alp0_minerr_ypar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
//Bit 15: 8,        reg_nr_alp0_minerr_ypar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
//Bit  7: 0,        reserved
#define P_NR_ALP0C_ERR2CURV_TH_RATE                (volatile uint32_t *)0xff01405c
//Bit 31:24,        reg_nr_alp0_minerr_cpar0                    : threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.. unsigned  , default = 10
//Bit 23:16,        reg_nr_alp0_minerr_cpar1                    : threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
//Bit 15: 8,        reg_nr_alp0_minerr_cpar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_nr_alp0_minerr_cpar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
#define P_NR_ALP0C_ERR2CURV_LIMIT                  (volatile uint32_t *)0xff014060
//Bit 31:24,        reg_nr_alp0_minerr_cpar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
//Bit 23:16,        reg_nr_alp0_minerr_cpar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
//Bit 15: 8,        reg_nr_alp0_minerr_cpar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
//Bit  7: 0,        reserved
#define P_NR_ALP0_MIN_MAX                          (volatile uint32_t *)0xff014064
//Bit 31:30,        reserved
//Bit 29:24,        reg_nr_alp0_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_nr_alp0_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp0_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp0_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define P_NR_ALP1_MIERR_CORING                     (volatile uint32_t *)0xff014068
//Bit 31:17,        reserved
//Bit 16,            reg_nr_alp1_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp1_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp1_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 3
#define P_NR_ALP1_ERR2CURV_TH_RATE                 (volatile uint32_t *)0xff01406c
//Bit 31:24,        reg_nr_alp1_minerr_par0                     : threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_nr_alp1_minerr_par1                     : threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.. unsigned  , default = 24
//Bit 15: 8,        reg_nr_alp1_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope.. unsigned  , default = 0
//Bit  7: 0,        reg_nr_alp1_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. unsigned  , default = 20
#define P_NR_ALP1_ERR2CURV_LIMIT                   (volatile uint32_t *)0xff014070
//Bit 31:24,        reg_nr_alp1_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_nr_alp1_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.. unsigned  , default = 16
//Bit 15: 8,        reg_nr_alp1_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before. unsigned  , default = 63
//Bit  7: 0,        reserved
#define P_NR_ALP1_MIN_MAX                          (volatile uint32_t *)0xff014074
//Bit 31:30,        reserved
//Bit 29:24,        reg_nr_alp1_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_nr_alp1_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp1_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp1_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define P_PK_ALP2_MIERR_CORING                     (volatile uint32_t *)0xff014078
//Bit 31:17,        reserved
//Bit 16,            reg_pk_alp2_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_pk_alp2_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_pk_alp2_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 1
#define P_PK_ALP2_ERR2CURV_TH_RATE                 (volatile uint32_t *)0xff01407c
//Bit 31:24,        reg_pk_alp2_minerr_par0                     : threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking.. unsigned  , default = 0
//Bit 23:16,        reg_pk_alp2_minerr_par1                     : threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255.. unsigned  , default = 24
//Bit 15: 8,        reg_pk_alp2_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 0
//Bit  7: 0,        reg_pk_alp2_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 20
#define P_PK_ALP2_ERR2CURV_LIMIT                   (volatile uint32_t *)0xff014080
//Bit 31:24,        reg_pk_alp2_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_pk_alp2_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255.. unsigned  , default = 16
//Bit 15: 8,        reg_pk_alp2_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 32;. unsigned  , default = 32
//Bit  7: 0,        reserved
#define P_PK_ALP2_MIN_MAX                          (volatile uint32_t *)0xff014084
//Bit 31:14,        reserved
//Bit 13: 8,        reg_pk_alp2_min                             : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_pk_alp2_max                             : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define P_PK_FINALGAIN_HP_BP                       (volatile uint32_t *)0xff014088
//Bit 31:18,        reserved
//Bit 17:16,        reg_final_gain_rs                           : s2: right shift bits for the gain normalization, 0 normal to 32 as 1; 1 normalize to 64 as 1; -2 normalized to 8 as 1; -1 normalize 16 as 1. default = 0
//Bit 15: 8,        reg_hp_final_gain                           : gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 40
//Bit  7: 0,        reg_bp_final_gain                           : gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 30
#define P_PK_OS_HORZ_CORE_GAIN                     (volatile uint32_t *)0xff01408c
//Bit 31:24,        reg_pk_os_hsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
//Bit 23:16,        reg_pk_os_hsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
//Bit 15: 8,        reg_pk_os_hmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
//Bit  7: 0,        reg_pk_os_hmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
#define P_PK_OS_VERT_CORE_GAIN                     (volatile uint32_t *)0xff014090
//Bit 31:24,        reg_pk_os_vsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
//Bit 23:16,        reg_pk_os_vsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
//Bit 15: 8,        reg_pk_os_vmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
//Bit  7: 0,        reg_pk_os_vmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
#define P_PK_OS_ADPT_MISC                          (volatile uint32_t *)0xff014094
//Bit 31:24,        reg_pk_os_minerr_core                       : coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 40
//Bit 23:16,        reg_pk_os_minerr_gain                       : gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255;. unsigned  , default = 6
//Bit 15: 8,        reg_pk_os_adpt_max                          : maximum limit adaptive overshoot margin (4x). 0~255;                          . unsigned  , default = 200
//Bit  7: 0,        reg_pk_os_adpt_min                          : minimun limit adaptive overshoot margin (1x). 0~255;                          . unsigned  , default = 20
#define P_PK_OS_STATIC                             (volatile uint32_t *)0xff014098
//Bit 31:30,        reserved
//Bit 29:28,        reg_pk_osh_mode                             : 0~3: (2x+1) window in H direction                                             . unsigned  , default = 2
//Bit 27:26,        reserved
//Bit 25:24,        reg_pk_osv_mode                             : 0~3: (2x+1) window in V direction                                             . unsigned  , default = 2
//Bit 23:22,        reserved
//Bit 21:12,        reg_pk_os_down                              : static negative overshoot margin. 0~1023;                                     . unsigned  , default = 200
//Bit 11:10,        reserved
//Bit  9: 0,        reg_pk_os_up                                : static positive overshoot margin. 0~1023;                                     . unsigned  , default = 200
#define P_PK_NR_ENABLE                             (volatile uint32_t *)0xff01409c
//Bit 31: 4,        reserved
//Bit  3: 2,        reg_3d_mode                                 , 0: no 3D; 1: L/R; 2: T/B; 3: horizontal interleaved, dft = 0                                             //. unsigned  , default = 0
//Bit  1,            reg_pk_en                                                                                                                   . unsigned  , default = 1
//Bit  0,            reg_nr_en                                                                                                                   . unsigned  , default = 1
#define P_PK_DRT_SAD_MISC                          (volatile uint32_t *)0xff0140a0
//Bit 31:24,        reg_pk_sad_ver_gain                         : gain to sad[4], 16 normalized to "1";                                         . unsigned  , default = 32
//Bit 23:16,        reg_pk_sad_hor_gain                         : gain to sad[0], 16 normalized to "1";                                         . unsigned  , default = 24
//Bit 15:12,        reserved
//Bit 11            reserved
//Bit 10: 9,        reg_pk_bias_diag                            : bias towards diag                                                             . unsigned  , default = 0
//Bit  8,           reserved
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_pk_drt_force                            : force direction of drt peaking filter, h2b: 0:hp drt force, 1: bp drt force; 2: bp+hp drt force, 3: no force;. unsigned  , default = 24
#define P_NR_TI_DNLP_BLEND                         (volatile uint32_t *)0xff0140a4
//Bit 31:11,        reserved
//Bit 10: 8,        reg_dnlp_input_mode                         : dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os). unsigned  , default = 4
//Bit  7: 4,        reserved
//Bit  3: 2,        reg_nr_cti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:cti; 2: (nr+cti)/2; 3:cti + dlt_nr  . unsigned  , default = 1
//Bit  1: 0,        reg_nr_lti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:lti; 2: (nr+lti)/2; 3:lti + dlt_nr  . unsigned  , default = 2
////////////////////////////////////////////////////////////////////////////////
// new ti registers from here
////////////////////////////////////////////////////////////////////////////////
#define P_LTI_DIR_CORE_ALPHA                       (volatile uint32_t *)0xff0140a8
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_lti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 10
//Bit 23:20,        reserved
//Bit 19:16,        reg_adp_lti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_lti_dir_alpmin                      : min value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=10              . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_lti_dir_alpmax                      : max value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=63              . unsigned  , default = 63
#define P_CTI_DIR_ALPHA                            (volatile uint32_t *)0xff0140ac
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_cti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 5
//Bit 23:20,        reserved
//Bit 19:16,        reg_adp_cti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_cti_dir_alpmin                      : min value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=10             . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_cti_dir_alpmax                      : max value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=63             . unsigned  , default = 63
#define P_LTI_CTI_DF_GAIN                          (volatile uint32_t *)0xff0140b0
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_lti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit 23:22,        reserved
//Bit 21:16,        reg_adp_lti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_cti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_cti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
#define P_LTI_CTI_DIR_AC_DBG                       (volatile uint32_t *)0xff0140b4
//Bit 31,            reserved
//Bit 30,            reg_adp_lti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf                                               . unsigned  , default = 1
//Bit 29,            reserved
//Bit 28,            reg_adp_lti_dir_difmode                     : 0: y_dif; 1: y_dif + (u_dif+v_dif)/2;                                         . unsigned  , default = 1
//Bit 27,            reserved
//Bit 26,            reg_adp_cti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf  dft=1                                        . unsigned  , default = 1
//Bit 25:24,        reg_adp_cti_dir_difmode                     : 0: (u_dif+v_dif); 1: y_dif/2 + (u_dif+v_dif)*3/4; 2: y_dif + (u_dif+v_dif)/2; 3: y_dif*2 (not recommended). unsigned  , default = 2
//Bit 23:22,        reg_adp_hvlti_dcblend_mode                  : 0: hlti_dc; 1:vlti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3
//Bit 21:20,        reg_adp_hvcti_dcblend_mode                  : 0: hcti_dc; 1:vcti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 2
//Bit 19:18,        reg_adp_hvlti_acblend_mode                  : hlti_ac; 1:vlti_ac; 2: add  3;:adaptive to alpha                              . unsigned  , default = 3
//Bit 17:16,        reg_adp_hvcti_acblend_mode                  : hcti_ac; 1:vcti_ac; 2: add  3;: adaptive to alpha                             . unsigned  , default = 2
//Bit 15,            reserved
//Bit 14:12,        reg_adp_hlti_debug                          , for hlti debug, default = 0                                                   . unsigned  , default = 0
//Bit 11,            reserved
//Bit 10: 8,        reg_adp_vlti_debug                          , for vlti debug, default = 0                                                   . unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_adp_hcti_debug                          , for hcti debug, default = 0                                                   . unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_vcti_debug                          , for vcti debug, default = 0                                                   . unsigned  , default = 0
#define P_HCTI_FLT_CLP_DC                          (volatile uint32_t *)0xff0140b8
//Bit 31:29,        reserved
//Bit 28,            reg_adp_hcti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
//Bit 27:26,        reg_adp_hcti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8  3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
//Bit 25:24,        reg_adp_hcti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2
//Bit 23:22,        reg_adp_hcti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2     . unsigned  , default = 2
//Bit 21:20,        reg_adp_hcti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
//Bit 19:18,        reg_adp_hcti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
//Bit 17:16,        reg_adp_hcti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
//Bit 15:12,        reg_adp_hcti_hard_clp_win                   , window size, 0~8, default = 5                                                 . unsigned  , default = 5
//Bit 11: 8,        reg_adp_hcti_hard_win_min                   , window size, 0~8, default = 3                                                 . unsigned  , default = 3
//Bit  7: 5,        reserved
//Bit  4,            reg_adp_hcti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 1                                   . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_hcti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 0    . unsigned  , default = 0
#define P_HCTI_BST_GAIN                            (volatile uint32_t *)0xff0140bc
//Bit 31:24,        reg_adp_hcti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 80                         . unsigned  , default = 80
//Bit 23:16,        reg_adp_hcti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 96                          . unsigned  , default = 96
//Bit 15: 8,        reg_adp_hcti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 64                          . unsigned  , default = 64
//Bit  7: 0,        reg_adp_hcti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16
#define P_HCTI_BST_CORE                            (volatile uint32_t *)0xff0140c0
//Bit 31:24,        reg_adp_hcti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
//Bit 23:16,        reg_adp_hcti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hcti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
//Bit  7: 0,        reg_adp_hcti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 5
#define P_HCTI_CON_2_GAIN_0                        (volatile uint32_t *)0xff0140c4
//Bit 31:29,        reg_adp_hcti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: .... default = 1. unsigned  , default = 1
//Bit 28:26,        reg_adp_hcti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 2                       . unsigned  , default = 2
//Bit 25:24,        reg_adp_hcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit 23:16,        reg_adp_hcti_con_2_gain0                    , default = 25                                                                  . unsigned  , default = 25
//Bit 15: 8,        reg_adp_hcti_con_2_gain1                    , default = 60                                                                  . unsigned  , default = 60
//Bit  7: 0,        reg_adp_hcti_con_2_gain2                    0;, default = 5                                                                 . unsigned  , default = 5
#define P_HCTI_CON_2_GAIN_1                        (volatile uint32_t *)0xff0140c8
//Bit 31:24,        reg_adp_hcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
//Bit 23:16,        reg_adp_hcti_con_2_gain4                    5;, default = 5                                                                 . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit  7: 0,        reg_adp_hcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
#define P_HCTI_OS_MARGIN                           (volatile uint32_t *)0xff0140cc
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_adp_hcti_os_margin                      : margin for hcti overshoot, default = 0                                        . unsigned  , default = 0
#define P_HLTI_FLT_CLP_DC                          (volatile uint32_t *)0xff0140d0
//Bit 31:29,        reserved
//Bit 28,            reg_adp_hlti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
//Bit 27:26,        reg_adp_hlti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
//Bit 25:24,        reg_adp_hlti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 1. unsigned  , default = 1
//Bit 23:22,        reg_adp_hlti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 1    . unsigned  , default = 1
//Bit 21:20,        reg_adp_hlti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
//Bit 19:18,        reg_adp_hlti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
//Bit 17:16,        reg_adp_hlti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
//Bit 15:12,        reg_adp_hlti_hard_clp_win                   , window size, 0~8, default = 2                                                 . unsigned  , default = 2
//Bit 11: 8,        reg_adp_hlti_hard_win_min                   , window size, 0~8, default = 1                                                 . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4,            reg_adp_hlti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 0                                   . unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_hlti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 4    . unsigned  , default = 4
#define P_HLTI_BST_GAIN                            (volatile uint32_t *)0xff0140d4
//Bit 31:24,        reg_adp_hlti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 32                         . unsigned  , default = 32
//Bit 23:16,        reg_adp_hlti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 32                          . unsigned  , default = 32
//Bit 15: 8,        reg_adp_hlti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 28                          . unsigned  , default = 28
//Bit  7: 0,        reg_adp_hlti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 12                       . unsigned  , default = 12
#define P_HLTI_BST_CORE                            (volatile uint32_t *)0xff0140d8
//Bit 31:24,        reg_adp_hlti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
//Bit 23:16,        reg_adp_hlti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hlti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
//Bit  7: 0,        reg_adp_hlti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 3
#define P_HLTI_CON_2_GAIN_0                        (volatile uint32_t *)0xff0140dc
//Bit 31:29,        reg_adp_hlti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: ....., default = 1. unsigned  , default = 1
//Bit 28:26,        reg_adp_hlti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 1                       . unsigned  , default = 1
//Bit 25:24,        reg_adp_hlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit 23:16,        reg_adp_hlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 15: 8,        reg_adp_hlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit  7: 0,        reg_adp_hlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
#define P_HLTI_CON_2_GAIN_1                        (volatile uint32_t *)0xff0140e0
//Bit 31:24,        reg_adp_hlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
//Bit 23:16,        reg_adp_hlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 15: 8,        reg_adp_hlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit  7: 0,        reg_adp_hlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
#define P_HLTI_OS_MARGIN                           (volatile uint32_t *)0xff0140e4
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_adp_hlti_os_margin                      : margin for hlti overshoot, default = 0                                        . unsigned  , default = 0
#define P_VLTI_FLT_CON_CLP                         (volatile uint32_t *)0xff0140e8
//Bit 31:15,        reserved
//Bit 14,            reg_adp_vlti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
//Bit 13:12,        reg_adp_vlti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit 11:10,        reg_adp_vlti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  9: 8,        reg_adp_vlti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  7: 6,        reg_adp_vlti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  5: 4,        reg_adp_vlti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2,            reg_adp_vlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit  1,            reserved
//Bit  0,            reg_adp_vlti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
#define P_VLTI_BST_GAIN                            (volatile uint32_t *)0xff0140ec
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vlti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 32                                 . unsigned  , default = 32
//Bit 15: 8,        reg_adp_vlti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 32                             . unsigned  , default = 32
//Bit  7: 0,        reg_adp_vlti_bst_gain2                      : gain to boost filter usf, default = 32                                        . unsigned  , default = 32
#define P_VLTI_BST_CORE                            (volatile uint32_t *)0xff0140f0
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vlti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
//Bit 15: 8,        reg_adp_vlti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vlti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
#define P_VLTI_CON_2_GAIN_0                        (volatile uint32_t *)0xff0140f4
//Bit 31:24,        reg_adp_vlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 23:16,        reg_adp_vlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit 15: 8,        reg_adp_vlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
#define P_VLTI_CON_2_GAIN_1                        (volatile uint32_t *)0xff0140f8
//Bit 31:24,        reg_adp_vlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 23:16,        reg_adp_vlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit 15: 8,        reg_adp_vlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
//Bit  7: 0,        reg_adp_vlti_os_margin                      : margin for vlti overshoot, default = 0                                        . unsigned  , default = 0
#define P_VCTI_FLT_CON_CLP                         (volatile uint32_t *)0xff0140fc
//Bit 31:15,        reserved
//Bit 14,            reg_adp_vcti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
//Bit 13:12,        reg_adp_vcti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit 11:10,        reg_adp_vcti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  9: 8,        reg_adp_vcti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  7: 6,        reg_adp_vcti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  5: 4,        reg_adp_vcti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2,            reg_adp_vcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit  1,            reserved
//Bit  0,            reg_adp_vcti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
#define P_VCTI_BST_GAIN                            (volatile uint32_t *)0xff014100
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vcti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 16                                  . unsigned  , default = 16
//Bit 15: 8,        reg_adp_vcti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 16                              . unsigned  , default = 16
//Bit  7: 0,        reg_adp_vcti_bst_gain2                      : gain to boost filter usf, default = 16                                         . unsigned  , default = 16
#define P_VCTI_BST_CORE                            (volatile uint32_t *)0xff014104
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vcti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
//Bit 15: 8,        reg_adp_vcti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vcti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
#define P_VCTI_CON_2_GAIN_0                        (volatile uint32_t *)0xff014108
//Bit 31:24,        reg_adp_vcti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 23:16,        reg_adp_vcti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit 15: 8,        reg_adp_vcti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
#define P_VCTI_CON_2_GAIN_1                        (volatile uint32_t *)0xff01410c
//Bit 31:24,        reg_adp_vcti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 23:16,        reg_adp_vcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit 15: 8,        reg_adp_vcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
//Bit  7: 0,        reg_adp_vcti_os_margin                      : margin for vcti overshoot, default = 0                                        . unsigned  , default = 0
#define P_SHARP_3DLIMIT                            (volatile uint32_t *)0xff014110
//Bit 31:29,        reserved
//Bit 28:16,        reg_3d_mid_width                            ,width of left part of 3d input, dft = half size of input width  default = 0    . unsigned  , default = 960
//Bit 15:13,        reserved
//Bit 12: 0,        reg_3d_mid_height                           ,height of left part of 3d input, dft = half size of input height  default = 0  . unsigned  , default = 540
#define P_DNLP_EN                                  (volatile uint32_t *)0xff014114
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnlp_hblank
//Bit  7: 1,        reserved
//Bit  0,           reg_dnlp_en                                                                                                                 . unsigned  , default = 1
#define P_DEMO_CRTL                                (volatile uint32_t *)0xff014158
//Bit 31:19,        reserved
//Bit 18:17,        demo_disp_position                                                                                                          . unsigned  , default = 2
//Bit 16,           demo_hsvsharp_enable                                                                                                        . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 0,        demo_left_top_screen_width                  :                                                                               . unsigned  , default = 360
#define P_SHARP_SR2_CTRL                           (volatile uint32_t *)0xff01415c
//Bit 31:25,    reserved
//Bit 24        reg_sr2_bic_pknr_bypass            :
//Bit 23:22     reserved
//Bit 21:16,    reg_sr2_pk_la_err_dis_rate         :     . unsigned  , low angle and high angle error should not be no less than nearby_error*rate/64; default = 24
//Bit 15:8,     reg_sr2_pk_sad_diag_gain           :     . unsigned  , gain to sad[2] and sad[6], 16 normalized to "1"; default = 16
//Bit 7,        reg_sr2_vert_outphs                :     . unsigned  , default = 0
//Bit 6,        reg_sr2_horz_outphs                :     . unsigned  , default = 0
//Bit 5,        reg_sr2_vert_ratio                 :     . unsigned  , default = 0
//Bit 4,        reg_sr2_hori_ratio                 :     . unsigned  , default = 0
//Bit 3,        reg_sr2_bic_norm                   :     . unsigned  , default = 1
//Bit 2,        reg_sr2_enable                     :     . unsigned  , default = 0
//Bit 1,        reg_sr2_sharp_prc_lr_hbic          :     . unsigned  , default = 0
//Bit 0,        reg_sr2_sharp_prc_lr               : lti/cti/nr/peaking processing using LR grid, 0: on HR grid; 1:on LR grid, horizontally no upscale, but using simple bic   . unsigned  , default = 0
#define P_SHARP_SR2_YBIC_HCOEF0                    (volatile uint32_t *)0xff014160
//Bit 31:24, reg_sr2_y_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel Filter will be normalized to 128 as 1; default=0
//Bit 23:16, reg_sr2_y_bic_hcoef02            the same as above; default=0
//Bit 15: 8, reg_sr2_y_bic_hcoef01            the same as above; default=64
//Bit  7: 0, reg_sr2_y_bic_hcoef00            the same as above; default=0
#define P_SHARP_SR2_YBIC_HCOEF1                    (volatile uint32_t *)0xff014164
//Bit 31:24, reg_sr2_y_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as 1; default=-4
//Bit 23:16, reg_sr2_y_bic_hcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_y_bic_hcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_y_bic_hcoef10            the same as above; default=-4
#define P_SHARP_SR2_CBIC_HCOEF0                    (volatile uint32_t *)0xff014168
//Bit 31:24, reg_sr2_c_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel ,Filter will be normalized to 128 as 1; default=0
//Bit 23:16, reg_sr2_c_bic_hcoef02            the same as above; default=21
//Bit 15: 8, reg_sr2_c_bic_hcoef01            the same as above; default=22
//Bit  7: 0, reg_sr2_c_bic_hcoef00            the same as above; default=21
#define P_SHARP_SR2_CBIC_HCOEF1                    (volatile uint32_t *)0xff01416c
//Bit 31:24, reg_sr2_c_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as 1; default=-4
//Bit 23:16, reg_sr2_c_bic_hcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_c_bic_hcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_c_bic_hcoef10            the same as above; default=-4
#define P_SHARP_SR2_YBIC_VCOEF0                    (volatile uint32_t *)0xff014170
//Bit 31:24, reg_sr2_y_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as 1; default=0
//Bit 23:16, reg_sr2_y_bic_vcoef02            the same as above; default=0
//Bit 15: 8, reg_sr2_y_bic_vcoef01            the same as above; default=64
//Bit  7: 0, reg_sr2_y_bic_vcoef00            the same as above; default=0
#define P_SHARP_SR2_YBIC_VCOEF1                    (volatile uint32_t *)0xff014174
//Bit 31:24, reg_sr2_y_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channe, lFilter will be normalized to 128 as 1; default=-4
//Bit 23:16, reg_sr2_y_bic_vcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_y_bic_vcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_y_bic_vcoef10            the same as above; default=-4
#define P_SHARP_SR2_CBIC_VCOEF0                    (volatile uint32_t *)0xff014178
//Bit 31:24, reg_sr2_c_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as 1; default=0
//Bit 23:16, reg_sr2_c_bic_vcoef02            the same as above; default=21
//Bit 15: 8, reg_sr2_c_bic_vcoef01            the same as above; default=22
//Bit  7: 0, reg_sr2_c_bic_vcoef00            the same as above; default=21
#define P_SHARP_SR2_CBIC_VCOEF1                    (volatile uint32_t *)0xff01417c
//Bit 31:24, reg_sr2_c_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as 1; default=-4
//Bit 23:16, reg_sr2_c_bic_vcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_c_bic_vcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_c_bic_vcoef10            the same as above; default=-4
#define P_SHARP_SR2_MISC                           (volatile uint32_t *)0xff014180
//Bit 31:2,   reserved
//Bit 1,      reg_sr2_cmpmux_bef                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR;
//Bit 0,      reg_sr2_cmpmux_aft                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB;
#define P_SHARP_SR3_SAD_CTRL                       (volatile uint32_t *)0xff014184
//Bit 31:30 reserved
//Bit 29:24 reg_sr3_pk_sad_core_rate         // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
//Bit 23:22 reserved
//Bit 21:16 reg_sr3_lti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
//Bit 15:14 reserved
//Bit 13:8  reg_sr3_cti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
//Bit 7,    reg_sr3_lti_hsad_mode            // u1: mode for hsad of lti calculation; 0: block based; 1:other shape; default= 1
//Bit 6,    reg_sr3_cti_hsad_mode            // u1: mode for hsad of cti calculation; 0: block based; 1:other shape; default= 1
//Bit 5,    reg_sr3_lti_dsad_mode            // u1: mode for dsad of lti calculation, 0: block based; 1:other shape; default= 1
//Bit 4,    reg_sr3_cti_dsad_mode            // u1: mode for dsad of cti calculation, 0: block based; 1:other shape; default= 1
//Bit 3,    reg_sr3_lti_vsad_mode            // u1: mode for vsad of lti calculation, 0: block based; 1:other shape; default= 1
//Bit 2,    reg_sr3_cti_vsad_mode            // u1: mode for vsad of cti calculation, 0: block based; 1:other shape; default= 1
//Bit 1,    reg_sr3_lti_hsad_hlpf            // u1: hlpf for hsad of lti calculation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
//Bit 0,    reg_sr3_cti_hsad_hlpf            // u1: hlpf for hsad of cti calculation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
#define P_SHARP_SR3_PK_CTRL0                       (volatile uint32_t *)0xff014188
//Bit 31:12 reserved
//Bit 11,   reg_sr3_pk_sad_mode              // u1: mode for sad of peaking and noise reduction, 0: block based; 1:other shape; default= 1
//Bit 10,   reg_sr3_pk_hsad_hlpf             // u1: hlpf for hsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 9,    reg_sr3_pk_vsad_hlpf             // u1: hlpf for vsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 8,    reg_sr3_pk_dsad_hlpf             // u1: hlpf for dsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 7:6,  reg_sr3_pk_hpdrt_mode            // u2: mode for HPdrt filter:  default= 3
//Bit 5:4,  reg_sr3_pk_bpdrt_mode            // u2: mode for BPdrt filter:  default= 3
//Bit 3:2,  reg_sr3_pk_drtbld_range          // u2: range of the min2 and min direction distance; default =1
//Bit 1,    reserved
//Bit 0,    reg_sr3_pk_ti_blend_mode         // u1: blend mode of the TI and PK results: default = 0;
#define P_SHARP_SR3_PK_CTRL1                       (volatile uint32_t *)0xff01418c
//Bit 31,     reserved
//Bit 30:28,  reg_sr3_pk_hp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
//Bit 27,     reserved
//Bit 26:24,  reg_sr3_pk_bp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
//Bit 23:16,  reg_sr3_pk_hp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
//Bit 15:8,   reg_sr3_pk_bp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
//Bit 7,      reg_sr3_sad_intlev_mode                 //u1: interleave detection xerr mode: 0 max; 1:sum default=1
//Bit 6,      reg_sr3_sad_intlev_mode1                //u1: mode 1 of using diagonal protection: 0: no diagonal protection; 1: with diagonal protection default=1
//Bit 5:0,    reg_sr3_sad_intlev_gain                 //u6: interleave detection for sad gain applied, normalized to 8 as 1  default=12
#define P_SHARP_DEJ_CTRL                           (volatile uint32_t *)0xff014190
//Bit 31:4    reserved
//Bit 15:8,   reg_sr3_dejaggy_hblank           // u8
//Bit 7:4     reserved
//Bit 3:2,    reg_sr3_dejaggy_sameside_prtct   // u2:  enable of sr3 dejaggy same side curve protect from filter, [0] for proc, [1] for ctrl path,  default=3
//Bit 1,      reg_sr3_dejaggy_sameside_mode    // u1: mode of the sameside flag decision: default =1
//Bit 0,      reg_sr3_dejaggy_enable           // u1: enable of sr3 dejaggy: default =0
#define P_SHARP_DEJ_ALPHA                          (volatile uint32_t *)0xff014194
//Bit 31:28,  reg_sr3_dejaggy_ctrlchrm_alpha_1  //u4: alpha for LR video LPF,  default = 0
//Bit 27:24,  reg_sr3_dejaggy_ctrlchrm_alpha_0  //u4: alpha for LR video LPF,  default = 15
//Bit 23:20,  reg_sr3_dejaggy_ctrlluma_alpha_1  //u4: alpha for LR video LPF,  default = 0
//Bit 19:16,  reg_sr3_dejaggy_ctrlluma_alpha_0  //u4: alpha for LR video LPF,  default = 15
//Bit 15:12,  reg_sr3_dejaggy_procchrm_alpha_1  //u4: alpha for LR video LPF,  default = 4
//Bit 11:8,   reg_sr3_dejaggy_procchrm_alpha_0  //u4: alpha for LR video LPF,  default = 6
//Bit 7:4,    reg_sr3_dejaggy_procluma_alpha_1  //u4: alpha for LR video LPF,  default = 4
//Bit 3:0,    reg_sr3_dejaggy_procluma_alpha_0  //u4: alpha for LR video LPF,  default = 6
#define P_SHARP_SR3_DRTLPF_EN                      (volatile uint32_t *)0xff014198
//Bit 31:15   reserved
//Bit 14:8,   reg_pk_debug_edge                . unsigned  , default = 0
//Bit  7,     reserved
//Bit  6:4,   reg_sr3_drtlpf_theta_en           //u1x3 theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  3,     reserved
//Bit  2:0    reg_sr3_drtlpf_enable             //u1x3 directional lpf on luma U and V channels, default = 7
#define P_SHARP_SR3_DRTLPF_ALPHA_0                 (volatile uint32_t *)0xff01419c
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha3             //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 9
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha2             //u6: default =10
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha1             //u6: default = 11
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha0             //u6: default = 12
#define P_SHARP_SR3_DRTLPF_ALPHA_1                 (volatile uint32_t *)0xff0141a0
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha7             //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 1
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha6             //u6: default = 4
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha5             //u6: default = 7
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha4             //u6: default = 8
#define P_SHARP_SR3_DRTLPF_ALPHA_2                 (volatile uint32_t *)0xff0141a4
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha11            //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 0
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha10            //u6: default = 0
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha9             //u6: default = 0
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha8             //u6: default = 0
#define P_SHARP_SR3_DRTLPF_ALPHA_OFST              (volatile uint32_t *)0xff0141a8
//Bit 31:28   reg_sr3_drtlpf_alpha_ofst7        //s4: directional lpf alpha coef ofset of each directions, default = -8
//Bit 27:24   reg_sr3_drtlpf_alpha_ofst6        //s4: default = -8
//Bit 23:20   reg_sr3_drtlpf_alpha_ofst5        //s4: default = -8
//Bit 19:16   reg_sr3_drtlpf_alpha_ofst4        //s4: default = -8
//Bit 15:12   reg_sr3_drtlpf_alpha_ofst3        //s4: default = -8
//Bit 11:8    reg_sr3_drtlpf_alpha_ofst2        //s4: default = -8
//Bit 7:4     reg_sr3_drtlpf_alpha_ofst1        //s4: default = -8
//Bit 3:0     reg_sr3_drtlpf_alpha_ofst0        //s4: default = -8
#define P_SHARP_SR3_DERING_CTRL                    (volatile uint32_t *)0xff0141ac
//Bit 31      reserved
//Bit 30:28   reg_sr3_dering_enable                  // u3: dering enable bits; default = 1
//Bit 27      reserved
//Bit 26:24   reg_sr3_dering_varlpf_mode             // u3: local variant LPF mode: 0 no filter, 1, erosion 3x3; 2: 3x3 lpf; 3 and up: 3x3 erosion + lpf default = 3
//Bit 23:20   reg_sr3_dering_maxrange                // u4: maximum:range of dering in LR resolution, max to 12;  default = 9
//Bit 19:18   reserved
//Bit 17:16   reg_sr3_dering_lcvar_blend_mode        // u2: mode for lcvar calculation: 0: HVblend; 1: diagblend; 2: HVblend+V (for hring); 3: HVblend+ DiagBlend default = 2
//Bit 15:8    reg_sr3_dering_lcvar_gain              // u8: gain to local variant and normalized to 32 as "1"  default = 64
//Bit 7:0     reg_sr3_dering_lcvar_nearby_maxsad_th  // u8: threshold to use nearer side maxsad if that side sad is larger than this threshold, otherwise, use the max one default = 28
#define P_SHARP_SR3_DERING_LUMA2PKGAIN_0TO3        (volatile uint32_t *)0xff0141b0
//Bit 31:24   reg_sr3_dering_luma2pkgain3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkgain based on LPF luma level. default=255
//Bit 23:16   reg_sr3_dering_luma2pkgain2             // u8: level limit(for bpcon<th0) of curve for dering pkgain based on LPF luma level. default=255
//Bit 15:8    reg_sr3_dering_luma2pkgain1             // u8: threshold1 of curve for dering pkgain based on LPF luma level  default =200
//Bit 7:0     reg_sr3_dering_luma2pkgain0             // u8: threshold0 of curve for dering pkgain based on LPF luma level. default =30
#define P_SHARP_SR3_DERING_LUMA2PKGAIN_4TO6        (volatile uint32_t *)0xff0141b4
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_luma2pkgain6             // u8: rate1 (for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =24
//Bit 15:8    reg_sr3_dering_luma2pkgain5             // u8: rate0 (for bpcon<th0) of curve for dering pkgain based on LPF luma level. default =50
//Bit 7:0     reg_sr3_dering_luma2pkgain4             // u8: level limit(for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =255
#define P_SHARP_SR3_DERING_LUMA2PKOS_0TO3          (volatile uint32_t *)0xff0141b8
//Bit 31:24   reg_sr3_dering_luma2pkos3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkOS based on LPF luma level. default=255
//Bit 23:16   reg_sr3_dering_luma2pkos2             // u8: level limit(for bpcon<th0) of curve for dering pkOS based on LPF luma level. default=255
//Bit 15:8    reg_sr3_dering_luma2pkos1             // u8: threshold1 of curve for dering pkOS based on LPF luma level  default =200
//Bit 7:0     reg_sr3_dering_luma2pkos0             // u8: threshold0 of curve for dering pkOS based on LPF luma leve. default =30
#define P_SHARP_SR3_DERING_LUMA2PKOS_4TO6          (volatile uint32_t *)0xff0141bc
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_luma2pkos6             // u8: rate1 (for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =24
//Bit 15:8    reg_sr3_dering_luma2pkos5             // u8: rate0 (for bpcon<th0) of curve for dering pkOS based on LPF luma level. default =50
//Bit 7:0     reg_sr3_dering_luma2pkos4             // u8: level limit(for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =255
#define P_SHARP_SR3_DERING_GAINVS_MADSAD           (volatile uint32_t *)0xff0141c0
//Bit 31:28   reg_sr3_dering_gainvs_maxsad7        //u4: pkgain vs maxsad value, 8 node interpolations, default = 0
//Bit 27:24   reg_sr3_dering_gainvs_maxsad6        //u4: default = 0
//Bit 23:20   reg_sr3_dering_gainvs_maxsad5        //u4: default = 0
//Bit 19:16   reg_sr3_dering_gainvs_maxsad4        //u4: default = 0
//Bit 15:12   reg_sr3_dering_gainvs_maxsad3        //u4: default = 0
//Bit 11:8    reg_sr3_dering_gainvs_maxsad2        //u4: default = 0
//Bit 7:4     reg_sr3_dering_gainvs_maxsad1        //u4: default = 4
//Bit 3:0     reg_sr3_dering_gainvs_maxsad0        //u4: default = 8
#define P_SHARP_SR3_DERING_GAINVS_VR2MAX           (volatile uint32_t *)0xff0141c4
//Bit 31:28   reg_sr3_dering_gainvs_vr2max7        //u4: pkgain vs ratio = max(local_var, floor)/maxsad nearby, default = 15
//Bit 27:24   reg_sr3_dering_gainvs_vr2max6        //u4: default = 15
//Bit 23:20   reg_sr3_dering_gainvs_vr2max5        //u4: default = 15
//Bit 19:16   reg_sr3_dering_gainvs_vr2max4        //u4: default = 15
//Bit 15:12   reg_sr3_dering_gainvs_vr2max3        //u4: default = 14
//Bit 11:8    reg_sr3_dering_gainvs_vr2max2        //u4: default = 12
//Bit 7:4     reg_sr3_dering_gainvs_vr2max1        //u4: default = 2
//Bit 3:0     reg_sr3_dering_gainvs_vr2max0        //u4: default = 0
#define P_SHARP_SR3_DERING_PARAM0                  (volatile uint32_t *)0xff0141c8
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_lcvar_floor        //u8: local variant no smaller than this value to calculate dgain max(localvar,x)/maxsad. default = 10
//Bit 15:8    reg_sr3_dering_vr2max_gain        //u8: gain to max(local_var, floor)/maxsad  before feeding to LUT. default = 32
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_dering_vr2max_limt        //u6: limit of maxsad to max(local_var, floor)*(max(maxsad, lmit))/maxsad.  default = 16
#define P_SHARP_SR3_DRTLPF_THETA                   (volatile uint32_t *)0xff0141cc
//Bit 31:0    reg_sr3_drtlpf_theta              //u4x8: directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
#define P_SHARP_SATPRT_CTRL                        (volatile uint32_t *)0xff0141d0
//Bit 31:28   reserved
//Bit 27:16   reg_satprt_sat_core      //u8: 4x will be coring to cor(irgb_max-irgb_min) to calculate the oy_delt, the smaller the more protection to color, the larger only the rich color will be protected;
//Bit 15:8    reg_satprt_sat_rate      //u8: rate to cor(irgb_max-irgb_min) to calculate the oy_delt, the larger the more protection to rich color; norm 16 as 1
//Bit 7:4     reserved
//Bit 3:2     reg_satprt_csc_mode      //u2: csc mode of current yuv input: 0:601, 1:709, 2:BT2020 NCL, 3:reserved
//Bit 1       reg_satprt_is_lmt        //u1: flag telling the YUV is limited range data or full range data, 0 full range, 1: limited range
//Bit 0       reg_satprt_enable        //u1: enable of saturation protection for dnlp adjustments
#define P_SHARP_SATPRT_DIVM                        (volatile uint32_t *)0xff0141d4
//Bit 31:24   reserved
//Bit 23:0    reg_satprt_div_m        //u8x3, 1/m, normalized to 128 as 1, default=1
#define P_SHARP_DB_FLT_CTRL                        (volatile uint32_t *)0xff0141dc
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1
//Bit 25           reg_nrdeband_reset0
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0:yuv 1:RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strength of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define P_SHARP_DB_FLT_RANDLUT                     (volatile uint32_t *)0xff0141e4
//Bit 31:24        reserved
//Bit 23:21        reg_nrdebandslut7         // unsigned , default = 1   lut0
//Bit 20:18        reg_nrdebandslut6         // unsigned , default = 1   lut0
//Bit 17:15        reg_nrdebandslut5         // unsigned , default = 1   lut0
//Bit 14:12        reg_nrdebandslut4         // unsigned , default = 1   lut0
//Bit 11: 9        reg_nrdebandslut3         // unsigned , default = 1   lut0
//Bit  8: 6        reg_nrdebandslut2         // unsigned , default = 1   lut0
//Bit  5: 3        reg_nrdebandslut1         // unsigned , default = 1   lut0
//Bit  2: 0        reg_nrdebandslut0         // unsigned , default = 1   lut0
#define P_SHARP_DB_FLT_PXI_THRD                    (volatile uint32_t *)0xff0141e8
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
#define P_SHARP_DB_FLT_SEED_Y                      (volatile uint32_t *)0xff0141ec
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define P_SHARP_DB_FLT_SEED_U                      (volatile uint32_t *)0xff0141f0
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
#define P_SHARP_DB_FLT_SEED_V                      (volatile uint32_t *)0xff0141f4
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
#define P_SHARP_PKGAIN_VSLUMA_LUT_L                (volatile uint32_t *)0xff0141f8
//Bit 31:28       reg_pkgain_vsluma_lut7;
//Bit 27:24       reg_pkgain_vsluma_lut6;
//Bit 23:20       reg_pkgain_vsluma_lut5;
//Bit 19:16       reg_pkgain_vsluma_lut4;
//Bit 15:12       reg_pkgain_vsluma_lut3;
//Bit 11: 8       reg_pkgain_vsluma_lut2;
//Bit  7: 4       reg_pkgain_vsluma_lut1;
//Bit  3: 0       reg_pkgain_vsluma_lut0;
#define P_SHARP_PKGAIN_VSLUMA_LUT_H                (volatile uint32_t *)0xff0141fc
//Bit 31: 4       reserved;
//Bit  3: 0       reg_pkgain_vsluma_lut8;
#define P_SHARP_PKOSHT_VSLUMA_LUT_L                (volatile uint32_t *)0xff014200
//Bit 31:28       reg_pkosht_vsluma_lut7;
//Bit 27:24       reg_pkosht_vsluma_lut6;
//Bit 23:20       reg_pkosht_vsluma_lut5;
//Bit 19:16       reg_pkosht_vsluma_lut4;
//Bit 15:12       reg_pkosht_vsluma_lut3;
//Bit 11: 8       reg_pkosht_vsluma_lut2;
//Bit  7: 4       reg_pkosht_vsluma_lut1;
//Bit  3: 0       reg_pkosht_vsluma_lut0;
#define P_SHARP_PKOSHT_VSLUMA_LUT_H                (volatile uint32_t *)0xff014204
//Bit 31: 4       reserved;
//Bit  3: 0       reg_pkosht_vsluma_lut8;
#define P_SHARP_SATPRT_LMT_RGB1                    (volatile uint32_t *)0xff014208
//Bit 31:28       reserved
//Bit 27:16       reg_satprt_lmt_g      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
//Bit 15:12       reserved
//Bit 11:0        reg_satprt_lmt_r      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
#define P_SHARP_SATPRT_LMT_RGB2                    (volatile uint32_t *)0xff01420c
//Bit 31:12       reserved
//Bit 11:0        reg_satprt_lmt_b      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
#define P_SHARP_GATE_CLK_CTRL_0                    (volatile uint32_t *)0xff014210
//Bit  31: 0     reg_gate_clk_ctrl_0
#define P_SHARP_GATE_CLK_CTRL_1                    (volatile uint32_t *)0xff014214
//Bit  31: 0     reg_gate_clk_ctrl_1
#define P_SHARP_GATE_CLK_CTRL_2                    (volatile uint32_t *)0xff014218
//Bit  31: 0     reg_gate_clk_ctrl_2
#define P_SHARP_GATE_CLK_CTRL_3                    (volatile uint32_t *)0xff01421c
//Bit  31: 0     reg_gate_clk_ctrl_3
#define P_SHARP_DPS_CTRL                           (volatile uint32_t *)0xff014220
//Bit  31: 0     reg_sharp_dps_ctrl
#define P_DNLP_00                                  (volatile uint32_t *)0xff014240
//Bit 31: 0,      reg_dnlp_ygrid0                          : dnlp00                                                                        . unsigned  , default = 32'h00008060
#define P_DNLP_01                                  (volatile uint32_t *)0xff014244
//Bit 31: 0,      reg_dnlp_ygrid1                          : dnlp01                                                                        . unsigned  , default = 32'h100e0c0a
#define P_DNLP_02                                  (volatile uint32_t *)0xff014248
//Bit 31: 0,      reg_dnlp_ygrid2                          : dnlp02                                                                        . unsigned  , default = 32'h1a171412
#define P_DNLP_03                                  (volatile uint32_t *)0xff01424c
//Bit 31: 0,      reg_dnlp_ygrid3                          : dnlp03                                                                        . unsigned  , default = 32'h2824201d
#define P_DNLP_04                                  (volatile uint32_t *)0xff014250
//Bit 31: 0,      reg_dnlp_ygrid4                          : dnlp04                                                                        . unsigned  , default = 32'h3834302c
#define P_DNLP_05                                  (volatile uint32_t *)0xff014254
//Bit 31: 0,      reg_dnlp_ygrid5                          : dnlp05                                                                        . unsigned  , default = 32'h4b45403c
#define P_DNLP_06                                  (volatile uint32_t *)0xff014258
//Bit 31: 0,      reg_dnlp_ygrid6                          : dnlp06                                                                        . unsigned  , default = 32'h605b5550
#define P_DNLP_07                                  (volatile uint32_t *)0xff01425c
//Bit 31: 0,      reg_dnlp_ygrid7                          : dnlp07                                                                        . unsigned  , default = 32'h80787068
#define P_DNLP_08                                  (volatile uint32_t *)0xff014260
//Bit 31: 0,      reg_dnlp_ygrid8                          : dnlp08                                                                        . unsigned  , default = 32'ha0989088
#define P_DNLP_09                                  (volatile uint32_t *)0xff014264
//Bit 31: 0,      reg_dnlp_ygrid9                          : dnlp09                                                                        . unsigned  , default = 32'hb8b2aca6
#define P_DNLP_10                                  (volatile uint32_t *)0xff014268
//Bit 31: 0,      reg_dnlp_ygrid10                         : dnlp10                                                                        . unsigned  , default = 32'hc8c4c0bc
#define P_DNLP_11                                  (volatile uint32_t *)0xff01426c
//Bit 31: 0,      reg_dnlp_ygrid11                         : dnlp11                                                                        . unsigned  , default = 32'hd4d2cecb
#define P_DNLP_12                                  (volatile uint32_t *)0xff014270
//Bit 31: 0,      reg_dnlp_ygrid12                         : dnlp12                                                                        . unsigned  , default = 32'hdad8d7d6
#define P_DNLP_13                                  (volatile uint32_t *)0xff014274
//Bit 31: 0,      reg_dnlp_ygrid13                         : dnlp13                                                                        . unsigned  , default = 32'he2e0dedc
#define P_DNLP_14                                  (volatile uint32_t *)0xff014278
//Bit 31: 0,      reg_dnlp_ygrid14                         : dnlp14                                                                        . unsigned  , default = 32'hf0ece8e4
#define P_DNLP_15                                  (volatile uint32_t *)0xff01427c
//Bit 31: 0,      reg_dnlp_ygrid15                         : dnlp15                                                                        . unsigned  , default = 32'hfffcf8f4
#define P_DNLP_16                                  (volatile uint32_t *)0xff014280
//Bit 31: 0,      reg_dnlp_ygrid16                         : dnlp16                                                                        . unsigned  , default = 32'h08060402
#define P_DNLP_17                                  (volatile uint32_t *)0xff014284
//Bit 31: 0,      reg_dnlp_ygrid17                         : dnlp17                                                                        . unsigned  , default = 32'h100e0c0a
#define P_DNLP_18                                  (volatile uint32_t *)0xff014288
//Bit 31: 0,      reg_dnlp_ygrid18                         : dnlp18                                                                        . unsigned  , default = 32'h1a171412
#define P_DNLP_19                                  (volatile uint32_t *)0xff01428c
//Bit 31: 0,      reg_dnlp_ygrid19                         : dnlp19                                                                        . unsigned  , default = 32'h2824201d
#define P_DNLP_20                                  (volatile uint32_t *)0xff014290
//Bit 31: 0,      reg_dnlp_ygrid20                         : dnlp20                                                                        . unsigned  , default = 32'h3834302c
#define P_DNLP_21                                  (volatile uint32_t *)0xff014294
//Bit 31: 0,      reg_dnlp_ygrid21                         : dnlp21                                                                        . unsigned  , default = 32'h4b45403c
#define P_DNLP_22                                  (volatile uint32_t *)0xff014298
//Bit 31: 0,      reg_dnlp_ygrid22                         : dnlp22                                                                        . unsigned  , default = 32'h605b5550
#define P_DNLP_23                                  (volatile uint32_t *)0xff01429c
//Bit 31: 0,      reg_dnlp_ygrid23                         : dnlp23                                                                        . unsigned  , default = 32'h80787068
#define P_DNLP_24                                  (volatile uint32_t *)0xff0142a0
//Bit 31: 0,      reg_dnlp_ygrid24                         : dnlp24                                                                        . unsigned  , default = 32'ha0989088
#define P_DNLP_25                                  (volatile uint32_t *)0xff0142a4
//Bit 31: 0,      reg_dnlp_ygrid25                         : dnlp25                                                                        . unsigned  , default = 32'hb8b2aca6
#define P_DNLP_26                                  (volatile uint32_t *)0xff0142a8
//Bit 31: 0,      reg_dnlp_ygrid26                         : dnlp26                                                                        . unsigned  , default = 32'hc8c4c0bc
#define P_DNLP_27                                  (volatile uint32_t *)0xff0142ac
//Bit 31: 0,      reg_dnlp_ygrid27                         : dnlp27                                                                        . unsigned  , default = 32'hd4d2cecb
#define P_DNLP_28                                  (volatile uint32_t *)0xff0142b0
//Bit 31: 0,      reg_dnlp_ygrid28                         : dnlp28                                                                        . unsigned  , default = 32'hdad8d7d6
#define P_DNLP_29                                  (volatile uint32_t *)0xff0142b4
//Bit 31: 0,      reg_dnlp_ygrid29                         : dnlp29                                                                        . unsigned  , default = 32'he2e0dedc
#define P_DNLP_30                                  (volatile uint32_t *)0xff0142b8
//Bit 31: 0,      reg_dnlp_ygrid30                         : dnlp30                                                                        . unsigned  , default = 32'hf0ece8e4
#define P_DNLP_31                                  (volatile uint32_t *)0xff0142bc
//Bit 31: 0,      reg_dnlp_ygrid31                         : dnlp31                                                                        . unsigned  , default = 32'hfffcf8f4
#define P_SHARP_SYNC_CTRL                          (volatile uint32_t *)0xff0142c0
//Bit 15: 0,      reg_sync_ctrl                            //reg_sync_ctrl: shadow register control                                       . unsigned  , default = 0
#define P_LC_INPUT_MUX                             (volatile uint32_t *)0xff0142c4
//Bit 31:7   reserved
//Bit 6:4    reg_lcinput_ysel               //u3, local contrast luma input options 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os) . unsigned  , default = 5
//Bit 3      reserved
//Bit 2:0    reg_lcinput_csel               //u3, local contrast chroma input options 0: org_c; 1: gau_c; 2: gauadp_c; 3: edgadplpf_c; 4: nr_c;5: cti_c; 6: pk_c . unsigned  , default = 5
#define P_NR_GAU_YH_COEF02                         (volatile uint32_t *)0xff0142c8
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_yhcoef_0          //s10, luma's horizontal adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_yhcoef_1          //s10, luma's horizontal adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_yhcoef_2          //s10, luma's horizontal adaptive coef2   . signed  , default = 16
#define P_NR_GAU_YH_COEF34                         (volatile uint32_t *)0xff0142cc
//Bit 31:20   reserved
//Bit 19:10   reg_nr_gau_yhcoef_3          //s10, luma's horizontal adaptive coef3   . signed  , default = 0
//Bit  9: 0   reg_nr_gau_yhcoef_4          //s10, luma's horizontal adaptive coef4   . signed  , default = 0
#define P_NR_GAU_YV_COEF1                          (volatile uint32_t *)0xff0142d0
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_yvcoef_0          //s10, luma's vertical adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_yvcoef_1          //s10, luma's vertical adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_yvcoef_2          //s10, luma's vertical adaptive coef2   . signed  , default = 16
#define P_NR_GAU_CH_COEF02                         (volatile uint32_t *)0xff0142d4
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_chcoef_0          //s10, chroma's horizontal adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_chcoef_1          //s10, chroma's horizontal adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_chcoef_2          //s10, chroma's horizontal adaptive coef2   . signed  , default = 16
#define P_NR_GAU_CH_COEF34                         (volatile uint32_t *)0xff0142d8
//Bit 31:20   reserved
//Bit 19:10   reg_nr_gau_chcoef_3          //s10, chroma's horizontal adaptive coef3   . signed  , default = 0
//Bit  9: 0   reg_nr_gau_chcoef_4          //s10, chroma's horizontal adaptive coef4   . signed  , default = 0
#define P_NR_GAU_CV_COEF1                          (volatile uint32_t *)0xff0142dc
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_cvcoef_0          //s10, chroma's vertical adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_cvcoef_1          //s10, chroma's vertical adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_cvcoef_2          //s10, chroma's vertical adaptive coef2   . signed  , default = 16
#define P_SHARP_DB_FLT_CTRL1                       (volatile uint32_t *)0xff0142e0
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11           reserved
//Bit 10: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reserved
//Bit  3           reserved
//Bit  2: 0        reserved
#define P_SHARP_DB_FLT_LUMA_THRD                   (volatile uint32_t *)0xff0142e4
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define P_SHARP_DB_FLT_CHRM_THRD                   (volatile uint32_t *)0xff0142e8
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define P_LC_TOP_CTRL                              (volatile uint32_t *)0xff014300
    //Bit 31  :8      reg_lc_misc                        U     RW        default = 'h0
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4           reg_lc_enable                      U     RW        default = 'h1      enable signal for local contrast enhancement, 1-enable; 0 disable
    //Bit 3   :1      reserved                           U     RW        default = 'h0     None
    //Bit 0           reg_lc_blkblend_mode               U     RW        default = 'h1      use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
#define P_LC_HV_NUM                                (volatile uint32_t *)0xff014304
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :8      reg_lc_blk_hnum                    U     RW        default = 'hc      lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8)
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4   :0      reg_lc_blk_vnum                    U     RW        default = 'h8      lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12)
#define P_LC_SAT_LUT_0_1                           (volatile uint32_t *)0xff014308
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_0                 U     RW        default = 'hc      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_1                 U     RW        default = 'h20      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_2_3                           (volatile uint32_t *)0xff01430c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_2                 U     RW        default = 'h38      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_3                 U     RW        default = 'h54      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_4_5                           (volatile uint32_t *)0xff014310
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_4                 U     RW        default = 'h73      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_5                 U     RW        default = 'h95      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_6_7                           (volatile uint32_t *)0xff014314
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_6                 U     RW        default = 'hb9      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_7                 U     RW        default = 'hdf      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_8_9                           (volatile uint32_t *)0xff014318
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_8                 U     RW        default = 'h107      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_9                 U     RW        default = 'h131      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_10_11                         (volatile uint32_t *)0xff01431c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_10                U     RW        default = 'h15c      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_11                U     RW        default = 'h189      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_12_13                         (volatile uint32_t *)0xff014320
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_12                U     RW        default = 'h1b8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_13                U     RW        default = 'h1e8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_14_15                         (volatile uint32_t *)0xff014324
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_14                U     RW        default = 'h219      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_15                U     RW        default = 'h24c      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_16_17                         (volatile uint32_t *)0xff014328
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_16                U     RW        default = 'h280      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_17                U     RW        default = 'h2b6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_18_19                         (volatile uint32_t *)0xff01432c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_18                U     RW        default = 'h2ec      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_19                U     RW        default = 'h324      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_20_21                         (volatile uint32_t *)0xff014330
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_20                U     RW        default = 'h35d      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_21                U     RW        default = 'h397      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_22_23                         (volatile uint32_t *)0xff014334
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_22                U     RW        default = 'h3d2      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_23                U     RW        default = 'h40e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_24_25                         (volatile uint32_t *)0xff014338
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_24                U     RW        default = 'h44b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_25                U     RW        default = 'h489      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_26_27                         (volatile uint32_t *)0xff01433c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_26                U     RW        default = 'h4c8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_27                U     RW        default = 'h507      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_28_29                         (volatile uint32_t *)0xff014340
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_28                U     RW        default = 'h548      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_29                U     RW        default = 'h58a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_30_31                         (volatile uint32_t *)0xff014344
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_30                U     RW        default = 'h5cd      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_31                U     RW        default = 'h610      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_32_33                         (volatile uint32_t *)0xff014348
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_32                U     RW        default = 'h654      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_33                U     RW        default = 'h69a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_34_35                         (volatile uint32_t *)0xff01434c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_34                U     RW        default = 'h6e0      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_35                U     RW        default = 'h726      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_36_37                         (volatile uint32_t *)0xff014350
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_36                U     RW        default = 'h76e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_37                U     RW        default = 'h7b6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_38_39                         (volatile uint32_t *)0xff014354
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_38                U     RW        default = 'h7ff      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_39                U     RW        default = 'h849      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_40_41                         (volatile uint32_t *)0xff014358
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_40                U     RW        default = 'h894      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_41                U     RW        default = 'h8df      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_42_43                         (volatile uint32_t *)0xff01435c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_42                U     RW        default = 'h92b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_43                U     RW        default = 'h978      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_44_45                         (volatile uint32_t *)0xff014360
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_44                U     RW        default = 'h9c6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_45                U     RW        default = 'ha14      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_46_47                         (volatile uint32_t *)0xff014364
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_46                U     RW        default = 'ha63      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_47                U     RW        default = 'hab2      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_48_49                         (volatile uint32_t *)0xff014368
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_48                U     RW        default = 'hb02      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_49                U     RW        default = 'hb53      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_50_51                         (volatile uint32_t *)0xff01436c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_50                U     RW        default = 'hba5      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_51                U     RW        default = 'hbf7      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_52_53                         (volatile uint32_t *)0xff014370
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_52                U     RW        default = 'hc4a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_53                U     RW        default = 'hc9d      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_54_55                         (volatile uint32_t *)0xff014374
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_54                U     RW        default = 'hcf1      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_55                U     RW        default = 'hd46      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_56_57                         (volatile uint32_t *)0xff014378
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_56                U     RW        default = 'hd9b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_57                U     RW        default = 'hdf1      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_58_59                         (volatile uint32_t *)0xff01437c
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_58                U     RW        default = 'he47      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_59                U     RW        default = 'he9e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_60_61                         (volatile uint32_t *)0xff014380
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_60                U     RW        default = 'hef6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_61                U     RW        default = 'hf4e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_SAT_LUT_62                            (volatile uint32_t *)0xff014384
    //Bit 31  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_62                U     RW        default = 'hfa7      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define P_LC_CURVE_BLK_HIDX_0_1                    (volatile uint32_t *)0xff014388
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_0                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_1                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_2_3                    (volatile uint32_t *)0xff01438c
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_2                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_3                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_4_5                    (volatile uint32_t *)0xff014390
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_4                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_5                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_6_7                    (volatile uint32_t *)0xff014394
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_6                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_7                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_8_9                    (volatile uint32_t *)0xff014398
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_8                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_9                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_10_11                  (volatile uint32_t *)0xff01439c
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_10                 U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_11                 U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_HIDX_12                     (volatile uint32_t *)0xff0143a0
    //Bit 31  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_12                 U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_VIDX_0_1                    (volatile uint32_t *)0xff0143a4
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_0                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_1                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_VIDX_2_3                    (volatile uint32_t *)0xff0143a8
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_2                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_3                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_VIDX_4_5                    (volatile uint32_t *)0xff0143ac
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_4                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_5                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_VIDX_6_7                    (volatile uint32_t *)0xff0143b0
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_6                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_7                  U     RW        default = 'h0      block boundary x-index
#define P_LC_CURVE_BLK_VIDX_8                      (volatile uint32_t *)0xff0143b4
    //Bit 31  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_8                  U     RW        default = 'h0      block boundary x-index
#define P_LC_YUV2RGB_MAT_0_1                       (volatile uint32_t *)0xff0143b8
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_0            S     RW        default =  1192      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_1            S     RW        default = 'h0        yuv2rgb 3x3 matrix
#define P_LC_YUV2RGB_MAT_2_3                       (volatile uint32_t *)0xff0143bc
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_2            S     RW        default =  1836      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_3            S     RW        default =  1192       yuv2rgb 3x3 matrix
#define P_LC_YUV2RGB_MAT_4_5                       (volatile uint32_t *)0xff0143c0
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_4            S     RW        default = -218      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_5            S     RW        default = -547      yuv2rgb 3x3 matrix
#define P_LC_YUV2RGB_MAT_6_7                       (volatile uint32_t *)0xff0143c4
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_6            S     RW        default = 1192      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_7            S     RW        default = '2166      yuv2rgb 3x3 matrix
#define P_LC_YUV2RGB_MAT_8                         (volatile uint32_t *)0xff0143c8
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_8            S     RW        default = 'h0      yuv2rgb 3x3 matrix
#define P_LC_RGB2YUV_MAT_0_1                       (volatile uint32_t *)0xff0143cc
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_0            S     RW        default =  187      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_1            S     RW        default =  629      rgb2yuv 3x3 matrix
#define P_LC_RGB2YUV_MAT_2_3                       (volatile uint32_t *)0xff0143d0
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_2            S     RW        default = 63      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_3            S     RW        default = -103      rgb2yuv 3x3 matrix
#define P_LC_RGB2YUV_MAT_4_5                       (volatile uint32_t *)0xff0143d4
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_4            S     RW        default = -346      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_5            S     RW        default = 450      rgb2yuv 3x3 matrix
#define P_LC_RGB2YUV_MAT_6_7                       (volatile uint32_t *)0xff0143d8
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_6            S     RW        default = 450      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_7            S     RW        default = -409      rgb2yuv 3x3 matrix
#define P_LC_RGB2YUV_MAT_8                         (volatile uint32_t *)0xff0143dc
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_8            S     RW        default =  41     rgb2yuv 3x3 matrix
#define P_LC_YUV2RGB_OFST                          (volatile uint32_t *)0xff0143e0
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_yuv2rgb_ofset_0             U     RW        default = 'h40      yuv2rgb pre-offset to yuv,
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_yuv2rgb_ofset_1             U     RW        default = 'h200      yuv2rgb pre-offset to yuv,
#define P_LC_YUV2RGB_CLIP                          (volatile uint32_t *)0xff0143e4
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :28     reg_lc_yuv2rgb_rs                  U     RW        default = 'h0       matrix normalization right shift extra bits, norm= (1<<(8+rs))
    //Bit 27  :16     reg_lc_yuv2rgb_clip_0              U     RW        default = 'h0      yuv2rgb converted RGB clipping range
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_yuv2rgb_clip_1              U     RW        default = 'h3ff      yuv2rgb converted RGB clipping range
#define P_LC_RGB2YUV_OFST                          (volatile uint32_t *)0xff0143e8
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_rgb2yuv_ofset_0             U     RW        default = 'h40      rgb2yuv post-offset to yuv,
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_rgb2yuv_ofset_1             U     RW        default = 'h200      rgb2yuv post-offset to yuv,
#define P_LC_RGB2YUV_CLIP                          (volatile uint32_t *)0xff0143ec
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :28     reg_lc_rgb2yuv_rs                  U     RW        default = 'h0       matrix normalization right shift extra bits, norm= (1<<(10+rs))
    //Bit 27  :16     reg_lc_rgb2yuv_clip_0              U     RW        default = 'h0      rgb2yuv converted YUV clipping range
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_rgb2yuv_clip_1              U     RW        default = 'h3ff      rgb2yuv converted YUV clipping range
#define P_LC_MAP_RAM_CTRL                          (volatile uint32_t *)0xff0143f0
#define P_LC_MAP_RAM_ADDR                          (volatile uint32_t *)0xff0143f4
#define P_LC_MAP_RAM_DATA                          (volatile uint32_t *)0xff0143f8
#define P_SHARP_FMETER_CTRL                        (volatile uint32_t *)0xff014224
//Bit 31:12   reserved
//Bit 11:10   reg_fmeter_vwin_mm     //u2, vertical window size, 0:1 cloumn, 1:3cloumn, 2or3: 5cloumn .unsigned  , default = 0
//Bit 9 : 8   reg_fmeter_hwin_mm     //u2, horizontal window size, 0:1x7, 1:1x9, 2or3: 1x11 .unsigned  , default = 0
//Bit 7       reg_fmeter_d2_mode     //u1, selection filter D2, 0: [0 -2 0 0 2], 1: [-2 0 0 0 2] .unsigned  , default = 0
//Bit 6       reg_fmeter_v2_mode     //u1, selection filter V2, 0: [0 -2 0 0 2], 1: [-2 0 0 0 2] .unsigned  , default = 0
//Bit 5: 4    reg_fmeter_h2_mode     //u2, selection filter H2, 0: [0 0 0 -2 0 0 2 0 0], 1: [-2 0 0 0 2], 2or3: [0-2 0 0 0 0 0 2 0] .unsigned  , default = 0
//Bit 3: 1    reserved
//Bit 0       reg_freq_meter_en      //u1, freq meter enable  .unsigned  , default = 0
#define P_SHARP_FMETER_WIN_HOR                     (volatile uint32_t *)0xff014228
//Bit 31:29   reserved
//Bit 28:16   reg_fmeter_xwin_ed     //u13, window location: hend      .unsigned  , default = 1920
//Bit 15:13   reserved
//Bit 12: 0   reg_fmeter_xwin_st      //u13, window location: hstart   .unsigned  , default = 0
#define P_SHARP_FMETER_WIN_VER                     (volatile uint32_t *)0xff01422c
//Bit 31:29   reserved
//Bit 28:16   reg_fmeter_ywin_ed      //u14, window location: vend      .unsigned  , default = 1080
//Bit 15:13   reserved
//Bit 12: 0   reg_fmeter_ywin_st      //u14, window location: vstart   .unsigned  , default = 0
#define P_SHARP_FMETER_CORING                      (volatile uint32_t *)0xff014230
//Bit 31:24  reg_fmeter_low_bound //u8, low bound for threshold  .unsigned  , default = 4
//Bit 23:16  reg_fmeter_coring_d  //u8, coring of diff before compare with threshold for diagonal frequency .unsigned  , default = 4
//Bit 15:8   reg_fmeter_coring_v  //u8, coring of diff before compare with threshold for vertical frequency .unsigned  , default = 4
//Bit 7: 0   reg_fmeter_coring_h  //u8, coring of diff before compare with threshold for horizontal frequency .unsigned  , default = 4
#define P_SHARP_FMETER_RATIO_H                     (volatile uint32_t *)0xff014234
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_h2     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_h1     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_h0     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
#define P_SHARP_FMETER_RATIO_V                     (volatile uint32_t *)0xff014238
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_v2     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_v1     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_v0     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
#define P_SHARP_FMETER_RATIO_D                     (volatile uint32_t *)0xff01423c
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_d2     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_d1     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_d0     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
#define P_SHARP_RO_FMETER_HCNT_TYPE0               (volatile uint32_t *)0xff014118
//Bit 31:0 ro_fmeter_hcnt_type0     //u32, count for horizontal frequency
#define P_SHARP_RO_FMETER_HCNT_TYPE1               (volatile uint32_t *)0xff01411c
//Bit 31:0 ro_fmeter_hcnt_type1     //u32, count for horizontal frequency
#define P_SHARP_RO_FMETER_HCNT_TYPE2               (volatile uint32_t *)0xff014120
//Bit 31:0 ro_fmeter_hcnt_type2     //u32, count for horizontal frequency
#define P_SHARP_RO_FMETER_HCNT_TYPE3               (volatile uint32_t *)0xff014124
//Bit 31:0 ro_fmeter_hcnt_type3     //u32, count for horizontal frequency
#define P_SHARP_RO_FMETER_VCNT_TYPE0               (volatile uint32_t *)0xff014128
//Bit 31:0 ro_fmeter_vcnt_type0     //u32, count for vertical frequency
#define P_SHARP_RO_FMETER_VCNT_TYPE1               (volatile uint32_t *)0xff01412c
//Bit 31:0 ro_fmeter_vcnt_type1     //u32, count for vertical frequency
#define P_SHARP_RO_FMETER_VCNT_TYPE2               (volatile uint32_t *)0xff014130
//Bit 31:0 ro_fmeter_vcnt_type2     //u32, count for vertical frequency
#define P_SHARP_RO_FMETER_VCNT_TYPE3               (volatile uint32_t *)0xff014134
//Bit 31:0 ro_fmeter_vcnt_type3     //u32, count for vertical frequency
#define P_SHARP_RO_FMETER_PDCNT_TYPE0              (volatile uint32_t *)0xff014138
//Bit 31:0 ro_fmeter_pdcnt_type0     //u32, count for positive diagonal frequency
#define P_SHARP_RO_FMETER_PDCNT_TYPE1              (volatile uint32_t *)0xff01413c
//Bit 31:0 ro_fmeter_pdcnt_type1     //u32, count for positive diagonal frequency
#define P_SHARP_RO_FMETER_PDCNT_TYPE2              (volatile uint32_t *)0xff014140
//Bit 31:0 ro_fmeter_pdcnt_type2     //u32, count for positive diagonal frequency
#define P_SHARP_RO_FMETER_PDCNT_TYPE3              (volatile uint32_t *)0xff014144
//Bit 31:0 ro_fmeter_pdcnt_type3     //u32, count for positive diagonal frequency
#define P_SHARP_RO_FMETER_NDCNT_TYPE0              (volatile uint32_t *)0xff014148
//Bit 31:0 ro_fmeter_ndcnt_type0     //u32, count for negative diagonal frequency
#define P_SHARP_RO_FMETER_NDCNT_TYPE1              (volatile uint32_t *)0xff01414c
//Bit 31:0 ro_fmeter_ndcnt_type1     //u32, count for negative diagonal frequency
#define P_SHARP_RO_FMETER_NDCNT_TYPE2              (volatile uint32_t *)0xff014150
//Bit 31:0 ro_fmeter_ndcnt_type2     //u32, count for negative diagonal frequency
#define P_SHARP_RO_FMETER_NDCNT_TYPE3              (volatile uint32_t *)0xff014154
//Bit 31:0 ro_fmeter_ndcnt_type3     //u32, count for negative diagonal frequency
//
// Closing file:  sharp_regs.h
//

#define SRSHARP0_SHARP_HVSIZE                      (SRSHARP0_OFFSET + SHARP_HVSIZE                 )  //0x00  //
#define SRSHARP0_SHARP_HVBLANK_NUM                 (SRSHARP0_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
#define SRSHARP0_NR_GAUSSIAN_MODE                  (SRSHARP0_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
//`define SRSHARP0_PK_HVCON_LPF_MODE                 (`SRSHARP0_OFFSET + `PK_HVCON_LPF_MODE            )  //8'h03  //
//`define SRSHARP0_PK_CON_BLEND_GAIN                 (`SRSHARP0_OFFSET + `PK_CON_BLEND_GAIN            )  //8'h04  //
#define SRSHARP0_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
#define SRSHARP0_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
#define SRSHARP0_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
#define SRSHARP0_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
#define SRSHARP0_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
#define SRSHARP0_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
#define SRSHARP0_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
#define SRSHARP0_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
#define SRSHARP0_PK_CIRFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
#define SRSHARP0_PK_DRTFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
#define SRSHARP0_PK_CIRFB_HP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
#define SRSHARP0_PK_CIRFB_BP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
#define SRSHARP0_PK_DRTFB_HP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
#define SRSHARP0_PK_DRTFB_BP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
#define SRSHARP0_PK_CIRFB_BLEND_GAIN               (SRSHARP0_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
#define SRSHARP0_NR_ALPY_SSD_GAIN_OFST             (SRSHARP0_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
#define SRSHARP0_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
#define SRSHARP0_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
#define SRSHARP0_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
#define SRSHARP0_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
#define SRSHARP0_NR_ALP0_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
#define SRSHARP0_NR_ALP1_MIERR_CORING              (SRSHARP0_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
#define SRSHARP0_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
#define SRSHARP0_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
#define SRSHARP0_NR_ALP1_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
#define SRSHARP0_PK_ALP2_MIERR_CORING              (SRSHARP0_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
#define SRSHARP0_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
#define SRSHARP0_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
#define SRSHARP0_PK_ALP2_MIN_MAX                   (SRSHARP0_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
#define SRSHARP0_PK_FINALGAIN_HP_BP                (SRSHARP0_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
#define SRSHARP0_PK_OS_HORZ_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
#define SRSHARP0_PK_OS_VERT_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
#define SRSHARP0_PK_OS_ADPT_MISC                   (SRSHARP0_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
#define SRSHARP0_PK_OS_STATIC                      (SRSHARP0_OFFSET + PK_OS_STATIC                 )  //0x26  //
#define SRSHARP0_PK_NR_ENABLE                      (SRSHARP0_OFFSET + PK_NR_ENABLE                 )  //0x27  //
#define SRSHARP0_PK_DRT_SAD_MISC                   (SRSHARP0_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
#define SRSHARP0_NR_TI_DNLP_BLEND                  (SRSHARP0_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
#define SRSHARP0_LTI_DIR_CORE_ALPHA                (SRSHARP0_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
#define SRSHARP0_CTI_DIR_ALPHA                     (SRSHARP0_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
#define SRSHARP0_LTI_CTI_DF_GAIN                   (SRSHARP0_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
#define SRSHARP0_LTI_CTI_DIR_AC_DBG                (SRSHARP0_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
#define SRSHARP0_HCTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
#define SRSHARP0_HCTI_BST_GAIN                     (SRSHARP0_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
#define SRSHARP0_HCTI_BST_CORE                     (SRSHARP0_OFFSET + HCTI_BST_CORE                )  //0x30  //
#define SRSHARP0_HCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
#define SRSHARP0_HCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
#define SRSHARP0_HCTI_OS_MARGIN                    (SRSHARP0_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
#define SRSHARP0_HLTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
#define SRSHARP0_HLTI_BST_GAIN                     (SRSHARP0_OFFSET + HLTI_BST_GAIN                )  //0x35  //
#define SRSHARP0_HLTI_BST_CORE                     (SRSHARP0_OFFSET + HLTI_BST_CORE                )  //0x36  //
#define SRSHARP0_HLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
#define SRSHARP0_HLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
#define SRSHARP0_HLTI_OS_MARGIN                    (SRSHARP0_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
#define SRSHARP0_VLTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
#define SRSHARP0_VLTI_BST_GAIN                     (SRSHARP0_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
#define SRSHARP0_VLTI_BST_CORE                     (SRSHARP0_OFFSET + VLTI_BST_CORE                )  //0x3c  //
#define SRSHARP0_VLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
#define SRSHARP0_VLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
#define SRSHARP0_VCTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
#define SRSHARP0_VCTI_BST_GAIN                     (SRSHARP0_OFFSET + VCTI_BST_GAIN                )  //0x40  //
#define SRSHARP0_VCTI_BST_CORE                     (SRSHARP0_OFFSET + VCTI_BST_CORE                )  //0x41  //
#define SRSHARP0_VCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
#define SRSHARP0_VCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
#define SRSHARP0_SHARP_3DLIMIT                     (SRSHARP0_OFFSET + SHARP_3DLIMIT                )  //0x44  //
#define SRSHARP0_DNLP_EN                           (SRSHARP0_OFFSET + DNLP_EN                      )  //0x45  //
//`define SRSHARP0_DNLP_00                           (`SRSHARP0_OFFSET + `DNLP_00                      )  //8'h46  //
//`define SRSHARP0_DNLP_01                           (`SRSHARP0_OFFSET + `DNLP_01                      )  //8'h47  //
//`define SRSHARP0_DNLP_02                           (`SRSHARP0_OFFSET + `DNLP_02                      )  //8'h48  //
//`define SRSHARP0_DNLP_03                           (`SRSHARP0_OFFSET + `DNLP_03                      )  //8'h49  //
//`define SRSHARP0_DNLP_04                           (`SRSHARP0_OFFSET + `DNLP_04                      )  //8'h4a  //
//`define SRSHARP0_DNLP_05                           (`SRSHARP0_OFFSET + `DNLP_05                      )  //8'h4b  //
//`define SRSHARP0_DNLP_06                           (`SRSHARP0_OFFSET + `DNLP_06                      )  //8'h4c  //
//`define SRSHARP0_DNLP_07                           (`SRSHARP0_OFFSET + `DNLP_07                      )  //8'h4d  //
//`define SRSHARP0_DNLP_08                           (`SRSHARP0_OFFSET + `DNLP_08                      )  //8'h4e  //
//`define SRSHARP0_DNLP_09                           (`SRSHARP0_OFFSET + `DNLP_09                      )  //8'h4f  //
//`define SRSHARP0_DNLP_10                           (`SRSHARP0_OFFSET + `DNLP_10                      )  //8'h50  //
//`define SRSHARP0_DNLP_11                           (`SRSHARP0_OFFSET + `DNLP_11                      )  //8'h51  //
//`define SRSHARP0_DNLP_12                           (`SRSHARP0_OFFSET + `DNLP_12                      )  //8'h52  //
//`define SRSHARP0_DNLP_13                           (`SRSHARP0_OFFSET + `DNLP_13                      )  //8'h53  //
//`define SRSHARP0_DNLP_14                           (`SRSHARP0_OFFSET + `DNLP_14                      )  //8'h54  //
//`define SRSHARP0_DNLP_15                           (`SRSHARP0_OFFSET + `DNLP_15                      )  //8'h55  //
#define SRSHARP0_DEMO_CRTL                         (SRSHARP0_OFFSET + DEMO_CRTL                    )  //0x56  //
#define SRSHARP0_SHARP_SR2_CTRL                    (SRSHARP0_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
#define SRSHARP0_SHARP_SR2_YBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
#define SRSHARP0_SHARP_SR2_YBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
#define SRSHARP0_SHARP_SR2_CBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
#define SRSHARP0_SHARP_SR2_CBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
#define SRSHARP0_SHARP_SR2_YBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
#define SRSHARP0_SHARP_SR2_YBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
#define SRSHARP0_SHARP_SR2_CBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
#define SRSHARP0_SHARP_SR2_CBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
#define SRSHARP0_SHARP_SR2_MISC                    (SRSHARP0_OFFSET + SHARP_SR2_MISC               )  //0x60  //
#define SRSHARP0_SR3_SAD_CTRL                   (SRSHARP0_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
#define SRSHARP0_SR3_PK_CTRL0                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
#define SRSHARP0_SR3_PK_CTRL1                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
#define SRSHARP0_DEJ_CTRL                       (SRSHARP0_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
#define SRSHARP0_DEJ_ALPHA                      (SRSHARP0_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
#define SRSHARP0_SR3_DRTLPF_EN                  (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
#define SRSHARP0_SR3_DRTLPF_ALPHA_0             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
#define SRSHARP0_SR3_DRTLPF_ALPHA_1             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
#define SRSHARP0_SR3_DRTLPF_ALPHA_2             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
#define SRSHARP0_SR3_DRTLPF_ALPHA_OFST          (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
#define SRSHARP0_SR3_DERING_CTRL                (SRSHARP0_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
#define SRSHARP0_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
#define SRSHARP0_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
#define SRSHARP0_SR3_DERING_GAINVS_MADSAD       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
#define SRSHARP0_SR3_DERING_GAINVS_VR2MAX       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
#define SRSHARP0_SR3_DERING_PARAM0              (SRSHARP0_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
#define SRSHARP0_SR3_DRTLPF_THETA               (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
#define SRSHARP0_SATPRT_CTRL                    (SRSHARP0_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
#define SRSHARP0_SATPRT_DIVM                    (SRSHARP0_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
#define SRSHARP0_DB_FLT_CTRL                    (SRSHARP0_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
//`define SRSHARP0_DB_FLT_YC_THRD                 (`SRSHARP0_OFFSET + `SHARP_DB_FLT_YC_THRD             ) // 8'h78
#define SRSHARP0_DB_FLT_CTRL1                   (SRSHARP0_OFFSET + SHARP_DB_FLT_CTRL1                 ) // 0xb8
#define SRSHARP0_DB_FLT_LUMA_THRD               (SRSHARP0_OFFSET + SHARP_DB_FLT_LUMA_THRD             ) // 0xb9
#define SRSHARP0_DB_FLT_CHRM_THRD               (SRSHARP0_OFFSET + SHARP_DB_FLT_CHRM_THRD             ) // 0xba
#define SRSHARP0_DB_FLT_RANDLUT                 (SRSHARP0_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
#define SRSHARP0_DB_FLT_PXI_THRD                (SRSHARP0_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
#define SRSHARP0_DB_FLT_SEED_Y                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
#define SRSHARP0_DB_FLT_SEED_U                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
#define SRSHARP0_DB_FLT_SEED_V                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
#define SRSHARP0_PKGAIN_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x7e
#define SRSHARP0_PKGAIN_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x7f
#define SRSHARP0_PKOSHT_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x80
#define SRSHARP0_PKOSHT_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x81
#define SRSHARP0_SATPRT_LMT_RGB1                (SRSHARP0_OFFSET + SHARP_SATPRT_LMT_RGB1              ) // 0x82
#define SRSHARP0_SATPRT_LMT_RGB2                (SRSHARP0_OFFSET + SHARP_SATPRT_LMT_RGB2              ) // 0x83
#define SRSHARP0_SHARP_GATE_CLK_CTRL_0          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_0              ) // 0x84
#define SRSHARP0_SHARP_GATE_CLK_CTRL_1          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_1              ) // 0x85
#define SRSHARP0_SHARP_GATE_CLK_CTRL_2          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_2              ) // 0x86
#define SRSHARP0_SHARP_GATE_CLK_CTRL_3          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_3              ) // 0x87
#define SRSHARP0_SHARP_DPS_CTRL                 (SRSHARP0_OFFSET + SHARP_DPS_CTRL                     ) // 0x88
#define SRSHARP0_DNLP_00                        (SRSHARP0_OFFSET + DNLP_00                            ) // 0x90  //
#define SRSHARP0_DNLP_01                        (SRSHARP0_OFFSET + DNLP_01                            ) // 0x91  //
#define SRSHARP0_DNLP_02                        (SRSHARP0_OFFSET + DNLP_02                            ) // 0x92  //
#define SRSHARP0_DNLP_03                        (SRSHARP0_OFFSET + DNLP_03                            ) // 0x93  //
#define SRSHARP0_DNLP_04                        (SRSHARP0_OFFSET + DNLP_04                            ) // 0x94  //
#define SRSHARP0_DNLP_05                        (SRSHARP0_OFFSET + DNLP_05                            ) // 0x95  //
#define SRSHARP0_DNLP_06                        (SRSHARP0_OFFSET + DNLP_06                            ) // 0x96  //
#define SRSHARP0_DNLP_07                        (SRSHARP0_OFFSET + DNLP_07                            ) // 0x97  //
#define SRSHARP0_DNLP_08                        (SRSHARP0_OFFSET + DNLP_08                            ) // 0x98  //
#define SRSHARP0_DNLP_09                        (SRSHARP0_OFFSET + DNLP_09                            ) // 0x99  //
#define SRSHARP0_DNLP_10                        (SRSHARP0_OFFSET + DNLP_10                            ) // 0x9a  //
#define SRSHARP0_DNLP_11                        (SRSHARP0_OFFSET + DNLP_11                            ) // 0x9b  //
#define SRSHARP0_DNLP_12                        (SRSHARP0_OFFSET + DNLP_12                            ) // 0x9c  //
#define SRSHARP0_DNLP_13                        (SRSHARP0_OFFSET + DNLP_13                            ) // 0x9d  //
#define SRSHARP0_DNLP_14                        (SRSHARP0_OFFSET + DNLP_14                            ) // 0x9e  //
#define SRSHARP0_DNLP_15                        (SRSHARP0_OFFSET + DNLP_15                            ) // 0x9f  //
#define SRSHARP0_DNLP_16                        (SRSHARP0_OFFSET + DNLP_16                            ) // 0xa0  //
#define SRSHARP0_DNLP_17                        (SRSHARP0_OFFSET + DNLP_17                            ) // 0xa1  //
#define SRSHARP0_DNLP_18                        (SRSHARP0_OFFSET + DNLP_18                            ) // 0xa2  //
#define SRSHARP0_DNLP_19                        (SRSHARP0_OFFSET + DNLP_19                            ) // 0xa3  //
#define SRSHARP0_DNLP_20                        (SRSHARP0_OFFSET + DNLP_20                            ) // 0xa4  //
#define SRSHARP0_DNLP_21                        (SRSHARP0_OFFSET + DNLP_21                            ) // 0xa5  //
#define SRSHARP0_DNLP_22                        (SRSHARP0_OFFSET + DNLP_22                            ) // 0xa6  //
#define SRSHARP0_DNLP_23                        (SRSHARP0_OFFSET + DNLP_23                            ) // 0xa7  //
#define SRSHARP0_DNLP_24                        (SRSHARP0_OFFSET + DNLP_24                            ) // 0xa8  //
#define SRSHARP0_DNLP_25                        (SRSHARP0_OFFSET + DNLP_25                            ) // 0xa9  //
#define SRSHARP0_DNLP_26                        (SRSHARP0_OFFSET + DNLP_26                            ) // 0xaa  //
#define SRSHARP0_DNLP_27                        (SRSHARP0_OFFSET + DNLP_27                            ) // 0xab  //
#define SRSHARP0_DNLP_28                        (SRSHARP0_OFFSET + DNLP_28                            ) // 0xac  //
#define SRSHARP0_DNLP_29                        (SRSHARP0_OFFSET + DNLP_29                            ) // 0xad  //
#define SRSHARP0_DNLP_30                        (SRSHARP0_OFFSET + DNLP_30                            ) // 0xae  //
#define SRSHARP0_DNLP_31                        (SRSHARP0_OFFSET + DNLP_31                            ) // 0xaf  //
#define SRSHARP0_SHARP_SYNC_CTRL                (SRSHARP0_OFFSET + SHARP_SYNC_CTRL                    ) // 0xb0  //
#define SRSHARP0_LC_INPUT_MUX                   (SRSHARP0_OFFSET + LC_INPUT_MUX                       ) // 0xb1  //
#define SRSHARP0_NR_GAU_YH_COEF02               (SRSHARP0_OFFSET + NR_GAU_YH_COEF02                   ) // 0xb2  //
#define SRSHARP0_NR_GAU_YH_COEF34               (SRSHARP0_OFFSET + NR_GAU_YH_COEF34                   ) // 0xb3  //
#define SRSHARP0_NR_GAU_YV_COEF1                (SRSHARP0_OFFSET + NR_GAU_YV_COEF1                    ) // 0xb4  //
#define SRSHARP0_NR_GAU_CH_COEF02               (SRSHARP0_OFFSET + NR_GAU_CH_COEF02                   ) // 0xb5  //
#define SRSHARP0_NR_GAU_CH_COEF34               (SRSHARP0_OFFSET + NR_GAU_CH_COEF34                   ) // 0xb6  //
#define SRSHARP0_NR_GAU_CV_COEF1                (SRSHARP0_OFFSET + NR_GAU_CV_COEF1                    ) // 0xb7  //
#define SRSHARP0_LC_TOP_CTRL                    (SRSHARP0_OFFSET + LC_TOP_CTRL                        ) // 0xc0  //
#define SRSHARP0_LC_HV_NUM                      (SRSHARP0_OFFSET + LC_HV_NUM                          ) // 0xc1
#define SRSHARP0_LC_SAT_LUT_0_1                 (SRSHARP0_OFFSET + LC_SAT_LUT_0_1                     ) // 0xc2
#define SRSHARP0_LC_SAT_LUT_2_3                 (SRSHARP0_OFFSET + LC_SAT_LUT_2_3                     ) // 0xc3
#define SRSHARP0_LC_SAT_LUT_4_5                 (SRSHARP0_OFFSET + LC_SAT_LUT_4_5                     ) // 0xc4
#define SRSHARP0_LC_SAT_LUT_6_7                 (SRSHARP0_OFFSET + LC_SAT_LUT_6_7                     ) // 0xc5
#define SRSHARP0_LC_SAT_LUT_8_9                 (SRSHARP0_OFFSET + LC_SAT_LUT_8_9                     ) // 0xc6
#define SRSHARP0_LC_SAT_LUT_10_11               (SRSHARP0_OFFSET + LC_SAT_LUT_10_11                   ) // 0xc7
#define SRSHARP0_LC_SAT_LUT_12_13               (SRSHARP0_OFFSET + LC_SAT_LUT_12_13                   ) // 0xc8
#define SRSHARP0_LC_SAT_LUT_14_15               (SRSHARP0_OFFSET + LC_SAT_LUT_14_15                   ) // 0xc9
#define SRSHARP0_LC_SAT_LUT_16_17               (SRSHARP0_OFFSET + LC_SAT_LUT_16_17                   ) // 0xca
#define SRSHARP0_LC_SAT_LUT_18_19               (SRSHARP0_OFFSET + LC_SAT_LUT_18_19                   ) // 0xcb
#define SRSHARP0_LC_SAT_LUT_20_21               (SRSHARP0_OFFSET + LC_SAT_LUT_20_21                   ) // 0xcc
#define SRSHARP0_LC_SAT_LUT_22_23               (SRSHARP0_OFFSET + LC_SAT_LUT_22_23                   ) // 0xcd
#define SRSHARP0_LC_SAT_LUT_24_25               (SRSHARP0_OFFSET + LC_SAT_LUT_24_25                   ) // 0xce
#define SRSHARP0_LC_SAT_LUT_26_27               (SRSHARP0_OFFSET + LC_SAT_LUT_26_27                   ) // 0xcf
#define SRSHARP0_LC_SAT_LUT_28_29               (SRSHARP0_OFFSET + LC_SAT_LUT_28_29                   ) // 0xd0
#define SRSHARP0_LC_SAT_LUT_30_31               (SRSHARP0_OFFSET + LC_SAT_LUT_30_31                   ) // 0xd1
#define SRSHARP0_LC_SAT_LUT_32_33               (SRSHARP0_OFFSET + LC_SAT_LUT_32_33                   ) // 0xd2
#define SRSHARP0_LC_SAT_LUT_34_35               (SRSHARP0_OFFSET + LC_SAT_LUT_34_35                   ) // 0xd3
#define SRSHARP0_LC_SAT_LUT_36_37               (SRSHARP0_OFFSET + LC_SAT_LUT_36_37                   ) // 0xd4
#define SRSHARP0_LC_SAT_LUT_38_39               (SRSHARP0_OFFSET + LC_SAT_LUT_38_39                   ) // 0xd5
#define SRSHARP0_LC_SAT_LUT_40_41               (SRSHARP0_OFFSET + LC_SAT_LUT_40_41                   ) // 0xd6
#define SRSHARP0_LC_SAT_LUT_42_43               (SRSHARP0_OFFSET + LC_SAT_LUT_42_43                   ) // 0xd7
#define SRSHARP0_LC_SAT_LUT_44_45               (SRSHARP0_OFFSET + LC_SAT_LUT_44_45                   ) // 0xd8
#define SRSHARP0_LC_SAT_LUT_46_47               (SRSHARP0_OFFSET + LC_SAT_LUT_46_47                   ) // 0xd9
#define SRSHARP0_LC_SAT_LUT_48_49               (SRSHARP0_OFFSET + LC_SAT_LUT_48_49                   ) // 0xda
#define SRSHARP0_LC_SAT_LUT_50_51               (SRSHARP0_OFFSET + LC_SAT_LUT_50_51                   ) // 0xdb
#define SRSHARP0_LC_SAT_LUT_52_53               (SRSHARP0_OFFSET + LC_SAT_LUT_52_53                   ) // 0xdc
#define SRSHARP0_LC_SAT_LUT_54_55               (SRSHARP0_OFFSET + LC_SAT_LUT_54_55                   ) // 0xdd
#define SRSHARP0_LC_SAT_LUT_56_57               (SRSHARP0_OFFSET + LC_SAT_LUT_56_57                   ) // 0xde
#define SRSHARP0_LC_SAT_LUT_58_59               (SRSHARP0_OFFSET + LC_SAT_LUT_58_59                   ) // 0xdf
#define SRSHARP0_LC_SAT_LUT_60_61               (SRSHARP0_OFFSET + LC_SAT_LUT_60_61                   ) // 0xe0
#define SRSHARP0_LC_SAT_LUT_62                  (SRSHARP0_OFFSET + LC_SAT_LUT_62                      ) // 0xe1
#define SRSHARP0_LC_CURVE_BLK_HIDX_0_1          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_0_1              ) // 0xe2
#define SRSHARP0_LC_CURVE_BLK_HIDX_2_3          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_2_3              ) // 0xe3
#define SRSHARP0_LC_CURVE_BLK_HIDX_4_5          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_4_5              ) // 0xe4
#define SRSHARP0_LC_CURVE_BLK_HIDX_6_7          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_6_7              ) // 0xe5
#define SRSHARP0_LC_CURVE_BLK_HIDX_8_9          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_8_9              ) // 0xe6
#define SRSHARP0_LC_CURVE_BLK_HIDX_10_11        (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_10_11            ) // 0xe7
#define SRSHARP0_LC_CURVE_BLK_HIDX_12           (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_12               ) // 0xe8
#define SRSHARP0_LC_CURVE_BLK_VIDX_0_1          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_0_1              ) // 0xe9
#define SRSHARP0_LC_CURVE_BLK_VIDX_2_3          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_2_3              ) // 0xea
#define SRSHARP0_LC_CURVE_BLK_VIDX_4_5          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_4_5              ) // 0xeb
#define SRSHARP0_LC_CURVE_BLK_VIDX_6_7          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_6_7              ) // 0xec
#define SRSHARP0_LC_CURVE_BLK_VIDX_8            (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_8                ) // 0xed
#define SRSHARP0_LC_YUV2RGB_MAT_0_1             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_0_1                 ) // 0xee
#define SRSHARP0_LC_YUV2RGB_MAT_2_3             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_2_3                 ) // 0xef
#define SRSHARP0_LC_YUV2RGB_MAT_4_5             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_4_5                 ) // 0xf0
#define SRSHARP0_LC_YUV2RGB_MAT_6_7             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_6_7                 ) // 0xf1
#define SRSHARP0_LC_YUV2RGB_MAT_8               (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_8                   ) // 0xf2
#define SRSHARP0_LC_RGB2YUV_MAT_0_1             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_0_1                 ) // 0xf3
#define SRSHARP0_LC_RGB2YUV_MAT_2_3             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_2_3                 ) // 0xf4
#define SRSHARP0_LC_RGB2YUV_MAT_4_5             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_4_5                 ) // 0xf5
#define SRSHARP0_LC_RGB2YUV_MAT_6_7             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_6_7                 ) // 0xf6
#define SRSHARP0_LC_RGB2YUV_MAT_8               (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_8                   ) // 0xf7
#define SRSHARP0_LC_YUV2RGB_OFST                (SRSHARP0_OFFSET + LC_YUV2RGB_OFST                    ) // 0xf8
#define SRSHARP0_LC_YUV2RGB_CLIP                (SRSHARP0_OFFSET + LC_YUV2RGB_CLIP                    ) // 0xf9
#define SRSHARP0_LC_RGB2YUV_OFST                (SRSHARP0_OFFSET + LC_RGB2YUV_OFST                    ) // 0xfa
#define SRSHARP0_LC_RGB2YUV_CLIP                (SRSHARP0_OFFSET + LC_RGB2YUV_CLIP                    ) // 0xfb
#define SRSHARP0_LC_MAP_RAM_CTRL                (SRSHARP0_OFFSET + LC_MAP_RAM_CTRL                    ) // 0xfc
#define SRSHARP0_LC_MAP_RAM_ADDR                (SRSHARP0_OFFSET + LC_MAP_RAM_ADDR                    ) // 0xfd
#define SRSHARP0_LC_MAP_RAM_DATA                (SRSHARP0_OFFSET + LC_MAP_RAM_DATA                    ) // 0xfe

#define SRSHARP0_FMETER_CTRL                    (SRSHARP0_OFFSET +  SHARP_FMETER_CTRL                 ) // 0x89
#define SRSHARP0_FMETER_WIN_HOR                 (SRSHARP0_OFFSET +  SHARP_FMETER_WIN_HOR              ) // 0x8a
#define SRSHARP0_FMETER_WIN_VER                 (SRSHARP0_OFFSET +  SHARP_FMETER_WIN_VER              ) // 0x8b
#define SRSHARP0_FMETER_CORING                  (SRSHARP0_OFFSET +  SHARP_FMETER_CORING               ) // 0x8c
#define SRSHARP0_FMETER_RATIO_H                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_H              ) // 0x8d
#define SRSHARP0_FMETER_RATIO_V                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_V              ) // 0x8e
#define SRSHARP0_FMETER_RATIO_D                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_D              ) // 0x8f
#define SRSHARP0_RO_FMETER_HCNT_TYPE0           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE0        ) // 0x46
#define SRSHARP0_RO_FMETER_HCNT_TYPE1           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE1        ) // 0x47
#define SRSHARP0_RO_FMETER_HCNT_TYPE2           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE2        ) // 0x48
#define SRSHARP0_RO_FMETER_HCNT_TYPE3           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE3        ) // 0x49
#define SRSHARP0_RO_FMETER_VCNT_TYPE0           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE0        ) // 0x4a
#define SRSHARP0_RO_FMETER_VCNT_TYPE1           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE1        ) // 0x4b
#define SRSHARP0_RO_FMETER_VCNT_TYPE2           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE2        ) // 0x4c
#define SRSHARP0_RO_FMETER_VCNT_TYPE3           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE3        ) // 0x4d
#define SRSHARP0_RO_FMETER_PDCNT_TYPE0          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE0       ) // 0x4e
#define SRSHARP0_RO_FMETER_PDCNT_TYPE1          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE1       ) // 0x4f
#define SRSHARP0_RO_FMETER_PDCNT_TYPE2          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE2       ) // 0x50
#define SRSHARP0_RO_FMETER_PDCNT_TYPE3          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE3       ) // 0x51
#define SRSHARP0_RO_FMETER_NDCNT_TYPE0          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE0       ) // 0x52
#define SRSHARP0_RO_FMETER_NDCNT_TYPE1          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE1       ) // 0x53
#define SRSHARP0_RO_FMETER_NDCNT_TYPE2          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE2       ) // 0x54
#define SRSHARP0_RO_FMETER_NDCNT_TYPE3          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE3       ) // 0x55





//// srsharp1 reg define

#define SRSHARP1_SHARP_HVSIZE                      (SRSHARP1_OFFSET + SHARP_HVSIZE                 )  //0x00  //
#define SRSHARP1_SHARP_HVBLANK_NUM                 (SRSHARP1_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
#define SRSHARP1_NR_GAUSSIAN_MODE                  (SRSHARP1_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
#define SRSHARP1_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
#define SRSHARP1_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
#define SRSHARP1_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
#define SRSHARP1_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
#define SRSHARP1_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
#define SRSHARP1_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
#define SRSHARP1_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
#define SRSHARP1_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
#define SRSHARP1_PK_CIRFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
#define SRSHARP1_PK_DRTFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
#define SRSHARP1_PK_CIRFB_HP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
#define SRSHARP1_PK_CIRFB_BP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
#define SRSHARP1_PK_DRTFB_HP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
#define SRSHARP1_PK_DRTFB_BP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
#define SRSHARP1_PK_CIRFB_BLEND_GAIN               (SRSHARP1_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
#define SRSHARP1_NR_ALPY_SSD_GAIN_OFST             (SRSHARP1_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
#define SRSHARP1_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
#define SRSHARP1_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
#define SRSHARP1_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
#define SRSHARP1_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
#define SRSHARP1_NR_ALP0_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
#define SRSHARP1_NR_ALP1_MIERR_CORING              (SRSHARP1_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
#define SRSHARP1_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
#define SRSHARP1_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
#define SRSHARP1_NR_ALP1_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
#define SRSHARP1_PK_ALP2_MIERR_CORING              (SRSHARP1_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
#define SRSHARP1_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
#define SRSHARP1_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
#define SRSHARP1_PK_ALP2_MIN_MAX                   (SRSHARP1_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
#define SRSHARP1_PK_FINALGAIN_HP_BP                (SRSHARP1_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
#define SRSHARP1_PK_OS_HORZ_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
#define SRSHARP1_PK_OS_VERT_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
#define SRSHARP1_PK_OS_ADPT_MISC                   (SRSHARP1_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
#define SRSHARP1_PK_OS_STATIC                      (SRSHARP1_OFFSET + PK_OS_STATIC                 )  //0x26  //
#define SRSHARP1_PK_NR_ENABLE                      (SRSHARP1_OFFSET + PK_NR_ENABLE                 )  //0x27  //
#define SRSHARP1_PK_DRT_SAD_MISC                   (SRSHARP1_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
#define SRSHARP1_NR_TI_DNLP_BLEND                  (SRSHARP1_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
#define SRSHARP1_LTI_DIR_CORE_ALPHA                (SRSHARP1_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
#define SRSHARP1_CTI_DIR_ALPHA                     (SRSHARP1_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
#define SRSHARP1_LTI_CTI_DF_GAIN                   (SRSHARP1_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
#define SRSHARP1_LTI_CTI_DIR_AC_DBG                (SRSHARP1_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
#define SRSHARP1_HCTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
#define SRSHARP1_HCTI_BST_GAIN                     (SRSHARP1_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
#define SRSHARP1_HCTI_BST_CORE                     (SRSHARP1_OFFSET + HCTI_BST_CORE                )  //0x30  //
#define SRSHARP1_HCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
#define SRSHARP1_HCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
#define SRSHARP1_HCTI_OS_MARGIN                    (SRSHARP1_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
#define SRSHARP1_HLTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
#define SRSHARP1_HLTI_BST_GAIN                     (SRSHARP1_OFFSET + HLTI_BST_GAIN                )  //0x35  //
#define SRSHARP1_HLTI_BST_CORE                     (SRSHARP1_OFFSET + HLTI_BST_CORE                )  //0x36  //
#define SRSHARP1_HLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
#define SRSHARP1_HLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
#define SRSHARP1_HLTI_OS_MARGIN                    (SRSHARP1_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
#define SRSHARP1_VLTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
#define SRSHARP1_VLTI_BST_GAIN                     (SRSHARP1_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
#define SRSHARP1_VLTI_BST_CORE                     (SRSHARP1_OFFSET + VLTI_BST_CORE                )  //0x3c  //
#define SRSHARP1_VLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
#define SRSHARP1_VLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
#define SRSHARP1_VCTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
#define SRSHARP1_VCTI_BST_GAIN                     (SRSHARP1_OFFSET + VCTI_BST_GAIN                )  //0x40  //
#define SRSHARP1_VCTI_BST_CORE                     (SRSHARP1_OFFSET + VCTI_BST_CORE                )  //0x41  //
#define SRSHARP1_VCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
#define SRSHARP1_VCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
#define SRSHARP1_SHARP_3DLIMIT                     (SRSHARP1_OFFSET + SHARP_3DLIMIT                )  //0x44  //
#define SRSHARP1_DNLP_EN                           (SRSHARP1_OFFSET + DNLP_EN                      )  //0x45  //
//`define SRSHARP1_DNLP_00                           (`SRSHARP1_OFFSET + `DNLP_00                      )  //8'h46  //
//`define SRSHARP1_DNLP_01                           (`SRSHARP1_OFFSET + `DNLP_01                      )  //8'h47  //
//`define SRSHARP1_DNLP_02                           (`SRSHARP1_OFFSET + `DNLP_02                      )  //8'h48  //
//`define SRSHARP1_DNLP_03                           (`SRSHARP1_OFFSET + `DNLP_03                      )  //8'h49  //
//`define SRSHARP1_DNLP_04                           (`SRSHARP1_OFFSET + `DNLP_04                      )  //8'h4a  //
//`define SRSHARP1_DNLP_05                           (`SRSHARP1_OFFSET + `DNLP_05                      )  //8'h4b  //
//`define SRSHARP1_DNLP_06                           (`SRSHARP1_OFFSET + `DNLP_06                      )  //8'h4c  //
//`define SRSHARP1_DNLP_07                           (`SRSHARP1_OFFSET + `DNLP_07                      )  //8'h4d  //
//`define SRSHARP1_DNLP_08                           (`SRSHARP1_OFFSET + `DNLP_08                      )  //8'h4e  //
//`define SRSHARP1_DNLP_09                           (`SRSHARP1_OFFSET + `DNLP_09                      )  //8'h4f  //
//`define SRSHARP1_DNLP_10                           (`SRSHARP1_OFFSET + `DNLP_10                      )  //8'h50  //
//`define SRSHARP1_DNLP_11                           (`SRSHARP1_OFFSET + `DNLP_11                      )  //8'h51  //
//`define SRSHARP1_DNLP_12                           (`SRSHARP1_OFFSET + `DNLP_12                      )  //8'h52  //
//`define SRSHARP1_DNLP_13                           (`SRSHARP1_OFFSET + `DNLP_13                      )  //8'h53  //
//`define SRSHARP1_DNLP_14                           (`SRSHARP1_OFFSET + `DNLP_14                      )  //8'h54  //
//`define SRSHARP1_DNLP_15                           (`SRSHARP1_OFFSET + `DNLP_15                      )  //8'h55  //
#define SRSHARP1_DEMO_CRTL                         (SRSHARP1_OFFSET + DEMO_CRTL                    )  //0x56  //
#define SRSHARP1_SHARP_SR2_CTRL                    (SRSHARP1_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
#define SRSHARP1_SHARP_SR2_YBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
#define SRSHARP1_SHARP_SR2_YBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
#define SRSHARP1_SHARP_SR2_CBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
#define SRSHARP1_SHARP_SR2_CBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
#define SRSHARP1_SHARP_SR2_YBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
#define SRSHARP1_SHARP_SR2_YBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
#define SRSHARP1_SHARP_SR2_CBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
#define SRSHARP1_SHARP_SR2_CBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
#define SRSHARP1_SHARP_SR2_MISC                    (SRSHARP1_OFFSET + SHARP_SR2_MISC               )  //0x60  //
#define SRSHARP1_SR3_SAD_CTRL                   (SRSHARP1_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
#define SRSHARP1_SR3_PK_CTRL0                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
#define SRSHARP1_SR3_PK_CTRL1                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
#define SRSHARP1_DEJ_CTRL                       (SRSHARP1_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
#define SRSHARP1_DEJ_ALPHA                      (SRSHARP1_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
#define SRSHARP1_SR3_DRTLPF_EN                  (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
#define SRSHARP1_SR3_DRTLPF_ALPHA_0             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
#define SRSHARP1_SR3_DRTLPF_ALPHA_1             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
#define SRSHARP1_SR3_DRTLPF_ALPHA_2             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
#define SRSHARP1_SR3_DRTLPF_ALPHA_OFST          (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
#define SRSHARP1_SR3_DERING_CTRL                (SRSHARP1_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
#define SRSHARP1_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
#define SRSHARP1_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
#define SRSHARP1_SR3_DERING_GAINVS_MADSAD       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
#define SRSHARP1_SR3_DERING_GAINVS_VR2MAX       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
#define SRSHARP1_SR3_DERING_PARAM0              (SRSHARP1_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
#define SRSHARP1_SR3_DRTLPF_THETA               (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
#define SRSHARP1_SATPRT_CTRL                    (SRSHARP1_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
#define SRSHARP1_SATPRT_DIVM                    (SRSHARP1_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
#define SRSHARP1_DB_FLT_CTRL                    (SRSHARP1_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
//`define SRSHARP1_DB_FLT_YC_THRD               (`SRSHARP1_OFFSET + `SHARP_DB_FLT_YC_THRD               ) // 8'h78
#define SRSHARP1_DB_FLT_CTRL1                   (SRSHARP1_OFFSET + SHARP_DB_FLT_CTRL1                 ) // 0xb8
#define SRSHARP1_DB_FLT_LUMA_THRD               (SRSHARP1_OFFSET + SHARP_DB_FLT_LUMA_THRD             ) // 0xb9
#define SRSHARP1_DB_FLT_CHRM_THRD               (SRSHARP1_OFFSET + SHARP_DB_FLT_CHRM_THRD             ) // 0xba
#define SRSHARP1_DB_FLT_RANDLUT                 (SRSHARP1_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
#define SRSHARP1_DB_FLT_PXI_THRD                (SRSHARP1_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
#define SRSHARP1_DB_FLT_SEED_Y                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
#define SRSHARP1_DB_FLT_SEED_U                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
#define SRSHARP1_DB_FLT_SEED_V                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
#define SRSHARP1_PKGAIN_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x7e
#define SRSHARP1_PKGAIN_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x7f
#define SRSHARP1_PKOSHT_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x80
#define SRSHARP1_PKOSHT_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x81
#define SRSHARP1_SATPRT_LMT_RGB1                (SRSHARP1_OFFSET + SHARP_SATPRT_LMT_RGB1              ) // 0x82
#define SRSHARP1_SATPRT_LMT_RGB2                (SRSHARP1_OFFSET + SHARP_SATPRT_LMT_RGB2              ) // 0x83
#define SRSHARP1_SHARP_GATE_CLK_CTRL_0          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_0              ) // 0x84
#define SRSHARP1_SHARP_GATE_CLK_CTRL_1          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_1              ) // 0x85
#define SRSHARP1_SHARP_GATE_CLK_CTRL_2          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_2              ) // 0x86
#define SRSHARP1_SHARP_GATE_CLK_CTRL_3          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_3              ) // 0x87
#define SRSHARP1_SHARP_DPS_CTRL                 (SRSHARP1_OFFSET + SHARP_DPS_CTRL                     ) // 0x88
#define SRSHARP1_DNLP_00                        (SRSHARP1_OFFSET + DNLP_00                            ) // 0x90  //
#define SRSHARP1_DNLP_01                        (SRSHARP1_OFFSET + DNLP_01                            ) // 0x91  //
#define SRSHARP1_DNLP_02                        (SRSHARP1_OFFSET + DNLP_02                            ) // 0x92  //
#define SRSHARP1_DNLP_03                        (SRSHARP1_OFFSET + DNLP_03                            ) // 0x93  //
#define SRSHARP1_DNLP_04                        (SRSHARP1_OFFSET + DNLP_04                            ) // 0x94  //
#define SRSHARP1_DNLP_05                        (SRSHARP1_OFFSET + DNLP_05                            ) // 0x95  //
#define SRSHARP1_DNLP_06                        (SRSHARP1_OFFSET + DNLP_06                            ) // 0x96  //
#define SRSHARP1_DNLP_07                        (SRSHARP1_OFFSET + DNLP_07                            ) // 0x97  //
#define SRSHARP1_DNLP_08                        (SRSHARP1_OFFSET + DNLP_08                            ) // 0x98  //
#define SRSHARP1_DNLP_09                        (SRSHARP1_OFFSET + DNLP_09                            ) // 0x99  //
#define SRSHARP1_DNLP_10                        (SRSHARP1_OFFSET + DNLP_10                            ) // 0x9a  //
#define SRSHARP1_DNLP_11                        (SRSHARP1_OFFSET + DNLP_11                            ) // 0x9b  //
#define SRSHARP1_DNLP_12                        (SRSHARP1_OFFSET + DNLP_12                            ) // 0x9c  //
#define SRSHARP1_DNLP_13                        (SRSHARP1_OFFSET + DNLP_13                            ) // 0x9d  //
#define SRSHARP1_DNLP_14                        (SRSHARP1_OFFSET + DNLP_14                            ) // 0x9e  //
#define SRSHARP1_DNLP_15                        (SRSHARP1_OFFSET + DNLP_15                            ) // 0x9f  //
#define SRSHARP1_DNLP_16                        (SRSHARP1_OFFSET + DNLP_16                            ) // 0xa0  //
#define SRSHARP1_DNLP_17                        (SRSHARP1_OFFSET + DNLP_17                            ) // 0xa1  //
#define SRSHARP1_DNLP_18                        (SRSHARP1_OFFSET + DNLP_18                            ) // 0xa2  //
#define SRSHARP1_DNLP_19                        (SRSHARP1_OFFSET + DNLP_19                            ) // 0xa3  //
#define SRSHARP1_DNLP_20                        (SRSHARP1_OFFSET + DNLP_20                            ) // 0xa4  //
#define SRSHARP1_DNLP_21                        (SRSHARP1_OFFSET + DNLP_21                            ) // 0xa5  //
#define SRSHARP1_DNLP_22                        (SRSHARP1_OFFSET + DNLP_22                            ) // 0xa6  //
#define SRSHARP1_DNLP_23                        (SRSHARP1_OFFSET + DNLP_23                            ) // 0xa7  //
#define SRSHARP1_DNLP_24                        (SRSHARP1_OFFSET + DNLP_24                            ) // 0xa8  //
#define SRSHARP1_DNLP_25                        (SRSHARP1_OFFSET + DNLP_25                            ) // 0xa9  //
#define SRSHARP1_DNLP_26                        (SRSHARP1_OFFSET + DNLP_26                            ) // 0xaa  //
#define SRSHARP1_DNLP_27                        (SRSHARP1_OFFSET + DNLP_27                            ) // 0xab  //
#define SRSHARP1_DNLP_28                        (SRSHARP1_OFFSET + DNLP_28                            ) // 0xac  //
#define SRSHARP1_DNLP_29                        (SRSHARP1_OFFSET + DNLP_29                            ) // 0xad  //
#define SRSHARP1_DNLP_30                        (SRSHARP1_OFFSET + DNLP_30                            ) // 0xae  //
#define SRSHARP1_DNLP_31                        (SRSHARP1_OFFSET + DNLP_31                            ) // 0xaf  //
#define SRSHARP1_SHARP_SYNC_CTRL                (SRSHARP1_OFFSET + SHARP_SYNC_CTRL                    ) // 0xb0  //
#define SRSHARP1_LC_INPUT_MUX                   (SRSHARP1_OFFSET + LC_INPUT_MUX                       ) // 0xb1  //
#define SRSHARP1_NR_GAU_YH_COEF02               (SRSHARP1_OFFSET + NR_GAU_YH_COEF02                   ) // 0xb2  //
#define SRSHARP1_NR_GAU_YH_COEF34               (SRSHARP1_OFFSET + NR_GAU_YH_COEF34                   ) // 0xb3  //
#define SRSHARP1_NR_GAU_YV_COEF1                (SRSHARP1_OFFSET + NR_GAU_YV_COEF1                    ) // 0xb4  //
#define SRSHARP1_NR_GAU_CH_COEF02               (SRSHARP1_OFFSET + NR_GAU_CH_COEF02                   ) // 0xb5  //
#define SRSHARP1_NR_GAU_CH_COEF34               (SRSHARP1_OFFSET + NR_GAU_CH_COEF34                   ) // 0xb6  //
#define SRSHARP1_NR_GAU_CV_COEF1                (SRSHARP1_OFFSET + NR_GAU_CV_COEF1                    ) // 0xb7  //
#define SRSHARP1_LC_TOP_CTRL                    (SRSHARP1_OFFSET + LC_TOP_CTRL                        ) // 0xc0  //
#define SRSHARP1_LC_HV_NUM                      (SRSHARP1_OFFSET + LC_HV_NUM                          ) // 0xc1
#define SRSHARP1_LC_SAT_LUT_0_1                 (SRSHARP1_OFFSET + LC_SAT_LUT_0_1                     ) // 0xc2
#define SRSHARP1_LC_SAT_LUT_2_3                 (SRSHARP1_OFFSET + LC_SAT_LUT_2_3                     ) // 0xc3
#define SRSHARP1_LC_SAT_LUT_4_5                 (SRSHARP1_OFFSET + LC_SAT_LUT_4_5                     ) // 0xc4
#define SRSHARP1_LC_SAT_LUT_6_7                 (SRSHARP1_OFFSET + LC_SAT_LUT_6_7                     ) // 0xc5
#define SRSHARP1_LC_SAT_LUT_8_9                 (SRSHARP1_OFFSET + LC_SAT_LUT_8_9                     ) // 0xc6
#define SRSHARP1_LC_SAT_LUT_10_11               (SRSHARP1_OFFSET + LC_SAT_LUT_10_11                   ) // 0xc7
#define SRSHARP1_LC_SAT_LUT_12_13               (SRSHARP1_OFFSET + LC_SAT_LUT_12_13                   ) // 0xc8
#define SRSHARP1_LC_SAT_LUT_14_15               (SRSHARP1_OFFSET + LC_SAT_LUT_14_15                   ) // 0xc9
#define SRSHARP1_LC_SAT_LUT_16_17               (SRSHARP1_OFFSET + LC_SAT_LUT_16_17                   ) // 0xca
#define SRSHARP1_LC_SAT_LUT_18_19               (SRSHARP1_OFFSET + LC_SAT_LUT_18_19                   ) // 0xcb
#define SRSHARP1_LC_SAT_LUT_20_21               (SRSHARP1_OFFSET + LC_SAT_LUT_20_21                   ) // 0xcc
#define SRSHARP1_LC_SAT_LUT_22_23               (SRSHARP1_OFFSET + LC_SAT_LUT_22_23                   ) // 0xcd
#define SRSHARP1_LC_SAT_LUT_24_25               (SRSHARP1_OFFSET + LC_SAT_LUT_24_25                   ) // 0xce
#define SRSHARP1_LC_SAT_LUT_26_27               (SRSHARP1_OFFSET + LC_SAT_LUT_26_27                   ) // 0xcf
#define SRSHARP1_LC_SAT_LUT_28_29               (SRSHARP1_OFFSET + LC_SAT_LUT_28_29                   ) // 0xd0
#define SRSHARP1_LC_SAT_LUT_30_31               (SRSHARP1_OFFSET + LC_SAT_LUT_30_31                   ) // 0xd1
#define SRSHARP1_LC_SAT_LUT_32_33               (SRSHARP1_OFFSET + LC_SAT_LUT_32_33                   ) // 0xd2
#define SRSHARP1_LC_SAT_LUT_34_35               (SRSHARP1_OFFSET + LC_SAT_LUT_34_35                   ) // 0xd3
#define SRSHARP1_LC_SAT_LUT_36_37               (SRSHARP1_OFFSET + LC_SAT_LUT_36_37                   ) // 0xd4
#define SRSHARP1_LC_SAT_LUT_38_39               (SRSHARP1_OFFSET + LC_SAT_LUT_38_39                   ) // 0xd5
#define SRSHARP1_LC_SAT_LUT_40_41               (SRSHARP1_OFFSET + LC_SAT_LUT_40_41                   ) // 0xd6
#define SRSHARP1_LC_SAT_LUT_42_43               (SRSHARP1_OFFSET + LC_SAT_LUT_42_43                   ) // 0xd7
#define SRSHARP1_LC_SAT_LUT_44_45               (SRSHARP1_OFFSET + LC_SAT_LUT_44_45                   ) // 0xd8
#define SRSHARP1_LC_SAT_LUT_46_47               (SRSHARP1_OFFSET + LC_SAT_LUT_46_47                   ) // 0xd9
#define SRSHARP1_LC_SAT_LUT_48_49               (SRSHARP1_OFFSET + LC_SAT_LUT_48_49                   ) // 0xda
#define SRSHARP1_LC_SAT_LUT_50_51               (SRSHARP1_OFFSET + LC_SAT_LUT_50_51                   ) // 0xdb
#define SRSHARP1_LC_SAT_LUT_52_53               (SRSHARP1_OFFSET + LC_SAT_LUT_52_53                   ) // 0xdc
#define SRSHARP1_LC_SAT_LUT_54_55               (SRSHARP1_OFFSET + LC_SAT_LUT_54_55                   ) // 0xdd
#define SRSHARP1_LC_SAT_LUT_56_57               (SRSHARP1_OFFSET + LC_SAT_LUT_56_57                   ) // 0xde
#define SRSHARP1_LC_SAT_LUT_58_59               (SRSHARP1_OFFSET + LC_SAT_LUT_58_59                   ) // 0xdf
#define SRSHARP1_LC_SAT_LUT_60_61               (SRSHARP1_OFFSET + LC_SAT_LUT_60_61                   ) // 0xe0
#define SRSHARP1_LC_SAT_LUT_62                  (SRSHARP1_OFFSET + LC_SAT_LUT_62                      ) // 0xe1
#define SRSHARP1_LC_CURVE_BLK_HIDX_0_1          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_0_1              ) // 0xe2
#define SRSHARP1_LC_CURVE_BLK_HIDX_2_3          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_2_3              ) // 0xe3
#define SRSHARP1_LC_CURVE_BLK_HIDX_4_5          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_4_5              ) // 0xe4
#define SRSHARP1_LC_CURVE_BLK_HIDX_6_7          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_6_7              ) // 0xe5
#define SRSHARP1_LC_CURVE_BLK_HIDX_8_9          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_8_9              ) // 0xe6
#define SRSHARP1_LC_CURVE_BLK_HIDX_10_11        (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_10_11            ) // 0xe7
#define SRSHARP1_LC_CURVE_BLK_HIDX_12           (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_12               ) // 0xe8
#define SRSHARP1_LC_CURVE_BLK_VIDX_0_1          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_0_1              ) // 0xe9
#define SRSHARP1_LC_CURVE_BLK_VIDX_2_3          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_2_3              ) // 0xea
#define SRSHARP1_LC_CURVE_BLK_VIDX_4_5          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_4_5              ) // 0xeb
#define SRSHARP1_LC_CURVE_BLK_VIDX_6_7          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_6_7              ) // 0xec
#define SRSHARP1_LC_CURVE_BLK_VIDX_8            (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_8                ) // 0xed
#define SRSHARP1_LC_YUV2RGB_MAT_0_1             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_0_1                 ) // 0xee
#define SRSHARP1_LC_YUV2RGB_MAT_2_3             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_2_3                 ) // 0xef
#define SRSHARP1_LC_YUV2RGB_MAT_4_5             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_4_5                 ) // 0xf0
#define SRSHARP1_LC_YUV2RGB_MAT_6_7             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_6_7                 ) // 0xf1
#define SRSHARP1_LC_YUV2RGB_MAT_8               (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_8                   ) // 0xf2
#define SRSHARP1_LC_RGB2YUV_MAT_0_1             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_0_1                 ) // 0xf3
#define SRSHARP1_LC_RGB2YUV_MAT_2_3             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_2_3                 ) // 0xf4
#define SRSHARP1_LC_RGB2YUV_MAT_4_5             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_4_5                 ) // 0xf5
#define SRSHARP1_LC_RGB2YUV_MAT_6_7             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_6_7                 ) // 0xf6
#define SRSHARP1_LC_RGB2YUV_MAT_8               (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_8                   ) // 0xf7
#define SRSHARP1_LC_YUV2RGB_OFST                (SRSHARP1_OFFSET + LC_YUV2RGB_OFST                    ) // 0xf8
#define SRSHARP1_LC_YUV2RGB_CLIP                (SRSHARP1_OFFSET + LC_YUV2RGB_CLIP                    ) // 0xf9
#define SRSHARP1_LC_RGB2YUV_OFST                (SRSHARP1_OFFSET + LC_RGB2YUV_OFST                    ) // 0xfa
#define SRSHARP1_LC_RGB2YUV_CLIP                (SRSHARP1_OFFSET + LC_RGB2YUV_CLIP                    ) // 0xfb
#define SRSHARP1_LC_MAP_RAM_CTRL                (SRSHARP1_OFFSET + LC_MAP_RAM_CTRL                    ) // 0xfc
#define SRSHARP1_LC_MAP_RAM_ADDR                (SRSHARP1_OFFSET + LC_MAP_RAM_ADDR                    ) // 0xfd
#define SRSHARP1_LC_MAP_RAM_DATA                (SRSHARP1_OFFSET + LC_MAP_RAM_DATA                    ) // 0xfe

#define SRSHARP1_FMETER_CTRL                    (SRSHARP1_OFFSET +  SHARP_FMETER_CTRL                 ) // 0x89
#define SRSHARP1_FMETER_WIN_HOR                 (SRSHARP1_OFFSET +  SHARP_FMETER_WIN_HOR              ) // 0x8a
#define SRSHARP1_FMETER_WIN_VER                 (SRSHARP1_OFFSET +  SHARP_FMETER_WIN_VER              ) // 0x8b
#define SRSHARP1_FMETER_CORING                  (SRSHARP1_OFFSET +  SHARP_FMETER_CORING               ) // 0x8c
#define SRSHARP1_FMETER_RATIO_H                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_H              ) // 0x8d
#define SRSHARP1_FMETER_RATIO_V                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_V              ) // 0x8e
#define SRSHARP1_FMETER_RATIO_D                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_D              ) // 0x8f
#define SRSHARP1_RO_FMETER_HCNT_TYPE0           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE0        ) // 0x46
#define SRSHARP1_RO_FMETER_HCNT_TYPE1           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE1        ) // 0x47
#define SRSHARP1_RO_FMETER_HCNT_TYPE2           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE2        ) // 0x48
#define SRSHARP1_RO_FMETER_HCNT_TYPE3           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE3        ) // 0x49
#define SRSHARP1_RO_FMETER_VCNT_TYPE0           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE0        ) // 0x4a
#define SRSHARP1_RO_FMETER_VCNT_TYPE1           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE1        ) // 0x4b
#define SRSHARP1_RO_FMETER_VCNT_TYPE2           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE2        ) // 0x4c
#define SRSHARP1_RO_FMETER_VCNT_TYPE3           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE3        ) // 0x4d
#define SRSHARP1_RO_FMETER_PDCNT_TYPE0          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE0       ) // 0x4e
#define SRSHARP1_RO_FMETER_PDCNT_TYPE1          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE1       ) // 0x4f
#define SRSHARP1_RO_FMETER_PDCNT_TYPE2          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE2       ) // 0x50
#define SRSHARP1_RO_FMETER_PDCNT_TYPE3          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE3       ) // 0x51
#define SRSHARP1_RO_FMETER_NDCNT_TYPE0          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE0       ) // 0x52
#define SRSHARP1_RO_FMETER_NDCNT_TYPE1          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE1       ) // 0x53
#define SRSHARP1_RO_FMETER_NDCNT_TYPE2          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE2       ) // 0x54
#define SRSHARP1_RO_FMETER_NDCNT_TYPE3          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE3       ) // 0x55



// synopsys translate_off
// synopsys translate_on
//
// Closing file:  srsharp_regs.h
//
// -----------------------------------------------
// REG_BASE:  VPPE_VCBUS_BASE = 0x51
// -----------------------------------------------
// 8'h50/51/52/53  have used  for srsharp_regs
//
// Reading file:  srsharp_regs2.h
//
// synopsys translate_off
// synopsys translate_on
//SRSHARP0        8'h00  - 8'hff
//SRSHARP1        8'h100 - 8'1ff
#define  SRSHARP0_OFFSET   (0x000<<2)
#define  SRSHARP1_OFFSET   (0x200<<2)

//
// Reading file:  sharp_regs2.h
//
// synopsys translate_off
// synopsys translate_on
#define P_SR7_DRTLPF_EN                            (volatile uint32_t *)0xff014400
//Bit 31:11,        reserved
//Bit 10,            reg_sr7_drtlpf_beta_en2                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  9,            reg_sr7_drtlpf_beta_en1                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  8,            reg_sr7_drtlpf_beta_en0                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5,            reg_sr7_drtlpf_edge_en2                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  4,            reg_sr7_drtlpf_edge_en1                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  3,            reg_sr7_drtlpf_edge_en0                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  2,            reg_sr7_drtlpf_sdfd_en2                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
//Bit  1,            reg_sr7_drtlpf_sdfd_en1                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
//Bit  0,            reg_sr7_drtlpf_sdfd_en0                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
#define P_SR7_DRTLPF_BETA                          (volatile uint32_t *)0xff014404
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_drtlpf_beta3                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_drtlpf_beta2                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_drtlpf_beta1                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_drtlpf_beta0                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 15
#define P_SR7_PKBLD_BETA                           (volatile uint32_t *)0xff014408
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pkdrtbld_beta3                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_pkdrtbld_beta2                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pkdrtbld_beta1                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_pkdrtbld_beta0                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 15
#define P_SR7_XLTIBLD_BETA                         (volatile uint32_t *)0xff01440c
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_xlti_dcbld_beta3                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_xlti_dcbld_beta2                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_xlti_dcbld_beta1                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_xlti_dcbld_beta0                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 15
#define P_SR7_DRTLPF_EDGE0                         (volatile uint32_t *)0xff014410
//Bit 31:28,        reg_sr7_drtlpf_edge7                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_edge6                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_edge5                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_edge4                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_edge3                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_edge2                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_edge1                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_edge0                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
#define P_SR7_DRTLPF_EDGE1                         (volatile uint32_t *)0xff014414
//Bit 31:28,        reg_sr7_drtlpf_edge15                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_edge14                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_edge13                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_edge12                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_edge11                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_edge10                       : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_edge9                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_edge8                        : edge lambda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
#define P_SR7_DRTLPF_SDCOR0                        (volatile uint32_t *)0xff014418
//Bit 31:28,        reg_sr7_drtlpf_sdcor7                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_sdcor6                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_sdcor5                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_sdcor4                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_sdcor3                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_sdcor2                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_sdcor1                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_sdcor0                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_DRTLPF_SDCOR1                        (volatile uint32_t *)0xff01441c
//Bit 31:28,        reg_sr7_drtlpf_sdcor15                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_sdcor14                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_sdcor13                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_sdcor12                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_sdcor11                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_sdcor10                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_sdcor9                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_sdcor8                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_CTIGAIN_SDCOR0                       (volatile uint32_t *)0xff014420
//Bit 31:28,        reg_sr7_ctigain_sdcor7                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ctigain_sdcor6                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ctigain_sdcor5                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ctigain_sdcor4                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ctigain_sdcor3                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ctigain_sdcor2                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ctigain_sdcor1                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ctigain_sdcor0                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_CTIGAIN_SDCOR1                       (volatile uint32_t *)0xff014424
//Bit 31:28,        reg_sr7_ctigain_sdcor15                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ctigain_sdcor14                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ctigain_sdcor13                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ctigain_sdcor12                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ctigain_sdcor11                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ctigain_sdcor10                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ctigain_sdcor9                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ctigain_sdcor8                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_LTIGAIN_SDCOR0                       (volatile uint32_t *)0xff014428
//Bit 31:28,        reg_sr7_ltigain_sdcor7                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ltigain_sdcor6                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ltigain_sdcor5                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ltigain_sdcor4                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ltigain_sdcor3                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ltigain_sdcor2                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ltigain_sdcor1                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ltigain_sdcor0                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_LTIGAIN_SDCOR1                       (volatile uint32_t *)0xff01442c
//Bit 31:28,        reg_sr7_ltigain_sdcor15                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ltigain_sdcor14                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ltigain_sdcor13                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ltigain_sdcor12                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ltigain_sdcor11                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ltigain_sdcor10                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ltigain_sdcor9                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ltigain_sdcor8                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define P_SR7_HLTIBPF_TAP0                         (volatile uint32_t *)0xff014430
//Bit 31:24,        reg_sr7_hlti_bpf_tap153                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_hlti_bpf_tap152                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -34
//Bit 15: 8,        reg_sr7_hlti_bpf_tap151                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_hlti_bpf_tap150                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 120
#define P_SR7_HLTIBPF_TAP1                         (volatile uint32_t *)0xff014434
//Bit 31:24,        reg_sr7_hlti_bpf_tap157                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 2
//Bit 23:16,        reg_sr7_hlti_bpf_tap156                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -7
//Bit 15: 8,        reg_sr7_hlti_bpf_tap155                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 1
//Bit  7: 0,        reg_sr7_hlti_bpf_tap154                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -21
#define P_SR7_HCTIBPF_TAP0                         (volatile uint32_t *)0xff014438
//Bit 31:24,        reg_sr7_hcti_bpf_tap153                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_hcti_bpf_tap152                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -34
//Bit 15: 8,        reg_sr7_hcti_bpf_tap151                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_hcti_bpf_tap150                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 120
#define P_SR7_HCTIBPF_TAP1                         (volatile uint32_t *)0xff01443c
//Bit 31:24,        reg_sr7_hcti_bpf_tap157                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 2
//Bit 23:16,        reg_sr7_hcti_bpf_tap156                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -7
//Bit 15: 8,        reg_sr7_hcti_bpf_tap155                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 1
//Bit  7: 0,        reg_sr7_hcti_bpf_tap154                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -21
#define P_SR7_PKLONGBPF_HTAP0                      (volatile uint32_t *)0xff014440
//Bit 31:24,        reg_sr7_pk_long_bpf_hztap153                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -24
//Bit 23:16,        reg_sr7_pk_long_bpf_hztap152                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -19
//Bit 15: 8,        reg_sr7_pk_long_bpf_hztap151                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 31
//Bit  7: 0,        reg_sr7_pk_long_bpf_hztap150                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 66
#define P_SR7_PKLONGBPF_HTAP1                      (volatile uint32_t *)0xff014444
//Bit 31:24,        reg_sr7_pk_long_bpf_hztap157                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -6
//Bit 23:16,        reg_sr7_pk_long_bpf_hztap156                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -10
//Bit 15: 8,        reg_sr7_pk_long_bpf_hztap155                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_pk_long_bpf_hztap154                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -4
#define P_SR7_PKLONGHPF_HTAP0                      (volatile uint32_t *)0xff014448
//Bit 31:24,        reg_sr7_pk_long_hpf_hztap153                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 27
//Bit 23:16,        reg_sr7_pk_long_hpf_hztap152                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -15
//Bit 15: 8,        reg_sr7_pk_long_hpf_hztap151                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -32
//Bit  7: 0,        reg_sr7_pk_long_hpf_hztap150                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 58
#define P_SR7_PKLONGHPF_HTAP1                      (volatile uint32_t *)0xff01444c
//Bit 31:24,        reg_sr7_pk_long_hpf_hztap157                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 8
//Bit 23:16,        reg_sr7_pk_long_hpf_hztap156                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -6
//Bit 15: 8,        reg_sr7_pk_long_hpf_hztap155                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_pk_long_hpf_hztap154                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -10
#define P_SR7_VLTIBPF_TAP0                         (volatile uint32_t *)0xff014450
//Bit 31:24,        reg_sr7_vlti_bpf_tap093                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_vlti_bpf_tap092                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -41
//Bit 15: 8,        reg_sr7_vlti_bpf_tap091                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit  7: 0,        reg_sr7_vlti_bpf_tap090                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 126
#define P_SR7_VLTIBPF_TAP1                         (volatile uint32_t *)0xff014454
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_vlti_bpf_tap094                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -22
#define P_SR7_VCTIBPF_TAP0                         (volatile uint32_t *)0xff014458
//Bit 31:24,        reg_sr7_vcti_bpf_tap093                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_vcti_bpf_tap092                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -41
//Bit 15: 8,        reg_sr7_vcti_bpf_tap091                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit  7: 0,        reg_sr7_vcti_bpf_tap090                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 126
#define P_SR7_VCTIBPF_TAP1                         (volatile uint32_t *)0xff01445c
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_vcti_bpf_tap094                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -22
#define P_SR7_PKLONGBPF_VTAP0                      (volatile uint32_t *)0xff014460
//Bit 31:24,        reg_sr7_pk_long_bpf_vdtap093                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -32
//Bit 23:16,        reg_sr7_pk_long_bpf_vdtap092                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -28
//Bit 15: 8,        reg_sr7_pk_long_bpf_vdtap091                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 30
//Bit  7: 0,        reg_sr7_pk_long_bpf_vdtap090                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 68
#define P_SR7_PKLONGBPF_VTAP1                      (volatile uint32_t *)0xff014464
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_pk_long_bpf_vdtap094                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -4
#define P_SR7_PKLONGHPF_VTAP0                      (volatile uint32_t *)0xff014468
//Bit 31:24,        reg_sr7_pk_long_hpf_vdtap093                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 30
//Bit 23:16,        reg_sr7_pk_long_hpf_vdtap092                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -28
//Bit 15: 8,        reg_sr7_pk_long_hpf_vdtap091                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -31
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdtap090                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 68
#define P_SR7_PKLONGHPF_VTAP1                      (volatile uint32_t *)0xff01446c
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdtap094                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -5
#define P_SR7_CIRBPLONG_ALP                        (volatile uint32_t *)0xff014470
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_cirbp_long_alpha3                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_cirbp_long_alpha2                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cirbp_long_alpha1                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cirbp_long_alpha0                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
#define P_SR7_CIRHPLONG_ALP                        (volatile uint32_t *)0xff014474
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_cirhp_long_alpha3                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_cirhp_long_alpha2                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cirhp_long_alpha1                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cirhp_long_alpha0                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
#define P_SR7_DRTBPLONG_ALP                        (volatile uint32_t *)0xff014478
//Bit 31:28,        reg_sr7_drtbp_long_alpha7                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtbp_long_alpha6                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtbp_long_alpha5                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtbp_long_alpha4                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtbp_long_alpha3                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtbp_long_alpha2                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtbp_long_alpha1                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtbp_long_alpha0                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
#define P_SR7_DRTHPLONG_ALP                        (volatile uint32_t *)0xff01447c
//Bit 31:28,        reg_sr7_drthp_long_alpha7                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drthp_long_alpha6                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drthp_long_alpha5                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drthp_long_alpha4                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drthp_long_alpha3                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drthp_long_alpha2                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drthp_long_alpha1                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drthp_long_alpha0                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
#define P_SR7_PKMINMAXCIR_BLD_LUT2D0               (volatile uint32_t *)0xff014480
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d7          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d6          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d5          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d4          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d3          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d2          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d1          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d0          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define P_SR7_PKMINMAXCIR_BLD_LUT2D1               (volatile uint32_t *)0xff014484
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d15          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d14          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d13          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d12          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d11          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d10          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d9           : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d8           : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define P_SR7_PKMINMAXCIR_BLD_LUT2D2               (volatile uint32_t *)0xff014488
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d23          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d22          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d21          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d20          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d19          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d18          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d17          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d16          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define P_SR7_PKMINMAXCIR_BLD_LUT2D3               (volatile uint32_t *)0xff01448c
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d31          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 14
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d30          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d29          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d28          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 8
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d27          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d26          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d25          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d24          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
#define P_SR7_PKMINMAXCIR_BLD_LUT2D4               (volatile uint32_t *)0xff014490
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d35          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d34          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d33          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d32          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define P_SR7_PKMINMAXLPF_BLD_LUT2D0               (volatile uint32_t *)0xff014494
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d7          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d6          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d5          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d4          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d3          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d2          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d1          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d0          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define P_SR7_PKMINMAXLPF_BLD_LUT2D1               (volatile uint32_t *)0xff014498
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d15          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d14          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d13          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d12          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d11          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d10          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d9           : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d8           : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define P_SR7_PKMINMAXLPF_BLD_LUT2D2               (volatile uint32_t *)0xff01449c
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d23          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d22          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d21          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d20          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d19          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d18          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d17          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d16          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define P_SR7_PKMINMAXLPF_BLD_LUT2D3               (volatile uint32_t *)0xff0144a0
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d31          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 14
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d30          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d29          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d28          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 8
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d27          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d26          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d25          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d24          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
#define P_SR7_PKMINMAXLPF_BLD_LUT2D4               (volatile uint32_t *)0xff0144a4
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d35          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d34          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d33          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d32          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define P_SR7_PKDRT_BLD_EN                         (volatile uint32_t *)0xff0144a8
//Bit 31: 1,        reserved
//Bit  0,            reg_sr7_pkdrtbld_beta_en                       : enable of direction ambiguity protection for drt and cir blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
#define P_SR7_DRTDIF_TH                            (volatile uint32_t *)0xff0144ac
//Bit 31:16,        reserved
//Bit 15: 8,        reg_sr7_drtdif_min2sad_th1                   : for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;. unsigned  , default = 128
//Bit  7: 0,        reg_sr7_drtdif_min2sad_th0                   : for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;. unsigned  , default = 128
#define P_SR7_TIBLD_PRT                            (volatile uint32_t *)0xff0144b0
//Bit 31:14,        reserved
//Bit 13,            reg_sr7_hlti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit 12,            reg_sr7_vlti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit 11: 8,        reg_sr7_xcti_dcbld_beta1                     : beta for denoise and org dc blend base on the x=cal_drt_dif4(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_xcti_dcbld_beta0                     : beta for denoise and org dc blend base on the x=cal_drt_dif4(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 15
//Bit  3,            reg_sr7_hcti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit  2,            reg_sr7_vcti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit  1,            reg_sr7_hcti_dcbld_use_ybeta                   : enable to use beta from hlti, 0, use c-beta, 1, use y-beta. unsigned  , default = 0
//Bit  0,            reg_sr7_vcti_dcbld_use_ybeta                   : enable to use beta from vlti, 0, use c-beta, 1, use y-beta. unsigned  , default = 0
#define P_SR7_HTI_OPT_FORCE                        (volatile uint32_t *)0xff0144b4
//Bit 31: 6,        reserved
//Bit  5,            reg_sr7_diag_force_hti1                      :   force hti for diagonal edges luma/chroma, 0: diagonal use vti, 1: diagonal use hti, default=1. unsigned  , default = 1
//Bit  4,            reg_sr7_diag_force_hti0                      :   force hti for diagonal edges luma/chroma, 0: diagonal use vti, 1: diagonal use hti, default=1. unsigned  , default = 1
//Bit  3,            reg_sr7_horz_force_vti1                      :   force vti for horizontal edges luma/chroma, 0: bias hti, 1: horizontal edge force 100% vti,  default=1. unsigned  , default = 1
//Bit  2,            reg_sr7_horz_force_vti0                      :   force vti for horizontal edges luma/chroma, 0: bias hti, 1: horizontal edge force 100% vti,  default=1. unsigned  , default = 1
//Bit  1,            reg_sr7_alph_force_hvsad1                    :   alpha = minsad*64/maxsad, force minsad=sad_h, maxsad=sad_v for alpha calculation, [0]for luma, [1] for chroma. if sad_h>sad_v alpha will be large,  default=1. unsigned  , default = 1
//Bit  0,            reg_sr7_alph_force_hvsad0                    :   alpha = minsad*64/maxsad, force minsad=sad_h, maxsad=sad_v for alpha calculation, [0]for luma, [1] for chroma. if sad_h>sad_v alpha will be large,  default=1. unsigned  , default = 1
#define P_SR7_HVTI_FINALGAIN                       (volatile uint32_t *)0xff0144b8
//Bit 31:28,        reserved
//Bit 27:16,        reg_sr7_hvti_finalgain1                      :   final gain for HVTI boost, for easier level tuning for application, normalized to 256 as 1.0 default = 256. unsigned  , default = 256
//Bit 15:12,        reserved
//Bit 11: 0,        reg_sr7_hvti_finalgain0                      :   final gain for HVTI boost, for easier level tuning for application, normalized to 256 as 1.0 default = 256. unsigned  , default = 256
#define P_SR7_TIOS_SDRATIO                         (volatile uint32_t *)0xff0144bc
//Bit 31:30,        reserved
//Bit 29:24,        reg_sr7_hti_osmargin_sdratio1                :  ratio for HTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit 23:22,        reserved
//Bit 21:16,        reg_sr7_hti_osmargin_sdratio0                :  ratio for HTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit 15:14,        reserved
//Bit 13: 8,        reg_sr7_vti_osmargin_sdratio1                :  ratio for VTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_sr7_vti_osmargin_sdratio0                :  ratio for VTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
#define P_SR7_XTI_SDFDEN                           (volatile uint32_t *)0xff0144c0
//Bit 31: 2,        reserved
//Bit  1,            reg_sr7_xtigain_sdfd_en1                     :  adaptive gamma for cti boost gain enable.[0]for luma, [1] for chroma. 0: not enable, 1:enable, default = 1. unsigned  , default = 1
//Bit  0,            reg_sr7_xtigain_sdfd_en0                     :  adaptive gamma for cti boost gain enable.[0]for luma, [1] for chroma. 0: not enable, 1:enable, default = 1. unsigned  , default = 1
#define P_SR7_FDSD_PARAM                           (volatile uint32_t *)0xff0144c4
//Bit 31:26,        reserved
//Bit 25,            reg_fdsd_vlpf_en                               : use vertical [1 2 1] lpf filter for the fd and sd derivativecalculations. unsigned  , default = 1
//Bit 24,            reg_fdsd_hlpf_en                               : use horizontal [1 2 1] lpf filter for the fd and sd derivativecalculations. unsigned  , default = 1
//Bit 23:20,        reg_sd_coring_th1                            : coring to SD'= MAX(SD - FD*ratio - coring,0); default = 0. unsigned  , default = 0
//Bit 19:16,        reg_sd_coring_th0                            : coring to SD'= MAX(SD - FD*ratio - coring,0); default = 0. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_sd_coring_ratio2fd1                      : ratio to FD for adaptive coring to SD'= MAX(SD - FD*ratio - coring,0); normalized 64 as 1.0  default = 4. unsigned  , default = 4
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_sd_coring_ratio2fd0                      : ratio to FD for adaptive coring to SD'= MAX(SD - FD*ratio - coring,0); normalized 64 as 1.0  default = 4. unsigned  , default = 4
#define P_SR7_TI_BPF_EN                            (volatile uint32_t *)0xff0144c8
//Bit 31: 4,        reserved
//Bit  3,            reg_sr7_hlti_bpf_en                            :   enable of tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  2,            reg_sr7_hcti_bpf_en                            :   enable of tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  1,            reg_sr7_vlti_bpf_en                            :   enable of tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0, mainly for 2x2 UP case. unsigned  , default = 1
//Bit  0,            reg_sr7_vcti_bpf_en                            :   enable of tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0, mainly for 2x2 UP case. unsigned  , default = 1
#define P_SR7_PKLONG_PF_EN                         (volatile uint32_t *)0xff0144cc
//Bit 31: 2,        reserved
//Bit  1,            reg_sr7_pk_long_bpf_en                         :   enable of long BPF for peaking only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  0,            reg_sr7_pk_long_hpf_en                         :   enable of long HPF for peaking only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
#define P_SR7_PKLONG_PF_GAIN                       (volatile uint32_t *)0xff0144d0
//Bit 31:24,        reg_sr7_pk_long_bpf_hzgain                     :   gain to long horizontal BPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit 23:16,        reg_sr7_pk_long_bpf_vdgain                     :   gain to long vertical and diagonal BPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit 15: 8,        reg_sr7_pk_long_hpf_hzgain                     :   gain to long horizontal HPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdgain                     :   gain to long vertical and diagonal HPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
#define P_SR7_PKMINMAX_BLD                         (volatile uint32_t *)0xff0144d4
//Bit 31: 4,        reserved
//Bit  3,            reg_sr7_pk_mimaxerr2_cirbld_on_bp              : enable to use adaptive blender of drtBP vs cirBP alpha2, the larger of cell, the more cirPK results, 0: alp2=lut2d(minerr, maxerr),1:alp2=min_err/maxerr,default = 1. unsigned  , default = 1
//Bit  2,            reg_sr7_pk_mimaxerr2_cirbld_on_hp              : enable to use adaptive blender of drtHP vs cirHP alpha2, the larger of cell, the more cirPK results, 0: alp2=lut2d(minerr, maxerr),1:alp2=min_err/maxerr,default = 1. unsigned  , default = 1
//Bit  1,            reg_sr7_pk_mimaxerr2_lpfbld_on_bp              : enable to use adaptive blender of BP result lpf along edge based on the mimaxsad relationship, default = 1. unsigned  , default = 1
//Bit  0,            reg_sr7_pk_mimaxerr2_lpfbld_on_hp              : enable to use adaptive blender of HP result lpf along edge based on the mimaxsad relationship, default = 1. unsigned  , default = 1
#define P_SR7_TI_CONMAXERR_GAIN                    (volatile uint32_t *)0xff0144d8
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_hti_conmaxerr_gain1                  : con=max(con, maxerr) for the horizontal transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit 11: 8,        reg_sr7_hti_conmaxerr_gain0                  : con=max(con, maxerr) for the horizontal transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit  7: 4,        reg_sr7_vti_conmaxerr_gain1                  : con=max(con, maxerr) for the vertical transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_vti_conmaxerr_gain0                  : con=max(con, maxerr) for the vertical transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
#define P_SR7_CC_PK_ADJ                            (volatile uint32_t *)0xff0144dc
//Bit 31:25,        reserved
//Bit 24,            reg_sr7_cc_enable                              : color compensation enable, 0: no CC, 1: with CC, default = 1. unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_sr7_cc_yinp_sel                            : color compensation input luma selection, 0: org_y; 1: gau_y ; 2:gauadp_y; 3:edgeadp_y (same as dnlp input sel), default= 0. unsigned  , default = 0
//Bit 19:18,        reg_sr7_cc_ydlt_sel                            : color compensation output luma selection, 0: peaking+lti output; 1: dnlp output; 2/3: peaking+lti+dnlp, default = 2. unsigned  , default = 2
//Bit 17:16,        reg_sr7_cc_sat_norm                            : normalization of lut cell to saturation. 0: norm to 8 as 1.0, sat[0:23/8]; 1: norm to 16 as 1.0, sat[1/16:31/16]; 2: norm to 32 as 1.0, sat[17/32:47/32]; 3:norm to 64 as 1.0, sat[49/64:79/64]. unsigned  , default = 1
//Bit 15: 8,        reg_sr7_cc_ydlt_pscl                           : prescale to the y-delta (if >0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_cc_ydlt_nscl                           : prescale to the y-delta (if <0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.. unsigned  , default = 64
#define P_SR7_CC_LUT0                              (volatile uint32_t *)0xff0144e0
//Bit 31:28,        reg_sr7_cc_lut003                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 27:24,        reg_sr7_cc_lut002                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 23:20,        reg_sr7_cc_lut001                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 19:16,        reg_sr7_cc_lut000                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 15:12,        reg_sr7_cc_lut103                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 8
//Bit 11: 8,        reg_sr7_cc_lut102                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_cc_lut101                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 2
//Bit  3: 0,        reg_sr7_cc_lut100                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 1
#define P_SR7_CC_LUT1                              (volatile uint32_t *)0xff0144e4
//Bit 31:28,        reserved
//Bit 27:24,        reg_sr7_cc_lut202                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 12
//Bit 23:20,        reg_sr7_cc_lut201                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 8
//Bit 19:16,        reg_sr7_cc_lut200                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 4
//Bit 15:12,        reserved
//Bit 11: 8,        reg_sr7_cc_lut302                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cc_lut301                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 10
//Bit  3: 0,        reg_sr7_cc_lut300                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 5
#define P_SR7_CC_LUT2                              (volatile uint32_t *)0xff0144e8
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut401                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 15
//Bit 19:16,        reg_sr7_cc_lut400                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 8
//Bit 15:12,        reg_sr7_cc_lut501                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}. unsigned  , default = 13
//Bit 11: 8,        reg_sr7_cc_lut500                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}. unsigned  , default = 6
//Bit  7: 4,        reg_sr7_cc_lut600                           : valid for y-lumadlt=  1/4,              ; of x-lumainput=6/8   dft={5}. unsigned  , default = 5
//Bit  3: 0,        reg_sr7_cc_lut700                           : valid for y-lumadlt=  1/4,              ; of x-lumainput=7/8   dft={4}. unsigned  , default = 4
#define P_SR7_CC_LUT3                              (volatile uint32_t *)0xff0144ec
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut710                           : valid for y-lumadlt= -1/4,              ; of x-lumainput=1/8   dft={4}. unsigned  , default = 4
//Bit 19:16,        reg_sr7_cc_lut610                           : valid for y-lumadlt= -1/4,              ; of x-lumainput=2/8   dft={5}. unsigned  , default = 5
//Bit 15:12,        reg_sr7_cc_lut511                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}. unsigned  , default = 13
//Bit 11: 8,        reg_sr7_cc_lut510                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}. unsigned  , default = 6
//Bit  7: 4,        reg_sr7_cc_lut411                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cc_lut410                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 8
#define P_SR7_CC_LUT4                              (volatile uint32_t *)0xff0144f0
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut312                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 15
//Bit 19:16,        reg_sr7_cc_lut311                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 10
//Bit 15:12,        reg_sr7_cc_lut310                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 5
//Bit 11: 8,        reg_sr7_cc_lut212                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 12
//Bit  7: 4,        reg_sr7_cc_lut211                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_cc_lut210                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 4
#define P_SR7_CC_LUT5                              (volatile uint32_t *)0xff0144f4
//Bit 31:28,        reg_sr7_cc_lut113                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 8
//Bit 27:24,        reg_sr7_cc_lut112                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 4
//Bit 23:20,        reg_sr7_cc_lut111                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 2
//Bit 19:16,        reg_sr7_cc_lut110                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 1
//Bit 15:12,        reg_sr7_cc_lut013                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_cc_lut012                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_cc_lut011                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_cc_lut010                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
#define P_SR7_GRAPHIC_CTRL                         (volatile uint32_t *)0xff0144f8
//Bit 31:11,        reserved
//Bit 10,            reg_sr7_grph_en                                : enable graphic statistic    . unsigned  , default = 1
//Bit  9,            reg_sr7_grph_hflt                              : horizontal filter, 0: [0 1 -1], 1: [-1 2 -1]. unsigned  , default = 1
//Bit  8,            reg_sr7_grph_vflt                              : vertical filter, 0: [0 1 -1], 1: [-1 2 -1]. unsigned  , default = 1
//Bit  7: 0,        reg_sr7_grph_dif_cor                           : coring for dif while count for graphic. unsigned  , default = 0
#define P_SR7_GRAPHIC_THD_GAIN                     (volatile uint32_t *)0xff0144fc
//Bit 31:24,        reg_sr7_grph_flt_thd                           : flat threshold for dif while count for graphic. unsigned  , default = 2
//Bit 23:16,        reg_sr7_grph_dtl_thd                           : detail threshold for dif while count for graphic. unsigned  , default = 40
//Bit 15: 8,        reg_sr7_grph_hgain                             : horizontal gain for fast squart of hp. unsigned  , default = 32
//Bit  7: 0,        reg_sr7_grph_vgain                             : vertical gain for fast squart of hp. unsigned  , default = 32
#define P_SR7_RO_GRAPHIC_FLT_CNT                   (volatile uint32_t *)0xff014500
//Bit 31: 0,        ro_sr7_grph_flt_cnt                            : flat count numbers for graphic. unsigned  , default = 0
#define P_SR7_RO_GRAPHIC_DTL_CNT                   (volatile uint32_t *)0xff014504
//Bit 31: 0,        ro_sr7_grph_dtl_cnt                            : detail count numbers for graphic. unsigned  , default = 0
#define P_SR7_CLR_PRT_PARAM                        (volatile uint32_t *)0xff014508
//Bit 31:18,        reserved
//Bit 17:16,        reg_sr7_clr_prct_inpsel                        : input UV selection for color protection, 0: org; 1: NRout; 2: CTIout; 3: (NR+TIout)/2. unsigned  , default = 3
//Bit 15: 8,        reg_sr7_clr_prct_dnlp_gain                     : gain to de-boost of dnlp_dlt base on color region, norm to 64 as 1.0. set to 0 as disable. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_clr_prct_peak_gain                     : gain to de-boost of peak_dlt base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
#define P_SR7_CLR_PRT_LC_GAIN                      (volatile uint32_t *)0xff01450c
//Bit 31:24,        reserved
//Bit 23:16,        reg_sr7_clr_prct_lc_gain2                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
//Bit 15: 8,        reg_sr7_clr_prct_lc_gain1                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_clr_prct_lc_gain0                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
#define P_SR7_CLR_PRT_LUT0                         (volatile uint32_t *)0xff014510
//Bit 31:28,        reg_sr7_clr_prct_lut7                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut6                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut5                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut4                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut3                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut2                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut1                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut0                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT1                         (volatile uint32_t *)0xff014514
//Bit 31:28,        reg_sr7_clr_prct_lut15                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut14                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut13                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut12                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut11                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut10                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut9                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut8                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT2                         (volatile uint32_t *)0xff014518
//Bit 31:28,        reg_sr7_clr_prct_lut23                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut22                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut21                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut20                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut19                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut18                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut17                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut16                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT3                         (volatile uint32_t *)0xff01451c
//Bit 31:28,        reg_sr7_clr_prct_lut31                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut30                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut29                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut28                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut27                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut26                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut25                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut24                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT4                         (volatile uint32_t *)0xff014520
//Bit 31:28,        reg_sr7_clr_prct_lut39                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut38                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut37                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut36                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut35                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut34                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut33                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut32                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT5                         (volatile uint32_t *)0xff014524
//Bit 31:28,        reg_sr7_clr_prct_lut47                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut46                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut45                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut44                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut43                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut42                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut41                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut40                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT6                         (volatile uint32_t *)0xff014528
//Bit 31:28,        reg_sr7_clr_prct_lut55                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut54                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut53                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut52                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut51                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut50                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut49                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut48                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT7                         (volatile uint32_t *)0xff01452c
//Bit 31:28,        reg_sr7_clr_prct_lut63                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut62                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut61                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut60                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut59                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut58                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut57                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut56                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT8                         (volatile uint32_t *)0xff014530
//Bit 31:28,        reg_sr7_clr_prct_lut71                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut70                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut69                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut68                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut67                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut66                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut65                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut64                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT9                         (volatile uint32_t *)0xff014534
//Bit 31:28,        reg_sr7_clr_prct_lut79                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut78                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut77                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut76                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut75                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut74                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut73                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut72                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT10                        (volatile uint32_t *)0xff014538
//Bit 31:28,        reg_sr7_clr_prct_lut87                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut86                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut85                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut84                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut83                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut82                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut81                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut80                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT11                        (volatile uint32_t *)0xff01453c
//Bit 31:28,        reg_sr7_clr_prct_lut95                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut94                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut93                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut92                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut91                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut90                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut89                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut88                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT12                        (volatile uint32_t *)0xff014540
//Bit 31:28,        reg_sr7_clr_prct_lut103                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut102                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut101                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut100                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut99                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut98                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut97                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut96                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT13                        (volatile uint32_t *)0xff014544
//Bit 31:28,        reg_sr7_clr_prct_lut111                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut110                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut109                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut108                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut107                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut106                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut105                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut104                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT14                        (volatile uint32_t *)0xff014548
//Bit 31:28,        reg_sr7_clr_prct_lut119                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut118                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut117                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut116                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut115                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut114                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut113                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut112                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT15                        (volatile uint32_t *)0xff01454c
//Bit 31:28,        reg_sr7_clr_prct_lut127                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut126                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut125                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut124                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut123                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut122                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut121                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut120                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT16                        (volatile uint32_t *)0xff014550
//Bit 31:28,        reg_sr7_clr_prct_lut135                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut134                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut133                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut132                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut131                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut130                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut129                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut128                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT17                        (volatile uint32_t *)0xff014554
//Bit 31:28,        reg_sr7_clr_prct_lut143                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut142                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut141                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut140                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut139                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut138                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut137                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut136                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT18                        (volatile uint32_t *)0xff014558
//Bit 31:28,        reg_sr7_clr_prct_lut151                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut150                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut149                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut148                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut147                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut146                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut145                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut144                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT19                        (volatile uint32_t *)0xff01455c
//Bit 31:28,        reg_sr7_clr_prct_lut159                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut158                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut157                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut156                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut155                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut154                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut153                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut152                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT20                        (volatile uint32_t *)0xff014560
//Bit 31:28,        reg_sr7_clr_prct_lut167                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut166                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut165                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut164                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut163                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut162                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut161                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut160                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT21                        (volatile uint32_t *)0xff014564
//Bit 31:28,        reg_sr7_clr_prct_lut175                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut174                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut173                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut172                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut171                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut170                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut169                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut168                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT22                        (volatile uint32_t *)0xff014568
//Bit 31:28,        reg_sr7_clr_prct_lut183                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut182                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut181                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut180                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut179                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut178                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut177                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut176                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT23                        (volatile uint32_t *)0xff01456c
//Bit 31:28,        reg_sr7_clr_prct_lut191                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut190                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut189                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut188                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut187                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut186                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut185                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut184                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT24                        (volatile uint32_t *)0xff014570
//Bit 31:28,        reg_sr7_clr_prct_lut199                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut198                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut197                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut196                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut195                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut194                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut193                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut192                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT25                        (volatile uint32_t *)0xff014574
//Bit 31:28,        reg_sr7_clr_prct_lut207                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut206                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut205                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut204                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut203                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut202                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut201                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut200                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT26                        (volatile uint32_t *)0xff014578
//Bit 31:28,        reg_sr7_clr_prct_lut215                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut214                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut213                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut212                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut211                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut210                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut209                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut208                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT27                        (volatile uint32_t *)0xff01457c
//Bit 31:28,        reg_sr7_clr_prct_lut223                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut222                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut221                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut220                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut219                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut218                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut217                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut216                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT28                        (volatile uint32_t *)0xff014580
//Bit 31:28,        reg_sr7_clr_prct_lut231                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut230                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut229                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut228                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut227                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut226                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut225                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut224                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT29                        (volatile uint32_t *)0xff014584
//Bit 31:28,        reg_sr7_clr_prct_lut239                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut238                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut237                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut236                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut235                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut234                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut233                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut232                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define P_SR7_CLR_PRT_LUT30                        (volatile uint32_t *)0xff014588
//Bit 31:28,        reg_sr7_clr_prct_lut247                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut246                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut245                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut244                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut243                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut242                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut241                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut240                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define P_SR7_CLR_PRT_LUT31                        (volatile uint32_t *)0xff01458c
//Bit 31:28,        reg_sr7_clr_prct_lut255                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut254                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut253                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut252                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut251                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut250                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut249                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut248                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  sharp_regs2.h
//

#define SRSHARP0_SR7_DRTLPF_EN                     (SRSHARP0_OFFSET + SR7_DRTLPF_EN             )//
#define SRSHARP0_SR7_DRTLPF_BETA                   (SRSHARP0_OFFSET + SR7_DRTLPF_BETA           )//
#define SRSHARP0_SR7_PKBLD_BETA                    (SRSHARP0_OFFSET + SR7_PKBLD_BETA            )//
#define SRSHARP0_SR7_XLTIBLD_BETA                  (SRSHARP0_OFFSET + SR7_XLTIBLD_BETA          )//
#define SRSHARP0_SR7_DRTLPF_EDGE0                  (SRSHARP0_OFFSET + SR7_DRTLPF_EDGE0          )//
#define SRSHARP0_SR7_DRTLPF_EDGE1                  (SRSHARP0_OFFSET + SR7_DRTLPF_EDGE1          )//
#define SRSHARP0_SR7_DRTLPF_SDCOR0                 (SRSHARP0_OFFSET + SR7_DRTLPF_SDCOR0         )//
#define SRSHARP0_SR7_DRTLPF_SDCOR1                 (SRSHARP0_OFFSET + SR7_DRTLPF_SDCOR1         )//
#define SRSHARP0_SR7_CTIGAIN_SDCOR0                (SRSHARP0_OFFSET + SR7_CTIGAIN_SDCOR0        )//
#define SRSHARP0_SR7_CTIGAIN_SDCOR1                (SRSHARP0_OFFSET + SR7_CTIGAIN_SDCOR1        )//
#define SRSHARP0_SR7_LTIGAIN_SDCOR0                (SRSHARP0_OFFSET + SR7_LTIGAIN_SDCOR0        )//
#define SRSHARP0_SR7_LTIGAIN_SDCOR1                (SRSHARP0_OFFSET + SR7_LTIGAIN_SDCOR1        )//
#define SRSHARP0_SR7_HLTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_HLTIBPF_TAP0          )//
#define SRSHARP0_SR7_HLTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_HLTIBPF_TAP1          )//
#define SRSHARP0_SR7_HCTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_HCTIBPF_TAP0          )//
#define SRSHARP0_SR7_HCTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_HCTIBPF_TAP1          )//
#define SRSHARP0_SR7_PKLONGBPF_HTAP0               (SRSHARP0_OFFSET + SR7_PKLONGBPF_HTAP0       ) //
#define SRSHARP0_SR7_PKLONGBPF_HTAP1               (SRSHARP0_OFFSET + SR7_PKLONGBPF_HTAP1       ) //
#define SRSHARP0_SR7_PKLONGHPF_HTAP0               (SRSHARP0_OFFSET + SR7_PKLONGHPF_HTAP0       ) //
#define SRSHARP0_SR7_PKLONGHPF_HTAP1               (SRSHARP0_OFFSET + SR7_PKLONGHPF_HTAP1       ) //
#define SRSHARP0_SR7_VLTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_VLTIBPF_TAP0          ) //
#define SRSHARP0_SR7_VLTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_VLTIBPF_TAP1          ) //
#define SRSHARP0_SR7_VCTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_VCTIBPF_TAP0          ) //
#define SRSHARP0_SR7_VCTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_VCTIBPF_TAP1          ) //
#define SRSHARP0_SR7_PKLONGBPF_VTAP0               (SRSHARP0_OFFSET + SR7_PKLONGBPF_VTAP0       ) //
#define SRSHARP0_SR7_PKLONGBPF_VTAP1               (SRSHARP0_OFFSET + SR7_PKLONGBPF_VTAP1       ) //
#define SRSHARP0_SR7_PKLONGHPF_VTAP0               (SRSHARP0_OFFSET + SR7_PKLONGHPF_VTAP0       ) //
#define SRSHARP0_SR7_PKLONGHPF_VTAP1               (SRSHARP0_OFFSET + SR7_PKLONGHPF_VTAP1       ) //
#define SRSHARP0_SR7_CIRBPLONG_ALP                 (SRSHARP0_OFFSET + SR7_CIRBPLONG_ALP         ) //
#define SRSHARP0_SR7_CIRHPLONG_ALP                 (SRSHARP0_OFFSET + SR7_CIRHPLONG_ALP         ) //
#define SRSHARP0_SR7_DRTBPLONG_ALP                 (SRSHARP0_OFFSET + SR7_DRTBPLONG_ALP         ) //
#define SRSHARP0_SR7_DRTHPLONG_ALP                 (SRSHARP0_OFFSET + SR7_DRTHPLONG_ALP         ) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D0        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D0) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D1        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D1) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D2        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D2) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D3        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D3) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D4        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D4) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D0        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D0) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D1        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D1) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D2        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D2) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D3        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D3) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D4        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D4) //
#define SRSHARP0_SR7_PKDRT_BLD_EN                  (SRSHARP0_OFFSET + SR7_PKDRT_BLD_EN          ) //
#define SRSHARP0_SR7_DRTDIF_TH                     (SRSHARP0_OFFSET + SR7_DRTDIF_TH             ) //
#define SRSHARP0_SR7_TIBLD_PRT                     (SRSHARP0_OFFSET + SR7_TIBLD_PRT             ) //
#define SRSHARP0_SR7_HTI_OPT_FORCE                 (SRSHARP0_OFFSET + SR7_HTI_OPT_FORCE         ) //
#define SRSHARP0_SR7_HVTI_FINALGAIN                (SRSHARP0_OFFSET + SR7_HVTI_FINALGAIN        ) //
#define SRSHARP0_SR7_TIOS_SDRATIO                  (SRSHARP0_OFFSET + SR7_TIOS_SDRATIO          ) //
#define SRSHARP0_SR7_XTI_SDFDEN                    (SRSHARP0_OFFSET + SR7_XTI_SDFDEN            ) //
#define SRSHARP0_SR7_FDSD_PARAM                    (SRSHARP0_OFFSET + SR7_FDSD_PARAM            ) //
#define SRSHARP0_SR7_TI_BPF_EN                     (SRSHARP0_OFFSET + SR7_TI_BPF_EN             ) //
#define SRSHARP0_SR7_PKLONG_PF_EN                  (SRSHARP0_OFFSET + SR7_PKLONG_PF_EN          ) //
#define SRSHARP0_SR7_PKLONG_PF_GAIN                (SRSHARP0_OFFSET + SR7_PKLONG_PF_GAIN        ) //
#define SRSHARP0_SR7_PKMINMAX_BLD                  (SRSHARP0_OFFSET + SR7_PKMINMAX_BLD          ) //
#define SRSHARP0_SR7_TI_CONMAXERR_GAIN             (SRSHARP0_OFFSET + SR7_TI_CONMAXERR_GAIN     ) //
#define SRSHARP0_SR7_CC_PK_ADJ                     (SRSHARP0_OFFSET + SR7_CC_PK_ADJ             ) //
#define SRSHARP0_SR7_CC_LUT0                       (SRSHARP0_OFFSET + SR7_CC_LUT0               ) //
#define SRSHARP0_SR7_CC_LUT1                       (SRSHARP0_OFFSET + SR7_CC_LUT1               ) //
#define SRSHARP0_SR7_CC_LUT2                       (SRSHARP0_OFFSET + SR7_CC_LUT2               ) //
#define SRSHARP0_SR7_CC_LUT3                       (SRSHARP0_OFFSET + SR7_CC_LUT3               ) //
#define SRSHARP0_SR7_CC_LUT4                       (SRSHARP0_OFFSET + SR7_CC_LUT4               ) //
#define SRSHARP0_SR7_CC_LUT5                       (SRSHARP0_OFFSET + SR7_CC_LUT5               ) //
#define SRSHARP0_SR7_GRAPHIC_CTRL                  (SRSHARP0_OFFSET + SR7_GRAPHIC_CTRL          ) //
#define SRSHARP0_SR7_GRAPHIC_THD_GAIN              (SRSHARP0_OFFSET + SR7_GRAPHIC_THD_GAIN      ) //
#define SRSHARP0_SR7_RO_GRAPHIC_FLT_CNT            (SRSHARP0_OFFSET + SR7_RO_GRAPHIC_FLT_CNT    ) //
#define SRSHARP0_SR7_RO_GRAPHIC_DTL_CNT            (SRSHARP0_OFFSET + SR7_RO_GRAPHIC_DTL_CNT    ) //
#define SRSHARP0_SR7_CLR_PRT_PARAM                 (SRSHARP0_OFFSET + SR7_CLR_PRT_PARAM         ) //
#define SRSHARP0_SR7_CLR_PRT_LC_GAIN               (SRSHARP0_OFFSET + SR7_CLR_PRT_LC_GAIN       ) //
#define SRSHARP0_SR7_CLR_PRT_LUT0                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT0          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT1                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT1          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT2                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT2          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT3                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT3          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT4                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT4          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT5                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT5          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT6                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT6          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT7                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT7          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT8                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT8          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT9                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT9          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT10                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT10         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT11                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT11         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT12                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT12         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT13                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT13         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT14                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT14         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT15                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT15         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT16                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT16         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT17                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT17         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT18                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT18         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT19                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT19         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT20                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT20         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT21                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT21         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT22                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT22         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT23                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT23         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT24                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT24         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT25                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT25         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT26                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT26         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT27                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT27         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT28                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT28         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT29                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT29         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT30                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT30         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT31                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT31         ) //


//// srsharp1 reg define
#define SRSHARP1_SR7_DRTLPF_EN                     (SRSHARP1_OFFSET + SR7_DRTLPF_EN             )//
#define SRSHARP1_SR7_DRTLPF_BETA                   (SRSHARP1_OFFSET + SR7_DRTLPF_BETA           )//
#define SRSHARP1_SR7_PKBLD_BETA                    (SRSHARP1_OFFSET + SR7_PKBLD_BETA            )//
#define SRSHARP1_SR7_XLTIBLD_BETA                  (SRSHARP1_OFFSET + SR7_XLTIBLD_BETA          )//
#define SRSHARP1_SR7_DRTLPF_EDGE0                  (SRSHARP1_OFFSET + SR7_DRTLPF_EDGE0          )//
#define SRSHARP1_SR7_DRTLPF_EDGE1                  (SRSHARP1_OFFSET + SR7_DRTLPF_EDGE1          )//
#define SRSHARP1_SR7_DRTLPF_SDCOR0                 (SRSHARP1_OFFSET + SR7_DRTLPF_SDCOR0         )//
#define SRSHARP1_SR7_DRTLPF_SDCOR1                 (SRSHARP1_OFFSET + SR7_DRTLPF_SDCOR1         )//
#define SRSHARP1_SR7_CTIGAIN_SDCOR0                (SRSHARP1_OFFSET + SR7_CTIGAIN_SDCOR0        )//
#define SRSHARP1_SR7_CTIGAIN_SDCOR1                (SRSHARP1_OFFSET + SR7_CTIGAIN_SDCOR1        )//
#define SRSHARP1_SR7_LTIGAIN_SDCOR0                (SRSHARP1_OFFSET + SR7_LTIGAIN_SDCOR0        )//
#define SRSHARP1_SR7_LTIGAIN_SDCOR1                (SRSHARP1_OFFSET + SR7_LTIGAIN_SDCOR1        )//
#define SRSHARP1_SR7_HLTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_HLTIBPF_TAP0          )//
#define SRSHARP1_SR7_HLTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_HLTIBPF_TAP1          )//
#define SRSHARP1_SR7_HCTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_HCTIBPF_TAP0          )//
#define SRSHARP1_SR7_HCTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_HCTIBPF_TAP1          )//
#define SRSHARP1_SR7_PKLONGBPF_HTAP0               (SRSHARP1_OFFSET + SR7_PKLONGBPF_HTAP0       ) //
#define SRSHARP1_SR7_PKLONGBPF_HTAP1               (SRSHARP1_OFFSET + SR7_PKLONGBPF_HTAP1       ) //
#define SRSHARP1_SR7_PKLONGHPF_HTAP0               (SRSHARP1_OFFSET + SR7_PKLONGHPF_HTAP0       ) //
#define SRSHARP1_SR7_PKLONGHPF_HTAP1               (SRSHARP1_OFFSET + SR7_PKLONGHPF_HTAP1       ) //
#define SRSHARP1_SR7_VLTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_VLTIBPF_TAP0          ) //
#define SRSHARP1_SR7_VLTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_VLTIBPF_TAP1          ) //
#define SRSHARP1_SR7_VCTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_VCTIBPF_TAP0          ) //
#define SRSHARP1_SR7_VCTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_VCTIBPF_TAP1          ) //
#define SRSHARP1_SR7_PKLONGBPF_VTAP0               (SRSHARP1_OFFSET + SR7_PKLONGBPF_VTAP0       ) //
#define SRSHARP1_SR7_PKLONGBPF_VTAP1               (SRSHARP1_OFFSET + SR7_PKLONGBPF_VTAP1       ) //
#define SRSHARP1_SR7_PKLONGHPF_VTAP0               (SRSHARP1_OFFSET + SR7_PKLONGHPF_VTAP0       ) //
#define SRSHARP1_SR7_PKLONGHPF_VTAP1               (SRSHARP1_OFFSET + SR7_PKLONGHPF_VTAP1       ) //
#define SRSHARP1_SR7_CIRBPLONG_ALP                 (SRSHARP1_OFFSET + SR7_CIRBPLONG_ALP         ) //
#define SRSHARP1_SR7_CIRHPLONG_ALP                 (SRSHARP1_OFFSET + SR7_CIRHPLONG_ALP         ) //
#define SRSHARP1_SR7_DRTBPLONG_ALP                 (SRSHARP1_OFFSET + SR7_DRTBPLONG_ALP         ) //
#define SRSHARP1_SR7_DRTHPLONG_ALP                 (SRSHARP1_OFFSET + SR7_DRTHPLONG_ALP         ) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D0        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D0) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D1        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D1) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D2        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D2) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D3        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D3) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D4        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D4) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D0        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D0) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D1        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D1) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D2        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D2) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D3        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D3) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D4        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D4) //
#define SRSHARP1_SR7_PKDRT_BLD_EN                  (SRSHARP1_OFFSET + SR7_PKDRT_BLD_EN          ) //
#define SRSHARP1_SR7_DRTDIF_TH                     (SRSHARP1_OFFSET + SR7_DRTDIF_TH             ) //
#define SRSHARP1_SR7_TIBLD_PRT                     (SRSHARP1_OFFSET + SR7_TIBLD_PRT             ) //
#define SRSHARP1_SR7_HTI_OPT_FORCE                 (SRSHARP1_OFFSET + SR7_HTI_OPT_FORCE         ) //
#define SRSHARP1_SR7_HVTI_FINALGAIN                (SRSHARP1_OFFSET + SR7_HVTI_FINALGAIN        ) //
#define SRSHARP1_SR7_TIOS_SDRATIO                  (SRSHARP1_OFFSET + SR7_TIOS_SDRATIO          ) //
#define SRSHARP1_SR7_XTI_SDFDEN                    (SRSHARP1_OFFSET + SR7_XTI_SDFDEN            ) //
#define SRSHARP1_SR7_FDSD_PARAM                    (SRSHARP1_OFFSET + SR7_FDSD_PARAM            ) //
#define SRSHARP1_SR7_TI_BPF_EN                     (SRSHARP1_OFFSET + SR7_TI_BPF_EN             ) //
#define SRSHARP1_SR7_PKLONG_PF_EN                  (SRSHARP1_OFFSET + SR7_PKLONG_PF_EN          ) //
#define SRSHARP1_SR7_PKLONG_PF_GAIN                (SRSHARP1_OFFSET + SR7_PKLONG_PF_GAIN        ) //
#define SRSHARP1_SR7_PKMINMAX_BLD                  (SRSHARP1_OFFSET + SR7_PKMINMAX_BLD          ) //
#define SRSHARP1_SR7_TI_CONMAXERR_GAIN             (SRSHARP1_OFFSET + SR7_TI_CONMAXERR_GAIN     ) //
#define SRSHARP1_SR7_CC_PK_ADJ                     (SRSHARP1_OFFSET + SR7_CC_PK_ADJ             ) //
#define SRSHARP1_SR7_CC_LUT0                       (SRSHARP1_OFFSET + SR7_CC_LUT0               ) //
#define SRSHARP1_SR7_CC_LUT1                       (SRSHARP1_OFFSET + SR7_CC_LUT1               ) //
#define SRSHARP1_SR7_CC_LUT2                       (SRSHARP1_OFFSET + SR7_CC_LUT2               ) //
#define SRSHARP1_SR7_CC_LUT3                       (SRSHARP1_OFFSET + SR7_CC_LUT3               ) //
#define SRSHARP1_SR7_CC_LUT4                       (SRSHARP1_OFFSET + SR7_CC_LUT4               ) //
#define SRSHARP1_SR7_CC_LUT5                       (SRSHARP1_OFFSET + SR7_CC_LUT5               ) //
#define SRSHARP1_SR7_GRAPHIC_CTRL                  (SRSHARP1_OFFSET + SR7_GRAPHIC_CTRL          ) //
#define SRSHARP1_SR7_GRAPHIC_THD_GAIN              (SRSHARP1_OFFSET + SR7_GRAPHIC_THD_GAIN      ) //
#define SRSHARP1_SR7_RO_GRAPHIC_FLT_CNT            (SRSHARP1_OFFSET + SR7_RO_GRAPHIC_FLT_CNT    ) //
#define SRSHARP1_SR7_RO_GRAPHIC_DTL_CNT            (SRSHARP1_OFFSET + SR7_RO_GRAPHIC_DTL_CNT    ) //
#define SRSHARP1_SR7_CLR_PRT_PARAM                 (SRSHARP1_OFFSET + SR7_CLR_PRT_PARAM         ) //
#define SRSHARP1_SR7_CLR_PRT_LC_GAIN               (SRSHARP1_OFFSET + SR7_CLR_PRT_LC_GAIN       ) //
#define SRSHARP1_SR7_CLR_PRT_LUT0                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT0          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT1                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT1          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT2                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT2          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT3                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT3          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT4                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT4          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT5                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT5          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT6                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT6          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT7                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT7          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT8                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT8          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT9                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT9          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT10                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT10         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT11                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT11         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT12                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT12         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT13                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT13         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT14                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT14         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT15                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT15         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT16                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT16         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT17                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT17         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT18                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT18         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT19                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT19         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT20                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT20         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT21                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT21         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT22                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT22         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT23                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT23         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT24                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT24         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT25                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT25         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT26                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT26         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT27                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT27         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT28                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT28         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT29                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT29         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT30                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT30         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT31                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT31         ) //

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  srsharp_regs2.h
//
// -----------------------------------------------
// REG_BASE:  VPPG_VCBUS_BASE = 0x52
// -----------------------------------------------
// 8'h50/51/52/53  have used  for srsharp_regs
// -----------------------------------------------
// REG_BASE:  VPPH_VCBUS_BASE = 0x53
// -----------------------------------------------
// 8'h50/51/52/53  have used  for srsharp_regs
//afbcd_multx6 use 3 reg_pages
// -----------------------------------------------
// REG_BASE:  MADE_VCBUS_BASE = 0x54
// -----------------------------------------------
//
// Reading file:  afbcd_mult_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//   reg addr map
//   8'h0  - 8'h3f :  rdmif
//   8'h40 - 8'h6f :  afbcd
//   8'h70 - 8'h7f :  fgrain
////===============================////
#define P_RDMIFXN_GEN_REG                          (volatile uint32_t *)0xff015000
#define P_RDMIFXN_CANVAS0                          (volatile uint32_t *)0xff015004
#define P_RDMIFXN_CANVAS1                          (volatile uint32_t *)0xff015008
#define P_RDMIFXN_LUMA_X0                          (volatile uint32_t *)0xff01500c
#define P_RDMIFXN_LUMA_Y0                          (volatile uint32_t *)0xff015010
#define P_RDMIFXN_CHROMA_X0                        (volatile uint32_t *)0xff015014
#define P_RDMIFXN_CHROMA_Y0                        (volatile uint32_t *)0xff015018
#define P_RDMIFXN_LUMA_X1                          (volatile uint32_t *)0xff01501c
#define P_RDMIFXN_LUMA_Y1                          (volatile uint32_t *)0xff015020
#define P_RDMIFXN_CHROMA_X1                        (volatile uint32_t *)0xff015024
#define P_RDMIFXN_CHROMA_Y1                        (volatile uint32_t *)0xff015028
#define P_RDMIFXN_RPT_LOOP                         (volatile uint32_t *)0xff01502c
#define P_RDMIFXN_LUMA0_RPT_PAT                    (volatile uint32_t *)0xff015030
#define P_RDMIFXN_CHROMA0_RPT_PAT                  (volatile uint32_t *)0xff015034
#define P_RDMIFXN_LUMA1_RPT_PAT                    (volatile uint32_t *)0xff015038
#define P_RDMIFXN_CHROMA1_RPT_PAT                  (volatile uint32_t *)0xff01503c
#define P_RDMIFXN_LUMA_PSEL                        (volatile uint32_t *)0xff015040
#define P_RDMIFXN_CHROMA_PSEL                      (volatile uint32_t *)0xff015044
#define P_RDMIFXN_DUMMY_PIXEL                      (volatile uint32_t *)0xff015048
#define P_RDMIFXN_LUMA_FIFO_SIZE                   (volatile uint32_t *)0xff01504c
#define P_RDMIFXN_AXI_CMD_CNT                      (volatile uint32_t *)0xff015050
#define P_RDMIFXN_AXI_RDAT_CNT                     (volatile uint32_t *)0xff015054
#define P_RDMIFXN_RANGE_MAP_Y                      (volatile uint32_t *)0xff015058
#define P_RDMIFXN_RANGE_MAP_CB                     (volatile uint32_t *)0xff01505c
#define P_RDMIFXN_RANGE_MAP_CR                     (volatile uint32_t *)0xff015060
#define P_RDMIFXN_GEN_REG2                         (volatile uint32_t *)0xff015064
#define P_RDMIFXN_PROT                             (volatile uint32_t *)0xff015068
#define P_RDMIFXN_URGENT_CTRL                      (volatile uint32_t *)0xff01506c
#define P_RDMIFXN_GEN_REG3                         (volatile uint32_t *)0xff015070
#define P_RDMIFXN_CFMT_CTRL                        (volatile uint32_t *)0xff015074
#define P_RDMIFXN_CFMT_W                           (volatile uint32_t *)0xff015078
#define P_RDMIFXN_BADDR_Y                          (volatile uint32_t *)0xff015080
//Bit 31:0      cntl_f0_baddr_y                        //unsigned, RW, default = 0
#define P_RDMIFXN_BADDR_CB                         (volatile uint32_t *)0xff015084
//Bit 31:0      cntl_f0_baddr_cb                       //unsigned, RW, default = 0
#define P_RDMIFXN_BADDR_CR                         (volatile uint32_t *)0xff015088
//Bit 31:0      cntl_f0_baddr_cr                       //unsigned, RW, default = 0
#define P_RDMIFXN_STRIDE_0                         (volatile uint32_t *)0xff01508c
//Bit 31:29     reserved
//Bit 28:16     cntl_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_y                       //unsigned, RW, default = 256
#define P_RDMIFXN_STRIDE_1                         (volatile uint32_t *)0xff015090
//Bit 31:17     reserved
//Bit 16        cntl_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_cr                      //unsigned, RW, default = 256
#define P_RDMIFXN_BADDR_Y_F1                       (volatile uint32_t *)0xff015094
//Bit 31:0      cntl_f1_baddr_y                     //unsigned, RW, default = 0
#define P_RDMIFXN_BADDR_CB_F1                      (volatile uint32_t *)0xff015098
//Bit 31:0      cntl_f1_baddr_cb                    //unsigned, RW, default = 0
#define P_RDMIFXN_BADDR_CR_F1                      (volatile uint32_t *)0xff01509c
//Bit 31:0      cntl_f1_baddr_cr                    //unsigned, RW, default = 0
#define P_RDMIFXN_STRIDE_0_F1                      (volatile uint32_t *)0xff0150a0
//Bit 31:29     reserved
//Bit 28:16     cntl_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_y                    //unsigned, RW, default = 256
#define P_RDMIFXN_STRIDE_1_F1                      (volatile uint32_t *)0xff0150a4
//Bit 31:27     reserved
//Bit 26        cntl_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        cntl_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        cntl_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     cntl_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     cntl_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     cntl_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17        reserved
//Bit 16        cntl_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_cr                   //unsigned, RW, default = 256
#define P_AFBCDM_ENABLE                            (volatile uint32_t *)0xff015100
//Bit   31:29,    reserved
//Bit   28:23,    reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22,       reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21,       reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20,       reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19,       reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16,    soft_rst          unsigned  , default = 4
//Bit   15:14,    reserved
//Bit   13:12,    ddr_blk_size      unsigned  , default = 1
//Bit   11:9,     cmd_blk_size      unsigned  , default = 3
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:2,      reserved
//Bit   1,        head_len_sel      unsigned  , default = 1
//Bit   0,        dec_frm_start     unsigned  , default = 0
#define P_AFBCDM_MODE                              (volatile uint32_t *)0xff015104
//Bit   31:30,    reserved
//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num     uns, default = 0 ,
//Bit   15:14,    burst_len         uns, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8,     compbits_yuv      uns, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vertical skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define P_AFBCDM_SIZE_IN                           (volatile uint32_t *)0xff015108
//Bit   31:29,    reserved
//Bit   28:16     hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in          uns, default = 1080 , pic vertical size in  unit: pixel
#define P_AFBCDM_DEC_DEF_COLOR                     (volatile uint32_t *)0xff01510c
//Bit   31:30,   reserved
//Bit   29:20,   def_color_y        uns, default = 255, afbc dec y default setting value
//Bit   19:10,   def_color_u        uns, default = 128, afbc dec u default setting value
//Bit    9: 0,   def_color_v        uns, default = 128, afbc dec v default setting value
#define P_AFBCDM_CONV_CTRL                         (volatile uint32_t *)0xff015110
//Bit   31:14,   reserved
//Bit   13:12,   fmt_mode            uns, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
#define P_AFBCDM_LBUF_DEPTH                        (volatile uint32_t *)0xff015114
//Bit   31:28,   reserved
//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
//Bit   15:12,   reserved
//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
#define P_AFBCDM_HEAD_BADDR                        (volatile uint32_t *)0xff015118
//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
#define P_AFBCDM_BODY_BADDR                        (volatile uint32_t *)0xff01511c
//Bit   31:0,   mif_data_baddr      uns, default = 32'h00010000;
#define P_AFBCDM_SIZE_OUT                          (volatile uint32_t *)0xff015120
//Bit   31:29,   reserved
//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
#define P_AFBCDM_OUT_YSCOPE                        (volatile uint32_t *)0xff015124
//Bit   31:29,   reserved
//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
#define P_AFBCDM_STAT                              (volatile uint32_t *)0xff015128
//Bit   31:1,   ro_dbg_top_info      uns,   default = 0
//Bit      0,   frm_end_stat         uns, default = 0 frame end status
#define P_AFBCDM_VD_CFMT_CTRL                      (volatile uint32_t *)0xff01512c
//Bit 31    cfmt_gclk_bit_dis      uns, default = 0    ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      uns, default = 0    ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         uns, default = 0    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               uns, default = 0    ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en uns, default = 0    ; //if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     uns, default = 0    ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   uns, default = 0    ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     uns, default = 0    ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    uns, default = 0    ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        uns, default = 0    ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       uns, default = 0    ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               uns, default = 0    ; //vertical formatter enable
#define P_AFBCDM_VD_CFMT_W                         (volatile uint32_t *)0xff015130
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                uns, default = 0    ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                uns, default = 0    ;vertical formatter width
#define P_AFBCDM_MIF_HOR_SCOPE                     (volatile uint32_t *)0xff015134
//Bit   31:26,   reserved
//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10,   reserved
//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
#define P_AFBCDM_MIF_VER_SCOPE                     (volatile uint32_t *)0xff015138
//Bit   31:28,   reserved
//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12,   reserved
//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
#define P_AFBCDM_PIXEL_HOR_SCOPE                   (volatile uint32_t *)0xff01513c
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
#define P_AFBCDM_PIXEL_VER_SCOPE                   (volatile uint32_t *)0xff015140
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
#define P_AFBCDM_VD_CFMT_H                         (volatile uint32_t *)0xff015144
//Bit 31:13,    reserved
//Bit 12:0      cfmt_h  uns, default = 142  ; //vertical formatter height
#define P_AFBCDM_IQUANT_ENABLE                     (volatile uint32_t *)0xff015148
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1     //unsigned,      RW, default = 0  enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0     //unsigned,      RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           //signed ,       RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define P_AFBCDM_IQUANT_LUT_1                      (volatile uint32_t *)0xff01514c
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDM_IQUANT_LUT_2                      (volatile uint32_t *)0xff015150
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDM_IQUANT_LUT_3                      (volatile uint32_t *)0xff015154
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDM_IQUANT_LUT_4                      (volatile uint32_t *)0xff015158
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define P_AFBCDM_ROT_CTRL                          (volatile uint32_t *)0xff015180
//Bit   31:30   reg_rot_ohds2_mode                  //unsigned, RW, default = 0 , rot output format down hor drop mode,0:average 1:use 0 2:use 1
//Bit   29:28   reg_rot_ovds2_mode                  //unsigned, RW, default = 0 , rot output format down ver drop mode,0:average 1:use 0 2:use 1
//Bit   27      reg_pip_mode                        //unsigned, RW, default = 0 , 0:dec_src from vdin/dos  1:dec_src from pip
//Bit   26:24   reg_rot_uv_vshrk_drop_mode          //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   23      reserved
//Bit   22:20   reg_rot_uv_hshrk_drop_mode          //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   19:18   reg_rot_uv_vshrk_ratio              //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   17:16   reg_rot_uv_hshrk_ratio              //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   15      reserved
//Bit   14:12   reg_rot_y_vshrk_drop_mode           //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   11      reserved
//Bit   10:8    reg_rot_y_hshrk_drop_mode           //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   7:6     reg_rot_y_vshrk_ratio               //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   5:4     reg_rot_y_hshrk_ratio               //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   3:2     reg_rot_uv422_drop_mode             //unsigned, RW, default = 0 , 0:average 1:left 2:right
//Bit   1       reg_rot_uv422_omode                 //unsigned, RW, default = 0 , when rot input fmt422, 0:output_uv422  1:output_uv420
//Bit   0       reg_rot_enable                      //unsigned, RW, default = 0 , rotation enable
#define P_AFBCDM_ROT_SCOPE                         (volatile uint32_t *)0xff015184
//Bit   31:26   reserved
//Bit   25:20   reg_rot_debug_probe      //unsigned, RW , default = 0, y:[2:0] uv:[5:3]; 0:iblk_size 1:oblk_size 2:iblk_cnt 3:oblk_cnt 4:hsize_in 5:vsize_in 6:vstep
//Bit   19      reg_rot_dout_ds_mode_sw  //unsigned, RW , default = 0, 0:use hardware mode 1:use software mode
//Bit   18:17   reg_rot_dout_ds_mode     //unsigned, RW , default = 0, rot output fmt_down mode: [0]:h_downscale [1]:v_downscale
//Bit   16      reg_rot_ifmt_force444    //unsigned, RW , default = 1, 1: rot input fmt force as 444
//Bit   15:14   reg_rot_ofmt_mode        //unsigned, RW , default = 0, rot output fmt mode
//Bit   13:12   reg_rot_compbits_out_y   //unsigned, RW , default = 0, rot output compbit y
//Bit   11:10   reg_rot_compbits_out_uv  //unsigned, RW , default = 0, rot output compbit uv
//Bit   9:8     reg_rot_wrbgn_v          //unsigned, RW , default = 0, rot pic vertical size window begin pixel
//Bit   7:5     reserved
//Bit   4:0     reg_rot_wrbgn_h          //unsigned, RW , default = 0, rot pic hori size window begin pixel
#define P_AFBCDM_RPLC_CTRL                         (volatile uint32_t *)0xff015188
//Bit   31        reg_rplc_inter_corr_en //unsigned, RW , default = 0   , //pip replace inte-frame edge correct enable
//Bit   30        reg_rplc_dummy_corr_en //unsigned, RW , default = 0   , //pip replace outsize of real-pipframe edge correct enable
//Bit   29        reg_rplc_byps          //unsigned, RW , default = 1   , //pip replace module bypass
//Bit   28:16     reg_rplc_vsize_in      //unsigned, RW , default = 1080, //
//Bit   15:13     reserved
//Bit   12:0      reg_rplc_hsize_in      //unsigned, RW , default = 1920,
#define P_AFBCDM_RPLC_PICEN                        (volatile uint32_t *)0xff01518c
//Bit  31:28      reserved
//Bit  27:16      reg_rplc_def_color_y    //unsigned, RW , default =0        , //pip replace def_color_y
//Bit  15:0       reg_rplc_pic_enable     //unsigned, RW , default =16'hffff , //pip replace pip_picure enbale
#define P_AFBCDM_RPLC_DEFCOL                       (volatile uint32_t *)0xff015190
//Bit  31:24     reserved
//Bit  23:12     reg_rplc_def_color_v    //unsigned, RW , default =0        , //pip replace def_color_v
//Bit  11:0      reg_rplc_def_color_u    //unsigned, RW , default =0        , //pip replace def_color_u
#define P_AFBCDM_RPLC_SCPXN_ADDR                   (volatile uint32_t *)0xff015194
//Bit  31:0      reg_rplc_scpxn_addr     //unsigned, RW , default =0        , //pip replace scopx16 addr
#define P_AFBCDM_RPLC_SCPXN_DATA                   (volatile uint32_t *)0xff015198
//Bit  31:0      reg_rplc_scpxn_data     //unsigned, RW , default =0        , //pip replace scopx16 data
#define P_AFBCDM_ROT_RO_STAT                       (volatile uint32_t *)0xff01519c
//Bit   31:0     ro_rot_debug           //unsigned, RO , default = 0, rot some status
#define P_AFBCDM_FGRAIN_CTRL                       (volatile uint32_t *)0xff0151c0
//Bit 31:26     reserved
//Bit 25:24     reg_sync_ctrl              // unsigned , RW, default = 0
//Bit 23        reserved
//Bit 22        reg_dma_st_clr             // unsigned , RW, default = 0 clear DMA error status
//Bit 21        reg_hold4dma_scale         // unsigned , RW, default = 0 1 to wait DMA scale data ready before accept input data        default = 0
//Bit 20        reg_hold4dma_tbl           // unsigned , RW, default = 0 1 to wait DMA grain table data ready before accept input data  default = 0
//Bit 19        reg_cin_uv_swap            // unsigned , RW, default = 0 1 to swap U/V input
//Bit 18        reg_cin_rev                // unsigned , RW, default = 0 1 to reverse the U/V input order
//Bit 17        reg_yin_rev                // unsigned , RW, default = 0 1 to reverse the Y input order
//Bit 16        reg_fgrain_ext_imode       // unsigned , RW, default = 1 0 to indicate the input data is *4 in 8bit mode
//Bit 15        reg_use_par_apply_fgrain   // unsigned , RW, default = 0 1 to use apply_fgrain from DMA table
//Bit 14        reg_fgrain_last_ln_mode    // unsigned , RW, default = 0 1 to keep fgrain noise generator though the input is finished for rdmif.
//Bit 13        reg_fgrain_use_sat4bp      // unsigned , RW, default = 0 1 to use fgain_max/min for sat not {DW{1'b1}}/0
//Bit 12        reg_apply_c_mode           // unsigned , RW, default = 1 0 to following C
//Bit 11        reg_fgrain_tbl_sign_mode   // unsigned , RW, default = 1 0 to indicate signed bit is not extended in 8bit mode
//Bit 10        reg_fgrain_tbl_ext_mode    // unsigned , RW, default = 1 0 to indicate the grain table is *4 in 8bit mode
//Bit  9: 8     reg_fmt_mode               // unsigned , RW, default = 2 0:444; 1:422; 2:420; 3:reserved
//Bit  7: 6     reg_comp_bits              // unsigned , RW, default = 1 0:8bits; 1:10bits, else 12 bits
//Bit  5: 4     reg_rev_mode               // unsigned . RW, default = 0 0:h_rev; 1:v_rev;
//Bit  3        reserved
//Bit  2        reg_block_mode             // unsigned , RW, default = 1
//Bit  1        reg_fgrain_loc_en          // unsigned , RW, default = 0 frame-based  fgrain enable
//Bit  0        reg_fgrain_glb_en          // unsigned , RW, default = 0 global-based fgrain enable
#define P_AFBCDM_FGRAIN_WIN_H                      (volatile uint32_t *)0xff0151c4
//Bit  31:16     reg_win_end_h      .unsigned , default = 3812
//Bit  15: 0,    reg_win_bgn_h      .unsigned , default = 0
#define P_AFBCDM_FGRAIN_WIN_V                      (volatile uint32_t *)0xff0151c8
//Bit  31:16     reg_win_end_v      .unsigned , default = 2156
//Bit  15: 0,    reg_win_bgn_v      .unsigned , default = 0
#define P_AFBCDM_FGRAIN_SW_Y_RANNGE                (volatile uint32_t *)0xff0151cc
//Bit 31,        reg_fgrain_sw_yrange   .unsigned , default = 0
//Bit 30:26,     reserved
//Bit 25:16,     reg_fgrain_ymax        .unsigned , default = 1023
//Bit 15:10,     reserved
//Bit  9: 0,     reg_fgrain_ymin        .unsigned , default = 0
#define P_AFBCDM_FGRAIN_SW_C_RANNGE                (volatile uint32_t *)0xff0151d0
//Bit 31,        reg_fgrain_sw_crange   .unsigned , default = 0
//Bit 30:26,     reserved
//Bit 25:16,     reg_fgrain_cmax        .unsigned , default = 1023
//Bit 15:10,     reserved
//Bit  9: 0,     reg_fgrain_cmin        .unsigned , default = 0
#define P_AFBCDM_FGRAIN_GCLK_CTRL_0                (volatile uint32_t *)0xff0151d4
//Bit 31:0,      reg_fgrain_gclk_ctrl0  .unsigned , default = 0
#define P_AFBCDM_FGRAIN_GCLK_CTRL_1                (volatile uint32_t *)0xff0151d8
//Bit 31:0,      reg_fgrain_gclk_ctrl1  .unsigned , default = 0
#define P_AFBCDM_FGRAIN_GCLK_CTRL_2                (volatile uint32_t *)0xff0151dc
//Bit 31:0,      reg_fgrain_gclk_ctrl2  .unsigned , default = 0
#define P_AFBCDM_FGRAIN_PARAM_ADDR                 (volatile uint32_t *)0xff0151e0
#define P_AFBCDM_FGRAIN_PARAM_DATA                 (volatile uint32_t *)0xff0151e4
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  afbcd_mult_regs.h
//
//afbcd_multx6 use 3 reg_pages
// -----------------------------------------------
// REG_BASE:  MADF_VCBUS_BASE = 0x55
// -----------------------------------------------
//`include "afbcd_mult_regs.h"
//afbcd_multx6 use 3 reg_pages
// -----------------------------------------------
// REG_BASE:  MADG_VCBUS_BASE = 0x56
// -----------------------------------------------
//`include "afbcd_mult_regs.h"
// -----------------------------------------------
// REG_BASE:  MADH_VCBUS_BASE = 0x57
// -----------------------------------------------
// -----------------------------------------------
// REG_BASE:  VPPI_VCBUS_BASE = 0x58
// -----------------------------------------------
//
// Reading file:  pip_alph_gen_regs.h
//
//
// Reading file:  vd1_pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
////===================================////
////reg
////===================================////
#define P_VD1_PIP_ALPH_CTRL                        (volatile uint32_t *)0xff016200
//Bit   31:29     reserved
//Bit   28        reg_alph_gen_dbg     unsigned,default = 0     1 bit  dbg_mode: output pic with alph_256 to check function
//Bit   27:12     reg_pic_en           unsigned,default = 16'h0 16bits decide which pics are enable
//Bit   11:3      reg_alph0            unsigned,default = 0     9 bits alph0: alph value of those points which are out of the windows range
//Bit   2:1       reg_alph_gen_mode    unsigned, default = 0    2 bits out of window/border/inside of window: 0:original, 1:  0/0.5/1 alpha 2: 0/0.25/0.5/0.75/1 alph
//Bit   0         reg_alph_gen_byps    unsigned, default = 1    1 bit  bypass mode
#define P_VD1_PIP_ALPH_SCP_H_0                     (volatile uint32_t *)0xff016204
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h0     unsigned,default = 0     13bits pic_0 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h0     unsigned,default = 0     13bits pic_0 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_1                     (volatile uint32_t *)0xff016208
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h1     unsigned,default = 0     13bits pic_1 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h1     unsigned,default = 0     13bits pic_1 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_2                     (volatile uint32_t *)0xff01620c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h2     unsigned,default = 0     13bits pic_2 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h2     unsigned,default = 0     13bits pic_2 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_3                     (volatile uint32_t *)0xff016210
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h3     unsigned,default = 0     13bits pic_3 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h3     unsigned,default = 0     13bits pic_3 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_4                     (volatile uint32_t *)0xff016214
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h4     unsigned,default = 0     13bits pic_4 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h4     unsigned,default = 0     13bits pic_4 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_5                     (volatile uint32_t *)0xff016218
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h5     unsigned,default = 0     13bits pic_5 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h5     unsigned,default = 0     13bits pic_5 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_6                     (volatile uint32_t *)0xff01621c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h6     unsigned,default = 0     13bits pic_6 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h6     unsigned,default = 0     13bits pic_6 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_7                     (volatile uint32_t *)0xff016220
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h7     unsigned,default = 0     13bits pic_7 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h7     unsigned,default = 0     13bits pic_7 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_8                     (volatile uint32_t *)0xff016224
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h8     unsigned,default = 0     13bits pic_8 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h8     unsigned,default = 0     13bits pic_8 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_9                     (volatile uint32_t *)0xff016228
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h9     unsigned,default = 0     13bits pic_9 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h9     unsigned,default = 0     13bits pic_9 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_10                    (volatile uint32_t *)0xff01622c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h10     unsigned,default = 0    13bits pic_10 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h10     unsigned,default = 0    13bits pic_10 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_11                    (volatile uint32_t *)0xff016230
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h11     unsigned,default = 0    13bits pic_11 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h11     unsigned,default = 0    13bits pic_11 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_12                    (volatile uint32_t *)0xff016234
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h12     unsigned,default = 0    13bits pic_12 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h12     unsigned,default = 0    13bits pic_12 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_13                    (volatile uint32_t *)0xff016238
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h13     unsigned,default = 0    13bits pic_13 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h13     unsigned,default = 0    13bits pic_13 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_14                    (volatile uint32_t *)0xff01623c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h14     unsigned,default = 0    13bits pic_14 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h14     unsigned,default = 0    13bits pic_14 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_H_15                    (volatile uint32_t *)0xff016240
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h15     unsigned,default = 0    13bits pic_15 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h15     unsigned,default = 0    13bits pic_15 window horizontal begin
#define P_VD1_PIP_ALPH_SCP_V_0                     (volatile uint32_t *)0xff016244
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v0     unsigned,default = 0     13bits pic_0 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v0     unsigned,default = 0     13bits pic_0 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_1                     (volatile uint32_t *)0xff016248
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v1     unsigned,default = 0     13bits pic_1 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v1     unsigned,default = 0     13bits pic_1 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_2                     (volatile uint32_t *)0xff01624c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v2     unsigned,default = 0     13bits pic_2 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v2     unsigned,default = 0     13bits pic_2 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_3                     (volatile uint32_t *)0xff016250
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v3     unsigned,default = 0     13bits pic_3 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v3     unsigned,default = 0     13bits pic_3 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_4                     (volatile uint32_t *)0xff016254
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v4     unsigned,default = 0     13bits pic_4 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v4     unsigned,default = 0     13bits pic_4 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_5                     (volatile uint32_t *)0xff016258
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v5     unsigned,default = 0     13bits pic_5 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v5     unsigned,default = 0     13bits pic_5 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_6                     (volatile uint32_t *)0xff01625c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v6     unsigned,default = 0     13bits pic_6 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v6     unsigned,default = 0     13bits pic_6 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_7                     (volatile uint32_t *)0xff016260
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v7     unsigned,default = 0     13bits pic_7 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v7     unsigned,default = 0     13bits pic_7 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_8                     (volatile uint32_t *)0xff016264
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v8     unsigned,default = 0     13bits pic_8 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v8     unsigned,default = 0     13bits pic_8 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_9                     (volatile uint32_t *)0xff016268
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v9     unsigned,default = 0     13bits pic_9 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v9     unsigned,default = 0     13bits pic_9 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_10                    (volatile uint32_t *)0xff01626c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v10     unsigned,default = 0    13bits pic_10 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v10     unsigned,default = 0    13bits pic_10 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_11                    (volatile uint32_t *)0xff016270
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v11     unsigned,default = 0    13bits pic_11 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v11     unsigned,default = 0    13bits pic_11 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_12                    (volatile uint32_t *)0xff016274
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v12     unsigned,default = 0    13bits pic_12 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v12     unsigned,default = 0    13bits pic_12 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_13                    (volatile uint32_t *)0xff016278
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v13     unsigned,default = 0    13bits pic_13 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v13     unsigned,default = 0    13bits pic_13 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_14                    (volatile uint32_t *)0xff01627c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v14     unsigned,default = 0    13bits pic_14 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v14     unsigned,default = 0    13bits pic_14 window vertical begin
#define P_VD1_PIP_ALPH_SCP_V_15                    (volatile uint32_t *)0xff016280
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v15     unsigned,default = 0    13bits pic_15 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v15     unsigned,default = 0    13bits pic_15 window vertical begin
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vd1_pip_alph_gen_regs.h
//
//
// Reading file:  vd2_pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
////===================================////
////reg
////===================================////
#define P_VD2_PIP_ALPH_CTRL                        (volatile uint32_t *)0xff0162c0
//Bit   31:29     reserved
//Bit   28        reg_alph_gen_dbg     unsigned,default = 0     1 bit  dbg_mode: output pic with alph_256 to check function
//Bit   27:12     reg_pic_en           unsigned,default = 16'h0 16bits decide which pics are enable
//Bit   11:3      reg_alph0            unsigned,default = 0     9 bits alph0: alph value of those points which are out of the windows range
//Bit   2:1       reg_alph_gen_mode    unsigned, default = 0    2 bits out of window/border/inside of window: 0:original, 1:  0/0.5/1 alpha 2: 0/0.25/0.5/0.75/1 alph
//Bit   0         reg_alph_gen_byps    unsigned, default = 1    1 bit  bypass mode
#define P_VD2_PIP_ALPH_SCP_H_0                     (volatile uint32_t *)0xff0162c4
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h0     unsigned,default = 0     13bits pic_0 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h0     unsigned,default = 0     13bits pic_0 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_1                     (volatile uint32_t *)0xff0162c8
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h1     unsigned,default = 0     13bits pic_1 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h1     unsigned,default = 0     13bits pic_1 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_2                     (volatile uint32_t *)0xff0162cc
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h2     unsigned,default = 0     13bits pic_2 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h2     unsigned,default = 0     13bits pic_2 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_3                     (volatile uint32_t *)0xff0162d0
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h3     unsigned,default = 0     13bits pic_3 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h3     unsigned,default = 0     13bits pic_3 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_4                     (volatile uint32_t *)0xff0162d4
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h4     unsigned,default = 0     13bits pic_4 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h4     unsigned,default = 0     13bits pic_4 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_5                     (volatile uint32_t *)0xff0162d8
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h5     unsigned,default = 0     13bits pic_5 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h5     unsigned,default = 0     13bits pic_5 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_6                     (volatile uint32_t *)0xff0162dc
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h6     unsigned,default = 0     13bits pic_6 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h6     unsigned,default = 0     13bits pic_6 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_7                     (volatile uint32_t *)0xff0162e0
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h7     unsigned,default = 0     13bits pic_7 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h7     unsigned,default = 0     13bits pic_7 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_8                     (volatile uint32_t *)0xff0162e4
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h8     unsigned,default = 0     13bits pic_8 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h8     unsigned,default = 0     13bits pic_8 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_9                     (volatile uint32_t *)0xff0162e8
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h9     unsigned,default = 0     13bits pic_9 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h9     unsigned,default = 0     13bits pic_9 window horizontal begin
#define P_VD2_PIP_ALPH_SCP_H_10                    (volatile uint32_t *)0xff0162ec
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h10     unsigned,default = 0    13bits pic_10 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h10     unsigned,default = 0    13bits pic_10 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_H_11                    (volatile uint32_t *)0xff0162f0
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h11     unsigned,default = 0    13bits pic_11 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h11     unsigned,default = 0    13bits pic_11 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_H_12                    (volatile uint32_t *)0xff0162f4
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h12     unsigned,default = 0    13bits pic_12 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h12     unsigned,default = 0    13bits pic_12 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_H_13                    (volatile uint32_t *)0xff0162f8
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h13     unsigned,default = 0    13bits pic_13 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h13     unsigned,default = 0    13bits pic_13 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_H_14                    (volatile uint32_t *)0xff0162fc
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h14     unsigned,default = 0    13bits pic_14 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h14     unsigned,default = 0    13bits pic_14 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_H_15                    (volatile uint32_t *)0xff016300
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h15     unsigned,default = 0    13bits pic_15 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h15     unsigned,default = 0    13bits pic_15 window horizontal begi
#define P_VD2_PIP_ALPH_SCP_V_0                     (volatile uint32_t *)0xff016304
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v0     unsigned,default = 0     13bits pic_0 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v0     unsigned,default = 0     13bits pic_0 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_1                     (volatile uint32_t *)0xff016308
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v1     unsigned,default = 0     13bits pic_1 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v1     unsigned,default = 0     13bits pic_1 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_2                     (volatile uint32_t *)0xff01630c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v2     unsigned,default = 0     13bits pic_2 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v2     unsigned,default = 0     13bits pic_2 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_3                     (volatile uint32_t *)0xff016310
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v3     unsigned,default = 0     13bits pic_3 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v3     unsigned,default = 0     13bits pic_3 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_4                     (volatile uint32_t *)0xff016314
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v4     unsigned,default = 0     13bits pic_4 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v4     unsigned,default = 0     13bits pic_4 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_5                     (volatile uint32_t *)0xff016318
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v5     unsigned,default = 0     13bits pic_5 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v5     unsigned,default = 0     13bits pic_5 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_6                     (volatile uint32_t *)0xff01631c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v6     unsigned,default = 0     13bits pic_6 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v6     unsigned,default = 0     13bits pic_6 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_7                     (volatile uint32_t *)0xff016320
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v7     unsigned,default = 0     13bits pic_7 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v7     unsigned,default = 0     13bits pic_7 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_8                     (volatile uint32_t *)0xff016324
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v8     unsigned,default = 0     13bits pic_8 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v8     unsigned,default = 0     13bits pic_8 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_9                     (volatile uint32_t *)0xff016328
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v9     unsigned,default = 0     13bits pic_9 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v9     unsigned,default = 0     13bits pic_9 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_10                    (volatile uint32_t *)0xff01632c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v10     unsigned,default = 0    13bits pic_10 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v10     unsigned,default = 0    13bits pic_10 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_11                    (volatile uint32_t *)0xff016330
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v11     unsigned,default = 0    13bits pic_11 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v11     unsigned,default = 0    13bits pic_11 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_12                    (volatile uint32_t *)0xff016334
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v12     unsigned,default = 0    13bits pic_12 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v12     unsigned,default = 0    13bits pic_12 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_13                    (volatile uint32_t *)0xff016338
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v13     unsigned,default = 0    13bits pic_13 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v13     unsigned,default = 0    13bits pic_13 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_14                    (volatile uint32_t *)0xff01633c
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v14     unsigned,default = 0    13bits pic_14 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v14     unsigned,default = 0    13bits pic_14 window vertical begin
#define P_VD2_PIP_ALPH_SCP_V_15                    (volatile uint32_t *)0xff016340
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v15     unsigned,default = 0    13bits pic_15 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v15     unsigned,default = 0    13bits pic_15 window vertical begin
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vd2_pip_alph_gen_regs.h
//
//
// Closing file:  pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vcbus_regs.h
//
//
// Reading file:  ./ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
////// GE2D Registers    0x8a0 - 0x8ff
//address is 0xd016_0000 - 0xd0160000 - 0xd01603ff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  GE2D_GCBUS_BASE = 0x00
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst1 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 22:17,  reserved
//Bit 16:15, src2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 9:7    reserved
//Bit 6:5,   src1  8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define P_GE2D_GEN_CTRL0                           (volatile uint32_t *)0xff040280
//Bit 31, soft rst
//Bit 30, dst write response counter reset
//Bit 29, disable adding dst write response count to busy bit
//Bit 28:26, reserved
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords
//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 11, dst2 request urgent enable
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst1 request urgent enable
//Bit 7:0 src1 global alpha
#define P_GE2D_GEN_CTRL1                           (volatile uint32_t *)0xff040284
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0;
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst1 color_map
//        dst1_format=0                  : output 8-bit;
//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit
#define P_GE2D_GEN_CTRL2                           (volatile uint32_t *)0xff040288
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define P_GE2D_CMD_CTRL                            (volatile uint32_t *)0xff04028c
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define P_GE2D_STATUS0                             (volatile uint32_t *)0xff040290
//
//Read only
// Bit 29:16 ge2d_dst1_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define P_GE2D_STATUS1                             (volatile uint32_t *)0xff040294
//SRC1 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC1_DEF_COLOR                      (volatile uint32_t *)0xff040298
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define P_GE2D_SRC1_CLIPX_START_END                (volatile uint32_t *)0xff04029c
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define P_GE2D_SRC1_CLIPY_START_END                (volatile uint32_t *)0xff0402a0
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define P_GE2D_SRC1_CANVAS                         (volatile uint32_t *)0xff0402a4
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define P_GE2D_SRC1_X_START_END                    (volatile uint32_t *)0xff0402a8
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define P_GE2D_SRC1_Y_START_END                    (volatile uint32_t *)0xff0402ac
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_GE2D_SRC1_LUT_ADDR                       (volatile uint32_t *)0xff0402b0
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_GE2D_SRC1_LUT_DAT                        (volatile uint32_t *)0xff0402b4
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase,
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2
#define P_GE2D_SRC1_FMT_CTRL                       (volatile uint32_t *)0xff0402b8
//SRC2 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC2_DEF_COLOR                      (volatile uint32_t *)0xff0402bc
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define P_GE2D_SRC2_CLIPX_START_END                (volatile uint32_t *)0xff0402c0
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define P_GE2D_SRC2_CLIPY_START_END                (volatile uint32_t *)0xff0402c4
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define P_GE2D_SRC2_X_START_END                    (volatile uint32_t *)0xff0402c8
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define P_GE2D_SRC2_Y_START_END                    (volatile uint32_t *)0xff0402cc
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define P_GE2D_DST_CLIPX_START_END                 (volatile uint32_t *)0xff0402d0
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define P_GE2D_DST_CLIPY_START_END                 (volatile uint32_t *)0xff0402d4
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_X_START_END                     (volatile uint32_t *)0xff0402d8
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_Y_START_END                     (volatile uint32_t *)0xff0402dc
//Bit 23:16 DST2 canvas address
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST1 canvas address
#define P_GE2D_SRC2_DST_CANVAS                     (volatile uint32_t *)0xff0402e0
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_VSC_START_PHASE_STEP                (volatile uint32_t *)0xff0402e4
//phase slope
//Bit 24:0, bit 24 signed bit
#define P_GE2D_VSC_PHASE_SLOPE                     (volatile uint32_t *)0xff0402e8
//Bit 30:29, vertical repeat line0 number
//Bit 23:0, vertical scaler initial phase
#define P_GE2D_VSC_INI_CTRL                        (volatile uint32_t *)0xff0402ec
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_HSC_START_PHASE_STEP                (volatile uint32_t *)0xff0402f0
//phase slope
//Bit 24:0, bit 24 signed bit
#define P_GE2D_HSC_PHASE_SLOPE                     (volatile uint32_t *)0xff0402f4
//Bit 30:29, horizontal repeat line0 number
//Bit 23:0, horizontal scaler initial phase
#define P_GE2D_HSC_INI_CTRL                        (volatile uint32_t *)0xff0402f8
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode
#define P_GE2D_HSC_ADV_CTRL                        (volatile uint32_t *)0xff0402fc
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 28 is enable
//Bit 14, pre horizontal scaler enable
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat horizontal repeat line number as minus line number.
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat vertical repeat line number as minus line number.
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define P_GE2D_SC_MISC_CTRL                        (volatile uint32_t *)0xff040300
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_VSC_NRND_POINT                      (volatile uint32_t *)0xff040304
//Read only
//vertical scaler next round phase
//bit 23:0
#define P_GE2D_VSC_NRND_PHASE                      (volatile uint32_t *)0xff040308
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_HSC_NRND_POINT                      (volatile uint32_t *)0xff04030c
//Read only
//horizontal scaler next round phase
//bit 23:0
#define P_GE2D_HSC_NRND_PHASE                      (volatile uint32_t *)0xff040310
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define P_GE2D_MATRIX_PRE_OFFSET                   (volatile uint32_t *)0xff040314
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_GE2D_MATRIX_COEF00_01                    (volatile uint32_t *)0xff040318
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_GE2D_MATRIX_COEF02_10                    (volatile uint32_t *)0xff04031c
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_GE2D_MATRIX_COEF11_12                    (volatile uint32_t *)0xff040320
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_GE2D_MATRIX_COEF20_21                    (volatile uint32_t *)0xff040324
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define P_GE2D_MATRIX_COEF22_CTRL                  (volatile uint32_t *)0xff040328
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define P_GE2D_MATRIX_OFFSET                       (volatile uint32_t *)0xff04032c
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultipied)
//Bit 24    SRC2 color multiplier alpha selection
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define P_GE2D_ALU_OP_CTRL                         (volatile uint32_t *)0xff040330
//bit 31:0 (RGBA,YCBCRA)
#define P_GE2D_ALU_CONST_COLOR                     (volatile uint32_t *)0xff040334
//SRC1 Key
//31:0
#define P_GE2D_SRC1_KEY                            (volatile uint32_t *)0xff040338
//SRC1 Key Mask
//31:0
#define P_GE2D_SRC1_KEY_MASK                       (volatile uint32_t *)0xff04033c
//SRC2 Key
//31:0
#define P_GE2D_SRC2_KEY                            (volatile uint32_t *)0xff040340
//SRC2 Key Mask
//31:0
#define P_GE2D_SRC2_KEY_MASK                       (volatile uint32_t *)0xff040344
//Destination Bit Mask
//31:0
#define P_GE2D_DST_BITMASK                         (volatile uint32_t *)0xff040348
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define P_GE2D_DP_ONOFF_CTRL                       (volatile uint32_t *)0xff04034c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define P_GE2D_SCALE_COEF_IDX                      (volatile uint32_t *)0xff040350
//coefficients for vertical filter and horizontal filter
#define P_GE2D_SCALE_COEF                          (volatile uint32_t *)0xff040354
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above.
//Bit 7:0   src1 outside alpha
#define P_GE2D_SRC_OUTSIDE_ALPHA                   (volatile uint32_t *)0xff040358
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha
//Bit 23:16     register value for the first line alpha when bit 24 is 1
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha
//Bit 7:0      register value for the last line alpha when bit 8 is 1
#define P_GE2D_ANTIFLICK_CTRL0                     (volatile uint32_t *)0xff040360
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define P_GE2D_ANTIFLICK_CTRL1                     (volatile uint32_t *)0xff040364
//Bit 31:24, Y threshold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_COLOR_FILT0               (volatile uint32_t *)0xff040368
//Bit 31:24, Y threshold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT1               (volatile uint32_t *)0xff04036c
//Bit 31:24, Y threshold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT2               (volatile uint32_t *)0xff040370
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT3               (volatile uint32_t *)0xff040374
//Bit 31:24, Alpha threshold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_ALPHA_FILT0               (volatile uint32_t *)0xff040378
//Bit 31:24, Alpha threshold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT1               (volatile uint32_t *)0xff04037c
//Bit 31:24, Alpha threshold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT2               (volatile uint32_t *)0xff040380
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT3               (volatile uint32_t *)0xff040384
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL               (volatile uint32_t *)0xff04038c
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL              (volatile uint32_t *)0xff040390
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL              (volatile uint32_t *)0xff040394
//Bit 21:16     src1 prearbiter burst number
//Bit 13:8      src2 prearbiter burst number
//Bit 5:0       dst prearbiter burst number
#define P_GE2D_ARB_BURST_NUM                       (volatile uint32_t *)0xff040398
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define P_GE2D_TID_TOKEN                           (volatile uint32_t *)0xff04039c
//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
//Bit 25:24, dst2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 22:19 dst2 color_map
//        dst2_format=0                  : output 8-bit;
//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15     reserved
//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     9 reserved
//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
//Bit  7: 6 reserved
//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     1 reserved
//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
#define P_GE2D_GEN_CTRL3                           (volatile uint32_t *)0xff0403a0
//Read only
// Bit 13:0 ge2d_dst2_status, for debug only
#define P_GE2D_STATUS2                             (volatile uint32_t *)0xff0403a4
//Bit 27:26  src1 Y fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 25:24  src2 fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 23:22  dst1 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 21:20  dst2 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 19:18, dst1 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 17:16, dst2 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 15:1, top_wrap_ctrl
//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
#define P_GE2D_GEN_CTRL4                           (volatile uint32_t *)0xff0403a8
#define P_GE2D_GCLK_CTRL0                          (volatile uint32_t *)0xff0403bc
#define P_GE2D_GCLK_CTRL1                          (volatile uint32_t *)0xff0403c0
#define P_GE2D_GEN_CTRL5                           (volatile uint32_t *)0xff0403c4
#define P_GE2D_DST1_BADDR_CTRL                     (volatile uint32_t *)0xff0403c8
//Bit 31:0, dst1 base address in 64bits
#define P_GE2D_DST1_STRIDE_CTRL                    (volatile uint32_t *)0xff0403cc
//Bit 19:0, dst1 stride size in 64bits
#define P_GE2D_DST2_BADDR_CTRL                     (volatile uint32_t *)0xff0403d0
//Bit 31:0, dst1 base address in 64bits
#define P_GE2D_DST2_STRIDE_CTRL                    (volatile uint32_t *)0xff0403d4
//Bit 19:0, dst1 stride size in 64bits
#define P_GE2D_SRC1_BADDR_CTRL_Y                   (volatile uint32_t *)0xff0403d8
//Bit 31:0, src1 base address in 64bits
#define P_GE2D_SRC1_STRIDE_CTRL_Y                  (volatile uint32_t *)0xff0403dc
//Bit 19:0, src1 stride size in 64bits
#define P_GE2D_SRC1_BADDR_CTRL_CB                  (volatile uint32_t *)0xff0403e0
//Bit 31:0, src1 base address in 64bits
#define P_GE2D_SRC1_STRIDE_CTRL_CB                 (volatile uint32_t *)0xff0403e4
//Bit 19:0, src1 stride size in 64bits
#define P_GE2D_SRC1_BADDR_CTRL_CR                  (volatile uint32_t *)0xff0403e8
//Bit 31:0, src1 base address in 64bits
#define P_GE2D_SRC1_STRIDE_CTRL_CR                 (volatile uint32_t *)0xff0403ec
//Bit 19:0, src1 stride size in 64bits
#define P_GE2D_SRC2_BADDR_CTRL                     (volatile uint32_t *)0xff0403f0
//Bit 31:0, src2 base address in 64bits
#define P_GE2D_SRC2_STRIDE_CTRL                    (volatile uint32_t *)0xff0403f4
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define P_GE2D_MATRIX2_PRE_OFFSET                  (volatile uint32_t *)0xff040240
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_GE2D_MATRIX2_COEF00_01                   (volatile uint32_t *)0xff040244
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_GE2D_MATRIX2_COEF02_10                   (volatile uint32_t *)0xff040248
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_GE2D_MATRIX2_COEF11_12                   (volatile uint32_t *)0xff04024c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_GE2D_MATRIX2_COEF20_21                   (volatile uint32_t *)0xff040250
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define P_GE2D_MATRIX2_COEF22_CTRL                 (volatile uint32_t *)0xff040254
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define P_GE2D_MATRIX2_OFFSET                      (volatile uint32_t *)0xff040258
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define P_GE2D_MATRIX3_PRE_OFFSET                  (volatile uint32_t *)0xff04025c
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_GE2D_MATRIX3_COEF00_01                   (volatile uint32_t *)0xff040260
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_GE2D_MATRIX3_COEF02_10                   (volatile uint32_t *)0xff040264
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_GE2D_MATRIX3_COEF11_12                   (volatile uint32_t *)0xff040268
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_GE2D_MATRIX3_COEF20_21                   (volatile uint32_t *)0xff04026c
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define P_GE2D_MATRIX3_COEF22_CTRL                 (volatile uint32_t *)0xff040270
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define P_GE2D_MATRIX3_OFFSET                      (volatile uint32_t *)0xff040274
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./ge2d_regs.h
//
//
// Reading file:  ./parser_regs.h
//
//
//***************************************************************************
// Title:      parser.h
//
// Author:     chong.gu	
//
// Created:    17:15:11 06/08/2019
//
// Description:
//
// Note:
//
// History:
//
//***************************************************************************
//-----------------------------------------------------------
// PARSER
//-----------------------------------------------------------
// -----------------------------------------------
// REG_BASE:  PARSER_PCBUS_BASE = 0x38
// -----------------------------------------------
// bit 31:8 -- es_pack_size
// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
// bit 5 -- es_write
// bit 4 -- es_passthrough
// bit 3 -- insert_before_es_write
// bit 2 -- discard_cmd
// bit 1 -- search_cmd
// bit 0 -- Parser Busy
#define P_PARSER_CONTROL                           (volatile uint32_t *)0xfdf0e180
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define P_PARSER_FETCH_ADDR                        (volatile uint32_t *)0xfdf0e184
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr
//   4:3 cmd_wr_ptr
//   2:0 cmd_number
#define P_PARSER_FETCH_CMD                         (volatile uint32_t *)0xfdf0e188
// 31:0 stop_fetch_addr
#define P_PARSER_FETCH_STOP_ADDR                   (volatile uint32_t *)0xfdf0e18c
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define P_PARSER_FETCH_LEVEL                       (volatile uint32_t *)0xfdf0e190
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits)
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define P_PARSER_CONFIG                            (volatile uint32_t *)0xfdf0e194
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define P_PFIFO_WR_PTR                             (volatile uint32_t *)0xfdf0e198
// bit 9:0 -- point to byte address
#define P_PFIFO_RD_PTR                             (volatile uint32_t *)0xfdf0e19c
// bit 31:0 -- 8/16/24/32 bits data according to pfifo_data_width
#define P_PFIFO_DATA                               (volatile uint32_t *)0xfdf0e1a0
// bit 31:0 -- parser search pattern
#define P_PARSER_SEARCH_PATTERN                    (volatile uint32_t *)0xfdf0e1a4
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define P_PARSER_SEARCH_MASK                       (volatile uint32_t *)0xfdf0e1a8
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu
// bit 7:0 -- Parser interrupt enable for Amrisc
#define P_PARSER_INT_ENABLE                        (volatile uint32_t *)0xfdf0e1ac
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based)
#define P_PARSER_INT_STATUS                        (volatile uint32_t *)0xfdf0e1b0
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define P_PARSER_SCR_CTL                           (volatile uint32_t *)0xfdf0e1b4
// bit 31:0 SCR value
#define P_PARSER_SCR                               (volatile uint32_t *)0xfdf0e1b8
// bit 31:24 -- insert_loop_number
// bit 23:21 --
// bit 20:16 -- insert_byte_number
// bit 15:0 -- discard number
#define P_PARSER_PARAMETER                         (volatile uint32_t *)0xfdf0e1bc
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continuous write to this address can write upto 16 bytes
#define P_PARSER_INSERT_DATA                       (volatile uint32_t *)0xfdf0e1c0
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define P_VAS_STREAM_ID                            (volatile uint32_t *)0xfdf0e1c4
// Bit 31:0 -- VIDEO_DTS
#define P_VIDEO_DTS                                (volatile uint32_t *)0xfdf0e1c8
// Bit 31:0 -- VIDEO_PTS
#define P_VIDEO_PTS                                (volatile uint32_t *)0xfdf0e1cc
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define P_VIDEO_PTS_DTS_WR_PTR                     (volatile uint32_t *)0xfdf0e1d0
// Bit 31:0 -- AUDIO_PTS
#define P_AUDIO_PTS                                (volatile uint32_t *)0xfdf0e1d4
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define P_AUDIO_PTS_WR_PTR                         (volatile uint32_t *)0xfdf0e1d8
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian
// bit 0 -- VIDEO using manual read point
#define P_PARSER_ES_CONTROL                        (volatile uint32_t *)0xfdf0e1dc
// Bit 31:0 PFIFO_MONITOR
#define P_PFIFO_MONITOR                            (volatile uint32_t *)0xfdf0e1e0
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_VIDEO_START_PTR                   (volatile uint32_t *)0xfdf0e200
#define P_PARSER_VIDEO_END_PTR                     (volatile uint32_t *)0xfdf0e204
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_VIDEO_WP                          (volatile uint32_t *)0xfdf0e208
#define P_PARSER_VIDEO_RP                          (volatile uint32_t *)0xfdf0e20c
#define P_PARSER_VIDEO_HOLE                        (volatile uint32_t *)0xfdf0e210
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_AUDIO_START_PTR                   (volatile uint32_t *)0xfdf0e214
#define P_PARSER_AUDIO_END_PTR                     (volatile uint32_t *)0xfdf0e218
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_AUDIO_WP                          (volatile uint32_t *)0xfdf0e21c
#define P_PARSER_AUDIO_RP                          (volatile uint32_t *)0xfdf0e220
#define P_PARSER_AUDIO_HOLE                        (volatile uint32_t *)0xfdf0e224
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_SUB_START_PTR                     (volatile uint32_t *)0xfdf0e228
#define P_PARSER_SUB_END_PTR                       (volatile uint32_t *)0xfdf0e22c
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define P_PARSER_SUB_WP                            (volatile uint32_t *)0xfdf0e230
#define P_PARSER_SUB_RP                            (volatile uint32_t *)0xfdf0e234
#define P_PARSER_SUB_HOLE                          (volatile uint32_t *)0xfdf0e238
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define P_PARSER_FETCH_INFO                        (volatile uint32_t *)0xfdf0e23c
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define P_PARSER_STATUS                            (volatile uint32_t *)0xfdf0e240
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define P_PARSER_AV_WRAP_COUNT                     (volatile uint32_t *)0xfdf0e244
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define P_WRRSP_PARSER                             (volatile uint32_t *)0xfdf0e248
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_VIDEO2_START_PTR                  (volatile uint32_t *)0xfdf0e24c
#define P_PARSER_VIDEO2_END_PTR                    (volatile uint32_t *)0xfdf0e250
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define P_PARSER_VIDEO2_WP                         (volatile uint32_t *)0xfdf0e254
#define P_PARSER_VIDEO2_RP                         (volatile uint32_t *)0xfdf0e258
#define P_PARSER_VIDEO2_HOLE                       (volatile uint32_t *)0xfdf0e25c
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define P_PARSER_AV2_WRAP_COUNT                    (volatile uint32_t *)0xfdf0e260
//-----------------------------------------------------------
// PARSER_B
//-----------------------------------------------------------
// -----------------------------------------------
// REG_BASE:  PARSER_B_PCBUS_BASE = 0x11
// -----------------------------------------------
#define P_PARSER_B_PARSER_CONTROL                  (volatile uint32_t *)0xfdf04580
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define P_PARSER_B_PARSER_FETCH_ADDR               (volatile uint32_t *)0xfdf04584
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr
//   4:3 cmd_wr_ptr
//   2:0 cmd_number
#define P_PARSER_B_PARSER_FETCH_CMD                (volatile uint32_t *)0xfdf04588
// 31:0 stop_fetch_addr
#define P_PARSER_B_PARSER_FETCH_STOP_ADDR          (volatile uint32_t *)0xfdf0458c
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define P_PARSER_B_PARSER_FETCH_LEVEL              (volatile uint32_t *)0xfdf04590
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits)
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define P_PARSER_B_PARSER_CONFIG                   (volatile uint32_t *)0xfdf04594
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define P_PARSER_B_PFIFO_WR_PTR                    (volatile uint32_t *)0xfdf04598
// bit 9:0 -- point to byte address
#define P_PARSER_B_PFIFO_RD_PTR                    (volatile uint32_t *)0xfdf0459c
// bit 31:0 -- 8/16/24/32 bits data according to pfifo_data_width
#define P_PARSER_B_PFIFO_DATA                      (volatile uint32_t *)0xfdf045a0
// bit 31:0 -- parser search pattern
#define P_PARSER_B_PARSER_SEARCH_PATTERN           (volatile uint32_t *)0xfdf045a4
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define P_PARSER_B_PARSER_SEARCH_MASK              (volatile uint32_t *)0xfdf045a8
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu
// bit 7:0 -- Parser interrupt enable for Amrisc
#define P_PARSER_B_PARSER_INT_ENABLE               (volatile uint32_t *)0xfdf045ac
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based)
#define P_PARSER_B_PARSER_INT_STATUS               (volatile uint32_t *)0xfdf045b0
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define P_PARSER_B_PARSER_SCR_CTL                  (volatile uint32_t *)0xfdf045b4
// bit 31:0 SCR value
#define P_PARSER_B_PARSER_SCR                      (volatile uint32_t *)0xfdf045b8
// bit 31:24 -- insert_loop_number
// bit 23:21 --
// bit 20:16 -- insert_byte_number
// bit 15:0 -- discard number
#define P_PARSER_B_PARSER_PARAMETER                (volatile uint32_t *)0xfdf045bc
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continuous write to this address can write upto 16 bytes
#define P_PARSER_B_PARSER_INSERT_DATA              (volatile uint32_t *)0xfdf045c0
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define P_PARSER_B_VAS_STREAM_ID                   (volatile uint32_t *)0xfdf045c4
// Bit 31:0 -- VIDEO_DTS
#define P_PARSER_B_VIDEO_DTS                       (volatile uint32_t *)0xfdf045c8
// Bit 31:0 -- VIDEO_PTS
#define P_PARSER_B_VIDEO_PTS                       (volatile uint32_t *)0xfdf045cc
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define P_PARSER_B_VIDEO_PTS_DTS_WR_PTR            (volatile uint32_t *)0xfdf045d0
// Bit 31:0 -- AUDIO_PTS
#define P_PARSER_B_AUDIO_PTS                       (volatile uint32_t *)0xfdf045d4
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define P_PARSER_B_AUDIO_PTS_WR_PTR                (volatile uint32_t *)0xfdf045d8
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian
// bit 0 -- VIDEO using manual read point
#define P_PARSER_B_PARSER_ES_CONTROL               (volatile uint32_t *)0xfdf045dc
// Bit 31:0 PFIFO_MONITOR
#define P_PARSER_B_PFIFO_MONITOR                   (volatile uint32_t *)0xfdf045e0
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_B_PARSER_VIDEO_START_PTR          (volatile uint32_t *)0xfdf04600
#define P_PARSER_B_PARSER_VIDEO_END_PTR            (volatile uint32_t *)0xfdf04604
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_B_PARSER_VIDEO_WP                 (volatile uint32_t *)0xfdf04608
#define P_PARSER_B_PARSER_VIDEO_RP                 (volatile uint32_t *)0xfdf0460c
#define P_PARSER_B_PARSER_VIDEO_HOLE               (volatile uint32_t *)0xfdf04610
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_B_PARSER_AUDIO_START_PTR          (volatile uint32_t *)0xfdf04614
#define P_PARSER_B_PARSER_AUDIO_END_PTR            (volatile uint32_t *)0xfdf04618
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_B_PARSER_AUDIO_WP                 (volatile uint32_t *)0xfdf0461c
#define P_PARSER_B_PARSER_AUDIO_RP                 (volatile uint32_t *)0xfdf04620
#define P_PARSER_B_PARSER_AUDIO_HOLE               (volatile uint32_t *)0xfdf04624
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_B_PARSER_SUB_START_PTR            (volatile uint32_t *)0xfdf04628
#define P_PARSER_B_PARSER_SUB_END_PTR              (volatile uint32_t *)0xfdf0462c
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define P_PARSER_B_PARSER_SUB_WP                   (volatile uint32_t *)0xfdf04630
#define P_PARSER_B_PARSER_SUB_RP                   (volatile uint32_t *)0xfdf04634
#define P_PARSER_B_PARSER_SUB_HOLE                 (volatile uint32_t *)0xfdf04638
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define P_PARSER_B_PARSER_FETCH_INFO               (volatile uint32_t *)0xfdf0463c
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define P_PARSER_B_PARSER_STATUS                   (volatile uint32_t *)0xfdf04640
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define P_PARSER_B_PARSER_AV_WRAP_COUNT            (volatile uint32_t *)0xfdf04644
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define P_PARSER_B_WRRSP_PARSER                    (volatile uint32_t *)0xfdf04648
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_B_PARSER_VIDEO2_START_PTR         (volatile uint32_t *)0xfdf0464c
#define P_PARSER_B_PARSER_VIDEO2_END_PTR           (volatile uint32_t *)0xfdf04650
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define P_PARSER_B_PARSER_VIDEO2_WP                (volatile uint32_t *)0xfdf04654
#define P_PARSER_B_PARSER_VIDEO2_RP                (volatile uint32_t *)0xfdf04658
#define P_PARSER_B_PARSER_VIDEO2_HOLE              (volatile uint32_t *)0xfdf0465c
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define P_PARSER_B_PARSER_AV2_WRAP_COUNT           (volatile uint32_t *)0xfdf04660
//
// Closing file:  ./parser_regs.h
//

#endif // P_REGISTER_H

